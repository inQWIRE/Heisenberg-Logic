Require Import Psatz.
Require Import Reals.
Require Import Orders.
Require Import OrdersTac.
Require Import OrdersFacts.
Require Import Sorted.
Require Import Mergesort.
Require Import Setoid.
Require Import Permutation.

Require Export HeisenbergFoundations.new_Helper.

Require Export QuantumLib.GenMatrix.
Require Export QuantumLib.GenSubspaces.
Require Export QuantumLib.Complex.
Require Export QuantumLib.Matrix.
Require Export QuantumLib.VecSet.
Require Export QuantumLib.Quantum.
Require Export QuantumLib.Eigenvectors.
Require Export QuantumLib.VectorStates.
Require Export QuantumLib.Bits.
Require Export QuantumLib.Modulus.
Require Export QuantumLib.Permutations.
Require Export QuantumLib.PermutationAutomation.

Declare Scope Predicate_scope.
Delimit Scope Predicate_scope with P.
Open Scope Predicate_scope.


(************************)
(* Helper Lemmas *)
(************************)

Lemma Ropp_R0 : (- R0)%R = R0. Proof. lra. Qed.

Lemma Ropp_mult_twice : (-R1 * -R1)%R = R1. Proof. lra. Qed.

Ltac Rsimpl :=
repeat
  match goal with
  | _ => rewrite Rmult_0_l
  | _ => rewrite Rmult_0_r
  | _ => rewrite Rplus_0_l
  | _ => rewrite Rplus_0_r
  | _ => rewrite Rmult_1_l
  | _ => rewrite Rmult_1_r
  | _ => rewrite Ropp_0
  | _ => rewrite Ropp_involutive
  | _ => rewrite Ropp_R0
  | _ => rewrite Ropp_mult_twice
  | _ => rewrite Ropp_mult_distr_l
  | _ => rewrite Ropp_mult_distr_r
  end.

Ltac Rsimpl_context H :=
repeat
  match goal with
  | _ => rewrite Rmult_0_l in H
  | _ => rewrite Rmult_0_r in H
  | _ => rewrite Rplus_0_l in H
  | _ => rewrite Rplus_0_r in H
  | _ => rewrite Rmult_1_l in H
  | _ => rewrite Rmult_1_r in H
  | _ => rewrite Ropp_0 in H
  | _ => rewrite Ropp_involutive in H
  | _ => rewrite Ropp_R0 in H
  | _ => rewrite Ropp_mult_twice in H
  | _ => rewrite Ropp_mult_distr_l in H
  | _ => rewrite Ropp_mult_distr_r in H
  end.

Ltac Csimpl_context H :=
  repeat
   match goal with
   | _ => rewrite Cmult_0_l in H
   | _ => rewrite Cmult_0_r in H
   | _ => rewrite Cplus_0_l in H
   | _ => rewrite Cplus_0_r in H
   | _ => rewrite Cmult_1_l in H
   | _ => rewrite Cmult_1_r in H
   | _ => rewrite Cconj_R in H
   end.

Lemma fold_right_app_nil_app : forall {A : Type} (l1 l2 : list (list A)),
    fold_right (@app A) [] (l1 ++ l2) = 
      (fold_right (@app A) [] l1) ++ (fold_right (@app A) [] l2).
Proof. intros A l1 l2.
  induction l1; auto.
  simpl. rewrite <- app_assoc. 
  f_equal. auto.
Qed.

Lemma fold_right_app_nil_map : forall {A B : Type} (l : list (list A)) (f : A -> B),
    fold_right (app (A:=B)) [] (map (map f) l) = map f (fold_right (app (A:=A)) [] l).
Proof. intros A B l f.
  induction l; auto; simpl.
  rewrite map_app. f_equal. auto.
Qed.

Lemma WF_Matrix_fold_right_Mmult_I : forall {n : nat} (LM : list (Square n)),
    Forall WF_Matrix LM ->
    WF_Matrix (fold_right Mmult (I n) LM).
Proof. intros n LM H.
  induction LM; simpl.
  - auto with wf_db.
  - rewrite Forall_cons_iff in H. destruct H. 
    apply WF_mult; auto.
Qed.

Lemma fold_right_Mmult_I_app : forall {n : nat} {LM1 LM2 : list (Square n)},
    Forall WF_Matrix LM2 ->
    fold_right Mmult (I n) (LM1 ++ LM2) = 
      fold_right Mmult (I n) LM1 × fold_right Mmult (I n) LM2.
Proof. intros n LM1 LM2 H.
  induction LM1.
  - simpl. rewrite Mmult_1_l; auto.
    apply WF_Matrix_fold_right_Mmult_I; auto.
  - simpl. rewrite Mmult_assoc. f_equal. auto.
Qed.

Lemma fold_right_add_0_app : forall {Ln1 Ln2 : list nat},
fold_right Init.Nat.add 0%nat (Ln1 ++ Ln2) =
  (fold_right Init.Nat.add 0%nat Ln1 + fold_right Init.Nat.add 0%nat Ln2)%nat.
Proof. intros Ln1 Ln2.
  induction Ln1; auto.
  simpl. rewrite <- Nat.add_assoc. f_equal. auto.
Qed.

Lemma firstn_last_nth_app : forall {A : Type} (k : nat) (d : A) (ls : list A),
    (k < length ls)%nat ->
    firstn k ls ++ [nth k ls d] = firstn (S k) ls.
Proof. intros A k d ls H.
  gen k. induction ls; intros. simpl in *. lia.
  simpl in *. destruct k. simpl. auto.
  simpl. f_equal. apply IHls. lia.
Qed. 

Lemma map_fst_combine : forall {A B : Type} (La : list A) (Lb : list B),
   length La = length Lb -> map fst (combine La Lb) = La.
Proof. intros A B La Lb H.
  gen Lb. induction La; intros; auto.
  destruct Lb; try discriminate.
  simpl in *. apply Nat.succ_inj in H.
  f_equal. apply IHLa; auto.
Qed.
  
Lemma map_snd_combine : forall {A B : Type} (La : list A) (Lb : list B),
   length La = length Lb -> map snd (combine La Lb) = Lb.
Proof. intros A B La Lb H.
  gen La. induction Lb; intros. 
  - rewrite combine_nil; auto.
  - destruct La; try discriminate.
    simpl in *. apply Nat.succ_inj in H.
    f_equal. apply IHLb; auto.
Qed.

Lemma combine_app : forall {A B : Type} (La1 La2 : list A) (Lb1 Lb2 : list B),
    length La1 = length Lb1 ->
    combine (La1 ++ La2) (Lb1 ++ Lb2) = (combine La1 Lb1) ++ (combine La2 Lb2).
Proof. intros A B La1 La2 Lb1 Lb2 H.
  gen La2 Lb1 Lb2. induction La1; intros.
  - destruct Lb1; try discriminate. auto.
  - destruct Lb1; try discriminate. simpl in *.
    apply Nat.succ_inj in H.
    f_equal. apply IHLa1; auto.
Qed.

Lemma combine_cons : forall {A B : Type} (La : list A) (Lb : list B) (a : A) (b : B),
    combine (a :: La) (b :: Lb) = (a, b) :: (combine La Lb).
Proof. intros A B La Lb a b. auto. Qed.

Lemma switch_switch_overshadow : forall {X : Type} (n : nat) (ls : list X) (a b : X),
    switch (switch ls a n) b n = switch ls b n.
Proof. intros X n ls a b.
  gen ls a b.
  induction n; intros; destruct ls; auto.
  simpl. f_equal. auto.
Qed.

Lemma list_coord_map_destruct : forall {A B : Type} (l1 l2 : list (A * B)),
    map fst l1 = map fst l2 -> map snd l1 = map snd l2 -> l1 = l2.
Proof. intros A B l1 l2 H H0.
  rewrite <- map_id.
  rewrite <- map_id at 1.
  assert ((fun x : A * B => x) = (fun x : A * B => (fst x, snd x))).
  { apply functional_extensionality. intros x. destruct x. auto. }
  rewrite ! H1.
  clear H1.
  gen l2.
  induction l1; intros.
  - simpl in *. symmetry in H, H0.
    apply map_eq_nil in H, H0.
    subst. auto.
  - destruct l2 as [ | b l2].
    + simpl in *.
      inversion H.
    + simpl in *.
      inversion H; subst; clear H.
      inversion H0; subst; clear H0.
      specialize (IHl1 l2 H3 H4).
      rewrite IHl1. auto.
Qed.

Lemma nonzero_mat_nonzero_elem : forall {n m : nat} (M : Matrix n m),
    WF_Matrix M -> (M <> Zero <-> (exists i j, (i < n)%nat /\ (j < m)%nat /\ M i j <> C0)).
Proof. intros n m M H.
  split; intros.
  - destruct (Classical_Prop.classic (exists i j : nat, (i < n)%nat /\ (j < m)%nat /\ M i j <> 0)); auto. 
    contradict H0.
    prep_matrix_equality.
    apply Classical_Pred_Type.not_ex_all_not with (n := x) in H1.
    apply Classical_Pred_Type.not_ex_all_not with (n := y) in H1.
    apply Classical_Prop.not_and_or in H1.
    destruct H1.
    + assert ((x >= n)%nat \/ (y >= m)%nat) by lia.
      apply H in H1.
      assumption.
    + apply Classical_Prop.not_and_or in H0.
      destruct H0.
      * assert ((x >= n)%nat \/ (y >= m)%nat) by lia.
        apply H in H1.
        assumption.
      * apply Classical_Prop.NNPP in H0.
        assumption.
  - destruct H0 as [i [j [H0 [H1 H2]]]].
    bdestruct (i <? n); bdestruct (j <? m); 
      try (assert (H' : (i >= n)%nat \/ (j >= m)%nat) by lia;
           apply H in H'; contradiction).
    intro.
    rewrite H5 in H2.
    contradiction.
Qed.

Lemma kron_breakdown3 : forall (a a' b b' c c' : Square 2),
  WF_Matrix a -> WF_Matrix a' -> WF_Matrix b -> WF_Matrix b' -> WF_Matrix c -> WF_Matrix c' ->
  a ⊗ b ⊗ c = a' ⊗ b' ⊗ c' -> 
  (forall i j k l m n : nat, ((a i j) * (b k l) * (c m n) = (a' i j) * (b' k l) * (c' m n))%C).
Proof. intros a a' b b' c c' H H0 H1 H2 H3 H4 H5 i j k l m n. 
  bdestruct (i <? 2); bdestruct (j <? 2); 
    bdestruct (k <? 2); bdestruct (l <? 2);
    bdestruct (m <? 2); bdestruct (n <? 2);
    try (rewrite H, H0; try (left; easy); try (right; easy); lca);
    try (rewrite H1, H2; try (left; easy); try (right; easy); lca);
    try (rewrite H3, H4; try (left; easy); try (right; easy); lca).
  assert (H' : ((a ⊗ b ⊗ c) (m + (k + i*2)*2) (n + (l + j*2)*2) = (a' ⊗ b' ⊗ c') (m + (k + i*2)*2) (n + (l + j*2)*2))%nat).
  rewrite H5; easy. 
  unfold kron in H'. 
  assert (H_0 : ((m + (k + i * 2) * 2) / 2 = m / 2 + (k + i * 2))%nat) by (rewrite Nat.div_add; auto).
  assert (H_1 : ((n + (l + j * 2) * 2) / 2 = n / 2 + (l + j * 2))%nat) by (rewrite Nat.div_add; auto).
  rewrite ! Nat.Div0.mod_add, ! H_0, ! H_1 in H'.
  assert (H_2 : ((m / 2 + (k + i * 2)) = ((m / 2 + k) + i * 2))%nat) by lia.
  assert (H_3 : ((n / 2 + (l + j * 2)) = ((n / 2 + l) + j * 2))%nat) by lia.
  rewrite ! H_2, ! H_3 in H'. 
  rewrite ! Nat.div_add, ! Nat.Div0.mod_add in H'; auto.
  rewrite ! Nat.div_small in H'; try rewrite ! Nat.div_small; try lia.
  rewrite ! Nat.mod_small in H'; auto.
Qed.

Lemma kron_rearrange3 : forall (a a' b b' C C' : Square 2),
    WF_Matrix a -> WF_Matrix a' -> WF_Matrix b -> WF_Matrix b' ->
    WF_Matrix C -> C <> Zero ->
    a ⊗ C ⊗ b = a' ⊗ C' ⊗ b' -> C = C' ->
    a ⊗ b = a' ⊗ b'.
Proof. intros; subst.
  prep_matrix_equality. 
  rewrite (nonzero_mat_nonzero_elem C' H3) in H4.
  destruct H4 as [i [j [H6 [H7 H4]]]].
  unfold kron.
  apply Cmult_cancel_r with (a := C' i j); auto.
  setoid_rewrite <- Cmult_assoc.
  setoid_rewrite Cmult_comm at 2.
  setoid_rewrite Cmult_comm at 4.
  setoid_rewrite Cmult_assoc.
  apply kron_breakdown3; auto.
Qed.

Lemma eq_implies_JMeq : forall (A : Type) (x y : A), 
    x = y -> JMeq x y.
Proof. intros A x y H. rewrite H. reflexivity. Qed.

Lemma eq_eq_dep : forall (U : Type) (P : U -> Type) (p : U) (x y : P p),
  x = y -> EqdepFacts.eq_dep U P p x p y.
Proof. intros. apply JMeq_eq_dep; auto. 
  apply eq_implies_JMeq; auto. 
Qed.

Lemma filter_orth_app_permutation : forall A l f,
    Permutation l ((filter f l) ++ (filter (fun (x : A) => negb (f x)) l)).
Proof. intros. gen l.
  induction l; try easy.
  simpl. destruct (f a); simpl.
  - constructor. easy.
  - assert (Permutation ((a :: filter (fun x : A => negb (f x)) l) ++ filter f l) (filter f l ++ a :: filter (fun x : A => negb (f x)) l)).
    { apply Permutation_app_comm. }
    apply perm_trans with (l' := ((a :: filter (fun x : A => ¬ f x) l) ++ filter f l)); try easy.
    simpl. constructor.
    assert (Permutation (filter f l ++ filter (fun x : A => ¬ f x) l) (filter (fun x : A => ¬ f x) l ++ filter f l)). 
    { apply perm_trans with (l' := (filter f l ++ filter (fun x : A => ¬ f x) l)); try easy.
      apply Permutation_app_comm. }
    apply perm_trans with (l' := (filter f l ++ filter (fun x : A => ¬ f x) l)); easy.
Qed.

Lemma filter_orth_length : forall A l f, (length l = length (filter f l) + length (filter (fun (x : A) => negb (f x)) l))%nat.
Proof. intros.
  assert (Permutation l ((filter f l) ++ (filter (fun (x : A) => negb (f x)) l))).
  { apply (filter_orth_app_permutation A l f). }
  apply Permutation_length in H.
  rewrite app_length in H.
  easy.
Qed.

Lemma WF_Unitary_implies_WF_Matrix : forall {n} (U : Square n),
    WF_Unitary U -> WF_Matrix U.
Proof. intros. unfold WF_Unitary in H. destruct H. assumption. Qed.

#[export] Hint Resolve WF_Unitary_implies_WF_Matrix : wf_db unit_db.

Lemma get_vec_vec : forall {n} (v : Vector n),
  WF_Matrix v -> get_vec 0 v = v.
Proof. intros. 
       unfold get_vec.
       prep_matrix_equality. 
       bdestruct (y =? 0). 
       - rewrite H0; easy.
       - unfold WF_Matrix in H.  
         rewrite H; try easy.
         right. 
         bdestruct (y <? 1); try lia.          
Qed.

Lemma Cmult_neg1_mult : ((-C1 * -C1)%C = C1). Proof. lca. Qed.
 
Lemma Copp_opp : forall (a b : C), -a = b <-> a = -b. Proof. split; intros; [rewrite <- H | rewrite H]; lca. Qed. 

Lemma Cplus_opp_r : forall c : C, c + - c = 0. Proof. intros; lca. Qed.

Lemma Cplus_inj_r : forall (c : C) {c1 c2 : C},
    c1 = c2 -> c1 + c = c2 + c.
Proof. intros. rewrite H. reflexivity. Qed.

Lemma Cplus_inj_l : forall (c : C) {c1 c2 : C},
    c1 = c2 -> c + c1 = c + c2.
Proof. intros. rewrite H. reflexivity. Qed.

Lemma Cplus_inv_r : forall (c c1 c2 : C),
    c1 + c = c2 + c -> c1 = c2.
Proof. intros. apply Cplus_inj_r with (c:=-c) in H.
  rewrite <- ! Cplus_assoc in H.
  rewrite ! Cplus_opp_r in H.
  rewrite ! Cplus_0_r in H.
  assumption.
Qed.

Lemma Cplus_inv_l : forall (c c1 c2 : C),
    c + c1= c + c2 -> c1 = c2.
Proof. intros. apply Cplus_inj_l with (c:=-c) in H.
  rewrite ! Cplus_assoc in H.
  rewrite ! Cplus_opp_l in H.
  rewrite ! Cplus_0_l in H.
  assumption.
Qed.

Lemma Cplus_zero_iff_equals_minus : forall (c1 c2 : C),
    c1 + c2 = 0 <-> c1 = -c2.
Proof. split.
  - intro. apply Cplus_inj_r with (c := -c2) in H.
    rewrite <- ! Cplus_assoc in H.
    rewrite Cplus_opp_r in H.
    rewrite Cplus_0_l, Cplus_0_r in H.
    assumption.
  - intro. rewrite H. rewrite Cplus_opp_l. reflexivity.
Qed.

Lemma adjoint_inj : forall {j k : nat} (A B : Matrix j k),
    A = B -> A † = B †.
Proof. intros. rewrite H. reflexivity. Qed.

Lemma Mmult_inj_l : forall {i j k : nat} (m : Matrix i j) {m1 m2 : Matrix j k},
    m1 = m2 -> m × m1 = m × m2.
Proof. intros. rewrite H. reflexivity. Qed.

Lemma Mmult_inj_r : forall {i j k : nat} (m : Matrix j k) {m1 m2 : Matrix i j},
    m1 = m2 -> m1 × m = m2 × m.
Proof. intros. rewrite H. reflexivity. Qed.

Lemma WF_Unitary_implies_invertible : forall {n : nat} (M : Square n),
    WF_Unitary M -> invertible M.
Proof. intros. unfold WF_Unitary in H. destruct H. unfold invertible.
  exists M †. unfold Minv. split; auto with wf_db. 
  split; auto; rewrite Minv_flip; auto with wf_db. 
Qed.

#[export] Hint Resolve WF_Unitary_implies_invertible : unit_db.

Lemma Mmult_inj_square_inv_l : forall {n m : nat} (M : Square n) (M1 M2 : Matrix n m),
    invertible M -> WF_Matrix M1 -> WF_Matrix M2 -> M × M1 = M × M2 -> M1 = M2.
Proof. intros. unfold invertible in H. destruct H as [M' [H3 [H4 H5]]].
  apply @Mmult_inj_l with (i := n) (m := M') in H2.
  rewrite <- ! Mmult_assoc in H2.
  rewrite ! H5 in H2.
  rewrite ! Mmult_1_l in H2.
  all : trivial.
Qed.

Lemma Mmult_inj_square_inv_r : forall {n m} (M : Square n) (M1 M2 : Matrix m n),
    invertible M -> WF_Matrix M1 -> WF_Matrix M2 -> M1 × M = M2 × M -> M1 = M2.
Proof. intros. unfold invertible in H. destruct H as [M' [H3 [H4 H5]]].
  apply @Mmult_inj_r with (k := n) (m := M') in H2.
  rewrite ! Mmult_assoc in H2.
  rewrite ! H4 in H2.
  rewrite ! Mmult_1_r in H2.
  all : trivial.
Qed.

Lemma Mmult_double_side : forall {i j k : nat} {m1 m1' : Matrix i j} {m2 m2' : Matrix j k} ,
    m1 = m1' -> m2 = m2' -> m1 × m2 = m1' × m2'.
Proof. intros. rewrite H, H0. reflexivity. Qed.

Lemma Mplus_inj_l : forall {j k : nat} (m m1 m2 : Matrix j k),
    m1 = m2 -> m .+ m1 = m .+ m2.
Proof. intros. rewrite H. reflexivity. Qed.

Lemma Mplus_inj_r : forall {j k : nat} (m m1 m2 : Matrix j k),
    m1 = m2 -> m1 .+ m = m2 .+ m.
Proof. intros. rewrite H. reflexivity. Qed.

Lemma Mplus_double_side : forall {j k : nat} {m1 m1' m2 m2' : Matrix j k} ,
    m1 = m1' -> m2 = m2' -> m1 .+ m2 = m1' .+ m2'.
Proof. intros. rewrite H, H0. reflexivity. Qed.

Lemma Mplus_opp_r : forall {j k : nat} (m : Matrix j k),
    WF_Matrix m -> m .+ - C1 .* m = Zero.
Proof. intros. lma'. Qed.

Lemma Mplus_opp_l : forall {j k : nat} (m : Matrix j k),
    WF_Matrix m -> - C1 .* m .+ m = Zero.
Proof. intros. lma'. Qed.

Lemma Mplus_inv_r : forall {j k : nat} (m m1 m2 : Matrix j k),
    WF_Matrix m -> m1 .+ m = m2 .+ m -> m1 = m2.
Proof. intros. apply Mplus_inj_r with (m := -C1.*m) in H0.
  rewrite ! Mplus_assoc in H0.
  rewrite ! Mplus_opp_r in H0; auto.
  rewrite ! Mplus_0_r in H0.
  assumption.
Qed. 

Lemma Mplus_inv_l : forall {j k : nat} (m m1 m2 : Matrix j k),
    WF_Matrix m -> m .+ m1 = m .+ m2 -> m1 = m2.
Proof. intros. apply Mplus_inj_l with (m := -C1.*m) in H0.
  rewrite <- ! Mplus_assoc in H0.
  rewrite ! Mplus_opp_l in H0; auto.
  rewrite ! Mplus_0_l in H0.
  assumption.
Qed. 

Lemma Mplus_zero_iff_equals_minus : forall {j k : nat} (m1 m2 : Matrix j k),
    WF_Matrix m2 -> (m1 .+ m2 = Zero <-> m1 = -C1 .* m2).
Proof. intros. split.
  - intro. apply Mplus_inj_r with (m := -C1 .* m2) in H0.
    rewrite Mplus_assoc in H0.
    rewrite Mplus_opp_r in H0; auto.
    rewrite Mplus_0_l, Mplus_0_r in H0.
    assumption.
  - intro. rewrite H0. lma'.
Qed.


Lemma trace_kron_dist : forall n m (A : Square n) (B : Square m),
    m <> 0%nat -> trace (A ⊗ B) = ((trace A) * (trace B))%G.
Proof.
  intros.
  unfold trace, kron.
  rewrite big_sum_product; auto.
Qed.


Lemma In_list_WF_Matrix_implies_WF_big_kron : forall {m n} (A : list (Matrix m n)),
    (forall a, In a A -> WF_Matrix a) -> WF_Matrix (⨂ A).
Proof. intros. induction A.
  - auto with wf_db.
  - simpl.
    apply WF_kron; auto.
    specialize (H a). assert (In a (a :: A)). { simpl. left. reflexivity. }
    apply H in H0. assumption.
    apply IHA. intros.
    specialize (H a0). assert (In a0 (a :: A)). {simpl. right. assumption. }
    apply H in H1. assumption.
Qed.

Lemma big_kron_split : forall {m n} (A B : list (Matrix m n)),
    (forall a, In a A -> WF_Matrix a) -> (forall b, In b B -> WF_Matrix b) -> 
    (⨂ (A ++ B)) = (⨂ A) ⊗ (⨂ B).
Proof. intros. induction A.
  - simpl. rewrite kron_1_l. easy.
    induction B.
    + simpl. auto with wf_db.
    + simpl. apply WF_kron; try easy.
      specialize (H0 a). assert (In a (a :: B)). { simpl. left. reflexivity. }
      apply H0 in H1. assumption.
      apply IHB. intros.
      specialize (H0 b). assert (In b (a :: B)). { simpl. right. assumption. }
      apply H0 in H2. assumption.
  - simpl. rewrite IHA. rewrite kron_assoc.
    rewrite ! app_length.
    assert ((Init.Nat.mul (Nat.pow m (@length (Matrix m n) A))
               (Nat.pow m (@length (Matrix m n) B))) =
              (Nat.pow m (Init.Nat.add (@length (Matrix m n) A) (@length (Matrix m n) B)))).
    { rewrite Nat.pow_add_r. reflexivity. }
    assert ((Init.Nat.mul (Nat.pow n (@length (Matrix m n) A))
               (Nat.pow n (@length (Matrix m n) B))) =
              (Nat.pow n (Init.Nat.add (@length (Matrix m n) A) (@length (Matrix m n) B)))).
    { rewrite Nat.pow_add_r. reflexivity. }
    rewrite ! H1, ! H2.
    reflexivity.
    specialize (H a). assert (In a (a :: A)). { simpl. left. reflexivity. }
    apply H in H1. assumption.
    assert  (forall a, In a A -> WF_Matrix a).
    { intros. specialize (H a0). assert (In a0 (a :: A)).
      { simpl. right. assumption. }
      apply H in H2. assumption. }
    apply In_list_WF_Matrix_implies_WF_big_kron in H1.
    assumption.
    apply In_list_WF_Matrix_implies_WF_big_kron in H0.
    assumption.
    intros. specialize (H a0). assert (In a0 (a :: A)).
    { simpl. right. assumption. }
    apply H in H2. assumption.
Qed.

Lemma linearly_independent_dimensions : forall {n m : nat} (A : Matrix n m),
    WF_Matrix A -> linearly_independent A -> (m <= n)%nat.
Proof. intros n m A H H0. 
  bdestruct (n <? m)%nat; auto.
  contradict H0.
  apply lindep_implies_not_linindep.
  apply gt_dim_lindep; auto.
Qed.

Lemma seq_inc : forall (a k : nat),
    (0 <= a < k)%nat -> seq 0 k = seq 0 a ++ [a] ++ seq (S a) (k - (S a)).
Proof. intros a k H.
  replace [a] with (seq a 1) by auto.
  rewrite app_assoc.
  rewrite <- seq_app.
  replace (a + 1)%nat with (S a) by lia.
  rewrite <- seq_app.
  replace (S a + (k - S a))%nat with k by lia.
  auto.
Qed.

Fixpoint removeKfromList (K ls : list nat) : list nat :=
  match K with
  | [] => ls
  | h :: t => removeKfromList t (remove Nat.eq_dec h ls)
  end.

Ltac minmax_breakdown :=
  repeat match goal with
    | |- context [Nat.min ?n ?m] =>
        try replace (Nat.min n m) with n by lia;
        try replace (Nat.min n m) with m by lia
    | |- context [Nat.max ?n ?m] =>
        try replace (Nat.max n m) with n by lia;
        try replace (Nat.max n m) with m by lia
    end.

Ltac minmax_breakdown_context :=
  repeat match goal with
    | [H : context [Nat.min ?n ?m] |- _] =>
        try replace (Nat.min n m) with n in H by lia;
        try replace (Nat.min n m) with m in H by lia
    | [H : context [Nat.max ?n ?m] |- _] =>
        try replace (Nat.max n m) with n in H by lia;
        try replace (Nat.max n m) with m in H by lia
    end.


(************************)
(* Defining coeficients *)
(************************)


Definition Coef := C.

Definition cBigMul (cs : list Coef) : Coef :=
  fold_left Cmult cs C1.

Lemma cBigMul_app : forall (l1 l2 : list Coef),
  (cBigMul l1) * (cBigMul l2) = cBigMul (l1 ++ l2).
Proof. induction l1 as [| h]; try easy.
  intros. simpl.
  - unfold cBigMul. simpl. lca.
  - intros l2. simpl. unfold cBigMul. simpl.
    rewrite 2 fold_left_Cmult. rewrite <- Cmult_assoc.
    unfold cBigMul in IHl1.
    rewrite  IHl1; easy.
Qed.


(**********************)
(* Defining the types *)
(**********************)

(* this is the lowest level, only Pauli gates are defined *)
Inductive Pauli :=
| gI
| gX
| gY
| gZ.


Definition beq_Pauli (a b : Pauli) : bool :=
  match a, b with
  | gI, gI => true
  | gZ, gI => false
  | gY, gI => false
  | gX, gI => false
  | gI, gZ => false
  | gZ, gZ => true
  | gY, gZ => false
  | gX, gZ => false
  | gI, gY => false
  | gZ, gY => false
  | gY, gY => true
  | gX, gY => false
  | gI, gX => false
  | gZ, gX => false
  | gY, gX => false
  | gX, gX => true
  end.

Lemma eqdec_Pauli (a b : Pauli) : { a = b } + { a <> b }.
Proof. destruct a, b.
  all : try (left; reflexivity); try (right; intro; discriminate).
Qed.


Module PauliOrdering <: UsualOrderedTypeFull'.
Definition t := Pauli.
Definition eq := @eq t.
Definition eq_equiv : Equivalence eq := eq_equivalence.

Definition eqb (a b : t) : bool :=
  match a, b with
  | gI, gI => true
  | gZ, gI => false
  | gY, gI => false
  | gX, gI => false
  | gI, gZ => false
  | gZ, gZ => true
  | gY, gZ => false
  | gX, gZ => false
  | gI, gY => false
  | gZ, gY => false
  | gY, gY => true
  | gX, gY => false
  | gI, gX => false
  | gZ, gX => false
  | gY, gX => false
  | gX, gX => true
  end.

Definition lt (p1 p2 : t) := 
  match p1 with
  | gI => match p2 with
         | gI => False
         | gZ => False
         | gY => False
         | gX => False
         end
  | gZ => match p2 with
         | gI => True
         | gZ => False
         | gY => False
         | gX => False
         end
  | gY => match p2 with
         | gI => True
         | gZ => True
         | gY => False
         | gX => False
         end
  | gX => match p2 with
         | gI => True
         | gZ => True
         | gY => True
         | gX => False
         end
  end.
Lemma lt_strorder : StrictOrder lt.
Proof. constructor. 
  - unfold Irreflexive, Reflexive, complement.
    intro x; destruct x; simpl; auto.
  - unfold Transitive.
    intros x y z; destruct x, y, z; simpl; auto.
Qed.
Lemma lt_compat : Proper (Logic.eq ==> Logic.eq ==> iff) lt. Proof. constructor; subst; auto. Qed.
Definition compare (p1 p2 : t) : comparison := 
  match p1 with
  | gI => match p2 with
         | gI => Eq
         | gZ => Gt
         | gY => Gt
         | gX => Gt
         end
  | gZ => match p2 with
         | gI => Lt
         | gZ => Eq
         | gY => Gt
         | gX => Gt
         end
  | gY => match p2 with
         | gI => Lt
         | gZ => Lt
         | gY => Eq
         | gX => Gt
         end
  | gX => match p2 with
         | gI => Lt
         | gZ => Lt
         | gY => Lt
         | gX => Eq
         end
  end.
Lemma compare_spec :
  forall x y : t, CompareSpec (x = y) (lt x y) (lt y x) (compare x y).
Proof. intros x y; destruct x, y;
    try (apply CompEq; simpl; easy);
    try (apply CompLt; simpl; easy);
    try (apply CompGt; simpl; easy).
Qed.
Lemma eq_dec : forall x y : t, {x = y} + {x <> y}.
Proof. destruct x, y;
    try (left; reflexivity); 
    try (right; intro; discriminate).
Qed.
Definition le (p1 p2 : t) := 
  match p1 with
  | gI => match p2 with
         | gI => True
         | gZ => False
         | gY => False
         | gX => False
         end
  | gZ => match p2 with
         | gI => True
         | gZ => True
         | gY => False
         | gX => False
         end
  | gY => match p2 with
         | gI => True
         | gZ => True
         | gY => True
         | gX => False
         end
  | gX => match p2 with
         | gI => True
         | gZ => True
         | gY => True
         | gX => True
         end
  end.
Lemma le_lteq : forall x y : t, le x y <-> lt x y \/ x = y.
Proof. intros x y. split; intros;
    destruct x, y; simpl in *;
    try contradiction;
    try (left; easy);
    try (right; easy);
    auto; destruct H;
    try discriminate;
    try contradiction.
Qed.

Definition leb (p1 p2 : t) := 
  match p1 with
  | gI => match p2 with
         | gI => true
         | gZ => false
         | gY => false
         | gX => false
         end
  | gZ => match p2 with
         | gI => true
         | gZ => true
         | gY => false
         | gX => false
         end
  | gY => match p2 with
         | gI => true
         | gZ => true
         | gY => true
         | gX => false
         end
  | gX => match p2 with
         | gI => true
         | gZ => true
         | gY => true
         | gX => true
         end
  end.
Infix "<=?" := leb (at level 70).
Lemma leb_total : forall x y, (x <=? y) = true \/ (y <=? x) = true.
Proof. intros x y. destruct x, y; simpl; auto. Qed.  
Lemma leb_trans : Transitive (fun x y => leb x y = true).
Proof. intros x y z H0 H1. destruct x, y, z; simpl; auto. Qed.  

End PauliOrdering.

Module POrd := PauliOrdering <+ OrderedTypeFullFacts(PauliOrdering) <+ Sort(PauliOrdering).



Definition not_gI (g : Pauli) : Prop := g = gX \/ g = gY \/ g = gZ.

Lemma not_gI_equiv : forall (g : Pauli), not_gI g <-> g <> gI.
Proof. intros g.
  unfold not_gI.
  split; intros.
  - intro; subst.
    repeat (destruct H; try discriminate).
  - destruct g; try contradiction.
    + left; reflexivity.
    + right; left; reflexivity.
    + right; right; reflexivity.
Qed. 

Definition translate_P (g : Pauli) : Square 2 :=
  match g with
  | gI => I 2
  | gX => σx
  | gY => σy
  | gZ => σz
  end.

Lemma list_Pauli_Hermitian : forall (l : list Pauli),  (⨂ map translate_P l) † = ⨂ map translate_P l.
Proof. intros l. induction l.
  - simpl. lma'.
  - simpl. setoid_rewrite kron_adjoint. rewrite IHl.
    destruct a; simpl.
    + replace  (Matrix.I 2) †  with  (Matrix.I 2) by lma'. reflexivity.
    + replace (σx) † with  (σx) by lma'. reflexivity.
    + replace (σy) † with  (σy) by lma'. reflexivity.
    + replace (σz) † with  (σz) by lma'. reflexivity.
Qed.
 
Lemma WF_Matrix_Pauli : forall (g : Pauli), WF_Matrix (translate_P g).
Proof. intros. 
  destruct g; simpl; auto with wf_db.
Qed.

Lemma In_list_WF_Matrix_Pauli : forall (A : list Pauli),
  forall a : Square 2, In a (map translate_P A) -> WF_Matrix a.
Proof. induction A; intros.
  - simpl in H. exfalso. assumption.
  - simpl in H. destruct H.
    + rewrite <- H. apply WF_Matrix_Pauli.
    + apply IHA. assumption.
Qed.

Lemma WF_Matrix_nth_Pauli : forall (l : list Pauli),
  forall i : nat, WF_Matrix (nth i (map translate_P l) Zero).
Proof. intros. destruct (nth_in_or_default i (map translate_P l) Zero).
  - apply In_list_WF_Matrix_Pauli with (A := l). assumption.
  - rewrite e. auto with wf_db.
Qed.

Lemma WF_Unitary_Pauli : forall (g : Pauli), WF_Unitary (translate_P g).
Proof. intros.
       destruct g; simpl; auto with unit_db.
Qed.

Lemma WF_Matrix_Big_Pauli : forall (l : list Pauli), WF_Matrix (⨂ map translate_P l).
Proof. intros.
  induction l; simpl; auto with wf_db.
  apply Matrix.WF_kron; try lia; try apply IHl.
  apply WF_Matrix_Pauli.
Qed.

#[export] Hint Resolve WF_Matrix_Pauli WF_Matrix_Big_Pauli : wf_db.
#[export] Hint Resolve WF_Unitary_Pauli : unit_db.


(* Here we define a gMul to give Coef followed by a gMul to give the actual type *)
(* this allows for an easy zip in gMulT *)

Definition gMul_Coef (g1 g2 : Pauli) : Coef :=
  match g1, g2 with
  | gI, _ => C1
  | _, gI => C1
  | gX, gX => C1
  | gY, gY => C1
  | gZ, gZ => C1
  | gX, gY => Ci
  | gY, gX => (- Ci)%C
  | gX, gZ => (-Ci)%C
  | gZ, gX => Ci
  | gY, gZ => Ci
  | gZ, gY => (-Ci)%C
  end.



Definition gMul_base (g1 g2 : Pauli) : Pauli :=
  match g1, g2 with
  | gI, _ => g2
  | _, gI => g1
  | gX, gX => gI
  | gY, gY => gI
  | gZ, gZ => gI
  | gX, gY => gZ
  | gY, gX => gZ
  | gX, gZ => gY
  | gZ, gX => gY
  | gY, gZ => gX
  | gZ, gY => gX
  end.


(* Scaling, and tensoring done at this level *)
Definition TType (len : nat) := (Coef * (list Pauli))%type.

Definition TTypes := (Coef * (list Pauli))%type.

Definition ForgetT {len : nat} (t : TType len) := (t : TTypes).
Definition AssignT (len : nat) (t : TTypes) := (t : TType len).

Lemma AssignTForgetT : forall (len : nat) (t : TType len),
    AssignT len (ForgetT t) = (t : TType len).
Proof. intros. unfold AssignT, ForgetT. auto. Qed.

Lemma ForgetTAssignT : forall (len : nat) (t : TTypes),
    ForgetT (AssignT len t) = (t : TTypes).
Proof. intros. unfold AssignT, ForgetT. auto. Qed.


Definition PtoT (P : Pauli) : TType 1%nat := (C1, [P]).
Coercion PtoT : Pauli >-> TType.


Module TTypeOrdering <: OrderedTypeFull'.

Definition t : Type := C * (list Pauli).
Definition eq (x y : t) := (eq (snd x) (snd y)).
Lemma eq_equiv : Equivalence eq.
Proof. repeat constructor.
  - unfold Symmetric, eq.
    intros x y H; destruct x, y; simpl in *; auto.
  - unfold Transitive, eq.
    intros x y z H H0; destruct x, y, z; simpl in *.
    apply eq_trans with (y := l0); auto.
Qed.

Fixpoint lt_listP (l1 l2 : list Pauli) :=
  match l1 with
  | [] => match l2 with
         | [] => False
         | _ :: _ => True
         end
  | h1 :: t1 => match l2 with
              | [] => False
              | h2 :: t2 => 
                  match POrd.compare h1 h2 with
                  | Lt => True
                  | Eq => lt_listP t1 t2
                  | Gt => False
                  end
              end
  end.

Lemma lt_listP_nil_r : forall (l : list Pauli), lt_listP l [] = False.
Proof. intros l. destruct l; auto. Qed. 

Definition lt (x y : t) := lt_listP (snd x) (snd y).
Lemma lt_strorder : StrictOrder lt.
Proof. constructor.
  - unfold Irreflexive, Reflexive, complement, lt in *.
    intros x H. destruct x. simpl in *.
    induction l; simpl in *; auto.
    destruct a; simpl in *; auto.
  - unfold Transitive, lt in *.
    intros x y z H H0.
    destruct x, y, z; simpl in *; auto.
    gen l0 l1.
    induction l; intros; simpl in *.
    + destruct l1; auto.
      rewrite lt_listP_nil_r in H0; contradiction.
    + destruct l0; simpl in *; try contradiction.
      destruct (POrd.compare a p) eqn:E;
        try contradiction.
      * rewrite POrd.compare_eq_iff in E.
        subst.
        destruct l1; try contradiction.
        destruct (POrd.compare p p0) eqn:E;
          try contradiction; auto.
        apply IHl with (l0 := l0); auto.
      * destruct l1; try contradiction.
        destruct (POrd.compare p p0) eqn:E0;
          try contradiction;
          destruct (POrd.compare a p0) eqn:E1;
          auto.
        -- rewrite POrd.compare_eq_iff in E0, E1.
           subst.
           rewrite POrd.compare_lt_iff in E.
           destruct p0; simpl in *; contradiction.
        -- rewrite POrd.compare_eq_iff in E0.
           subst.
           rewrite POrd.compare_lt_iff in E.
           rewrite POrd.compare_gt_iff in E1.
           destruct a, p0; simpl in *; try contradiction.
        -- rewrite POrd.compare_eq_iff in E1.
           subst.
           rewrite POrd.compare_lt_iff in E, E0.
           destruct p, p0; simpl in *; try contradiction.
        -- rewrite POrd.compare_lt_iff in E, E0.
           rewrite POrd.compare_gt_iff in E1.
           destruct a, p, p0; simpl in *; try contradiction.
Qed.

Lemma lt_compat : Proper (eq ==> eq ==> iff) lt.
Proof. constructor; intros; 
    destruct x, y, x0, y0;
    unfold eq, lt in *;
    simpl in *;
    subst; auto.
Qed.

Fixpoint ltb_listP (l1 l2 : list Pauli) : bool :=
  match l1 with
  | [] => match l2 with
         | [] => false
         | _ :: _ => true
         end
  | h1 :: t1 => match l2 with
              | [] => false
              | h2 :: t2 => 
                  match POrd.compare h1 h2 with
                  | Lt => true
                  | Eq => ltb_listP t1 t2
                  | Gt => false
                  end
              end
  end.

Lemma ltb_listP_nil_r : forall (l : list Pauli),  ltb_listP l [] = false.
Proof. intros l. destruct l; simpl; auto. Qed. 

Definition ltb (x y : t) := ltb_listP (snd x) (snd y).

Fixpoint eqb_listP (l1 l2 : list Pauli) : bool :=
  match l1 with
  | [] => match l2 with
         | [] => true
         | _ :: _ => false
         end
  | h1 :: t1 => match l2 with
              | [] => false
              | h2 :: t2 => 
                  match POrd.compare h1 h2 with
                  | Lt => false
                  | Eq => eqb_listP t1 t2
                  | Gt => false
                  end
              end
  end.

Lemma eqb_listP_refl : forall (l : list Pauli),  eqb_listP l l = true.
Proof. intros l. induction l; simpl; auto. 
  destruct a; simpl; apply IHl.
Qed. 

Lemma eqb_listP_neq_false : forall (l1 l2 : list Pauli),  l1 <> l2 <-> eqb_listP l1 l2 = false.
Proof. intros l1 l2. split; intro H.
  - gen l2.
    induction l1; intros.
    + destruct l2; try contradiction; simpl; auto.
    + simpl. 
      destruct l2; auto.
      destruct (POrd.compare a p) eqn:E; auto.
      rewrite POrd.compare_eq_iff in E; subst.
      assert (l1 <> l2).
      { intro; subst; contradiction. }
      apply IHl1; auto.
  - intro. subst.
    rewrite eqb_listP_refl in H.
    discriminate.
Qed.

Lemma eqb_listP_eq_true : forall (l1 l2 : list Pauli),  l1 = l2 <-> eqb_listP l1 l2 = true.
Proof. intros l1 l2. split; intro H.
  - gen l2.
    induction l1; intros.
    + destruct l2; auto; discriminate.
    + simpl. 
      destruct l2; try discriminate.
      destruct (POrd.compare a p) eqn:E; 
        inversion H; subst;
        unfold POrd.compare in E; 
        rewrite POrd.compare_refl in E;
        try discriminate;
        try rewrite eqb_listP_refl; auto.
  - gen l2. induction l1; intros.
    + destruct l2; simpl in *; auto; discriminate.
    + destruct l2.
      * simpl in *; discriminate.
      * simpl in *.
        destruct (POrd.compare a p) eqn:E;
          simpl in *; try discriminate.
        rewrite POrd.compare_eq_iff in E; subst.
        f_equal.
        apply IHl1; auto.
Qed.
  
Lemma ltb_listP_neq_or : forall (l1 l2 : list Pauli), 
    l1 <> l2 -> (ltb_listP l1 l2) = true \/ (ltb_listP l2 l1) = true.
Proof. intros l1 l2 H.
  gen l2.
  induction l1; intros.
  - destruct l2; try contradiction; simpl; auto.
  - destruct l2; simpl in *; auto.
    destruct (POrd.compare a p) eqn:E; auto.
    + rewrite POrd.compare_eq_iff in E; subst.
      assert (l1 <> l2).
      { intro; subst; contradiction. }
      assert (POrd.compare p p = Eq).
      { unfold POrd.compare. rewrite POrd.compare_refl. auto. }
      rewrite H1.
      apply IHl1; auto.
    + right. 
      assert (POrd.compare p a = Lt).
      { unfold POrd.compare in *.
        rewrite POrd.compare_antisym.
        destruct a, p; try discriminate; auto. }
      rewrite H0; auto.
Qed.

Lemma ltb_listP_neq_nor : forall (l1 l2 : list Pauli), 
    l1 <> l2 -> (ltb_listP l1 l2) = false \/ (ltb_listP l2 l1) = false.
Proof. intros l1 l2 H.
    gen l2.
  induction l1; intros.
  - destruct l2; try contradiction; simpl; auto.
  - destruct l2; simpl in *; auto.
    destruct (POrd.compare a p) eqn:E; auto.
    + rewrite POrd.compare_eq_iff in E; subst.
      assert (l1 <> l2).
      { intro; subst; contradiction. }
      assert (POrd.compare p p = Eq).
      { unfold POrd.compare. rewrite POrd.compare_refl. auto. }
      rewrite H1.
      apply IHl1; auto.
    + right. 
      assert (POrd.compare p a = Gt).
      { unfold POrd.compare in *.
        rewrite POrd.compare_antisym.
        unfold CompOpp in *.
        destruct a, p; try discriminate; auto. }
      rewrite H0; auto.
Qed.

Lemma lt_listP_iff_ltb_listP : forall (l1 l2 : list Pauli), 
    lt_listP l1 l2 <-> ltb_listP l1 l2 = true.
Proof. intros l1 l2. split; intro H;
    gen l2; induction l1; intros;
    destruct l2; simpl in *; auto; 
    try contradiction; try discriminate;
    destruct (POrd.compare a p) eqn:E;
    auto; try contradiction; try discriminate.
Qed. 

Definition eqb (x y : t) := eqb_listP (snd x) (snd y).

Definition compare (x y : t) : comparison :=
  if eqb x y then Eq else if ltb x y then Lt else Gt.

Lemma compare_spec :
  forall x y : t, CompareSpec (eq x y) (lt x y) (lt y x) (compare x y).
Proof. intros x y. destruct x, y; unfold eq, lt, compare; simpl.
  unfold eqb, ltb; simpl.
  destruct (eqb_listP l l0) eqn:E;
    try rewrite eqb_listP_eq_true in E; subst;
    try rewrite <- eqb_listP_neq_false in E;
    try constructor.
  - rewrite <- eqb_listP_eq_true in E; auto.
  - remember E as E'. clear HeqE'.
    apply ltb_listP_neq_or in E.
    apply ltb_listP_neq_nor in E'.
    destruct E; destruct E'; try rewrite H in *; try discriminate.
    + constructor.
      rewrite <- lt_listP_iff_ltb_listP in H; auto.
    + rewrite H0. constructor.
      rewrite <- lt_listP_iff_ltb_listP in H; auto.
Qed.

Lemma eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
Proof. intros x y.
  destruct x, y; unfold eq; simpl.
  apply (list_eq_dec eqdec_Pauli).
Qed.

Fixpoint le_listP (l1 l2 : list Pauli) :=
  match l1 with
  | [] => match l2 with
         | [] => True
         | _ :: _ => True
         end
  | h1 :: t1 => match l2 with
              | [] => False
              | h2 :: t2 => 
                  match POrd.compare h1 h2 with
                  | Lt => True
                  | Eq => le_listP t1 t2
                  | Gt => False
                  end
              end
  end.

Lemma le_listP_refl : forall (l : list Pauli), le_listP l l.
Proof. intros l. induction l; simpl; auto. 
  destruct a; simpl; apply IHl.
Qed. 

Definition le (x y : t) := le_listP (snd x) (snd y).
Lemma le_lteq : forall x y : t, le x y <-> lt x y \/ eq x y.
Proof. intros x y.
  unfold le, lt, eq in *; 
    destruct x, y;
    simpl in *.
  split; intro H.
  - gen l0. induction l; intros; auto.
    + destruct l0; auto.
    + simpl. destruct l0; simpl in *; try contradiction.
      destruct (POrd.compare a p) eqn:E; auto.
      rewrite POrd.compare_eq_iff in E; subst.
      destruct (IHl l0 H); subst; auto.
  - destruct H.
    + gen l0. induction l; intros;
        destruct l0; simpl in *; auto.
      destruct (POrd.compare a p) eqn:E; auto.
    + subst. apply le_listP_refl.
Qed.
(* Not needed
Fixpoint leb_listP (l1 l2 : list Pauli) :=
  match l1 with
  | [] => match l2 with
         | [] => true
         | _ :: _ => true
         end
  | h1 :: t1 => match l2 with
              | [] => false
              | h2 :: t2 => 
                  match POrd.compare h1 h2 with
                  | Lt => true
                  | Eq => leb_listP t1 t2
                  | Gt => false
                  end
              end
  end.

Definition leb' (x y : t) := leb_listP (snd x) (snd y). *)

Definition leb (x y : t) := orb (eqb x y) (ltb x y).
Infix "<=?" := leb (at level 70).
Lemma leb_total : forall x y, (x <=? y) = true \/ (y <=? x) = true.
Proof. intros x y.
  unfold "<=?".
  destruct x, y; unfold eqb, ltb; simpl.
  destruct (eqb_listP l l0) eqn:E.
  - rewrite <- eqb_listP_eq_true in E; subst.
    left. auto.
  - rewrite <- eqb_listP_neq_false in E.
    remember E as E'. clear HeqE'.
    apply ltb_listP_neq_or in E.
    apply ltb_listP_neq_nor in E'.
    destruct E, E'; rewrite H in *; 
      try discriminate; rewrite H0 in *; auto.
    right. destruct (eqb_listP l0 l); auto.
Qed.

Lemma ltb_listP_trans : forall (l0 l1 l2 : list Pauli),
    ltb_listP l0 l1 = true -> ltb_listP l1 l2 = true -> ltb_listP l0 l2 = true.
Proof. intros l0 l1 l2 H H0.
  gen l1 l2.
  induction l0; intros.
  - simpl. destruct l2; auto.
    simpl in *. 
    rewrite ltb_listP_nil_r in H0.
    discriminate.
  - destruct l2.
    + rewrite ltb_listP_nil_r in *.
      discriminate.
    + simpl in *.
      destruct l1; try discriminate.
      simpl in *.
      destruct (POrd.compare a p0) eqn:E;
        simpl in *; try discriminate.
      * rewrite POrd.compare_eq_iff in E.
        subst.
        destruct (POrd.compare p0 p) eqn:E;
          auto; try discriminate.
        rewrite POrd.compare_eq_iff in E;
          subst.
        apply (IHl0 l1); auto.
      * destruct (POrd.compare p0 p) eqn:E';
          try discriminate.
        -- rewrite POrd.compare_eq_iff in E';
             subst.
           rewrite E in *. auto.
        -- destruct a, p0, p; simpl in *;
             auto; try discriminate.
Qed.
 
Lemma leb_trans : Transitive (fun x y => leb x y = true).
Proof. unfold Transitive, "<=?".
  intros x y z H H0.
  rewrite orb_true_iff in *.
  destruct x, y, z; 
    unfold eqb, ltb in *;
    simpl in *.
  destruct H, H0;
    try rewrite <- eqb_listP_eq_true in *;
    subst; auto.
  right. apply ltb_listP_trans with (l1 := l0); auto.
Qed.

End TTypeOrdering.

Module TOrd := TTypeOrdering <+ OrderedTypeFullFacts(TTypeOrdering) <+ Sort (TTypeOrdering).

Definition lexicographic {n : nat} (Lt : list (TType n)) : list (TType n) := rev (TOrd.sort Lt).

Definition T1 : TType 3 := (C1, [gX;  gX; gI]).
Definition T2 : TType 3 := (C1, [gZ;  gZ; gI]).
Definition T3 : TType 3 := (C1, [gZ;  gZ; gZ]).
Definition LT3 : list (TType 3) := [T1; T2; T3].
(* Eval cbn in lexicographic LT3. *)


Definition defaultT_Z (n : nat) : TType n := (C1, repeat gZ n).
Definition defaultT_I (n : nat) : TType n := (C1, repeat gI n).


(* we define an error TType for when things go wrong *)
Definition ErrT : TType 0 := (C1, []).




Definition proper_length_TType_nil {n : nat} (t : TType n) : Prop := length (snd t) = n.
Definition proper_length_TType {n : nat} (t : TType n) : Prop := n <> O /\ length (snd t) = n.

Lemma proper_length_TType_implies_proper_length_TType_nil : forall {n} (t : TType n),
   proper_length_TType t -> proper_length_TType_nil t.
Proof.  intros. destruct H. auto. Qed.


Lemma proper_length_TType_defaultT_I : forall (n : nat),
    n <> 0%nat -> proper_length_TType (defaultT_I n).
Proof. intros n H.
  unfold proper_length_TType.
  split; auto.
  unfold defaultT_I.
  simpl. rewrite repeat_length; auto.
Qed.

Lemma proper_length_TType_defaultT_Z : forall (n : nat),
    n <> 0%nat -> proper_length_TType (defaultT_Z n).
Proof. intros n H.
  unfold proper_length_TType.
  split; auto.
  unfold defaultT_Z.
  simpl. rewrite repeat_length; auto.
Qed.


Definition gMulT {n} (A B : TType n) : TType n :=
  match A with
  | (c1, g1) =>
    match B with
    | (c2, g2) =>(c1 * c2 * (cBigMul (zipWith gMul_Coef g1 g2)), 
                       zipWith gMul_base g1 g2)
    end
  end.

Definition gTensorT {n m} (A : TType n) (B : TType m) : TType (n + m) :=
  match A with
  | (c1, g1) =>
    match B with
    | (c2, g2) => (c1 * c2, g1 ++ g2)
    end
  end.

Definition gScaleT {n} (c : Coef) (A : TType n) : TType n :=
  match A with
  | (c1, g1) => (c * c1, g1)
  end.

Definition gScaleTTypes (c : Coef) (A : TTypes) : TTypes :=
  match A with
  | (c1, g1) => (c * c1, g1)
  end.

Definition translate {n} (A : TType n) : Square (2 ^ n)%nat := 
  (fst A) .* ⨂ (map translate_P (snd A)).

Lemma translate_defaultT_I : forall {n : nat},
    translate (defaultT_I n) = I (2 ^ n)%nat.
Proof. intros n. unfold translate. simpl. 
  rewrite Mscale_1_l.
  induction n; auto.
  replace (2 ^ (S n))%nat with (2 * (2 ^ n))%nat by (simpl; lia).
  rewrite <- id_kron. simpl. rewrite ! IHn. 
  rewrite map_length, repeat_length; auto.
Qed.
  
Lemma gScaleT_1 : forall n (A : TType n), gScaleT C1 A = A.
Proof. intros n A. destruct A. simpl. rewrite Cmult_1_l. reflexivity. Qed.

Lemma gScaleT_comm : forall {n} (c1 c2 : Coef) (t : TType n),
    gScaleT c1 (gScaleT c2 t) = gScaleT c2 (gScaleT c1 t).
Proof. intros n c1 c2 t.
  unfold gScaleT. destruct t. f_equal. lca.
Qed.

Lemma gScaleT_merge : forall {n} (c1 c2 : Coef) (t : TType n),
    gScaleT c1 (gScaleT c2 t) = gScaleT (c1 * c2)%C t.
Proof. intros n c1 c2 t.
  unfold gScaleT. destruct t. f_equal. lca.
Qed. 

Lemma gScaleTTypes_1 : forall (A : TTypes), gScaleTTypes C1 A = A.
Proof. intros A. destruct A. simpl. rewrite Cmult_1_l. reflexivity. Qed.

Lemma gScaleTTypes_comm : forall (c1 c2 : Coef) (t : TTypes),
    gScaleTTypes c1 (gScaleTTypes c2 t) = gScaleTTypes c2 (gScaleTTypes c1 t).
Proof. intros c1 c2 t.
  unfold gScaleTTypes. destruct t. f_equal. lca.
Qed.

Lemma gScaleTTypes_merge : forall (c1 c2 : Coef) (t : TTypes),
    gScaleTTypes c1 (gScaleTTypes c2 t) = gScaleTTypes (c1 * c2)%C t.
Proof. intros c1 c2 t.
  unfold gScaleTTypes. destruct t. f_equal. lca.
Qed. 


(* Additive Type: list elements are added to each other *)
(* len is the number of qubits (= number of tensoring elements) *)
Definition AType (len : nat) := list (TType len).

Definition TtoA {n : nat} (t : TType n) : AType n := [t].
Coercion TtoA : TType >-> AType.

Definition AtoT {n : nat} (a : AType n) : TType n :=
  hd (defaultT_I n) a.

(* we define an error AType for when things go wrong *)
Definition ErrA : AType 0 := [].

Definition defaultA_Z (n : nat) : AType n := [defaultT_Z n].
Definition defaultA_I (n : nat) : AType n := [defaultT_I n].


Inductive proper_length_AType_nil (n : nat) : AType n -> Prop :=
| proper_length_A_nil_Base : proper_length_AType_nil n nil
| proper_length_A_nil_Cons (t : TType n) (a : AType n) : proper_length_TType t -> proper_length_AType_nil n a -> proper_length_AType_nil n (t :: a).

Arguments proper_length_AType_nil {n}.


Inductive proper_length_AType (n : nat) : AType n -> Prop :=
| proper_length_A_Sing (t : TType n) : proper_length_TType t -> proper_length_AType n (cons t nil)
| proper_length_A_Cons (t : TType n) (a : AType n) : proper_length_TType t -> proper_length_AType n a -> proper_length_AType n (t :: a).

Arguments proper_length_AType {n}.


Lemma proper_length_AType_implies_proper_length_AType_nil : forall {n} (a : AType n),
   proper_length_AType a -> proper_length_AType_nil a.
Proof. intros. induction H; constructor; try easy; constructor. Qed.


Fixpoint gTensorA  {n m : nat} (a : AType n) (b : AType m) {struct a}: AType (n+m) :=
  match a with
  | [] => []
  | h :: t => map (fun x : TType m => gTensorT h x) b ++ gTensorA t b
  end.

Fixpoint gTensorA'  {n m : nat} (a : AType n) (b : AType m) {struct b}: AType (n+m) :=
  match b with
  | [] => []
  | h :: t => map (fun x : TType n => gTensorT x h) a ++ gTensorA' a t
  end.

Fixpoint gMulA {n : nat} (a b : AType n) {struct a} : AType n :=
  match a with
  | [] => []
  | h :: t => map (fun x : TType n => gMulT h x) b ++ gMulA t b
  end.

Fixpoint gMulA' {n : nat} (a b : AType n) {struct b} : AType n :=
  match b with
  | [] => []
  | h :: t => map (fun x : TType n => gMulT x h) a ++ gMulA' a t
  end.

Lemma gMulA_nil_r : forall n (a : AType n), gMulA a [] = [].
Proof. intros n a. induction a; try easy. Qed.

Lemma gMulA'_nil_l : forall n (a : AType n), gMulA [] a = [].
Proof. intros n a. induction a; try easy. Qed.


Definition gScaleA {n : nat} (c : Coef) (a : AType n) :=
  map (fun a' => gScaleT c a') a .

Definition gAddA {n : nat} (a b : AType n) : AType n :=  a ++ b.

Definition translateA {n} (a : AType n) : Square (2 ^ n) :=
  fold_left Mplus (map translate a) Zero.

Lemma translateA_defaultA_I : forall {n : nat}, translateA (defaultA_I n) = I (2 ^ n)%nat.
Proof. intros n. unfold translateA, defaultA_I. simpl.
  rewrite Mplus_0_l. apply translate_defaultT_I.
Qed.

Lemma translateA_app : forall {n} (a1 a2 : AType n),
translateA (a1 ++ a2) = (translateA a1) .+ (translateA a2).
Proof. intros. unfold translateA. rewrite map_app.
  rewrite fold_left_Mplus_app_Zero. reflexivity.
Qed.

Lemma gScaleA_1 : forall n (A : AType n), gScaleA C1 A = A.
Proof. intros n A. induction A; simpl; try easy. rewrite gScaleT_1. rewrite IHA. reflexivity. Qed.

Lemma gScaleA_dist_app : forall {n} (c : Coef) (a1 a2 : AType n),
    gScaleA c (a1 ++ a2) = (gScaleA c a1) ++ (gScaleA c a2).
Proof. intros n c a1 a2.
  unfold gScaleA. apply map_app.
Qed.

Lemma gScaleA_comm : forall {n} (c1 c2 : Coef) (a : AType n),
    gScaleA c1 (gScaleA c2 a) = gScaleA c2 (gScaleA c1 a).
Proof. intros n c1 c2 a.
  unfold gScaleA. rewrite ! map_map.
  f_equal. apply functional_extensionality.
  intros. rewrite gScaleT_comm.
  reflexivity.
Qed.

Lemma gScaleA_merge : forall {n} (c1 c2 : Coef) (a : AType n),
    gScaleA c1 (gScaleA c2 a) = gScaleA (c1 * c2)%C a.
Proof. intros n c1 c2 a. 
  unfold gScaleA. rewrite ! map_map.
  f_equal. apply functional_extensionality.
  intros. apply gScaleT_merge.
Qed.

Lemma in_gScaleTA_mult : forall {n} (c: Coef) (t : TType n) (a : AType n),
    In t a -> In (gScaleT c t) (gScaleA c a).
Proof. intros n c t a H.
  induction a.
  - inversion H.
  - inversion H; subst; clear H.
    + simpl; auto.
    + apply IHa in H0.
      simpl; auto.
Qed.

Lemma in_gScaleTA_mult_inv : forall {n} (c: Coef) (t : TType n) (a : AType n),
    c <> C0 -> In (gScaleT c t) (gScaleA c a) -> In t a.
Proof. intros n c t a H H0. 
  apply in_gScaleTA_mult with (c := /c) in H0.
  rewrite gScaleT_merge, gScaleA_merge in H0.
  rewrite Cinv_l in H0; auto.
  rewrite gScaleT_1, gScaleA_1 in H0; auto.
Qed.

Inductive Predicate (n : nat) : Type :=
| AtoPred : AType n -> Predicate n
| Cap : list (AType n) -> Predicate n
| Sep : (list nat) * (list (list TTypes)) * (list nat) -> Predicate n
| Cup : Predicate n -> Predicate n -> Predicate n
| Err : Predicate n.

Coercion AtoPred : AType >-> Predicate.

Arguments AtoPred {n}.
Arguments Cap {n}.
Arguments Sep {n}.
Arguments Cup {n}.
Arguments Err {n}.


Definition defaultP_Z (n : nat) : Predicate n := AtoPred (defaultA_Z n).
Definition defaultP_I (n : nat) : Predicate n := AtoPred (defaultA_I n).


Fixpoint pad_Sep_listP (Lp : list Pauli) (Ln : list nat) (m : nat) :=
  match Ln with
  | [] => repeat gI m
  | n :: Ln' => 
    match Lp with
    | [] => repeat gI m
    | p :: Lp' => switch (pad_Sep_listP Lp' Ln' m) p n
    end
  end.

Lemma pad_Sep_listP_length : forall (Lp : list Pauli) (Ln : list nat) (m : nat),
    length (pad_Sep_listP Lp Ln m) = m.
Proof. intros Lp Ln m.
  gen Lp m.
  induction Ln.
  - induction Lp; intros; simpl; 
      rewrite repeat_length; auto.
  - induction Lp; intros; simpl;
      try rewrite repeat_length; auto.
    rewrite switch_len.
    apply IHLn.
Qed. 

Lemma pad_Sep_listP_nil_l : forall (Ln : list nat) (m : nat),
  pad_Sep_listP [] Ln m = repeat gI m.
Proof. intros Ln m.
  induction Ln; auto.
Qed.

Lemma pad_Sep_listP_nil_r : forall (Lp : list Pauli) (m : nat),
  pad_Sep_listP Lp [] m = repeat gI m.
Proof. intros Lp m.
  induction Lp; auto.
Qed.

Lemma pad_Sep_listP_nth : forall (i m : nat) (Ln : list nat) (Lp : list Pauli),
    NoDup Ln -> (i < length Ln)%nat -> length Ln = length Lp -> incl Ln (List.seq 0 m) ->
    nth (nth i Ln 0%nat) (pad_Sep_listP Lp Ln m) gI = nth i Lp gI.
Proof. intros i m Ln Lp H H0 H1 H2.
  gen Ln Lp i.
    induction m.
    - induction Ln; intros; simpl in *.
      + inversion H0.
      + apply incl_cons_inv in H2.
        destruct H2.
        inversion H2.
    - induction Ln; intros.
      + inversion H0.
      + destruct Lp.
        * rewrite pad_Sep_listP_nil_l.
          rewrite nth_repeat.
          destruct i; auto.
        * simpl.
          destruct i.
          -- rewrite nth_switch_hit; auto.
             rewrite pad_Sep_listP_length.
             apply incl_cons_inv in H2.
             destruct H2.
             rewrite in_seq in H2.
             lia.
          -- rewrite NoDup_cons_iff in H.
             destruct H.
             bdestruct (nth i Ln 0%nat =? a).
             ++ subst. 
                simpl in H0.
                rewrite <- Nat.succ_lt_mono in H0.
                assert (In (nth i Ln 0%nat) Ln).
                { apply nth_In; lia. }
                contradiction.
             ++ simpl in H0.
                rewrite <- Nat.succ_lt_mono in H0.
                rewrite nth_switch_miss; auto.
                rewrite IHLn; auto.
                apply incl_cons_inv in H2.
                destruct H2; auto.
Qed.

Lemma pad_Sep_listP_not_in : forall (m k : nat) (Ln : list nat) (Lp : list Pauli),
    NoDup Ln -> length Ln = length Lp -> incl Ln (List.seq 0 m) ->
    ~ In k Ln -> nth k (pad_Sep_listP Lp Ln m) gI = gI.
Proof. intros m k Ln Lp H H0 H1 H2.
  bdestruct (k <? m).
  - destruct Lp as [ | p Lp'].
    + rewrite pad_Sep_listP_nil_l.
      rewrite nth_repeat; auto.
    + destruct Ln as [ | n Ln'].
      * rewrite pad_Sep_listP_nil_r.
        rewrite nth_repeat; auto.
      * simpl.
        bdestruct (k =? n%nat).
        -- subst.
           apply not_in_cons in H2.
           destruct H2. contradiction.
        -- rewrite nth_switch_miss; auto.
           apply incl_cons_inv in H1.
           destruct H1.
           apply not_in_cons in H2.
           destruct H2.
           rewrite NoDup_cons_iff in H.
           destruct H.
           clear H. simpl in H0. clear H2. clear H1. clear H4.
           clear n. clear p.
           apply Nat.succ_inj in H0.
           gen Lp'.
           induction Ln'; intros.
           ++ rewrite pad_Sep_listP_nil_r, nth_repeat; auto.
           ++ destruct Lp'.
              ** rewrite pad_Sep_listP_nil_l, nth_repeat; auto.
              ** simpl in H0. apply Nat.succ_inj in H0.
                 rewrite NoDup_cons_iff in H7.
                 destruct H7.
                 apply incl_cons_inv in H5.
                 destruct H5.
                 rewrite not_in_cons in H6.
                 destruct H6.
                 simpl. 
                 rewrite nth_switch_miss; auto.
  - rewrite nth_overflow; auto; rewrite pad_Sep_listP_length; lia.
Qed.

Lemma pad_Sep_listP_seq : forall (Lp : list Pauli) (m : nat),
    length Lp = m -> pad_Sep_listP Lp (List.seq 0 m) m = Lp.
Proof. intros Lp m H.
  apply nth_ext with (d := gI) (d' := gI).
  - rewrite pad_Sep_listP_length, H; auto.
  - intros. rewrite pad_Sep_listP_length in H0.
    assert (nth n (List.seq 0 m) 0%nat = n).
    { rewrite seq_nth; auto. }
    setoid_rewrite <- H1 at 1.
    rewrite pad_Sep_listP_nth; auto.
    apply seq_NoDup.
    rewrite seq_length; lia.
    rewrite seq_length, H; lia.
    apply incl_refl.
Qed.    


Definition unpad_Sep_listP (Lp : list Pauli) (Ln : list nat) := map (fun n => nth n Lp gI) Ln.

Lemma unpad_pad_Sep_listP : forall (Lp : list Pauli) (Ln : list nat) (m : nat),
    NoDup Ln -> length Ln = length Lp -> incl Ln (List.seq 0 m) ->
    unpad_Sep_listP (pad_Sep_listP Lp Ln m) Ln = Lp.
Proof. intros Lp Ln m H H0 H1. 
  unfold unpad_Sep_listP.
  apply nth_ext with (d := gI) (d' := gI).
  - rewrite map_length; auto.
  - intros n H2.
    rewrite map_length in H2.
    assert ((fun n0 : nat => nth n0 (pad_Sep_listP Lp Ln m) gI) m = gI).
    { assert (~ In m Ln).
      { intro. apply H1 in H3. rewrite in_seq in H3. lia. }
      rewrite pad_Sep_listP_not_in; auto. }
    rewrite <- H3 at 1.
    rewrite map_nth with (d := m).
    rewrite nth_indep with (d' := 0%nat); auto.
    rewrite pad_Sep_listP_nth; auto.
Qed.

Definition pad_Sep_TTypes (t : TTypes) (l : list nat) (m : nat) : TType m := 
  (fst t, pad_Sep_listP (snd t) l m).

Definition pad_Sep_TType {n : nat} (t : TType n) (l : list nat) (m : nat) : TType m := 
  (fst t, pad_Sep_listP (snd t) l m).

Lemma pad_Sep_TType_seq : forall {n : nat} (t : TType n) (m : nat),
    proper_length_TType t -> m = n -> pad_Sep_TType t (List.seq 0 m) m = t.
Proof. intros n t m H H0.
  subst.
  destruct t as [c l]; simpl in *.
  unfold pad_Sep_TType; simpl.
  rewrite pad_Sep_listP_seq; auto.
  destruct H as [H H']; simpl in *; auto.
Qed.

Lemma proper_length_TType_pad_Sep_TType : forall {n : nat} (t : TType n) (l : list nat) (m : nat),
    m <> 0%nat -> proper_length_TType (pad_Sep_TType t l m).
Proof. intros n t l m H.
  destruct t.
  unfold proper_length_TType, pad_Sep_TType in *.
  simpl in *.
  split; try rewrite pad_Sep_listP_length; auto.
Qed.


Definition unpad_Sep_TTypes (t : TTypes) (l : list nat) : TType (length l) :=
  (fst t, unpad_Sep_listP (snd t) l).

Definition unpad_Sep_TType {n : nat} (t : TType n) (l : list nat) : TType (length l) :=
  (fst t, unpad_Sep_listP (snd t) l).

Lemma unpad_pad_Sep_TType : forall {n : nat} (t : TType n) (l : list nat) (m : nat),
    proper_length_TType t ->
    NoDup l -> length l = n -> incl l (List.seq 0 m) ->
    unpad_Sep_TType (pad_Sep_TType t l m) l = t.
Proof. intros n t l m H H0 H1 H2.
  unfold unpad_Sep_TType, pad_Sep_TType.
  inversion H. subst. destruct t. simpl in *. f_equal.
  apply unpad_pad_Sep_listP; auto.
Qed.
  

Definition pad_Sep_AType {n : nat} (a : AType n) (l : list nat) (m : nat) : AType m := 
  map (fun t => pad_Sep_TType t l m) a.

Lemma pad_Sep_AType_seq_nil : forall {n : nat} (a : AType n) (m : nat),
    proper_length_AType_nil a -> m = n -> pad_Sep_AType a (List.seq 0 m) m = a.
Proof. intros n a m H H0.
  subst.
  unfold pad_Sep_AType.
  induction a; auto.
  inversion H; subst.
  simpl. f_equal; auto.
  apply pad_Sep_TType_seq; auto.
Qed.

Lemma pad_Sep_AType_seq : forall {n : nat} (a : AType n) (m : nat),
    proper_length_AType a -> m = n -> pad_Sep_AType a (List.seq 0 m) m = a.
Proof. intros. subst.
  apply pad_Sep_AType_seq_nil; auto.
  apply proper_length_AType_implies_proper_length_AType_nil; auto.
Qed.

Lemma proper_length_AType_nil_pad_Sep_AType : forall {n : nat} (a : AType n) (l : list nat) (m : nat),
    m <> 0%nat -> proper_length_AType_nil (pad_Sep_AType a l m).
Proof. intros n a l m H.
  unfold pad_Sep_AType in *.
  induction a.
  - simpl. constructor.
  - simpl. constructor; auto.
    apply proper_length_TType_pad_Sep_TType; auto.
Qed.

Lemma proper_length_AType_pad_Sep_AType : forall {n : nat} (a : AType n) (l : list nat) (m : nat),
    m <> 0%nat -> a <> [] -> proper_length_AType (pad_Sep_AType a l m).
Proof. intros n a l m H H0.
  unfold pad_Sep_AType in *.
  induction a.
  - simpl. contradiction.
  - simpl.
    destruct a0.
    + simpl. constructor. 
      apply proper_length_TType_pad_Sep_TType; auto.
    + constructor; auto.
      * apply proper_length_TType_pad_Sep_TType; auto.
      * assert (t :: a0 <> []). { intro. inversion H1. }
        apply IHa in H1; auto.
Qed.


Definition unpad_Sep_AType {n : nat} (a : AType n) (l : list nat) : AType (length l) :=
  map (fun t => unpad_Sep_TType t l) a.

Lemma unpad_pad_Sep_AType : forall {n : nat} (a : AType n) (l : list nat) (m : nat),
    proper_length_AType a ->
    NoDup l -> length l = n -> incl l (List.seq 0 m) ->
    unpad_Sep_AType (pad_Sep_AType a l m) l = a.
Proof. intros n a l m H H0 H1 H2.
  unfold unpad_Sep_AType, pad_Sep_AType.
  rewrite map_map.
  induction H; subst; simpl in *; f_equal; try apply unpad_pad_Sep_TType; auto.
Qed.


Definition translateP {n} (p : Predicate n) :=
  match p with
  | AtoPred s => translateA s
  | _ => Zero
  end.

Lemma translateP_defaultP_I : forall {n : nat}, 
    (0 < n)%nat ->  translateP (defaultP_I n) = I (2 ^ n)%nat.
Proof. intros n H. 
  unfold translateP, defaultP_I. 
  unfold defaultP_I.
  apply translateA_defaultA_I; auto.
Qed.

(* you cannot multiply cap or cup types 
   so any of these options returns Err *)
Definition mul {n} (A B : Predicate n) : Predicate n :=
  match A with
  | AtoPred a =>
    match B with
    | AtoPred b => AtoPred (gMulA a b)
    | _ => Err
    end
  | _ => Err
  end.

Definition add {n} (A B : Predicate n) : Predicate n :=
  match A with
  | AtoPred a =>
    match B with
    | AtoPred b => AtoPred (gAddA a b)
    | _ => Err
    end
  | _ => Err
  end.

Definition tensor {n m} (A : Predicate n) (B : Predicate m): Predicate (n + m) :=
  match A with
  | AtoPred a =>
      match B with
      | AtoPred b => AtoPred (gTensorA a b)
      | _ => Err
      end
  | _ => Err
  end.

(** We define scale to work for all predicate structures.
This will allow - - p = p for any predicate p. **)
Fixpoint scale {n} (c : Coef) (A : Predicate n) : Predicate n :=
  match A with
  | AtoPred a => AtoPred (gScaleA c a)
  | Cap la => Cap (map (gScaleA c) la)
  | Sep Ln_LLT_Perm => Sep (fst (fst Ln_LLT_Perm), (map (fun LT => map (fun T => gScaleTTypes c T) LT) (snd (fst Ln_LLT_Perm))), snd Ln_LLT_Perm)
  | Cup a b => Cup (scale c a) (scale c b)
  | Err => Err
  end.

Lemma scale_merge : forall {n : nat} (c1 c2 : Coef) (P : Predicate n),
    scale c2 (scale c1 P) = scale (c2 * c1) P.
Proof. intros n c1 c2 P.
  induction P; simpl; try rewrite gScaleA_merge; try rewrite IHP1, IHP2; auto.
  - rewrite map_map. do 2 f_equal.
    apply functional_extensionality; intros.
    rewrite gScaleA_merge; auto.
  - rewrite ! map_map. do 4 f_equal.
      apply functional_extensionality; intros.
      rewrite map_map. f_equal.
      apply functional_extensionality; intros.
      rewrite gScaleTTypes_merge; auto.
Qed.

#[export] Hint Rewrite gMulA_nil_r gMulA'_nil_l gScaleT_1 gScaleA_1 : typing_db.

Notation "- A" := (scale (Copp C1) A)  (at level 35, right associativity) : Predicate_scope.
Notation "+i A" := (scale Ci A)  (at level 35, right associativity) : Predicate_scope.
Notation "-i A" := (scale (Copp Ci) A)  (at level 35, right associativity) : Predicate_scope.

Lemma neg_inv : forall {n : nat} (p : Predicate n), (- (- p)) = p.
Proof. intros n p.  
  induction p; simpl; try (rewrite IHp1, IHp2); try rewrite IHp; auto.
  - rewrite gScaleA_merge.
    replace (- C1 * - C1) with C1 by lca.
    rewrite gScaleA_1; auto.
  - rewrite map_map. f_equal.
    assert (H : (fun x : AType n => gScaleA (- C1)%C (gScaleA (- C1)%C x)) 
                = (fun x : AType n => x)).
    { apply functional_extensionality. intros.
      rewrite gScaleA_merge.
      assert (H : (- C1 * - C1) = C1). { lca. }
      rewrite H, gScaleA_1. auto. }
    setoid_rewrite H. rewrite map_id. auto.
  - f_equal. do 2 destruct p. simpl. do 2 f_equal.
    rewrite ! map_map. setoid_rewrite <- map_id at 6.
    f_equal. apply functional_extensionality; intros.
    rewrite map_map. setoid_rewrite <- map_id at 3.
    f_equal. apply functional_extensionality; intros.
    rewrite gScaleTTypes_merge.
    replace ((- C1) * (- C1))%C with C1 by lca.
    rewrite gScaleTTypes_1. auto.
Qed.

Infix "⊗'" := tensor (at level 39, left associativity) : Predicate_scope.
Infix "*'" := mul (at level 40, left associativity) : Predicate_scope.
Infix "·'" := scale (at level 43, left associativity) : Predicate_scope.
Infix "+'" := add (at level 50, left associativity) : Predicate_scope.

Notation "⋂ la" := (Cap la) (at level 61, left associativity) : Predicate_scope.
Notation "A ⊍ B" := (Cup A B) (at level 61, left associativity) : Predicate_scope.
Notation "∩ Ln_LLT_Perm" := (Sep Ln_LLT_Perm) (at level 30, no associativity) : Predicate_scope.


(*** Most of these are not used ***)
(******************************************************************************)
(* Defining different types of Predicates to ensure WF(Well-formedness) and translations *)
(******************************************************************************)

(* Not used
Inductive TPredicate {n} : Predicate n -> Prop :=
| G_tp : forall t : TType n, TPredicate (G [t]).
*)

Lemma proper_length_TType_gScaleT : forall {n : nat} (c : Coef) (t : TType n),
  proper_length_TType t -> proper_length_TType (gScaleT c t).
Proof. intros n c t H. destruct t. unfold proper_length_TType in *. simpl in *. assumption.
Qed.

(* Not used
Inductive proper_length_TPredicate {n} : Predicate n -> Prop :=
| pl_tp : forall t : TType n, proper_length_TType n t -> proper_length_TPredicate (G [t]).

Lemma proper_length_TPredicate_implies_TPredicate : forall {n} (T : Predicate n),
    proper_length_TPredicate T -> TPredicate T.
Proof. intros n T H. inversion H. constructor. Qed.
*)
(* Not used
Inductive APredicate {n} : Predicate n -> Prop :=
| G_ap : forall a : AType n, APredicate (G a).
*)

Lemma proper_length_AType_nil_gScaleA : forall {n : nat} (c : Coef) (a : AType n),
    proper_length_AType_nil a -> proper_length_AType_nil (gScaleA c a).
Proof. intros n c a H. induction H.
  - constructor.
  - simpl in *. constructor.
    + apply proper_length_TType_gScaleT. assumption.
    + assumption.
Qed.

Lemma proper_length_AType_gScaleA : forall {n : nat} (c : Coef) (a : AType n),
    proper_length_AType a -> proper_length_AType (gScaleA c a).
Proof. intros n c a H. induction H.
  - constructor. apply proper_length_TType_gScaleT. assumption.
  - simpl in *. constructor.
    + apply proper_length_TType_gScaleT. assumption.
    + assumption.
Qed.

Lemma proper_length_AType_nil_App : forall {n : nat} (a1 a2 : AType n),
    proper_length_AType_nil a1 -> proper_length_AType_nil a2 ->
    proper_length_AType_nil (a1 ++ a2).
Proof. intros n a1 a2 H H0.
  induction H; simpl; try constructor; assumption.
Qed.

Lemma proper_length_AType_App : forall {n : nat} (a1 a2 : AType n),
    proper_length_AType a1 -> proper_length_AType a2 ->
    proper_length_AType (a1 ++ a2).
Proof. intros n a1 a2 H H0.
  induction H; simpl; constructor; assumption.
Qed.
(* Not used
Inductive proper_length_APredicate {n} : Predicate n -> Prop :=
| pl_ap : forall a : AType n, proper_length_AType n a -> proper_length_APredicate (G a).

Lemma proper_length_APredicate_implies_APredicate : forall {n} (A : Predicate n),
    proper_length_APredicate A -> APredicate A.
Proof. intros n A H. inversion H. constructor. Qed.

Lemma  proper_length_TPredicate_implies_proper_length_APredicate :
  forall {n} (T : Predicate n),
    proper_length_TPredicate T -> proper_length_APredicate T.
Proof. intros n T H. inversion H. do 2 constructor. auto. Qed. 

Inductive CPredicate {n} : Predicate n -> Prop :=
| Cap_p : forall A B : Predicate n, CPredicate (Cap A B)
| Cup_p : forall A B : Predicate n, CPredicate (Cup A B).

Lemma TPredicate_implies_APredicate : forall {n} (T : Predicate n),
    TPredicate T -> APredicate T.
Proof. intros. inversion H; apply G_ap. Qed.


Lemma TPredicate_simplify : forall {n} (A : Predicate n),
  TPredicate A -> (exists t, A = G [t]).
Proof. intros. destruct A; try easy.
       inversion H; subst.
       exists t. reflexivity. 
Qed.

Lemma APredicate_simplify : forall {n} (A : Predicate n),
  APredicate A -> (exists a, A = G a).
Proof. intros. destruct A; try easy.
       exists a. reflexivity. 
Qed.

#[export] Hint Resolve TPredicate_implies_APredicate TPredicate_simplify APredicate_simplify : wfpt_db.
*)

Notation tI := (C1, [gI]).
Notation tX := (C1, [gX]).
Notation tY := (C1, [gY]).
Notation tZ := (C1, [gZ]).
Notation tII := (C1, [gI; gI]).
Notation tXI := (C1, [gX; gI]).
Notation tIX := (C1, [gI; gX]).
Notation tXX := (C1, [gX; gX]).
Notation tYI := (C1, [gY; gI]).
Notation tIY := (C1, [gI; gY]).
Notation tYY := (C1, [gY; gY]).
Notation tYX := (C1, [gY; gX]).
Notation tXY := (C1, [gX; gY]).
Notation tZY := (C1, [gZ; gY]).
Notation tYZ := (C1, [gY; gZ]).
Notation tXZ := (C1, [gX; gZ]).
Notation tZX := (C1, [gZ; gX]).
Notation tZI := (C1, [gZ; gI]).
Notation tIZ := (C1, [gI; gZ]).
Notation tZZ := (C1, [gZ; gZ]).
Notation mtI := ((- C1)%C, [gI]).
Notation mtX := ((- C1)%C, [gX]).
Notation mtY := ((- C1)%C, [gY]).
Notation mtZ := ((- C1)%C, [gZ]).
Notation mtII := ((- C1)%C, [gI; gI]).
Notation mtXI := ((- C1)%C, [gX; gI]).
Notation mtIX := ((- C1)%C, [gI; gX]).
Notation mtXX := ((- C1)%C, [gX; gX]).
Notation mtYI := ((- C1)%C, [gY; gI]).
Notation mtIY := ((- C1)%C, [gI; gY]).
Notation mtYY := ((- C1)%C, [gY; gY]).
Notation mtYX := ((- C1)%C, [gY; gX]).
Notation mtXY := ((- C1)%C, [gX; gY]).
Notation mtZY := ((- C1)%C, [gZ; gY]).
Notation mtYZ := ((- C1)%C, [gY; gZ]).
Notation mtXZ := ((- C1)%C, [gX; gZ]).
Notation mtZX := ((- C1)%C, [gZ; gX]).
Notation mtZI := ((- C1)%C, [gZ; gI]).
Notation mtIZ := ((- C1)%C, [gI; gZ]).
Notation mtZZ := ((- C1)%C, [gZ; gZ]).

Notation aI := [tI].
Notation aX := [tX].
Notation aY := [tY].
Notation aZ := [tZ].
Notation aII := [tII].
Notation aXI := [tXI].
Notation aIX := [tIX].
Notation aXX := [tXX].
Notation aYI := [tYI].
Notation aIY := [tIY].
Notation aYY := [tYY].
Notation aYX := [tYX].
Notation aXY := [tXY].
Notation aZY := [tZY].
Notation aYZ := [tYZ].
Notation aXZ := [tXZ].
Notation aZX := [tZX].
Notation aZI := [tZI].
Notation aIZ := [tIZ].
Notation aZZ := [tZZ].
Notation maI := [mtI].
Notation maX := [mtX].
Notation maY := [mtY].
Notation maZ := [mtZ].
Notation maII := [mtII].
Notation maXI := [mtXI].
Notation maIX := [mtIX].
Notation maXX := [mtXX].
Notation maYI := [mtYI].
Notation maIY := [mtIY].
Notation maYY := [mtYY].
Notation maYX := [mtYX].
Notation maXY := [mtXY].
Notation maZY := [mtZY].
Notation maYZ := [mtYZ].
Notation maXZ := [mtXZ].
Notation maZX := [mtZX].
Notation maZI := [mtZI].
Notation maIZ := [mtIZ].
Notation maZZ := [mtZZ].
Notation aXY2 := (gScaleA (C1/√2)%C [(C1, [gX]); (C1, [gY])]).
Notation aYX2 := (gScaleA (C1/√2)%C [(C1, [gY]); (C1, [gX])]).
Notation aX2Y2 := [((C1/√2)%C, [gX]); ((C1/√2)%C, [gY])].
Notation aY2X2 := [((C1/√2)%C, [gY]); ((C1/√2)%C, [gX])].
Notation aYmX2 := (gScaleA (C1/√2)%C [(C1, [gY]); ((- C1)%C, [gX])]).
Notation amXY2 := (gScaleA (C1/√2)%C [((- C1)%C, [gX]); (C1, [gY])]).
Notation aY2mX2 := [((C1/√2)%C, [gY]); (((C1/√2) * (- C1))%C, [gX])].
Notation amX2Y2 := [(((C1/√2) * (- C1))%C, [gX]); ((C1/√2)%C, [gY])].

Notation pI := (@AtoPred 1 aI).
Notation pX := (@AtoPred 1 aX).
Notation pY := (@AtoPred 1 aY).
Notation pZ := (@AtoPred 1 aZ).
Notation pII := (@AtoPred 2 aII).
Notation pXI := (@AtoPred 2 aXI).
Notation pIX := (@AtoPred 2 aIX).
Notation pXX := (@AtoPred 2 aXX).
Notation pYI := (@AtoPred 2 aYI).
Notation pIY := (@AtoPred 2 aIY).
Notation pYY := (@AtoPred 2 aYY).
Notation pYX := (@AtoPred 2 aYX).
Notation pXY := (@AtoPred 2 aXY).
Notation pZY := (@AtoPred 2 aZY).
Notation pYZ := (@AtoPred 2 aYZ).
Notation pXZ := (@AtoPred 2 aXZ).
Notation pZX := (@AtoPred 2 aZX).
Notation pZI := (@AtoPred 2 aZI).
Notation pIZ := (@AtoPred 2 aIZ).
Notation pZZ := (@AtoPred 2 aZZ).
Notation mpI := (@AtoPred 1 maI).
Notation mpX := (@AtoPred 1 maX).
Notation mpY := (@AtoPred 1 maY).
Notation mpZ := (@AtoPred 1 maZ).
Notation mpII := (@AtoPred 2 maII).
Notation mpXI := (@AtoPred 2 maXI).
Notation mpIX := (@AtoPred 2 maIX).
Notation mpXX := (@AtoPred 2 maXX).
Notation mpYI := (@AtoPred 2 maYI).
Notation mpIY := (@AtoPred 2 maIY).
Notation mpYY := (@AtoPred 2 maYY).
Notation mpYX := (@AtoPred 2 maYX).
Notation mpXY := (@AtoPred 2 maXY).
Notation mpZY := (@AtoPred 2 maZY).
Notation mpYZ := (@AtoPred 2 maYZ).
Notation mpXZ := (@AtoPred 2 maXZ).
Notation mpZX := (@AtoPred 2 maZX).
Notation mpZI := (@AtoPred 2 maZI).
Notation mpIZ := (@AtoPred 2 maIZ).
Notation mpZZ := (@AtoPred 2 maZZ).
Notation pXY2 := (@AtoPred 1 aXY2).
Notation pYX2 := (@AtoPred 1 aYX2).
Notation pX2Y2 := (@AtoPred 1 aX2Y2).
Notation pY2X2 := (@AtoPred 1 aY2X2).
Notation pYmX2 := (@AtoPred 1 aYmX2).
Notation pmXY2 := (@AtoPred 1 amXY2).
Notation pY2mX2 := (@AtoPred 1 aY2mX2).
Notation pmX2Y2 := (@AtoPred 1 amX2Y2).


Lemma Y_is_iXZ : pY = (+i (pX *' pZ)).
Proof. simpl.
  unfold gMulA; simpl. compute.
  autorewrite with R_db.
  assert (R0 = (-R0)%R). { lra. }
  rewrite <- H.
  constructor.
Qed.

#[export] Hint Resolve Y_is_iXZ : wfpt_db.

(*** Most of these are not used ***)
(*
(***************)
(* TPredicate Lemmas *)
(***************)
Lemma TI : TPredicate pI. Proof. easy. Qed.
Lemma TX : TPredicate pX. Proof. easy. Qed.
Lemma TZ : TPredicate pZ. Proof. easy. Qed.

Lemma T_scale : forall {n} (A : Predicate n) (c : Coef), TPredicate A -> (TPredicate (scale c A)).  
Proof. intros. inversion H. simpl. easy. Qed. 

Lemma T_neg : forall {n} (A : Predicate n), TPredicate A -> TPredicate (- A).
Proof. intros. inversion H. simpl. easy. Qed. 
 
Lemma T_i : forall {n} (A : Predicate n), TPredicate A -> TPredicate (+i A).
Proof. intros. inversion H. simpl. easy. Qed. 

Lemma T_mul : forall {n} (A B : Predicate n), TPredicate A -> TPredicate B -> TPredicate (A *' B).
Proof. intros. inversion H. inversion H0. simpl. easy. Qed.

Lemma T_tensor : forall {n m} (A : Predicate n) (B : Predicate m), TPredicate A -> TPredicate B -> TPredicate (A ⊗' B).
Proof. intros. inversion H. inversion H0. simpl. constructor. Qed.

Lemma TY : TPredicate pY.
Proof. easy. Qed.

#[export] Hint Resolve TI TX TZ TY T_scale T_neg T_i T_mul T_tensor : wfpt_db.




(***************)
(* APredicate Lemmas *)
(***************)

Lemma AI : APredicate pI. Proof. easy. Qed.
Lemma AX : APredicate pX. Proof. easy. Qed.
Lemma AZ : APredicate pZ. Proof. easy. Qed.

Lemma A_scale : forall {n} (A : Predicate n) (c : Coef), APredicate A -> (APredicate (scale c A)).  
Proof. intros. destruct A; easy. Qed.
Locate "-".

Lemma A_neg : forall {n} (A : Predicate n), APredicate A -> APredicate (- A).
Proof. intros. destruct A; easy. Qed. 
 
Lemma A_i : forall {n} (A : Predicate n), APredicate A -> APredicate (+i A).
Proof. intros. destruct A; easy. Qed. 

Lemma A_mul : forall {n} (A B : Predicate n), APredicate A -> APredicate B -> APredicate (A *' B).
Proof. intros.
       destruct A; destruct B; easy.
Qed.

Lemma A_tensor : forall {n m} (A : Predicate n) (B : Predicate m), APredicate A -> APredicate B -> APredicate (A ⊗' B).
Proof. intros.
       destruct A; destruct B; easy.
Qed.

Lemma AY : APredicate pY.
Proof. easy. Qed.

#[export] Hint Resolve AI AX AZ AY A_scale A_neg A_i A_mul A_tensor : wfpt_db.
*)


(**************************)
(* Well Formedness Lemmas *)
(**************************)

(** can be commented out: anticommute_TType defined below
Definition Anticommutative_direct {n} (t1 t2 : TType n) : Prop :=
  cBigMul (zipWith gMul_Coef (snd t1) (snd t2)) = Copp (cBigMul (zipWith gMul_Coef (snd t2) (snd t1))).
**)
(* inductive version
Inductive Anticommutative_direct {n} : TType n -> TType n -> Prop :=
| AC : forall t1 t2 : TType n, cBigMul (zipWith gMul_Coef (snd t1) (snd t2)) = Copp (cBigMul (zipWith gMul_Coef (snd t2) (snd t1))) -> Anticommutative_direct t1 t2.
*)


(** Can define directly on Pauli strings, and cons on the list of Paulis **)
(*
Inductive Commutative_test : forall n, TType n -> TType n -> Prop :=
| comm_base_test : Commutative_test 1 (C1,[gX]) (C1,[gI])
| comm_tensor_test : forall m n (A B : TType m) (C D : TType n),
    Commutative_test m A B ->
    Commutative_test n C D ->
    Commutative_test (m+n) (gTensorT A C) (gTensorT B D)
                         
with 

Anticommutative_test : forall n, TType n -> TType n -> Prop :=
| anticomm_base_test : Anticommutative_test 1 (C1,[gX]) (C1,[gY])
| anticomm_tensor_test : forall m n (A B : TType m) (C D : TType n),
    Anticommutative_test m A B ->
    Commutative_test n C D ->
    Anticommutative_test (m+n) (gTensorT A C) (gTensorT B D).
*)

(** can be commented out
Inductive Commutative : list Pauli -> list Pauli -> Prop :=
| comm_base_I_L : forall (P:Pauli), Commutative [gI] [P]
| comm_base_I_R : forall (P:Pauli), Commutative [P] [gI]
| comm_base_same : forall (P:Pauli), Commutative [P] [P]
| comm_tensor_comm : forall (a b : Pauli) (A B : list Pauli),
    Commutative [a] [b] ->
    Commutative A B ->
    Commutative (a::A) (b::B)
| comm_tensor_anticomm : forall (a b : Pauli) (A B : list Pauli),
    Anticommutative [a] [b] ->
    Anticommutative A B ->
    Commutative (a::A) (b::B)

with 

Anticommutative : list Pauli -> list Pauli -> Prop :=
| anticomm_base_XY : Anticommutative [gX] [gY]
| anticomm_base_YX : Anticommutative [gY] [gX]
| anticomm_base_XZ : Anticommutative [gX] [gZ]
| anticomm_base_ZX : Anticommutative [gZ] [gX]
| anticomm_base_YZ : Anticommutative [gY] [gZ]
| anticomm_base_ZY : Anticommutative [gZ] [gY]
| anticomm_tensor_anticomm_comm : forall (a b : Pauli) (A B : list Pauli),
    Anticommutative [a] [b] ->
    Commutative A B ->
    Anticommutative (a::A) (b::B)
| anticomm_tensor_comm_anticomm : forall (a b : Pauli) (A B : list Pauli),
    Commutative [a] [b] ->
    Anticommutative A B ->
    Anticommutative (a::A) (b::B).
**)


(* old version : now proper_length_TType
Definition WF_TType (n : nat) (t : TType n) : Prop := n <> O /\ length (snd t) = n.
 *)
(* inductive version of the old version
Inductive WF_TType (n : nat) (t : TType n) : Prop :=
(* | WF_TT_nil : forall (c : Coef), WF_TType_nil n (c, []) *)
| WF_TT : n <> O /\ length (snd t) = n -> WF_TType n t.
 *)

Lemma translate_gMulT: forall (l l0 : list Pauli) (a b : Coef), length l0 = length l -> translate (gMulT (a, l) (b, l0)) =  (a * b .* ((⨂ map translate_P l) × (⨂ map translate_P l0)))%M.
Proof. induction l.
    - intros. simpl in *. rewrite length_zero_iff_nil in H. rewrite H. simpl. unfold translate, cBigMul, gMul_Coef, zipWith. simpl. rewrite Cmult_1_r.  lma'.
    - intros. simpl in *. destruct l0; try discriminate.
      simpl in *. inversion H.
      rewrite ! map_length. 
      assert (2 ^ length l + (2 ^ length l + 0) = 2 ^ (S (length l)))%nat. { simpl. easy. }
      rewrite ! H1.
      rewrite H0.
      assert (@Mmult (2 ^ S (length l)) (2 ^ S (length l)) (2 ^ S (length l)) (translate_P a ⊗ (⨂ map translate_P l)) (translate_P p ⊗ (⨂ map translate_P l0)) =  (@Mmult 2 2 2 (translate_P a) (translate_P p)) ⊗ (@Mmult (2 ^ length l) (2 ^ length l) (2 ^ length l) (⨂ map translate_P l) (⨂ map translate_P l0))).
      { rewrite ! map_length. rewrite ! H1.
        apply kron_mixed_product' with (A:= translate_P a) (B:= big_kron (map translate_P l)) (C:= translate_P p) (D:= big_kron (map translate_P l0)); easy. } 
      rewrite ! map_length in H2.
      setoid_rewrite kron_mixed_product.
      rewrite ! map_length in IHl.
      setoid_rewrite <- Mscale_kron_dist_r with (x:= a0 * b) at 1.
      rewrite <- IHl; try easy.
      unfold translate, cBigMul, zipWith, gMul_Coef, uncurry. simpl. rewrite ! fold_left_Cmult.

      setoid_rewrite <- Mscale_kron_dist_r.
      rewrite <- Mscale_assoc.
      setoid_rewrite Mscale_kron_dist_r.
      setoid_rewrite <- Mscale_kron_dist_l.
      setoid_rewrite Mscale_kron_dist_r.
      rewrite <- Mscale_assoc.
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite Mscale_kron_dist_l.
      setoid_rewrite Mscale_assoc.
      setoid_rewrite <- Mscale_kron_dist_l.
      symmetry.
      rewrite <- Mscale_assoc.

assert (translate_P a × translate_P p
  ⊗ (a0 * b
     .* (fold_left Cmult
           (map
              (fun p0 : Pauli * Pauli =>
               let (x, y) := p0 in
               match x with
               | gI => C1
               | gX => match y with
                       | gY => Ci
                       | gZ => (- Ci)%C
                       | _ => C1
                       end
               | gY => match y with
                       | gX => (- Ci)%C
                       | gZ => Ci
                       | _ => C1
                       end
               | gZ => match y with
                       | gX => Ci
                       | gY => (- Ci)%C
                       | _ => C1
                       end
               end) (combine l l0)) C1
         .* (⨂ map translate_P
                 (map (fun p0 : Pauli * Pauli => let (x, y) := p0 in gMul_base x y)
                    (combine l l0)))))%M
        =
          ((a0 * b) .* (translate_P a × translate_P p)
  ⊗ ((fold_left Cmult
           (map
              (fun p0 : Pauli * Pauli =>
               let (x, y) := p0 in
               match x with
               | gI => C1
               | gX => match y with
                       | gY => Ci
                       | gZ => (- Ci)%C
                       | _ => C1
                       end
               | gY => match y with
                       | gX => (- Ci)%C
                       | gZ => Ci
                       | _ => C1
                       end
               | gZ => match y with
                       | gX => Ci
                       | gY => (- Ci)%C
                       | _ => C1
                       end
               end) (combine l l0)) C1
         .* (⨂ map translate_P
                 (map (fun p0 : Pauli * Pauli => let (x, y) := p0 in gMul_base x y)
                    (combine l l0))))))%M).
{ 
  rewrite Mscale_kron_dist_r.
  rewrite <- Mscale_kron_dist_l.
  easy.
}
rewrite ! map_length in H3.
rewrite ! combine_length in H3.
rewrite H1 in H3.
replace (Init.Nat.min (length l) (length l)) with (length l) in H3 by lia.
setoid_rewrite H3.
rewrite ! map_length.
rewrite ! combine_length.
rewrite H1.
replace (Init.Nat.min (length l) (length l)) with (length l) by lia.
f_equal.
destruct a, p; simpl; try lma'.
Qed.

Lemma translate_gMulT_mult : forall {n : nat} (t1 t2 : TType n), 
    proper_length_TType t1 -> proper_length_TType t2 -> 
    translate (gMulT t1 t2) =  translate t1 × translate t2.
Proof. intros n t1 t2 H H0.
  unfold translate at 2. unfold translate at 2. 
  destruct H, H0, t1, t2. 
  simpl in H1, H2. 
  pose translate_gMulT as e.
  rewrite <- H1 in H2.
  specialize (e l l0 c c0 H2).
  setoid_rewrite e.
  simpl. subst.
  rewrite <- Mscale_assoc.
  rewrite <- Mscale_mult_dist_r.
  rewrite <- Mscale_mult_dist_l.
  f_equal. all: rewrite map_length; auto.
Qed.

Lemma translate_gTensorT : forall {n m : nat} (t1 : TType n) (t2 : TType m),
    length (snd t1) = n -> length (snd t2) = m ->
    translate (gTensorT t1 t2) = translate t1 ⊗ translate t2.
Proof. intros n m t1 t2 H H0.
  destruct t1, t2. simpl in *.
  unfold translate. simpl.
  rewrite ! map_length, ! H, ! H0, ! app_length.
  assert ((2 ^ n) * (2 ^ m) = 2 ^ (n + m))%nat.
  { rewrite <- Nat.pow_add_r. auto. }
  rewrite Mscale_kron_dist_l, Mscale_kron_dist_r.
  distribute_scale. f_equal.
  1-2: rewrite H, H0, H1; auto.
  rewrite map_app.
  rewrite big_kron_app; intros.
  - f_equal. all: rewrite map_length; try rewrite H; try rewrite H0; auto.
  - bdestruct (i <? n).
    + rewrite nth_indep with (d' := translate_P gI).
      2: rewrite map_length, H; lia.
      rewrite map_nth. 
      destruct (nth i l gI); simpl; auto with wf_db.
    + rewrite nth_overflow; auto with wf_db; rewrite map_length; lia.
  - bdestruct (i <? m).
    + rewrite nth_indep with (d' := translate_P gI).
      2: rewrite map_length, H0; lia.
      rewrite map_nth. 
      destruct (nth i l gI); simpl; auto with wf_db.
    + rewrite nth_overflow; auto with wf_db; rewrite map_length; lia.
Qed.

Lemma translate_gScaleT : forall {n} (c : Coef) (t : TType n),
    proper_length_TType t -> translate (gScaleT c t) = c .* translate t.
Proof. intros.  destruct H. destruct t. unfold gScaleT. unfold translate. simpl in *.
  rewrite map_length. rewrite H0. rewrite Mscale_assoc. reflexivity.
Qed.

Lemma WF_Matrix_translate_nil : forall {n : nat} (t : TType n), proper_length_TType_nil t -> WF_Matrix (translate t).
Proof. intros. destruct t. unfold translate. destruct H. simpl in *.
  rewrite map_length. apply WF_scale. 
  rewrite <- map_length with (f := translate_P).
  apply WF_big_kron with (A := I 2).
  intros.
  rewrite map_nth with (f := translate_P) (d := gI).
  auto with wf_db.
Qed.

Lemma WF_translate : forall {n : nat} (t : TType n), proper_length_TType t -> WF_Matrix (translate t).
Proof. intros. apply proper_length_TType_implies_proper_length_TType_nil in H.
  apply WF_Matrix_translate_nil.
  assumption.
Qed.

#[export] Hint Resolve WF_Matrix_translate_nil WF_translate : wf_db.


(** define this directly on the list of Paulis **)
(*
Inductive trace_zero_TType : forall n, TType n -> Prop :=
| trace_zero_X : forall c, trace_zero_TType 1 (c, [gX])
| trace_zero_Y : forall c, trace_zero_TType 1 (c, [gY])
| trace_zero_Z : forall c, trace_zero_TType 1 (c, [gZ])
| trace_zero_L : forall (n m : nat) (A : TType n) (B : TType m), trace_zero_TType n A -> trace_zero_TType (n+m) (gTensorT A B)
| trace_zero_R : forall (n m : nat) (A : TType n) (B : TType m), trace_zero_TType m B -> trace_zero_TType (n+m) (gTensorT A B).
*)

Inductive trace_zero_syntax : list Pauli -> Prop :=
| trace_zero_syntax_X : trace_zero_syntax [gX]
| trace_zero_syntax_Y : trace_zero_syntax [gY]
| trace_zero_syntax_Z : trace_zero_syntax [gZ]
| trace_zero_syntax_L : forall (A B : list Pauli), trace_zero_syntax A -> trace_zero_syntax (A++B)
| trace_zero_syntax_R : forall (A B : list Pauli), trace_zero_syntax B -> trace_zero_syntax (A++B).

Lemma trace_zero_syntax_implies_trace_zero : forall (A : list Pauli),
    trace_zero_syntax A -> trace (⨂ map translate_P A) = 0.
Proof. intros. induction H.
  1-3 : matrix_compute.
  1-2 : rewrite map_app; rewrite big_kron_app; try apply WF_Matrix_nth_Pauli;
  rewrite ! app_length;
  rewrite ! map_length;
  assert (H0 : (2 ^ (length A + length B))%nat = (2 ^ (length A) * 2 ^ (length B))%nat).
  1,3: rewrite Nat.pow_add_r; reflexivity.
  1-2: rewrite H0;
  rewrite trace_kron_dist;
  rewrite map_length in IHtrace_zero_syntax;
  try rewrite IHtrace_zero_syntax;
  try rewrite Cmult_0_l; try rewrite Cmult_0_r;
  try reflexivity.
  1-2: intro; rewrite Nat.pow_eq_0_iff in H1; destruct H1; lia.
Qed.
  
Definition coef_plus_minus_1 {n : nat} (t : TType n) := fst t = C1 \/ fst t = Copp C1.

Lemma translate_Hermitian : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_plus_minus_1 t -> adjoint (translate t) = translate t.
Proof. intros n t H H0.
  destruct H, t. unfold translate. simpl in *.
  pose (list_Pauli_Hermitian l) as H2.
  rewrite map_length in *.
  rewrite H1 in *.
  rewrite Mscale_adj.
  rewrite H2.
  f_equal.
  destruct H0; simpl in *; subst; lca.
Qed.

Lemma coef_plus_minus_1_defaultT_I : forall (n : nat),
    coef_plus_minus_1 (defaultT_I n).
Proof. intros n.
  unfold coef_plus_minus_1, defaultT_I.
  left. auto.
Qed.

Lemma coef_plus_minus_1_defaultT_Z : forall (n : nat),
    coef_plus_minus_1 (defaultT_Z n).
Proof. intros n.
  unfold coef_plus_minus_1, defaultT_Z.
  left. auto.
Qed.

Definition coef_size_1 {n : nat} (t : TType n) := (fst t) * (fst t)^* = C1.

Lemma coef_plus_minus_1_implies_coef_size_1 : forall {n : nat} (t : TType n),
    coef_plus_minus_1 t -> coef_size_1 t.
Proof. intros n t H.
  unfold coef_plus_minus_1, coef_size_1 in *.
  destruct t. simpl in *.
  destruct H; subst; lca.
Qed.

Lemma coef_size_1_defaultT_I : forall (n : nat),
    coef_size_1 (defaultT_I n).
Proof. intros n.
  apply coef_plus_minus_1_implies_coef_size_1.
  apply coef_plus_minus_1_defaultT_I.
Qed.

Lemma coef_size_1_defaultT_Z : forall (n : nat),
    coef_size_1 (defaultT_Z n).
Proof. intros n.
  apply coef_plus_minus_1_implies_coef_size_1.
  apply coef_plus_minus_1_defaultT_Z.
Qed.

Lemma coef_size_1_gMultT_preserve : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    coef_size_1 t1 -> coef_size_1 t2 -> coef_size_1 (gMulT t1 t2).
Proof. intros n t1 t2 H H0 H1 H2.
  unfold coef_size_1, gMulT in *.
  destruct t1, t2; simpl in *.
  rewrite ! Cconj_mult_distr.
  setoid_rewrite Cmult_comm at 2.
  setoid_rewrite Cmult_comm at 5.
  assert (cBigMul (zipWith gMul_Coef l l0) * (c * c0) *
            (c0 ^* * c ^* * (cBigMul (zipWith gMul_Coef l l0)) ^* ) =
               cBigMul (zipWith gMul_Coef l l0) * (c * (c0 *
                 c0 ^* ) * c ^* ) * (cBigMul (zipWith gMul_Coef l l0)) ^* ).
  { rewrite ! Cmult_assoc. auto. }
  rewrite H3.
  rewrite H2. rewrite Cmult_1_r. rewrite H1. rewrite Cmult_1_r.
  destruct H, H0. simpl in H4, H5. rewrite <- H5 in H4, H.
  clear - H H4.
  gen l0. induction l; intros. destruct l0; try contradiction; try discriminate.
  destruct l0; try discriminate. clear H. simpl in H4. apply Nat.succ_inj in H4.
  destruct l. destruct l0; try discriminate.
  unfold cBigMul, zipWith, uncurry, gMul_Coef; destruct a, p; lca.
  destruct l0; try discriminate. simpl in H4. apply Nat.succ_inj in H4.
  assert (length (p1 :: l0) <> 0%nat) by (simpl; auto).
  assert (length (p0 :: l) = length (p1 :: l0)) by (simpl; lia).
  specialize (IHl (p1 :: l0) H H0).
  unfold zipWith in *. simpl in *. 
  unfold uncurry in *; simpl. 
  destruct a, p; unfold cBigMul in *; simpl in *; rewrite <- ! Cmult_assoc;
  rewrite fold_left_Cmult in *;  repeat rewrite Cmult_1_l; auto.
  all : try (rewrite <- IHl at 3; lca).
Qed.

Lemma translate_mult_adjoint_inv : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_size_1 t -> (translate t) × (translate t)† = I (2 ^ n)%nat.
Proof. intros n t H H0. 
  unfold translate.
  unfold proper_length_TType, coef_size_1 in *.
  destruct H, t.
  simpl in *. 
  rewrite ! map_length, ! H1.
  rewrite Mscale_adj.
  rewrite Mscale_mult_dist_l.
  rewrite Mscale_mult_dist_r.
  rewrite Mscale_assoc.
  rewrite H0.
  rewrite Mscale_1_l.
  clear H0.
  gen n. induction l; intros.
  - simpl in *. subst. contradiction.
  - simpl in *. destruct n. contradiction. clear H.
    apply Nat.succ_inj in H1.
    destruct n.
    + rewrite length_zero_iff_nil in H1. subst. simpl.
      rewrite kron_1_r.
      destruct a; simpl; lma'.
    + rewrite ! map_length. rewrite ! H1.
      replace (2 ^ S (S n))%nat with (2 * (2 ^ S n))%nat by (simpl; lia).
      rewrite kron_adjoint.
      setoid_rewrite kron_mixed_product'; auto.
      rewrite IHl.
      assert (translate_P a × adjoint (translate_P a) = I 2) by (destruct a; simpl; lma').
      rewrite H. rewrite kron_2_l. auto.
      all : try rewrite H1; auto.
Qed.

Lemma translate_adjoint_mult_inv : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_size_1 t -> (translate t)† × (translate t) = I (2 ^ n)%nat.
Proof. intros n t H H0.
  apply Minv_flip.
  apply WF_translate; auto.
  apply WF_adjoint. apply WF_translate; auto.
  apply translate_mult_adjoint_inv; auto.
Qed.

Lemma translate_Minv : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_size_1 t -> Minv (translate t) ((translate t)†).
Proof. intros n t H H0.
  split. apply translate_mult_adjoint_inv; auto.
  apply translate_adjoint_mult_inv; auto.
Qed.

Lemma translate_invertible : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_size_1 t -> invertible (translate t).
Proof. intros n t H H0.
  unfold invertible.
  exists (translate t)†.
  split. apply WF_adjoint. apply WF_translate; auto.
  apply translate_Minv; auto.
Qed.

Lemma translate_adjoint_invertible : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_size_1 t -> invertible (adjoint (translate t)).
Proof. intros n t H H0.
  unfold invertible.
  exists (translate t).
  split. apply WF_translate; auto.
  apply Minv_symm.
  apply translate_Minv; auto.
Qed.

Lemma translate_adjoint_eq : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_plus_minus_1 t -> (translate t) † = translate t.
Proof. intros n t H H1.
  destruct H.
  unfold coef_plus_minus_1 in H1.
  unfold translate. destruct t. simpl in *.
  rewrite ! map_length, ! H0.
  rewrite Mscale_adj.
  destruct H1; subst; f_equal; try lca.
  - induction l. simpl in H. contradiction.
    clear H. simpl. rewrite ! map_length. 
    assert ((2 ^ length l + (2 ^ length l + 0))%nat = 2 * (2 ^ (length l)))%nat by (simpl; auto).
    rewrite ! H.
    rewrite kron_adjoint.
    f_equal.
    + destruct a; simpl; lma'.
    + destruct l.
      * simpl. rewrite id_adjoint_eq. auto.
      * assert (length (p :: l) <> 0%nat) by (simpl; auto).
        apply IHl. auto.
  - induction l. simpl in H. contradiction.
    clear H. simpl. rewrite ! map_length. 
    assert ((2 ^ length l + (2 ^ length l + 0))%nat = 2 * (2 ^ (length l)))%nat by (simpl; auto).
    rewrite ! H.
    rewrite kron_adjoint.
    f_equal.
    + destruct a; simpl; lma'.
    + destruct l.
      * simpl. rewrite id_adjoint_eq. auto.
      * assert (length (p :: l) <> 0%nat) by (simpl; auto).
        apply IHl. auto.
Qed.

Inductive WF_TType {n : nat} (t : TType n) : Prop :=
  (* | WF_TT_nil : forall (c : Coef), WF_TType_nil n (c, []) *)
  | WF_T : proper_length_TType t -> coef_plus_minus_1 t -> trace_zero_syntax (snd t) -> WF_TType t.
(** Coef = 1, -1, somewhere Pauli of trace zero
X, Y, Z, WF A -> A⊗B, WF A -> B⊗A
 **)

Lemma translate_mult_inv : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_plus_minus_1 t -> (translate t) × (translate t) = I (2 ^ n)%nat.
Proof. intros n t H H0. 
  unfold translate.
  unfold proper_length_TType, coef_plus_minus_1 in *.
  destruct H, t.
  simpl in *. 
  rewrite ! map_length, ! H1.
  rewrite Mscale_mult_dist_l.
  rewrite Mscale_mult_dist_r.
  rewrite Mscale_assoc.
  replace (c * c) with C1 by (destruct H0 as [H0 | H0]; rewrite H0; lca).
  rewrite Mscale_1_l.
  clear H0.
  gen n. induction l; intros.
  - simpl in *. subst. contradiction.
  - simpl in *. destruct n. contradiction. clear H.
    apply Nat.succ_inj in H1.
    destruct n.
    + rewrite length_zero_iff_nil in H1. subst. simpl.
      rewrite kron_1_r.
      destruct a; simpl; lma'.
    + setoid_rewrite kron_mixed_product'; auto.
      rewrite IHl.
      rewrite map_length, H1.
      assert (translate_P a × translate_P a = I 2) by (destruct a; simpl; lma').
      rewrite H. rewrite kron_2_l. auto.
      all : rewrite map_length; try rewrite H1; auto.
Qed.

Lemma WF_ErrT : ~ @WF_TType 0 ErrT.
Proof. intros H.
       inversion H. simpl in *. destruct H0. contradiction.
Qed.
Lemma WF_ErrT_n : forall n : nat, ~ @WF_TType n ErrT.
Proof. intros n H. inversion H. destruct H0. unfold ErrT in *.
  simpl in *. rewrite <- H3 in H0. contradiction.
Qed.

Lemma WF_defaultT_Z : forall {n : nat}, n <> 0%nat -> WF_TType (defaultT_Z n).
Proof. intros n H.
  unfold defaultT_Z.
  constructor; auto.
  - constructor; simpl; try rewrite repeat_length; auto.
  - unfold coef_plus_minus_1. auto.
  - simpl.
    destruct n; try contradiction.
    replace (S n) with (1 + n)%nat by lia.
    rewrite repeat_app.
    apply trace_zero_syntax_L.
    simpl. constructor.
Qed.

#[export] Hint Resolve WF_defaultT_Z : wf_db.


Lemma zipWith_gMul_base_inv : forall (l : list Pauli),
    zipWith gMul_base l l = repeat gI (length l).
Proof. intros l. induction l.
  - unfold zipWith, gMul_base; easy.
  - unfold zipWith, gMul_base, uncurry in *; simpl.
    rewrite IHl. f_equal.
    destruct a; easy.
Qed.

Lemma cBigMul_zipWith_gMul_Coef_inv : forall (l : list Pauli),
    cBigMul (zipWith gMul_Coef l l) = C1.
Proof. intros l. induction l.
  - unfold cBigMul, zipWith, uncurry, gMul_Coef; easy.
  - unfold cBigMul, zipWith, uncurry, gMul_Coef in *; simpl.
    rewrite fold_left_Cmult.
    rewrite IHl.
    destruct a; lca.
Qed.

Lemma proper_length_TType_gMulT : forall {n} (t t0 : TType n),
    proper_length_TType t -> proper_length_TType t0
    -> proper_length_TType (gMulT t t0).
Proof. intros n t t0 H H0.
  destruct t, t0. simpl in *.
  destruct H, H0.
  constructor; auto.
  simpl in *.
  apply zipWith_len_pres; auto.
Qed.

Lemma gMulT_inv : forall {n} (t : TType n),
    proper_length_TType t -> coef_plus_minus_1 t -> gMulT t t = defaultT_I n.
Proof. intros n t H H0.
  unfold defaultT_I.
  unfold coef_plus_minus_1 in *.
  inversion H.
  destruct t. simpl in *.
  rewrite zipWith_gMul_base_inv.
  rewrite cBigMul_zipWith_gMul_Coef_inv.
  destruct H0; subst; f_equal; lca.
Qed.

Lemma gMulT_id_l : forall {n} (t : TType n),
    proper_length_TType t -> gMulT (defaultT_I n) t = t.
Proof. intros n t H.
  unfold defaultT_I.
  unfold gMulT.
  destruct t.
  inversion H; clear H.
  simpl in *.
  f_equal.
  - rewrite Cmult_1_l.
    rewrite <- Cmult_1_r with (x := c) at 2.
    f_equal.
    gen n.
    induction l; intros; simpl in *.
    + symmetry in H1. contradiction.
    + destruct n; try contradiction.
      apply Nat.succ_inj in H1.
      destruct n.
      * rewrite length_zero_iff_nil in H1.
        subst.
        unfold cBigMul, zipWith, gMul_Coef, uncurry; simpl.
        lca.
      * assert (S n <> 0)%nat by lia.
        specialize (IHl (S n) H H1).
        unfold cBigMul, zipWith, gMul_Coef, uncurry in *; simpl in *.
        rewrite Cmult_1_l.
        auto.
  - gen n.
    induction l; intros; simpl in *.
    + symmetry in H1. contradiction.
    + do 2 (destruct n; try contradiction).
      * apply Nat.succ_inj in H1.
        rewrite length_zero_iff_nil in H1.
        subst.
        unfold zipWith, gMul_base, uncurry.
        auto.
      * apply Nat.succ_inj in H1.
        assert (S n <> 0)%nat by lia.
        specialize (IHl (S n) H H1).
        unfold zipWith, gMul_base, uncurry in *; simpl in *.
        f_equal.
        auto. 
Qed.
        
Lemma gMulT_id_r : forall {n} (t : TType n),
    proper_length_TType t -> gMulT t (defaultT_I n) = t.
Proof. intros n t H.
  unfold defaultT_I.
  unfold gMulT.
  destruct t.
  inversion H; clear H.
  simpl in *.
  f_equal.
  - rewrite Cmult_1_r.
    rewrite <- Cmult_1_r with (x := c) at 2.
    f_equal.
    gen n.
    induction l; intros; simpl in *.
    + symmetry in H1. contradiction.
    + destruct n; try contradiction.
      apply Nat.succ_inj in H1.
      destruct n.
      * rewrite length_zero_iff_nil in H1.
        subst.
        unfold cBigMul, zipWith, gMul_Coef, uncurry; simpl.
        destruct a; lca.
      * assert (S n <> 0)%nat by lia.
        specialize (IHl (S n) H H1).
        unfold cBigMul, zipWith, gMul_Coef, uncurry in *; simpl in *.
        rewrite Cmult_1_l.
        destruct a; auto.
  - gen n.
    induction l; intros; simpl in *.
    + symmetry in H1. contradiction.
    + do 2 (destruct n; try contradiction).
      * apply Nat.succ_inj in H1.
        rewrite length_zero_iff_nil in H1.
        subst.
        unfold zipWith, gMul_base, uncurry.
        simpl.
        destruct a; auto.
      * apply Nat.succ_inj in H1.
        assert (S n <> 0)%nat by lia.
        specialize (IHl (S n) H H1).
        unfold zipWith, gMul_base, uncurry in *; simpl in *.
        f_equal;
        destruct a; auto.
Qed.

Lemma gMulT_reduce : forall (n : nat) (c1 c2 : Coef) (p1 p2 : Pauli) (l1 l2 : list Pauli),
  length l1 = n -> length l2 = n ->
  gMulT (c1, p1 :: l1) (c2, p2 :: l2) = 
  @gTensorT 1 n (gMul_Coef p1 p2, [gMul_base p1 p2]) (gMulT (c1, l1) (c2, l2)).
Proof. intros. simpl. rewrite zipWith_cons.
  apply injective_projections; try easy.
  simpl.
  unfold cBigMul.
  simpl.
  rewrite fold_left_Cmult.
  rewrite Cmult_assoc.
  replace (c1 * c2 * gMul_Coef p1 p2) with (gMul_Coef p1 p2 * (c1 * c2)) by lca.
  rewrite <- Cmult_assoc.
  reflexivity.
Qed.

Lemma gMulT_gTensorT_dist : forall {n m : nat} (t1 t2 : TType n) (t3 t4 : TType m),
    proper_length_TType t1 -> proper_length_TType t2 ->
    proper_length_TType t3 -> proper_length_TType t4 ->
  gMulT (gTensorT t1 t3) (gTensorT t2 t4) = gTensorT (gMulT t1 t2) (gMulT t3 t4).
Proof. intros. 
       destruct t1; destruct t2; destruct t3; destruct t4. 
       simpl gTensorT.
       inversion H; inversion H0; inversion H1; inversion H2. 
       simpl in *.
       bdestruct_all. simpl. 
       apply injective_projections; simpl. 
  - rewrite (Cmult_assoc).
    rewrite (Cmult_comm).
    symmetry.
    rewrite (Cmult_assoc).
    rewrite (Cmult_comm).
    rewrite (Cmult_comm ( c * c0 ) (cBigMul (zipWith gMul_Coef l l0))).
    rewrite (Cmult_assoc ).
    
    rewrite (Cmult_assoc (cBigMul (zipWith gMul_Coef l1 l2)) (cBigMul (zipWith gMul_Coef l l0)) (c * c0)).
    rewrite (Cmult_comm ( cBigMul (zipWith gMul_Coef l1 l2)) (cBigMul (zipWith gMul_Coef l l0))).
    rewrite (cBigMul_app).
    rewrite (zipWith_app_product _ n); try easy.
    rewrite <- 4 (Cmult_assoc).
    assert (c0 * (c1 * c2) = c1 * (c0 * c2)). { lca. }
    rewrite H11. reflexivity.
  - rewrite (zipWith_app_product _ n); try easy.
Qed.

Lemma gMulT_assoc : forall (n : nat) (t1 t2 t3 : TType n),
  proper_length_TType t1 -> proper_length_TType t2 -> proper_length_TType t3 ->
  gMulT (gMulT t1 t2) t3 = gMulT t1 (gMulT t2 t3).
Proof. intros n t1 t2 t3 H H0 H1.
  induction n; [| destruct n].
  - inversion H; inversion H0; inversion H1.
    destruct t1; destruct t2; destruct t3.
    destruct l; destruct l0; destruct l1; try easy.
  - inversion H; inversion H0; inversion H1.
    destruct t1; destruct t2; destruct t3.
    destruct l; destruct l0; destruct l1; try easy.
    simpl in H3; simpl in H5; simpl in H7.
    apply Nat.succ_inj in H3;
      apply Nat.succ_inj in H5;
      apply Nat.succ_inj in H7.
    rewrite length_zero_iff_nil in *.
    rewrite H3, H5, H7.
    simpl. unfold cBigMul, zipWith, gMul_Coef, uncurry; induction p, p0, p1; apply injective_projections; simpl; try easy; try lca.
  - destruct t1, t2, t3.
    destruct l, l0, l1; inversion H; inversion H0; inversion H1.
    1-7 : simpl in *; try discriminate.
    simpl in H3; simpl in H5; simpl in H7.
         apply Nat.succ_inj in H3;
         apply Nat.succ_inj in H5;
           apply Nat.succ_inj in H7.
         repeat rewrite gMulT_reduce; try easy.
         assert (H9 : (c1, p1 :: l1) = @gTensorT 1 n (C1, [p1]) (c1, l1)).
         { simpl. bdestruct_all. apply injective_projections; simpl; try easy. lca. }
         assert (H10 : (c, p :: l) = @gTensorT 1 n (C1, [p]) (c, l)).
         { simpl. bdestruct_all. apply injective_projections; simpl; try easy. lca. }
         rewrite H9, H10. 
         do 2 replace (S n) with (1 + n)%nat by lia.
         pose (@gMulT_gTensorT_dist 1 (S n) (gMul_Coef p p0, [gMul_base p p0])  (C1, [p1]) (gMulT (c, l) (c0, l0)) (c1, l1)) as e; rewrite e at 1.
         pose (@gMulT_gTensorT_dist 1 (S n) (C1, [p]) (gMul_Coef p0 p1, [gMul_base p0 p1]) (c, l) (gMulT (c0, l0) (c1, l1))) as w; rewrite w at 1.
         all : try easy.
         rewrite IHn; try easy.
         assert (H11 : (@gMulT 1 (gMul_Coef p p0, [gMul_base p p0]) (C1, [p1])) = 
                      (@gMulT 1 (C1, [p]) (gMul_Coef p0 p1, [gMul_base p0 p1]))).
         { destruct p; destruct p0; destruct p1; compute; autorewrite with R_db; replace R0 with 0 by lra; autorewrite with R_db; try easy. }
         rewrite H11; easy. 
         all : simpl; bdestruct_all; try constructor; simpl. 
         all : try rewrite (zipWith_len_pres _ (S n)); try easy.
Qed.


Lemma translateA_gScaleA_nil : forall {n} (c : Coef) (A : AType n),
    proper_length_AType_nil A -> translateA (gScaleA c A) = c .* (translateA A).
Proof. intros. induction A; simpl; unfold translateA in *; simpl.
  - rewrite Mscale_0_r. reflexivity.
  - unfold gScaleA in *. rewrite ! fold_left_Mplus. rewrite Mscale_plus_distr_r.
    rewrite IHA. f_equal. apply translate_gScaleT. inversion H; assumption.
    inversion H. assumption.
Qed.

Lemma translateA_gScaleA : forall {n} (c : Coef) (A : AType n),
    proper_length_AType A -> translateA (gScaleA c A) = c .* (translateA A).
Proof. intros. apply proper_length_AType_implies_proper_length_AType_nil in H.
  apply translateA_gScaleA_nil. assumption.
Qed.


Lemma WF_Matrix_translateA_nil : forall {n : nat} (a : AType n), proper_length_AType_nil a -> WF_Matrix (translateA a).
Proof. intros. unfold translateA.
  induction a; simpl.
  - auto with wf_db.
  - rewrite fold_left_Mplus.
    apply WF_plus.
    apply IHa.
    inversion H.
    assumption.
    apply WF_translate.
    inversion H.
    assumption.
Qed.

Lemma WF_Matrix_translateA : forall {n : nat} (a : AType n), proper_length_AType a -> WF_Matrix (translateA a).
Proof. intros.
  apply proper_length_AType_implies_proper_length_AType_nil in H.
  apply WF_Matrix_translateA_nil.
  assumption.
Qed.

#[export] Hint Resolve WF_Matrix_translateA_nil WF_Matrix_translateA : wf_db.


(*** Normalization ***)
(*
(** ** Version with more fixed points ** **)
(* Prove that this version is equivalent with the less fixpointed version later on *)
(** k := lenL   < fuel >
     nth_j_L_defaultT := nth j L (defaultT_I n)   < fixed >
     initL := L   < fixed >
     n, i, j, lenL   < fixed > **)
Fixpoint loop_replaceT_XY_fixed (n i j k lenL : nat) (nth_j_L_defaultT : TType n) (initL L : list (TType n)) {struct k} : list (TType n) :=
match k with
| 0%nat => L
| S k' => 
    if Nat.eqb (lenL - k) j
    then loop_replaceT_XY_fixed n i j k' lenL nth_j_L_defaultT initL L
    else 
      match nth i (snd (nth (lenL - k) initL (defaultT_I n))) gI with
      | gX | gY => loop_replaceT_XY_fixed n i j k' lenL nth_j_L_defaultT initL (switch L (gMulT nth_j_L_defaultT (nth (lenL - k) initL (defaultT_I n))) (lenL - k))
      | _ => loop_replaceT_XY_fixed n i j k' lenL nth_j_L_defaultT initL L
      end
end.

(** k := lenL   < fuel >
     nth_j_L_defaultT := nth j L (defaultT_I n)   < fixed >
     initL := L   < fixed >
     n, i, j, lenL   < fixed > **)
Fixpoint loop_replaceT_Z_fixed (n i j k lenL : nat) (nth_j_L_defaultT : TType n) (initL L : list (TType n)) {struct k} : list (TType n) :=
match k with
| 0%nat => L
| S k' => 
    if Nat.eqb (lenL - k) j
    then loop_replaceT_Z_fixed n i j k' lenL nth_j_L_defaultT initL L
    else 
      match nth i (snd (nth (lenL - k) initL (defaultT_I n))) gI with
      | gZ => loop_replaceT_Z_fixed n i j k' lenL nth_j_L_defaultT initL (switch L (gMulT nth_j_L_defaultT (nth (lenL - k) initL (defaultT_I n))) (lenL - k))
      | _ => loop_replaceT_Z_fixed n i j k' lenL nth_j_L_defaultT initL L
      end
end.

(** j := lenL   < fuel >
     Lz := []
     n, i, lenL   < fixed > **)
Fixpoint loop_j_return_PL_fixed (n i j lenL : nat) (P : list nat) (L : list (TType n)) (Lz : list nat) : (list nat) * (list (TType n)) := 
  match j with
  | S j' => 
      if (existsb (fun p : nat => Nat.eqb p (lenL - j)%nat) P) 
      then
        (* loop on next j *)
        loop_j_return_PL_fixed n i j' lenL P L Lz
      else 
        match nth i (snd (nth (lenL - j)%nat L (defaultT_I n))) gI with
        | gI => 
            (* loop on next j *)
            loop_j_return_PL_fixed n i j' lenL P L Lz
        | gZ => 
            (* add j to Lz and loop on next j *)
            loop_j_return_PL_fixed n i j' lenL P L ((lenL - j)%nat :: Lz)
        | _ => 
            (* add j to P and return P, (loop_replaceT_XY n i j (length L) L) *)
            (((lenL - j)%nat :: P), (loop_replaceT_XY_fixed n i (lenL - j)%nat lenL lenL (nth (lenL - j)%nat L (defaultT_I n)) L L))
        end
  | 0%nat =>
      match rev Lz with
      | [] => 
          (* return P, L *)
          (P, L)
      | h :: _ => 
          (* add j to P and return P, (loop_replaceT_Z n i j (length L) L) *)
          ((h :: P), (loop_replaceT_Z_fixed n i h lenL lenL (nth (lenL - j)%nat L (defaultT_I n)) L L))
      end
  end.

(** i := n   < fuel >
     lenL := length L   < fixed >
     n := initialized from input   < fixed >
     P := []
     L := initialized from input **)
Fixpoint loop_normalization_fixed (n i lenL : nat) (P : list nat) (L : list (TType n)) {struct i} : list (TType n)  :=
  match i with
  | S i' =>
      (* do loop_j_return_PL and get (P, L), recurse on next i *)
      let (P', L') := loop_j_return_PL_fixed n (n - i)%nat lenL lenL P L [] in
      loop_normalization_fixed n i' lenL P' L'
  | 0%nat =>
      (* Final Ordering with rev P *)
      (map (fun p : nat => nth p L (defaultT_I n)) (rev P)) ++ 
        lexicographic (map (fun q : nat => nth q L (defaultT_I n))
                     (filter (fun a : nat => negb (existsb (fun p : nat => if Nat.eq_dec p a then true else false) P))
                        (List.seq 0 (lenL))))
  end.

(**  : list (TType n) **)
Definition normalize_fixed {n : nat} (L : list (TType n)) := loop_normalization_fixed n n (length L) [] L.

(* Eval cbn in normalize_fixed (rev LT3). *)
*)

(** ** Version with less fixpoints ** **)
(** k := length L
     n, i, j   < fixed > **)
Fixpoint loop_replaceT_XY (n i j k : nat) (L : list (TType n)) {struct k} : list (TType n) :=
match k with
| 0%nat => L
| S k' => 
    if Nat.eqb ((length L) - k) j
    then loop_replaceT_XY n i j k' L
    else 
      match nth i (snd (nth ((length L) - k) L (defaultT_I n))) gI with
      | gX | gY => loop_replaceT_XY n i j k' (switch L (gMulT (nth j L (defaultT_I n)) (nth ((length L) - k) L (defaultT_I n))) ((length L) - k))
      | _ => loop_replaceT_XY n i j k' L
      end
end.

(** k := length L
     n, i, j   < fixed > **)
Fixpoint loop_replaceT_Z (n i j k : nat) (L : list (TType n)) {struct k} : list (TType n) :=
match k with
| 0%nat => L
| S k' => 
    if Nat.eqb ((length L) - k) j
    then loop_replaceT_Z n i j k' L
    else 
      match nth i (snd (nth ((length L) - k) L (defaultT_I n))) gI with
      | gZ => loop_replaceT_Z n i j k' (switch L (gMulT (nth j L (defaultT_I n)) (nth ((length L) - k) L (defaultT_I n))) ((length L) - k))
      | _ => loop_replaceT_Z n i j k' L
      end
end.

(** j := length L
     Lz := []
     n, i   < fixed > **)
Fixpoint loop_j_return_PL (n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat) : (list nat) * (list (TType n)) := 
  match j with
  | S j' => 
      if (existsb (fun p : nat => Nat.eqb p ((length L) - j)%nat) P) 
      then
        (* loop on next j *)
        loop_j_return_PL n i j' P L Lz
      else 
        match nth i (snd (nth ((length L) - j)%nat L (defaultT_I n))) gI with
        | gI => 
            (* loop on next j *)
            loop_j_return_PL n i j' P L Lz
        | gZ => 
            (* add j to Lz and loop on next j *)
            loop_j_return_PL n i j' P L (((length L) - j)%nat :: Lz)
        | _ => 
            (* add j to P and return P, (loop_replaceT_XY n i j (length L) L) *)
            ((((length L) - j)%nat :: P), (loop_replaceT_XY n i ((length L) - j)%nat (length L) L))
        end
  | 0%nat =>
      match rev Lz with
      | [] => 
          (* return P, L *)
          (P, L)
      | h :: _ => 
          (* add j to P and return P, (loop_replaceT_Z n i j (length L) L) *)
          ((h :: P), (loop_replaceT_Z n i h (length L) L))
      end
  end.

(** i := n
     n := initialized from input   < fixed >
     P := []
     L := initialized from input **)
Fixpoint loop_normalization (n i : nat) (P : list nat) (L : list (TType n)) {struct i} : list (TType n)  :=
  match i with
  | S i' =>
      (* do loop_j_return_PL and get (P, L), recurse on next i *)
      let (P', L') := loop_j_return_PL n (n - i)%nat (length L) P L [] in
      loop_normalization n i' P' L'
  | 0%nat =>
      (* Final Ordering with rev P *)
      (map (fun p : nat => nth p L (defaultT_I n)) (rev P)) ++ 
        lexicographic (map (fun q : nat => nth q L (defaultT_I n))
                     (filter (fun a : nat => negb (existsb (fun p : nat => if Nat.eq_dec p a then true else false) P))
                        (List.seq 0 (length L))))
  end.

(**  : list (TType n) **)
Definition normalize {n : nat} (L : list (TType n)) := loop_normalization n n [] L.

Lemma loop_replaceT_XY_nil : forall (n i j k : nat), loop_replaceT_XY n i j k [] = [].
Proof. intros n i j k. gen i j.
  induction k; intros;
    unfold loop_replaceT_XY; auto.
  bdestruct_all; simpl in *; subst.
  rewrite IHk; auto.
  destruct (nth i (repeat gI n) gI) eqn:E; try rewrite IHk; auto.
Qed.

Lemma loop_replaceT_Z_nil : forall (n i j k : nat), loop_replaceT_Z n i j k [] = [].
Proof. intros n i j k. gen i j.
  induction k; intros;
    unfold loop_replaceT_Z; auto.
  bdestruct_all; simpl in *; subst.
  rewrite IHk; auto.
  destruct (nth i (repeat gI n) gI) eqn:E; try rewrite IHk; auto.
Qed.

Lemma loop_j_return_PL_nil : forall (n i j : nat) (P : list nat) (Lz : list nat),
    snd (loop_j_return_PL n i j P [] Lz) = [].
Proof. intros n i j P Lz.
  gen i P Lz. induction j; intros; 
    unfold loop_j_return_PL.
  destruct (rev Lz); simpl; auto.
  destruct (existsb (fun p : nat => p =? length [] - S j) P) eqn:E.
  rewrite IHj; auto.
  destruct (nth i (snd (nth (length [] - S j) [] (defaultT_I n))) gI) eqn:E';
    try rewrite IHj; auto.
Qed.

Lemma loop_normalization_nil : forall (n i : nat), loop_normalization n i [] [] = [].
Proof. intros n i. 
  induction i;
    unfold loop_normalization; simpl;
    unfold lexicographic; simpl; auto.
Qed.

Lemma normalize_nil : forall {n : nat}, @normalize n [] = [].
Proof. intros n.
  unfold normalize.
  apply loop_normalization_nil.
Qed.

(* Eval cbn in normalize (rev LT3). *)



(** ** Fuel based admissibility proof ** **)
(** Assuming that Permutation on intersections is provably admissible *) 

(** ** Lemma 1 ** **)
Lemma Permutation_filter_existsb_eqdec : 
  forall {A : Type} (eq_dec : (forall x y : A, {x = y} + {x <> y})) (L P : list A),
    NoDup L -> NoDup P -> incl P L ->
    Permutation P (filter (fun a => existsb (fun p => if eq_dec p a then true else false) P) L).
Proof. intros A eq_dec L P H H0 H1.
  gen P.
  induction L; intros.
  - destruct P; auto.
    simpl in *.
    assert (In a (a :: P)) by (simpl; auto).
    apply H1 in H2.
    contradiction.
  - destruct (in_dec eq_dec a P).
    + apply In_nth with (d := a) in i.
      destruct i as [n [H2 H3]].
      pose (nth_inc n P a H2).
      rewrite H3 in e.

      assert (Permutation P ([a] ++ firstn n P ++ skipn (S n) P)).
      { rewrite e at 1.  rewrite ! app_assoc.
        apply Permutation_app_tail.
        apply Permutation_app_comm. }
      apply Permutation_trans with (l' := [a] ++ firstn n P ++ skipn (S n) P); auto.
      
      assert ((filter (fun a0 : A =>
                         existsb (fun p : A => if eq_dec p a0 then true else false) P) (a :: L)) =
                a :: (filter (fun a : A =>
                               existsb (fun p : A => if eq_dec p a then true else false) P) L)).
      { simpl. 
        destruct (existsb (fun p : A => if eq_dec p a then true else false) P) eqn:E; auto.
        rewrite e in E.
        rewrite existsb_app in E.
        simpl in E.
        destruct (eq_dec a a); try contradiction.
        simpl in E.
        rewrite orb_true_r in E.
        discriminate. }
      rewrite H5.
      replace ([a] ++ firstn n P ++ skipn (S n) P) 
        with (a :: (firstn n P ++ skipn (S n) P)) by auto.
      constructor.
      rewrite NoDup_cons_iff in H.
      destruct H.

      assert ((filter (fun a0 : A => existsb 
                                    (fun p : A => if eq_dec p a0 then true else false) 
                                    P) L) = 
                (filter (fun a0 : A => existsb 
                                      (fun p : A => if eq_dec p a0 then true else false) 
                                      (firstn n P ++ skipn (S n) P)) L)).
      { replace (fun a0 : A => existsb (fun p : A => if eq_dec p a0 then true else false) P)
                  with (fun a0 : A => existsb (fun p : A => if eq_dec p a0 then true else false) 
                                     (firstn n P ++ [a] ++ skipn (S n) P))
          by (rewrite <- e; auto).
        apply filter_ext_in.
        intros a0 H7.
        rewrite ! existsb_app.
        f_equal.
        setoid_rewrite <- orb_false_l at 6.
        f_equal.
        simpl.
        destruct (eq_dec a a0) eqn:E; auto.
        subst. contradiction. }
      rewrite H7.
      replace ([a] ++ skipn (S n) P) with (a :: skipn (S n) P) in e by auto.
      apply (IHL H6 (firstn n P ++ skipn (S n) P)).
      * rewrite e in H0.
        apply NoDup_remove_1 in H0.
        auto.
      * unfold incl. intros.
        assert (incl (firstn n P ++ skipn (S n) P) P).
        { unfold incl. intros.
          rewrite e.
          rewrite in_app_iff.
          rewrite in_app_iff in H9.
          destruct H9.
          - left; auto.
          - right; apply in_cons; auto. } 
        rewrite e in H0.
        apply NoDup_remove in H0.
        destruct H0.
        destruct (eq_dec a a0).
        -- subst. contradiction.
        -- apply H9 in H8.
           apply H1 in H8.
           destruct H8; try contradiction; auto.
    + assert (incl P L).
      { unfold incl. intros.
        destruct (eq_dec a a0).
        - subst. contradiction.
        - apply H1 in H2.
          destruct H2; try contradiction; auto. }
      rewrite NoDup_cons_iff in H.
      destruct H.
      specialize (IHL H3 P H0 H2).
      assert ((filter (fun a : A => 
                         existsb (fun p : A => if eq_dec p a then true else false) P) L)
              = (filter (fun a0 : A =>
                           existsb (fun p : A => if eq_dec p a0 then true else false) P) (a :: L))).
      { simpl.
        destruct (existsb (fun p : A => if eq_dec p a then true else false) P) eqn:E; auto.
        rewrite existsb_exists in E.
        destruct E as [x [H4 H5]].
        destruct (eq_dec x a) eqn:E; try discriminate.
        subst. contradiction. }
      rewrite <- H4; auto.
Qed.

(** ** Corollary 1 ** **)
Lemma Permutation_filter_existsb_eqdec_seq : forall (k : nat) (P : list nat),
    NoDup P -> incl P (List.seq 0 k) ->
    Permutation P (filter (fun a => existsb (fun p => if Nat.eq_dec p a then true else false) P) (List.seq 0 k)).
Proof. intros k P H H0. 
  apply Permutation_filter_existsb_eqdec; auto.
  apply seq_NoDup.
Qed.


(** ** Lemma 2 ** **)
Lemma Permutation_map_nth : forall {A : Type} (default : A) (L : list A),
    L = (map (fun q : nat => nth q L default) (List.seq 0 (length L))).
Proof. intros A default L.
  induction L; auto.
  simpl. f_equal.
  rewrite IHL at 1.
  apply nth_ext with (d := nth 0%nat L default) (d' := a).
  - rewrite ! map_length, ! seq_length; auto.
  - intros n H.
     rewrite ! map_length, ! seq_length in H.
     rewrite ! map_nth with (d := 0%nat).
     rewrite ! seq_nth; auto.
Qed.

(** ** Lemma 3 ** **)
Lemma Permutation_map_nth_seq : forall {A : Type} (L : list A) (default : A) (S : list nat),
    Permutation (seq 0 (length L)) S ->
    Permutation L (map (fun p : nat => nth p L default) S).
Proof. intros A L default S H.
  rewrite (Permutation_map_nth default L) at 1.
  apply Permutation_map; auto.
Qed.

(** ** Lemma 4 ** **)
Lemma final_ordering_Permutation : forall (n : nat) (P : list nat) (L : list (TType n)) ,
    NoDup P -> incl P (seq 0 (length L)) ->
    Permutation L ((map (fun p : nat => nth p L (defaultT_I n)) (rev P)) ++ 
                     lexicographic (map (fun q : nat => nth q L (defaultT_I n))
                                      (filter (fun a : nat => negb (existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)) (List.seq 0 (length L))))).
Proof. intros n P L H H0.
  unfold lexicographic.
  rewrite map_rev.
  rewrite <- rev_app_distr.
  apply Permutation_trans with (l' := (TOrd.sort
                                        (map (fun q : nat => nth q L (defaultT_I n))
                                           (filter
                                              (fun a : nat =>
                                                 ¬ existsb
                                                   (fun p : nat =>
                                                      if Nat.eq_dec p a then true else false) P)
                                              (seq 0 (length L)))) ++
                                        map (fun p : nat => nth p L (defaultT_I n)) P));
    try apply Permutation_rev.

  assert (Permutation
            ((map (fun q : nat => nth q L (defaultT_I n))
                (filter
                   (fun a : nat =>
                      ¬ existsb
                        (fun p : nat => if Nat.eq_dec p a then true else false)
                        P) (seq 0 (length L)))) ++
               map (fun p : nat => nth p L (defaultT_I n)) P)
            (TOrd.sort
               (map (fun q : nat => nth q L (defaultT_I n))
                  (filter
                     (fun a : nat =>
                        ¬ existsb
                          (fun p : nat => if Nat.eq_dec p a then true else false)
                          P) (seq 0 (length L)))) ++
               map (fun p : nat => nth p L (defaultT_I n)) P)).
  { apply Permutation_app_tail.
    apply TOrd.Permuted_sort. }
  apply Permutation_trans with (l' := (map (fun q : nat => nth q L (defaultT_I n))
                                        (filter (fun a : nat =>
                                                   ¬ existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)
                                           (seq 0 (length L))) ++ map (fun p : nat => nth p L (defaultT_I n)) P));
    auto.
  rewrite <- map_app.

  assert (Permutation (seq 0 (length L))
            (filter
               (fun a : nat =>
                  ¬ existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)
               (seq 0 (length L)) ++ P)).
  { apply Permutation_trans with (l' := (P ++ filter
       (fun a : nat =>
        ¬ existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)
       (seq 0 (length L)))); try apply Permutation_app_comm.
    
    assert (Permutation
              ((filter (fun a => existsb (fun p => if Nat.eq_dec p a then true else false) P) (List.seq 0 (length L))) ++ (filter (fun a : nat => negb (existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)) (seq 0 (length L))))
              (P ++ (filter (fun a : nat => negb (existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)) (seq 0 (length L))))).
    { apply Permutation_app_tail.
      apply Permutation_sym.
      apply Permutation_filter_existsb_eqdec_seq; auto. }
    
    apply Permutation_trans with (l' := 
                                    (filter
                                       (fun a : nat =>
                                          existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)
                                       (seq 0 (length L)) ++
                                       filter
                                       (fun a : nat =>
                                          ¬ existsb (fun p : nat => if Nat.eq_dec p a then true else false) P)
                                       (seq 0 (length L))));
      auto.
    apply filter_orth_app_permutation. }
  apply Permutation_map_nth_seq; auto.
Qed.


(** ** Fueled version with less fixpoints ** **)
(** k := length L   < fuel >
     n, i, j   < fixed > **)
Fixpoint loop_replaceT_XY_fuel (kfuel n i j k : nat) (L : list (TType n)) {struct kfuel} : list (TType n) :=
  match kfuel with
  | S kfuel' =>
      match k with
      | 0%nat => L
      | S k' => 
          if Nat.eqb ((length L) - k) j
          then loop_replaceT_XY_fuel kfuel' n i j k' L
          else 
            match nth i (snd (nth ((length L) - k) L (defaultT_I n))) gI with
            | gX | gY => loop_replaceT_XY_fuel kfuel' n i j k' (switch L (gMulT (nth j L (defaultT_I n)) (nth ((length L) - k) L (defaultT_I n))) ((length L) - k))
            | _ => loop_replaceT_XY_fuel kfuel' n i j k' L
            end
      end
  | 0%nat => L
  end.

Lemma loop_replaceT_XY_length : forall (n i j k : nat) (L : list (TType n)),
    length (loop_replaceT_XY n i j k L) = length L.
Proof. intros n i j k L.
  gen L.
  induction k; intros; simpl; auto.
  bdestruct_all; auto.
  destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
  all: rewrite IHk; rewrite switch_len; auto.
Qed.

Lemma loop_replaceT_XY_fuel_length : forall (kfuel n i j k : nat) (L : list (TType n)),
    length (loop_replaceT_XY_fuel kfuel n i j k L) = length L.
Proof. intros kfuel n i j k L.
  gen k L.
  induction kfuel; intros; simpl; auto.
  destruct k; auto.
  bdestruct_all; simpl; auto.
  destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
  all: rewrite IHkfuel; rewrite switch_len; auto.
Qed.

Lemma loop_replaceT_XY_fuel_saturated_base : forall (n i j k : nat) (L : list (TType n)),
    loop_replaceT_XY_fuel k n i j k L = loop_replaceT_XY n i j k L.
Proof. intros n i j k L.
  gen L. induction k; intros; simpl; auto.
  bdestruct_all; auto.
  destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
Qed.

Lemma loop_replaceT_XY_fuel_saturated : forall (kfuel n i j k : nat) (L : list (TType n)),
    (kfuel >= k)%nat -> 
    loop_replaceT_XY_fuel kfuel n i j k L = loop_replaceT_XY n i j k L.
Proof. intros kfuel n i j k L H. 
  gen kfuel L. induction k; intros.
  - destruct kfuel; auto.
  - destruct kfuel; try lia.
    assert (kfuel >= k)%nat by lia.
    simpl. bdestruct_all; auto.
    destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
Qed.


(** k := length L   < fuel >
     n, i, j   < fixed > **)
Fixpoint loop_replaceT_Z_fuel (kfuel n i j k : nat) (L : list (TType n)) {struct kfuel} : list (TType n) :=
  match kfuel with
  | S kfuel' =>
      match k with
      | 0%nat => L
      | S k' => 
          if Nat.eqb ((length L) - k) j
          then loop_replaceT_Z_fuel kfuel' n i j k' L
          else 
            match nth i (snd (nth ((length L) - k) L (defaultT_I n))) gI with
            | gZ => loop_replaceT_Z_fuel kfuel' n i j k' (switch L (gMulT (nth j L (defaultT_I n)) (nth ((length L) - k) L (defaultT_I n))) ((length L) - k))
            | _ => loop_replaceT_Z_fuel kfuel' n i j k' L
            end
      end
  | 0%nat => L
  end.

Lemma loop_replaceT_Z_length : forall (n i j k : nat) (L : list (TType n)),
    length (loop_replaceT_Z n i j k L) = length L.
Proof. intros n i j k L.
  gen L.
  induction k; intros; simpl; auto.
  bdestruct_all; auto.
  destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
  all: rewrite IHk; rewrite switch_len; auto.
Qed.

Lemma loop_replaceT_Z_fuel_length : forall (kfuel n i j k : nat) (L : list (TType n)),
    length (loop_replaceT_Z_fuel kfuel n i j k L) = length L.
Proof. intros kfuel n i j k L.
  gen k L.
  induction kfuel; intros; simpl; auto.
  destruct k; auto.
  bdestruct_all; simpl; auto.
  destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
  all: rewrite IHkfuel; rewrite switch_len; auto.
Qed.

Lemma loop_replaceT_Z_fuel_saturated_base : forall (n i j k : nat) (L : list (TType n)),
    loop_replaceT_Z_fuel k n i j k L = loop_replaceT_Z n i j k L.
Proof. intros n i j k L.
  gen L. induction k; intros; simpl; auto.
  bdestruct_all; auto.
  destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
Qed.

Lemma loop_replaceT_Z_fuel_saturated : forall (kfuel n i j k : nat) (L : list (TType n)),
    (kfuel >= k)%nat -> 
    loop_replaceT_Z_fuel kfuel n i j k L = loop_replaceT_Z n i j k L.
Proof. intros kfuel n i j k L H. 
  gen kfuel L. induction k; intros.
  - destruct kfuel; auto.
  - destruct kfuel; try lia.
    assert (kfuel >= k)%nat by lia.
    simpl. bdestruct_all; auto.
    destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E; auto.
Qed.


(** j := length L   < fuel >
     Lz := []
     n, i   < fixed > **)
Fixpoint loop_j_return_PL_fuel (jfuel kfuel n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat) {struct jfuel} : (list nat) * (list (TType n)) := 
match jfuel with
| S jfuel' =>
  match j with
  | S j' => 
      if (existsb (fun p : nat => Nat.eqb p ((length L) - j)%nat) P) 
      then
        (* loop on next j *)
        loop_j_return_PL_fuel jfuel' kfuel n i j' P L Lz
      else 
        match nth i (snd (nth ((length L) - j)%nat L (defaultT_I n))) gI with
        | gI => 
            (* loop on next j *)
            loop_j_return_PL_fuel jfuel' kfuel n i j' P L Lz
        | gZ => 
            (* add j to Lz and loop on next j *)
            loop_j_return_PL_fuel jfuel' kfuel n i j' P L (((length L) - j)%nat :: Lz)
        | _ => 
            (* add j to P and return P, (loop_replaceT_XY n i j (length L) L) *)
            ((((length L) - j)%nat :: P), (loop_replaceT_XY_fuel kfuel n i ((length L) - j)%nat (length L) L))
        end
  | 0%nat =>
      match rev Lz with
      | [] => 
          (* return P, L *)
          (P, L)
      | h :: _ => 
          (* add j to P and return P, (loop_replaceT_Z n i j (length L) L) *)
          ((h :: P), (loop_replaceT_Z_fuel kfuel n i h (length L) L))
      end
  end
| 0%nat => 
    match rev Lz with
    | [] => 
        (* return P, L *)
        (P, L)
    | h :: _ => 
        (* add j to P and return P, (loop_replaceT_Z n i j (length L) L) *)
        ((h :: P), (loop_replaceT_Z_fuel kfuel n i h (length L) L))
    end
end.

Lemma loop_j_return_PL_length : 
  forall (n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    length (snd (loop_j_return_PL n i j P L Lz)) = length L.
Proof. intros n i j P L Lz.
  gen L Lz. 
  induction j; intros; simpl.
  - destruct (rev Lz); simpl; auto.
    rewrite loop_replaceT_Z_length; auto.
  - destruct (existsb (fun p : nat => p =? (length L) - S j) P) eqn:E; auto.
    destruct (nth i (snd (nth ((length L) - S j) L (defaultT_I n))) gI) eqn:E'; simpl; auto.
    all : try rewrite loop_replaceT_XY_length; auto.
Qed.

Lemma loop_j_return_PL_fuel_length : 
  forall (jfuel kfuel n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    length (snd (loop_j_return_PL_fuel jfuel kfuel n i j P L Lz)) = length L.
Proof. intros jfuel kfuel n i j P L Lz.
  gen L Lz j. 
  induction jfuel; intros; simpl.
  - destruct (rev Lz); simpl; auto.
    rewrite loop_replaceT_Z_fuel_length; auto.
  - destruct j.
    + destruct (rev Lz); simpl; auto.
      rewrite loop_replaceT_Z_fuel_length; auto.
    + destruct (existsb (fun p : nat => p =? (length L) - S j) P) eqn:E; auto.
      destruct (nth i (snd (nth ((length L) - S j) L (defaultT_I n))) gI) eqn:E'; simpl; auto.
      all : try rewrite loop_replaceT_XY_fuel_length; auto.
Qed.

Lemma loop_j_return_PL_fuel_saturated_base : 
  forall (kfuel n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    (kfuel >= length L)%nat ->
    loop_j_return_PL_fuel j kfuel n i j P L Lz = loop_j_return_PL n i j P L Lz.
Proof. intros kfuel n i j P L Lz H.
  gen L Lz. induction j; intros; simpl.
  - destruct (rev Lz); auto.
    f_equal. apply loop_replaceT_Z_fuel_saturated; auto.
  - destruct (existsb (fun p : nat => p =? (length L) - S j) P) eqn:E; auto.
    destruct (nth i (snd (nth ((length L) - S j) L (defaultT_I n))) gI) eqn:E'; simpl; auto;
      f_equal; apply loop_replaceT_XY_fuel_saturated; auto.
Qed.

Lemma loop_j_return_PL_fuel_saturated : 
  forall (jfuel kfuel n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    (kfuel >= length L)%nat -> (jfuel >= j)%nat ->
    loop_j_return_PL_fuel jfuel kfuel n i j P L Lz = loop_j_return_PL n i j P L Lz.
Proof. intros jfuel kfuel n i j P L Lz H H0.
  gen L Lz jfuel. induction j; intros.
  - destruct jfuel.
    + apply loop_j_return_PL_fuel_saturated_base; auto.
    + unfold loop_j_return_PL_fuel, loop_j_return_PL.
      destruct (rev Lz); auto.
      f_equal. apply loop_replaceT_Z_fuel_saturated; auto.
  - destruct jfuel; try lia.
    assert (jfuel >= j)%nat by lia. simpl.
    destruct (existsb (fun p : nat => p =? (length L) - S j) P) eqn:E; auto.
    destruct (nth i (snd (nth ((length L) - S j) L (defaultT_I n))) gI) eqn:E'; auto;
      f_equal; apply loop_replaceT_XY_fuel_saturated; auto. 
Qed.

Lemma loop_j_return_PL_fuel_NoDup_P : 
  forall (jfuel kfuel n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    (forall (x : nat), In x Lz -> forall (m d : nat), (m < length P)%nat -> (nth m P d <> x)) -> 
    NoDup P -> NoDup (fst (loop_j_return_PL_fuel jfuel kfuel n i j P L Lz)).
Proof. intros jfuel kfuel n i j P L Lz H H0.
  gen kfuel j P L Lz.
  induction jfuel; intros; simpl; auto.
  - destruct (rev Lz) eqn:E; auto; simpl.
    assert (In n0 (rev Lz)). { rewrite E. constructor. auto. }
    rewrite <- in_rev in H1.
    specialize (H n0 H1).
    assert (~ In n0 P).
    { intro.
      apply In_nth with (d := 0%nat) in H2.
      destruct H2 as [x [H2 H3]].
      specialize (H x 0%nat H2).
      contradiction. }
    pose (NoDup_cons n0 H2 H0).
    auto.
  - destruct j.
    + destruct (rev Lz) eqn:E; auto; simpl.
      assert (In n0 (rev Lz)). { rewrite E. constructor. auto. }
      rewrite <- in_rev in H1.
      specialize (H n0 H1).
      assert (~ In n0 P).
      { intro.
        apply In_nth with (d := 0%nat) in H2.
        destruct H2 as [x [H2 H3]].
        specialize (H x 0%nat H2).
        contradiction. }
      pose (NoDup_cons n0 H2 H0).
      auto.
    + destruct (existsb (fun p : nat => p =? (length L) - S j) P) eqn:E; auto.
      destruct (nth i (snd (nth ((length L) - S j) L (defaultT_I n))) gI) eqn:E'; simpl; auto.
      * assert (~ In ((length L) - S j)%nat P).
        { intro.
          apply In_nth with (d := 0%nat) in H1.
          destruct H1 as [x [H1 H2]].
          pose (existsb_nth (fun p : nat => p =? (length L) - S j) P 0%nat H1 E) as E0.
          simpl in E0.
          rewrite Nat.eqb_neq in E0.
          contradiction. }
        pose (NoDup_cons ((length L) - S j)%nat H1 H0); auto.
      * assert (~ In ((length L) - S j)%nat P).
        { intro.
          apply In_nth with (d := 0%nat) in H1.
          destruct H1 as [x [H1 H2]].
          pose (existsb_nth (fun p : nat => p =? (length L) - S j) P 0%nat H1 E) as E0.
          simpl in E0.
          rewrite Nat.eqb_neq in E0.
          contradiction. }
        pose (NoDup_cons ((length L) - S j)%nat H1 H0); auto.
      * apply IHjfuel; auto.
        intros x H1 m d H2.
        intro. subst.
        inversion H1.
        -- rewrite H3 in E.
           pose (existsb_nth (fun p : nat => p =? nth m P d) P d H2 E) as E0.
           simpl in E0.
           rewrite Nat.eqb_neq in E0.
           contradiction.
        -- specialize (H (nth m P d) H3 m d H2).
           contradiction.
Qed.

Lemma loop_j_return_PL_NoDup_P : 
  forall (n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    (forall (x : nat), In x Lz -> forall (m d : nat), (m < length P)%nat -> (nth m P d <> x)) -> 
    NoDup P -> NoDup (fst (loop_j_return_PL n i j P L Lz)).
Proof. intros n i j P L Lz H H0. 
  rewrite <- loop_j_return_PL_fuel_saturated_base with (kfuel := length L); auto.
  apply loop_j_return_PL_fuel_NoDup_P; auto.
Qed.

Lemma loop_j_return_PL_fuel_incl_P_seq_0_length_L : 
  forall (jfuel kfuel n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    length L <> 0%nat -> incl Lz (seq 0%nat (length L)) -> incl P (seq 0%nat (length L)) -> 
    incl (fst (loop_j_return_PL_fuel jfuel kfuel n i j P L Lz)) (seq 0%nat (length L)).
Proof. intros jfuel kfuel n i j P L Lz H H0 H1. 
  gen kfuel j P L Lz.
  induction jfuel; intros; simpl; auto.
  - destruct (rev Lz) eqn:E; auto; simpl.
    unfold incl; intros.
    inversion H2; subst; clear H2.
    + assert (In a Lz). { rewrite in_rev, E. constructor. auto. }
      apply H0 in H2; auto.
    + apply H1 in H3; auto.
  - destruct j.
    + destruct (rev Lz) eqn:E; auto; simpl.
      unfold incl; intros.
      inversion H2; subst; clear H2.
      * assert (In a Lz). { rewrite in_rev, E. constructor. auto. }
        apply H0 in H2; auto.
      * apply H1 in H3; auto.
    + destruct (existsb (fun p : nat => p =? (length L) - S j) P) eqn:E; auto.
      destruct (nth i (snd (nth ((length L) - S j) L (defaultT_I n))) gI) eqn:E'; auto; simpl.
      * unfold incl; intros.
        inversion H2; subst; clear H2.
        -- rewrite in_seq; lia.
        -- apply H1 in H3; auto.
      * unfold incl; intros.
        inversion H2; subst; clear H2.
        -- rewrite in_seq; lia.
        -- apply H1 in H3; auto.
      * apply IHjfuel; auto.
        unfold incl; intros.
        inversion H2; subst; clear H2.
        -- rewrite in_seq; lia.
        -- apply H0 in H3; auto.
Qed.

Lemma loop_j_return_PL_incl_P_seq_0_length_L : 
  forall (n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    length L <> 0%nat -> incl Lz (seq 0%nat (length L)) -> incl P (seq 0%nat (length L)) -> 
    incl (fst (loop_j_return_PL n i j P L Lz)) (seq 0%nat (length L)).
Proof. intros n i j P L Lz H H0 H1. 
  rewrite <- loop_j_return_PL_fuel_saturated_base with (kfuel := length L); auto.
  apply loop_j_return_PL_fuel_incl_P_seq_0_length_L; auto.
Qed.


(** i := n   < fuel >
     n := initialized from input   < fixed >
     P := []
     L := initialized from input **)
Fixpoint loop_normalization_fuel (ifuel jfuel kfuel n i : nat) (P : list nat) (L : list (TType n)) {struct ifuel} : list (TType n)  :=
  match ifuel with
  | S ifuel' =>
      match i with
      | S i' =>
          (* do loop_j_return_PL and get (P, L), recurse on next i *)
          let (P', L') := loop_j_return_PL_fuel jfuel kfuel n (n - i)%nat (length L) P L [] in
          loop_normalization_fuel ifuel' jfuel kfuel n i' P' L'
      | 0%nat =>
          (* Final Ordering with rev P *)
          (map (fun p : nat => nth p L (defaultT_I n)) (rev P)) ++ 
            lexicographic (map (fun q : nat => nth q L (defaultT_I n))
                             (filter (fun a : nat => negb (existsb (fun p : nat => if Nat.eq_dec p a then true else false) P))
                                (List.seq 0 (length L))))
      end
  | 0%nat => 
      (* Final Ordering with rev P *)
      (map (fun p : nat => nth p L (defaultT_I n)) (rev P)) ++ 
        lexicographic (map (fun q : nat => nth q L (defaultT_I n))
                         (filter (fun a : nat => negb (existsb (fun p : nat => if Nat.eq_dec p a then true else false) P))
                            (List.seq 0 (length L))))
  end.

Lemma loop_normalization_fuel_saturated_base : 
  forall (jfuel kfuel n i : nat) (P : list nat) (L : list (TType n)),
    (kfuel >= length L)%nat -> (jfuel >= length L)%nat -> 
    loop_normalization_fuel i jfuel kfuel n i P L = loop_normalization n i P L.
Proof. intros jfuel kfuel n i P L H H0.
  gen jfuel kfuel P L.
  induction i; intros; simpl; auto.
  destruct (loop_j_return_PL_fuel jfuel kfuel n (n - S i) (length L) P L) eqn:E.
  destruct (loop_j_return_PL n (n - S i) (length L) P L []) eqn:E'.
  rewrite loop_j_return_PL_fuel_saturated in E; auto.
  rewrite E in E'.
  inversion E'; subst; clear E'.
  pose (loop_j_return_PL_length n (n - S i) (length L) P L []) as E'.
  rewrite E in E'.
  simpl in E'.
  apply IHi; rewrite E'; auto.
Qed.

Lemma loop_normalization_fuel_saturated : 
  forall (ifuel jfuel kfuel n i : nat) (P : list nat) (L : list (TType n)),
    (kfuel >= length L)%nat -> (jfuel >= length L)%nat -> (ifuel >= i)%nat ->
    loop_normalization_fuel ifuel jfuel kfuel n i P L = loop_normalization n i P L.
Proof. intros ifuel jfuel kfuel n i P L H H0 H1.
   gen ifuel jfuel kfuel P L.
   induction i; intros; simpl.
  - destruct ifuel; auto.
  - destruct ifuel; try lia.
    assert (ifuel >= i)%nat by lia.
    simpl.
    rewrite loop_j_return_PL_fuel_saturated; auto.
    destruct (loop_j_return_PL n (n - S i) (length L) P L []) eqn:E.
    pose (loop_j_return_PL_length n (n - S i) (length L) P L []) as E'.
    rewrite E in E'.
    simpl in E'.
    apply IHi; try rewrite E'; auto.
Qed.


(**  : list (TType n) **)
Definition normalize_fuel (ifuel jfuel kfuel : nat) {n : nat} (L : list (TType n)) := loop_normalization_fuel ifuel jfuel kfuel n n [] L.

Lemma normalize_fuel_saturated : forall (ifuel jfuel kfuel : nat) {n : nat} (L : list (TType n)),
    (kfuel >= length L)%nat -> (jfuel >= length L)%nat -> (ifuel >= n)%nat ->
    normalize_fuel ifuel jfuel kfuel L = normalize L.
Proof. intros ifuel jfuel kfuel n L H H0 H1.
  unfold normalize_fuel, normalize.
  apply loop_normalization_fuel_saturated; auto.
Qed.


(** ** Property assumed to be provably admissible ** **)

Inductive PauliMult_listT {n : nat} (Lt1 Lt2 : list (TType n)) : Prop :=
| PauliMult_listT_step : length Lt1 = length Lt2 -> length Lt1 <> 0%nat ->
                (exists j k : nat, (j <> k) /\ (j < length Lt1)%nat /\ (k < length Lt1)%nat /\
                              (Lt2 = (switch Lt1 
                                        (gMulT (nth j Lt1 (defaultT_I n)) (nth k Lt1 (defaultT_I n))) k))) ->
              PauliMult_listT Lt1 Lt2.

Lemma PauliMult_listT_preserves_proper_length_TType : 
  forall {n : nat} (Lt1 Lt2 : list (TType n)),
    PauliMult_listT Lt1 Lt2 -> Forall proper_length_TType Lt1 -> 
    Forall proper_length_TType Lt2.
Proof. intros n Lt1 Lt2 H H0.
  inversion H.
  destruct H3 as [j [k [H3 [H4 [H5 H6]]]]].
  rewrite Forall_forall in H0.
  rewrite Forall_forall. intros x H7.
  apply In_nth with (d := defaultT_I n) in H7.
  destruct H7 as [i [H7 H8]].
  rewrite <- H1 in H7.
  subst.
  bdestruct (i =? k)%nat.
  - subst. rewrite nth_switch_hit; auto.
    apply proper_length_TType_gMulT; apply H0; apply nth_In; auto.
  - rewrite nth_switch_miss; auto.
    apply H0; apply nth_In; auto.
Qed.

Lemma PauliMult_listT_swap : forall {n : nat} (Lt1 Lt2 : list (TType n)),
    Forall proper_length_TType Lt1 -> 
    Forall coef_plus_minus_1 Lt1 ->
    PauliMult_listT Lt1 Lt2 -> PauliMult_listT Lt2 Lt1.
Proof. intros n Lt1 Lt2 PLLt1 UHLt1 H.
  assert (PLnth : forall i : nat, (i < length Lt1)%nat -> proper_length_TType (nth i Lt1 (defaultT_I n))).
  { intros. apply Forall_nth; auto. }
  assert (UHnth : forall i : nat, (i < length Lt1)%nat -> coef_plus_minus_1 (nth i Lt1 (defaultT_I n))).
  { intros. apply Forall_nth; auto. }
  inversion H.
  destruct H2 as [j [k [H2 [H3 [H4 H5]]]]].
  constructor; auto.
  lia.
  exists j. exists k.
  split; auto.
  split; try lia.
  split; try lia.
  assert (H6 : nth j Lt2 (defaultT_I n) = nth j Lt1 (defaultT_I n)).
  { rewrite H5. 
    rewrite nth_switch_miss; auto. }
  rewrite H6.
  rewrite H5.
  rewrite nth_switch_hit; auto.
  rewrite <- gMulT_assoc.
  rewrite gMulT_inv.
  rewrite gMulT_id_l.
  rewrite switch_switch_overshadow.
  rewrite switch_inc; auto.
  rewrite nth_inc with (n := k) (x := (defaultT_I n)) at 1; auto.
  all : auto.
Qed.

Inductive PauliMult_listT_chain {n : nat} : list (TType n) -> list (TType n) -> Prop :=
| PauliMult_listT_chain_id : forall (Lt1 Lt2 : list (TType n)), 
    Lt1 = Lt2 -> PauliMult_listT_chain Lt1 Lt2
| PauliMult_listT_chain_base : forall (Lt1 Lt2 : list (TType n)), 
    PauliMult_listT Lt1 Lt2 -> PauliMult_listT_chain Lt1 Lt2
| PauliMult_listT_chain_append : forall (Lt1 Lt2 Lt3 : list (TType n)),
    PauliMult_listT_chain Lt1 Lt2 -> PauliMult_listT_chain Lt2 Lt3 ->
    PauliMult_listT_chain Lt1 Lt3.

Lemma PauliMult_listT_chain_preserves_proper_length_TType : 
  forall {n : nat} (Lt1 Lt2 : list (TType n)),
    PauliMult_listT_chain Lt1 Lt2 -> Forall proper_length_TType Lt1 -> 
    Forall proper_length_TType Lt2.
Proof. intros n Lt1 Lt2 H H0.
  induction H; subst; auto.
  apply PauliMult_listT_preserves_proper_length_TType with (Lt1 := Lt1); auto.
Qed.

Inductive PauliMult_listT_chain_Permutation {n : nat} (Lt1 Lt3 : list (TType n)) : Prop :=
| exists_middle_PauliMult_listT_chain_Permutation : 
  (exists (Lt2 : list (TType n)), PauliMult_listT_chain Lt1 Lt2 /\ Permutation Lt2 Lt3) ->
  PauliMult_listT_chain_Permutation Lt1 Lt3.

Lemma PauliMult_listT_chain_Permutation_append : forall {n : nat} (Lt1 Lt2 Lt3 : list (TType n)),
    PauliMult_listT_chain Lt1 Lt2 -> PauliMult_listT_chain_Permutation Lt2 Lt3 ->
    PauliMult_listT_chain_Permutation Lt1 Lt3.
Proof. intros n Lt1 Lt2 Lt3 H H0.
  inversion H0; clear H0.
  destruct H1 as [Lt4 [H1 H2]].
  assert (PauliMult_listT_chain Lt1 Lt4) 
    by (apply PauliMult_listT_chain_append with (Lt2 := Lt2); auto).
  constructor. exists Lt4. split; auto.
Qed.


Lemma loop_replaceT_XY_fuel_PauliMult_listT : 
  forall (kfuel n i j k : nat) (L : list (TType n)),
    length L <> 0%nat -> (j < length L)%nat -> (k <= length L)%nat ->
    (loop_replaceT_XY_fuel kfuel n i j k L) =
      (loop_replaceT_XY_fuel (S kfuel) n i j k L) \/
      PauliMult_listT 
        (loop_replaceT_XY_fuel kfuel n i j k L)
        (loop_replaceT_XY_fuel (S kfuel) n i j k L).
Proof. intros kfuel n i j k L H H0 H1.
  gen k L.
  induction kfuel; intros.
  - simpl. destruct k; auto.
    destruct ((length L) - S k =? j) eqn:E; auto.
    destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E'; auto.
    + right. apply PauliMult_listT_step; auto.
      * rewrite switch_len; auto.
      * exists j. exists ((length L) - S k)%nat.
        repeat (split; auto; try lia).
        intro. rewrite <- H2 in E.
        rewrite Nat.eqb_neq in E.
        contradiction.
    + right. apply PauliMult_listT_step; auto.
      * rewrite switch_len; auto.
      * exists j. exists ((length L) - S k)%nat.
        repeat (split; auto; try lia).
        intro. rewrite <- H2 in E.
        rewrite Nat.eqb_neq in E.
        contradiction.
  - simpl. destruct k; auto.
    destruct ((length L) - S k =? j) eqn:E.
    + rewrite Nat.eqb_eq in E.
      assert (k <= length L)%nat by lia.
      destruct (IHkfuel k L H H0 H2); auto.
    + destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E';
        simpl in IHkfuel; apply IHkfuel; try rewrite switch_len; auto; try lia.
Qed.

Lemma loop_replaceT_XY_fuel_PauliMult_listT_chain : 
  forall (kfuel n i j k : nat) (L : list (TType n)),
    length L <> 0%nat -> (j < length L)%nat -> (k <= length L)%nat ->
    PauliMult_listT_chain L (loop_replaceT_XY_fuel kfuel n i j k L).
Proof. intros kfuel n i j k L H H0 H1.
  induction kfuel.
  - simpl. apply PauliMult_listT_chain_id; auto.
  - pose (loop_replaceT_XY_fuel_PauliMult_listT kfuel n i j k L H H0 H1) as E.
    destruct E;
      apply PauliMult_listT_chain_append with (Lt2 := loop_replaceT_XY_fuel kfuel n i j k L);
      auto.
    + apply PauliMult_listT_chain_id; auto.
    + apply PauliMult_listT_chain_base; auto.
Qed.

Lemma loop_replaceT_XY_PauliMult_listT_chain : 
  forall (n i j k : nat) (L : list (TType n)),
    length L <> 0%nat -> (j < length L)%nat -> (k <= length L)%nat ->
    PauliMult_listT_chain L (loop_replaceT_XY n i j k L).
Proof. intros n i j k L H H0 H1.
  rewrite <- loop_replaceT_XY_fuel_saturated_base.
  apply loop_replaceT_XY_fuel_PauliMult_listT_chain; auto.
Qed.

Lemma loop_replaceT_Z_fuel_PauliMult_listT : 
  forall (kfuel n i j k : nat) (L : list (TType n)),
    length L <> 0%nat -> (j < length L)%nat -> (k <= length L)%nat ->
    (loop_replaceT_Z_fuel kfuel n i j k L) =
      (loop_replaceT_Z_fuel (S kfuel) n i j k L) \/
      PauliMult_listT 
        (loop_replaceT_Z_fuel kfuel n i j k L)
        (loop_replaceT_Z_fuel (S kfuel) n i j k L).
Proof. intros kfuel n i j k L H H0 H1.
  gen k L.
  induction kfuel; intros.
  - simpl. destruct k; auto.
    destruct ((length L) - S k =? j) eqn:E; auto.
    destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E'; auto.
    + right. apply PauliMult_listT_step; auto.
      * rewrite switch_len; auto.
      * exists j. exists ((length L) - S k)%nat.
        repeat (split; auto; try lia).
        intro. rewrite <- H2 in E.
        rewrite Nat.eqb_neq in E.
        contradiction.
  - simpl. destruct k; auto.
    destruct ((length L) - S k =? j) eqn:E.
    + rewrite Nat.eqb_eq in E.
      assert (k <= length L)%nat by lia.
      destruct (IHkfuel k L H H0 H2); auto.
    + destruct (nth i (snd (nth ((length L) - S k) L (defaultT_I n))) gI) eqn:E';
        simpl in IHkfuel; apply IHkfuel; try rewrite switch_len; auto; try lia.
Qed.

Lemma loop_replaceT_Z_fuel_PauliMult_listT_chain : 
  forall (kfuel n i j k : nat) (L : list (TType n)),
    length L <> 0%nat -> (j < length L)%nat -> (k <= length L)%nat ->
    PauliMult_listT_chain L (loop_replaceT_Z_fuel kfuel n i j k L).
Proof. intros kfuel n i j k L H H0 H1.
  induction kfuel.
  - simpl. apply PauliMult_listT_chain_id; auto.
  - pose (loop_replaceT_Z_fuel_PauliMult_listT kfuel n i j k L H H0 H1) as E.
    destruct E;
      apply PauliMult_listT_chain_append with (Lt2 := loop_replaceT_Z_fuel kfuel n i j k L);
      auto.
    + apply PauliMult_listT_chain_id; auto.
    + apply PauliMult_listT_chain_base; auto.
Qed.

Lemma loop_replaceT_Z_PauliMult_listT_chain : 
  forall (n i j k : nat) (L : list (TType n)),
    length L <> 0%nat -> (j < length L)%nat -> (k <= length L)%nat ->
    PauliMult_listT_chain L (loop_replaceT_Z n i j k L).
Proof. intros n i j k L H H0 H1.
  rewrite <- loop_replaceT_Z_fuel_saturated_base.
  apply loop_replaceT_Z_fuel_PauliMult_listT_chain; auto.
Qed.


Lemma loop_j_return_PL_PauliMult_listT_chain : 
  forall (n i j : nat) (P : list nat) (L : list (TType n)) (Lz : list nat),
    length L <> 0%nat -> incl Lz (seq 0 (length L)) ->
    PauliMult_listT_chain L (snd (loop_j_return_PL n i j P L Lz)).
Proof. intros n i j P L Lz H H0.
  gen P L Lz. induction j; intros; simpl.
  - destruct (rev Lz) eqn:E; simpl.
    + apply PauliMult_listT_chain_id; auto.
    + assert (In n0 Lz).
      { rewrite in_rev, E; constructor; auto. }
      apply H0 in H1.
      rewrite in_seq in H1.
      apply loop_replaceT_Z_PauliMult_listT_chain; auto; lia.
  - destruct (existsb (fun p : nat => p =? length L - S j) P) eqn:E; auto.
    destruct (nth i (snd (nth (length L - S j) L (defaultT_I n))) gI) eqn:E'; simpl; auto.
    + apply loop_replaceT_XY_PauliMult_listT_chain; auto; lia.
    + apply loop_replaceT_XY_PauliMult_listT_chain; auto; lia.
    + apply IHj; auto.
      unfold incl; intros.
      inversion H1; subst; clear H1; auto.
      rewrite in_seq; lia.
Qed.

Lemma loop_normalization_fuel_PauliMult_listT_chain_Permutation : 
  forall (ifuel jfuel kfuel n i : nat) (P : list nat) (L : list (TType n)),
    (kfuel >= length L)%nat -> (jfuel >= length L)%nat ->
    NoDup P -> incl P (seq 0 (length L)) -> length L <> 0%nat ->
    PauliMult_listT_chain_Permutation L (loop_normalization_fuel ifuel jfuel kfuel n i P L).
Proof. intros ifuel jfuel kfuel n i P L H H0 H1 H2 H3.
  gen jfuel kfuel i P L. induction ifuel; intros.
  - simpl. constructor.
    exists L. split; try apply PauliMult_listT_chain_id; auto.
    apply final_ordering_Permutation; auto.
  - simpl. destruct i.
    + constructor.
      exists L. split; try apply PauliMult_listT_chain_id; auto.
      apply final_ordering_Permutation; auto.
    + destruct (loop_j_return_PL_fuel jfuel kfuel n (n - S i) (length L) P L []) eqn:E.
      pose (loop_j_return_PL_PauliMult_listT_chain n (n - S i) (length L) P L []) as E'.
      rewrite loop_j_return_PL_fuel_saturated in E; auto.
      rewrite E in E'. simpl in E'. 
      apply PauliMult_listT_chain_Permutation_append with (Lt2 := l0).
      * apply E'; auto; apply incl_nil_l.
      * apply IHifuel.
        -- pose (loop_j_return_PL_NoDup_P n (n - S i) (length L) P L []) as E''.
           rewrite E in E''. simpl in E''. apply E''; auto.
        -- pose (loop_j_return_PL_length n (n - S i) (length L) P L []) as E''.
           rewrite E in E''. simpl in E''. rewrite E''; auto.
        -- pose (loop_j_return_PL_length n (n - S i) (length L) P L []) as E''.
           rewrite E in E''. simpl in E''. rewrite E''; auto.
        -- pose (loop_j_return_PL_length n (n - S i) (length L) P L []) as E''.
           rewrite E in E''. simpl in E''. rewrite E''.
           pose (loop_j_return_PL_incl_P_seq_0_length_L n (n - S i) (length L) P L []) as E'''.
           rewrite E in E'''. simpl in E'''. apply E'''; auto; apply incl_nil_l.
        -- pose (loop_j_return_PL_length n (n - S i) (length L) P L []) as E''.
           rewrite E in E''. simpl in E''. rewrite E''; auto.
Qed.

Lemma loop_normalization_PauliMult_listT_chain_Permutation : 
  forall (n i : nat) (P : list nat) (L : list (TType n)),
    NoDup P -> incl P (seq 0 (length L)) -> length L <> 0%nat ->
    PauliMult_listT_chain_Permutation L (loop_normalization n i P L).
Proof. intros n i P L H H0 H1. 
  rewrite <- loop_normalization_fuel_saturated_base with (kfuel := length L) (jfuel := length L);
    auto.
  apply loop_normalization_fuel_PauliMult_listT_chain_Permutation; auto.
Qed.

Lemma normalize_PauliMult_listT_chain_Permutation : forall (n : nat) (L : list (TType n)),
    length L <> 0%nat -> PauliMult_listT_chain_Permutation L (normalize L).
Proof. intros n L H. unfold normalize.
  apply loop_normalization_PauliMult_listT_chain_Permutation; auto.
  - apply NoDup_nil.
  - apply incl_nil_l.
Qed.


(** ** Normalization example on 7 qubit Steane code ** **) (* 
g1 = IIIXXXX
g2 = IXXIIXX
g3 = XIXIXIX
g4 = IIIZZZZ
g5 = IZZIIZZ
g6 = ZIZIZIZ
Xb = XXXXXXX
Zb = ZZZZZZZ
ZL := g1 ∩ ... ∩ g6 ∩ Zb
XL := g1 ∩ ... ∩ g6 ∩ Xb *)
Definition g1 : TType 7 := (C1, [gI; gI; gI; gX; gX; gX; gX]).
Definition g2 : TType 7 := (C1, [gI; gX; gX; gI; gI; gX; gX]).
Definition g3 : TType 7 := (C1, [gX; gI; gX; gI; gX; gI; gX]).
Definition g4 : TType 7 := (C1, [gI; gI; gI; gZ; gZ; gZ; gZ]).
Definition g5 : TType 7 := (C1, [gI; gZ; gZ; gI; gI; gZ; gZ]).
Definition g6 : TType 7 := (C1, [gZ; gI; gZ; gI; gZ; gI; gZ]).
Definition Xbar : TType 7 := (C1, [gX; gX; gX; gX; gX; gX; gX]).
Definition Zbar : TType 7 := (C1, [gZ; gZ; gZ; gZ; gZ; gZ; gZ]).
Definition ZL : list (TType 7) := [g1; g2; g3; g4; g5; g6; Zbar].
Definition XL : list (TType 7) := [g1; g2; g3; g4; g5; g6; Xbar].

Definition X1' : TType 7 := (C1, [gX; gX; gX; gI; gI; gI; gI]).
Definition Z1' : TType 7 := (C1, [gZ; gI; gI; gI; gI; gZ; gZ]).
Definition Z2' : TType 7 := (C1, [gZ; gZ; gI; gI; gZ; gZ; gI]).
Definition Z3' : TType 7 := (C1, [gZ; gI; gZ; gI; gZ; gI; gZ]).
Definition Z4' : TType 7 := (C1, [gI; gI; gI; gZ; gZ; gZ; gZ]).
Definition Z5' : TType 7 := (C1, [gI; gX; gX; gX; gX; gI; gI]).
Definition Z6' : TType 7 := (C1, [gX; gI; gX; gX; gI; gX; gI]).
Definition Z7' : TType 7 := (C1, [gX; gX; gI; gX; gI; gI; gX]).
Definition LZ : list (TType 7) := [Z1'; Z2'; Z3'; Z4'; Z5'; Z6'; Z7'].
Definition LX : list (TType 7) := [X1'; Z2'; Z3'; Z4'; Z5'; Z6'; Z7'].

Compute map snd (normalize ZL). (*
[[gX; gI; gX; gI; gX; gI; gX];
 [gI; gX; gX; gI; gI; gX; gX];
 [gZ; gZ; gZ; gI; gI; gI; gI];
 [gI; gI; gI; gX; gX; gX; gX];
 [gZ; gI; gI; gZ; gZ; gI; gI];
 [gI; gZ; gI; gZ; gI; gZ; gI];
 [gZ; gZ; gI; gZ; gI; gI; gZ]] *)
Compute map snd (normalize LZ). (*
[[gX; gI; gX; gI; gX; gI; gX];
 [gI; gX; gX; gI; gI; gX; gX];
 [gZ; gZ; gZ; gI; gI; gI; gI];
 [gI; gI; gI; gX; gX; gX; gX];
 [gZ; gI; gI; gZ; gZ; gI; gI];
 [gI; gZ; gI; gZ; gI; gZ; gI];
 [gZ; gZ; gI; gZ; gI; gI; gZ]] *)

Compute map snd (normalize XL). (*
[[gX; gI; gI; gI; gI; gX; gX];
 [gI; gX; gI; gI; gX; gI; gX];
 [gI; gI; gX; gI; gX; gX; gI];
 [gI; gI; gI; gX; gX; gX; gX];
 [gI; gZ; gZ; gZ; gZ; gI; gI];
 [gZ; gI; gZ; gZ; gI; gZ; gI];
 [gZ; gZ; gI; gZ; gI; gI; gZ]] *)
Compute map snd (normalize LX). (*
[[gX; gI; gI; gI; gI; gX; gX];
 [gI; gX; gI; gI; gX; gI; gX];
 [gI; gI; gX; gI; gX; gX; gI];
 [gI; gI; gI; gX; gX; gX; gX];
 [gI; gZ; gZ; gZ; gZ; gI; gI];
 [gZ; gI; gZ; gZ; gI; gZ; gI];
 [gZ; gZ; gI; gZ; gI; gI; gZ]] *)

Compute map snd (normalize (XL ++ [(C1,  [gI; gI; gX; gI; gX; gX; gI])])). (*
[[gX; gI; gI; gI; gI; gX; gX];
 [gI; gX; gI; gI; gX; gI; gX];
 [gI; gI; gX; gI; gX; gX; gI];
 [gI; gI; gI; gX; gX; gX; gX];
 [gI; gZ; gZ; gZ; gZ; gI; gI];
 [gZ; gI; gZ; gZ; gI; gZ; gI];
 [gZ; gZ; gI; gZ; gI; gI; gZ];
 [gI; gI; gI; gI; gI; gI; gI]] *)

Compute map snd (normalize (removelast XL)). (*
[[gX; gI; gX; gI; gX; gI; gX];
 [gI; gX; gX; gI; gI; gX; gX];
 [gZ; gI; gZ; gZ; gI; gZ; gI];
 [gI; gI; gI; gX; gX; gX; gX];
 [gZ; gZ; gI; gI; gZ; gZ; gI];
 [gZ; gZ; gI; gZ; gI; gI; gZ]] *)



Definition t1' : TType 7 := (C1, [gI; gI; gI; gI; gI; gY; gZ]).
Definition t2' : TType 7 := (C1, [gI; gI; gI; gI; gI; gZ; gX]).
Definition t3' : TType 7 := (C1, [gI; gI; gZ; gX; gZ; gI; gI]).
Definition t4' : TType 7 := (C1, [gI; gI; gZ; gZ; gY; gI; gI]).
Definition t5' : TType 7 := (C1, [gI; gI; gX; gX; gY; gI; gI]).
Definition t6' : TType 7 := (C1, [gX; gY; gI; gI; gI; gI; gI]).
Definition t7' : TType 7 := (C1, [gZ; gX; gI; gI; gI; gI; gI]).
Definition Test' : list (TType 7) := [t1'; t2'; t3'; t4'; t5'; t6'; t7'].

(* Test
[[gI; gI; gI; gI; gI; gY; gZ];
 [gI; gI; gI; gI; gI; gZ; gX];
 [gI; gI; gZ; gX; gZ; gI; gI];
 [gI; gI; gZ; gZ; gY; gI; gI];
 [gI; gI; gX; gX; gY; gI; gI];
 [gX; gY; gI; gI; gI; gI; gI];
 [gZ; gX; gI; gI; gI; gI; gI] *)
Compute map snd (normalize Test'). (*
[[gY; gZ; gI; gI; gI; gI; gI];
 [gZ; gX; gI; gI; gI; gI; gI];
 [gI; gI; gX; gZ; gZ; gI; gI];
 [gI; gI; gZ; gX; gZ; gI; gI];
 [gI; gI; gZ; gZ; gY; gI; gI];
 [gI; gI; gI; gI; gI; gY; gZ];
 [gI; gI; gI; gI; gI; gZ; gX]] *)

Definition t1'' : TType 3 := (C1, [gI; gZ; gX]).
Definition t2'' : TType 3 := (C1, [gI; gY; gZ]).
Definition t3'' : TType 3 := (C1, [gZ; gI; gI]).
Definition Test'' : list (TType 3) := [t1''; t2''; t3''].

(* Test'
[[gI; gZ; gX];
 [gI; gY; gZ];
 [gZ; gI; gI]] *)
Compute map snd (normalize Test''). (*
[[gZ; gI; gI];
 [gI; gY; gZ];
 [gI; gZ; gX]] *)

Definition t1''' : TType 4 := (C1, [gI; gI; gX; gX]).
Definition t2''' : TType 4 := (C1, [gI; gI; gZ; gY]).
Definition t3''' : TType 4 := (C1, [gY; gZ; gI; gI]).
Definition t4''' : TType 4 := (C1, [gZ; gX; gI; gI]).
Definition Test''' : list (TType 4) := [t1'''; t2'''; t3'''; t4'''].

(* Test''
[[gI; gZ; gX; gX];
 [gI; gI; gZ; gY];
 [gY; gZ; gI; gZ];
 [gZ; gX; gI; gI]] *)
Compute map snd (normalize Test'''). (*
[[gY; gZ; gI; gI];
 [gZ; gX; gI; gI];
 [gI; gI; gY; gZ];
 [gI; gI; gZ; gY]] *)


(*** Separability ***)
(** ith qubit has pivot **)
Definition has_pivot (n i : nat) (LLp : list (list Pauli)) : bool :=
  negb (forallb (fun p => POrd.eqb p gI) (map (fun Lp => nth i Lp gI) LLp)).

(** i := n = # of qubits
    m := length LLp = # of terms **)
Fixpoint get_pivots_loop (n m i : nat) (LLp : list (list Pauli)) (term_qubit : list (nat * nat)) {struct i} : list (nat * nat) :=
  match i with
  | 0%nat => rev term_qubit
  | Datatypes.S i' => if has_pivot n (n - i) LLp
                     then match LLp with
                          | [] => rev term_qubit
                          | _ :: L => get_pivots_loop n m i' L (((m - (length LLp)), (n - i))%nat :: term_qubit)
                          end
                     else get_pivots_loop n m i' LLp term_qubit
  end.

Definition get_pivots (n : nat) (LLp : list (list Pauli)) := 
  get_pivots_loop n (length LLp) n LLp [].

Definition all_pivots (K : list nat) (term_qubit : list (nat * nat)) :=
  forallb (fun k => (existsb (fun pivot => Nat.eqb pivot k) (map snd term_qubit))) K.

Definition commute (Lp1 Lp2 : list Pauli) :=
  Nat.even (length (filter (fun p =>
                              (andb
                                 (negb (orb
                                          (POrd.eqb (fst p) gI)
                                          (POrd.eqb (snd p) gI)))
                                 (negb (POrd.eqb (fst p) (snd p))))) 
                      (combine Lp1 Lp2))).

Definition commutativity_condition (n : nat) (LLp : list (list Pauli)) (K : list nat) :=
  forallb (fun p => commute 
                   (nth (hd 0%nat K) LLp (repeat gI n))
                   (nth p LLp (repeat gI n)))
    (tl K).

Definition total_mutual_commutativity_listlistP (n : nat) (LLp : list (list Pauli)) :=
  map (fun f => map f (List.seq 0 (length LLp))) 
    (map (fun i j => commute (nth i LLp (repeat gI n)) (nth j LLp (repeat gI n))) 
       (List.seq 0 (length LLp))).

Definition total_mutual_commutativity_listT {n : nat} (Lt : list (TType n)) :=
  total_mutual_commutativity_listlistP n (map snd Lt).


Definition check_complement (n : nat) (LLp : list (list Pauli)) (K : list nat) (term_qubit : list (nat * nat)) := 
  forallb (fun p =>
             forallb (fun i =>
                        POrd.eqb (nth i (nth (fst p) LLp (repeat gI n)) gI) gI
               ) (filter (fun a => negb (existsb (fun k => Nat.eqb k a) K)) (List.seq 0 n))
    ) (filter (fun p => existsb (fun k => Nat.eqb k (snd p)) K) term_qubit).

Definition separable {n : nat} (L : list (TType n)) (K : list nat) :=
  let LLp := map snd L in
  let term_qubit := get_pivots n LLp in
  all_pivots K term_qubit && 
    commutativity_condition n LLp K &&
    check_complement n LLp K term_qubit.

Definition separable_all {n : nat} (L : list (TType n)) (LK : list (list nat)) :=
  forallb (separable L) LK.

Inductive isCapT {n : nat} : Predicate n -> Prop :=
| CapT : forall (lt : list (TType n)), isCapT (Cap (map TtoA lt)).

Definition total_mutual_commutativity_listA {n : nat} (la : list (AType n)) :=
  total_mutual_commutativity_listT (map AtoT la).
 

Fixpoint get_pivot_loop {n : nat} (L : list (TType n)) (k : nat) (term_qubit : list (nat * nat)) : nat :=
  match term_qubit with
  | [] => 0%nat
  | (term, qubit) :: t => if Nat.eqb k qubit then term else get_pivot_loop L k t
  end. 

Definition get_pivot {n : nat} (L : list (TType n)) (k : nat) : nat :=
  let LLp := map snd L in
  let term_qubit := get_pivots n LLp in
  get_pivot_loop L k term_qubit.

Definition get_pivot_AType {n : nat} (la : list (AType n)) (k : nat) : nat :=
  get_pivot (map AtoT la) k.



(** ** Separability examples ** **)
Print T1. (* = XXI *)
Print T2. (* = ZZI *)
Print T3. (* = ZZZ *)
Print LT3. (* = [T1; T2; T3] = [XXI; ZZI; ZZZ] *)
Eval cbn in lexicographic LT3. (* = [T2; T3; T1] *)
Eval cbn in normalize LT3. (* [T1; T2; IIZ] = [XXI; ZZI; IIZ] *)
Eval vm_compute in normalize LT3.
Compute separable (normalize LT3) [0; 1]%nat. (* true *)
Compute separable (normalize LT3) [1; 0]%nat. (* true *)
Compute separable (normalize LT3) [2]%nat. (* true *)
Compute separable (normalize LT3) [1; 2]%nat. (* false *)
Compute separable (normalize LT3) [2; 0]%nat. (* false *)
Compute separable (normalize LT3) [0; 1; 2]%nat. (* true *)
Compute separable (normalize LT3) []%nat. (* true *)

(** To specify a valid eigenspace, we need independent commuting terms **)
(** Since we are mapping valid terms to valid terms, the checks need not be necessary **)
(* normalize Test'
[[gY; gZ; gI; gI; gI; gI; gI];
 [gZ; gX; gI; gI; gI; gI; gI];
 [gI; gI; gX; gZ; gZ; gI; gI];
 [gI; gI; gZ; gX; gZ; gI; gI];
 [gI; gI; gZ; gZ; gY; gI; gI];
 [gI; gI; gI; gI; gI; gY; gZ];
 [gI; gI; gI; gI; gI; gZ; gX]] *)
Compute separable (normalize Test') [0; 1; 3]%nat. (* false *)

(* normalize Test''
[[gZ; gI; gI];
 [gI; gY; gZ];
 [gI; gZ; gX]] *)
Compute separable (normalize Test'') [1; 2]%nat. (* true *)
Compute separable (normalize Test'') [0; 2]%nat. (* false *)

(* normalize Test'''
[[gY; gZ; gI; gI];
 [gZ; gX; gI; gI];
 [gI; gI; gY; gZ];
 [gI; gI; gZ; gY]] *)
Compute separable (normalize Test''') [0; 1]%nat. (* true *)
Compute separable (normalize Test''') [0; 2]%nat. (* false *)
Compute separable (normalize Test''') [1; 2]%nat. (* false *)
Compute separable (normalize Test''') [0; 3]%nat. (* false *)
Compute separable (normalize Test''') [0; 2; 3]%nat. (* false *)



(** ** mathematics for semantical proof of separability ** **)

(** Not needed? 
Inductive PauliGenerator {n : nat} (t : TType n) : Prop :=
| pauli_matrix_factors : fst t = C1 \/ fst t = (- C1)%C \/ fst t = Ci \/ fst t = (- Ci)%C -> 
                         PauliGenerator t.
*)


Declare Scope F2_scope.
Delimit Scope F2_scope with F2.
Open Scope F2_scope.

Inductive F2 : Type := zero | one.
Notation "0" := zero : F2_scope.
Notation "1" := one : F2_scope.

Definition F2plus (z1 z2 : F2) : F2 := 
  match z1, z2 with
  | zero, zero => zero
  | zero, one => one
  | one, zero => one
  | one, one => zero
  end.
Infix "+" := F2plus (at level 50, left associativity) : F2_scope.

Lemma F2plus_0_l : forall z : F2, 0 + z = z. Proof. intros; destruct z; auto. Qed.
Lemma F2plus_0_r : forall z : F2, z + 0 = z. Proof. intros; destruct z; auto. Qed.
Lemma F2plus_assoc : forall z1 z2 z3 : F2, 
    z1 + (z2 + z3) = (z1 + z2) + z3.
Proof. intros; destruct z1, z2, z3; auto. Qed.
Lemma F2plus_flip_l_0 : forall z : F2, 1 + z = 0 -> z = 1. Proof. intros; destruct z; auto. Qed.
Lemma F2plus_flip_l_1 : forall z : F2, 1 + z = 1 -> z = 0. Proof. intros; destruct z; auto. Qed.
Lemma F2plus_flip_r_0 : forall z : F2, z + 1 = 0 -> z = 1. Proof. intros; destruct z; auto. Qed.
Lemma F2plus_flip_r_1 : forall z : F2, z + 1 = 1 -> z = 0. Proof. intros; destruct z; auto. Qed.

#[global] Instance F2_is_monoid : Monoid F2 := 
  { Gzero := zero;
    Gplus := F2plus;
    Gplus_0_l := F2plus_0_l;
    Gplus_0_r := F2plus_0_r;
    Gplus_assoc := F2plus_assoc }.

(* Definition F2_is_monoid : Monoid F2 := 
  Build_Monoid F2 zero F2plus F2plus_0_l F2plus_0_r F2plus_assoc. *)

Existing Instance F2_is_monoid.

Definition F2opp (z : F2) : F2 := z.
Notation "- z" := (F2opp z) : F2_scope.

Definition F2minus (z1 z2 : F2) : F2 := z1 + (- z2).
Infix "-" := F2minus (at level 50, left associativity) : F2_scope.

Lemma F2opp_l : forall z : F2, - z + z = 0. Proof. intros; destruct z; auto. Qed.
Lemma F2opp_r : forall z : F2, z + (- z) = 0. Proof. intros; destruct z; auto. Qed.
Definition F2_is_group : Group F2 := 
  Build_Group F2 F2_is_monoid F2opp F2opp_l F2opp_r.

Existing Instance F2_is_group.

Lemma F2plus_comm : forall z1 z2 : F2, z1 + z2 = z2 + z1. 
Proof. intros; destruct z1, z2; auto. Qed.
Definition F2_is_comm_group : Comm_Group F2 := 
  Build_Comm_Group F2 F2_is_monoid F2_is_group F2plus_comm.

Existing Instance F2_is_comm_group.

Definition F2mult (z1 z2 : F2) : F2 := 
  match z1, z2 with
  | zero, zero => zero
  | zero, one => zero
  | one, zero => zero
  | one, one => one
  end.
Infix "·" := F2mult (at level 40, left associativity) : F2_scope.
Lemma F2mult_1_l : forall z : F2, 1 · z = z. Proof. intros; destruct z; auto. Qed.
Lemma F2mult_1_r : forall z : F2, z · 1 = z. Proof. intros; destruct z; auto. Qed.
Lemma F2mult_assoc : forall z1 z2 z3, z1 · (z2 · z3) = (z1 · z2) · z3.
Proof. intros; destruct z1, z2, z3; auto. Qed.
Lemma F2mult_plus_distr_l : forall z1 z2 z3, z3 · (z1 + z2) = (z3 · z1) + (z3 · z2).
Proof. intros; destruct z1, z2, z3; auto. Qed.
Lemma F2mult_plus_distr_r : forall z1 z2 z3, (z1 + z2) · z3 = (z1 · z3) + (z2 · z3).
Proof. intros; destruct z1, z2, z3; auto. Qed.
Lemma F2eq_dec : forall z1 z2 : F2, { z1 = z2 } + { z1 <> z2 }.
Proof. intros; destruct z1, z2; auto; try (left; easy); try (right; easy). Qed.    
Definition F2_is_ring : Ring F2 :=
  Build_Ring F2 F2_is_monoid F2_is_group F2_is_comm_group one F2mult
             F2mult_1_l F2mult_1_r F2mult_assoc F2mult_plus_distr_l F2mult_plus_distr_r
             F2eq_dec.

Existing Instance F2_is_ring.

Lemma F2mult_comm : forall z1 z2 : F2, F2mult z1 z2 = F2mult z2 z1.
Proof. intros; destruct z1, z2; auto. Qed.
Definition F2_is_comm_ring : Comm_Ring F2 :=
  Build_Comm_Ring F2 F2_is_monoid F2_is_group F2_is_comm_group F2_is_ring
                  F2mult_comm.

Existing Instance F2_is_comm_ring.

Lemma F2_ring_theory : ring_theory 0%F2 1%F2 F2plus F2mult F2minus F2opp eq.
Proof. apply (@G_ring_theory F2 F2_is_monoid F2_is_group F2_is_comm_group F2_is_ring F2_is_comm_ring). Qed.

Add Ring F_ring_ring : F2_ring_theory.

Definition F2inv (z : F2) : F2 := z.
Notation "/ z" := (F2inv z) : F2_scope.

Definition F2div (z1 z2 : F2) : F2 := z1 · (/ z2).
Lemma F2_1_neq_0 : 1 <> 0. Proof. intro. discriminate. Qed.
Lemma F2inv_r : forall z : F2, z <> 0 -> z · (/ z) = 1. Proof. intros; destruct z; auto; contradiction. Qed.
Definition F2_is_field : Field F2 := 
  Build_Field F2 F2_is_monoid F2_is_group F2_is_comm_group F2_is_ring
              F2_is_comm_ring F2inv F2_1_neq_0 F2inv_r.

Existing Instance F2_is_field.

Lemma F2_field_theory : field_theory 0%F2 1%F2 F2plus F2mult F2minus F2opp F2div F2inv eq.
Proof. apply (@G_field_theory F2 F2_is_monoid F2_is_group F2_is_comm_group F2_is_ring F2_is_comm_ring F2_is_field). Qed.

Add Field F_field : F2_field_theory.

Lemma F2mult_0_l : forall z : F2, 0 · z = 0. Proof. intros; destruct z; auto. Qed.
Lemma F2mult_0_r : forall z : F2, z · 0 = 0. Proof. intros; destruct z; auto. Qed.
Definition F2_beq (z1 z2 : F2) : bool :=
  match z1, z2 with
  | zero, zero => true
  | zero, one => false
  | one, zero => false
  | one, one => true
  end.
Infix "=?" := F2_beq : F2_scope.
Lemma F2_beq_true_iff : forall z1 z2 : F2, (z1 =? z2)%F2 = true <-> z1 = z2.
Proof. intros z1 z2. split; intros;  destruct z1, z2; simpl in *; auto; discriminate. Qed.
Lemma F2_beq_false_iff : forall z1 z2 : F2, (z1 =? z2)%F2 = false <-> z1 <> z2.
Proof. intros z1 z2. split; intros;  destruct z1, z2; simpl in *; auto; try discriminate; contradiction. Qed.
Lemma F2_neq0_iff_eq1 : forall z : F2, z <> 0 <-> z = 1.
Proof. intros z. split; intros H; destruct z; try contradiction; try discriminate; auto. Qed.
Lemma F2_neq1_iff_eq0 : forall z : F2, z <> 1 <-> z = 0.
Proof. intros z. split; intros H; destruct z; try contradiction; try discriminate; auto. Qed.

Ltac F2simpl :=
repeat
  match goal with
  | _ => rewrite F2mult_0_l
  | _ => rewrite F2mult_0_r
  | _ => rewrite F2plus_0_l
  | _ => rewrite F2plus_0_r
  | _ => rewrite F2mult_1_l
  | _ => rewrite F2mult_1_r
  end.

Declare Module F2Field : FieldModule
  with Definition F := F2
  with Definition R0 := F2_is_monoid
  with Definition R1 := F2_is_group
  with Definition R2 := F2_is_comm_group
  with Definition R3 := F2_is_ring
  with Definition R4 := F2_is_comm_ring
  with Definition R5 := F2_is_field.

Module F2Module := SubspacesOverField F2Field.


Notation MatrixF2 := (F2Module.GenMatrix).
Notation VectorF2 n := (F2Module.GenMatrix n%nat 1%nat).
Notation SquareF2 n := (F2Module.GenMatrix n%nat n%nat).
Notation WF_MatrixF2 := (F2Module.WF_GenMatrix).
Notation ZeroF2 := (F2Module.Zero).
Notation IF2 := (F2Module.I).
Notation traceF2 := (F2Module.trace).
Notation scaleF2 := (F2Module.scale).
Notation MplusF2 := (F2Module.GMplus).
Notation MoppF2 := (F2Module.GMopp).
Notation MminusF2 := (F2Module.GMminus).
Notation MmultF2 := (F2Module.GMmult).
Notation kronF2 := (F2Module.Gkron).
Notation transposeF2 := (F2Module.transpose).
Notation Mmult_nF2 := (F2Module.GMmult_n).
Notation genmat_equivF2 := (F2Module.genmat_equiv).
Notation get_colF2 := (F2Module.get_col).
Notation get_col_convF2 := (F2Module.get_col_conv).
Notation get_rowF2 := (F2Module.get_row).
Notation reduce_rowF2 := (F2Module.reduce_row).
Notation reduce_colF2 := (F2Module.reduce_col).
Notation col_swapF2 := (F2Module.col_swap).
Notation row_swapF2 := (F2Module.row_swap).
Notation col_addF2 := (F2Module.col_add).
Notation row_addF2 := (F2Module.row_add).
Notation col_swap_invF2 := (F2Module.col_swap_inv).
Notation row_swap_invF2 := (F2Module.row_swap_inv).
Notation col_add_invF2 := (F2Module.col_add_inv).
Notation row_add_invF2 := (F2Module.row_add_inv).
Notation swap_preserves_mul_ltF2 := (F2Module.swap_preserves_mul_lt).
Notation swap_preserves_mulF2 := (F2Module.swap_preserves_mul).
Notation add_preserves_mul_ltF2 := (F2Module.add_preserves_mul_lt).
Notation add_preserves_mulF2 := (F2Module.add_preserves_mul).
Notation WF_col_swapF2 := (F2Module.WF_col_swap).
Notation WF_row_swapF2 := (F2Module.WF_row_swap).
Notation WF_col_addF2 := (F2Module.WF_col_add).
Notation WF_row_addF2 := (F2Module.WF_row_add).
Notation col_swap_mult_rF2 := (F2Module.col_swap_mult_r).
Notation col_add_mult_rF2 := (F2Module.col_add_mult_r).
Notation col_row_swap_invr_IF2 := (F2Module.col_row_swap_invr_I).
Notation col_row_add_invr_IF2 := (F2Module.col_row_add_invr_I).
Notation e_iF2 := (F2Module.e_i).
Notation WF_e_iF2 := (F2Module.WF_e_i).
Notation matrix_by_basisF2 := (F2Module.matrix_by_basis).
Notation linearly_independentF2 := (F2Module.linearly_independent).
Notation linearly_dependentF2 := (F2Module.linearly_dependent).
Notation lindep_implies_not_linindepF2 := (F2Module.lindep_implies_not_linindep).
Notation not_lindep_implies_linindepF2 := (F2Module.not_lindep_implies_linindep).
Notation invr_col_swapF2 := (F2Module.invr_col_swap).
Notation invr_col_addF2 := (F2Module.invr_col_add).
Notation prop_zero_trueF2 := (F2Module.prop_zero_true).
Notation prop_zero_falseF2 := (F2Module.prop_zero_false).
Notation mat_prop_col_swap_convF2 := (F2Module.mat_prop_col_swap_conv).
Notation mat_prop_col_add_convF2 := (F2Module.mat_prop_col_add_conv).
Notation lin_indep_swap_invrF2 := (F2Module.lin_indep_swap_invr).
Notation lin_dep_swap_invrF2 := (F2Module.lin_dep_swap_invr).
Notation lin_indep_add_invrF2 := (F2Module.lin_indep_add_invr).
Notation lin_dep_add_invrF2 := (F2Module.lin_dep_add_invr).
Notation lin_indep_pzfF2 := (F2Module.lin_indep_pzf).
Notation lin_dep_pztF2 := (F2Module.lin_dep_pzt).
Notation smashF2 := (F2Module.smash).
Notation WF_smashF2 := (F2Module.WF_smash).

Infix ".+" := MplusF2 (at level 50, left associativity) : F2_scope.
Infix ".*" := scaleF2 (at level 40, left associativity) : F2_scope.
Infix "×" := MmultF2 (at level 40, left associativity) : F2_scope.
Infix "⊗" := kronF2 (at level 40, left associativity) : F2_scope.
Infix "≡" := genmat_equivF2 (at level 70) : F2_scope.
Notation "A ⊤" := (transposeF2 A) (at level 0) : F2_scope. 
Notation Σ2 := (@big_sum F2Field.F F2Field.R0).  (* we intoduce Σ2 notation here *)
Notation "p ⨉ A" := (Mmult_nF2 A p) (at level 30, no associativity) : F2_scope.

Check eq_refl : F2Field.F = F2.
Check eq_refl : F2Field.R0 = F2_is_monoid.


(** ** Defining a transposed Gaussian elimination. ** **)
Definition col_search_ones_right {m n : nat} (M : MatrixF2 m n) (r c : nat) :=
  filter (fun i : nat => (M r i =? one)%F2) (List.seq c (n - c)).

Fixpoint col_add_rec {m n : nat} (M : MatrixF2 m n) (c : nat) (cols : list nat) : MatrixF2 m n :=
  match cols with
  | [] => M
  | col :: t => col_add_rec (col_addF2 M col c 1%F2) c t
  end.

Definition col_add_right_ones {m n : nat} (M : MatrixF2 m n) (r c : nat): MatrixF2 m n :=
  col_add_rec M c (col_search_ones_right M r (Datatypes.S c)).

Fixpoint gaussian_elimination_transposed_rec {m n : nat} (M : MatrixF2 m n) (row_count col : nat) {struct row_count} : MatrixF2 m n :=
match row_count with
| 0%nat => M
| Datatypes.S row_count' => 
  match hd_error (col_search_ones_right M (m - row_count) col) with
  | None => gaussian_elimination_transposed_rec M row_count' col 
  | Some c => 
      if (col <? c)
      then gaussian_elimination_transposed_rec 
             (col_add_right_ones (col_swapF2 M col c) (m - row_count) col)
             row_count' (Datatypes.S col)
      else gaussian_elimination_transposed_rec 
             (col_add_right_ones M (m - row_count) col)
             row_count' (Datatypes.S col)
  end
end.

Definition gaussian_elimination_transposed {m n : nat} (M : MatrixF2 m n) :=
  gaussian_elimination_transposed_rec M m 0%nat.


(** ** Elementary column operations for matrices over F2 ** **)
Inductive elem_col_ops_chainF2 {m n : nat} : MatrixF2 m n -> MatrixF2 m n -> Prop :=
| idColOpsChain : forall (M : MatrixF2 m n), elem_col_ops_chainF2 M M
| swapColOpsChain : forall (M : MatrixF2 m n) (x y : nat), (x < n)%nat -> (y < n)%nat -> 
                                 elem_col_ops_chainF2 M (col_swapF2 M x y)
| addColOpsChain : forall (M : MatrixF2 m n) (x y : nat) (z : F2), x <> y -> (x < n)%nat -> (y < n)%nat -> 
                                         elem_col_ops_chainF2 M (col_addF2 M x y z)
| concatColOpsChain : forall (M M' M'' : MatrixF2 m n),
    elem_col_ops_chainF2 M M' -> elem_col_ops_chainF2 M' M'' ->
    elem_col_ops_chainF2 M M''.

Lemma elem_col_ops_chainF2_preserves_lin_indep : forall {m n : nat} (M M' : MatrixF2 m n), 
    elem_col_ops_chainF2 M M' -> (linearly_independentF2 M <-> linearly_independentF2 M').
Proof. intros m n M M' H.
  induction H; split; intros; auto.
  - pose lin_indep_swap_invrF2 as H'; inversion H'; subst; clear H'.
    apply H2; auto.
  - pose lin_indep_swap_invrF2 as H'.
    apply mat_prop_col_swap_convF2 in H1; auto.
  - pose lin_indep_add_invrF2 as H'; inversion H'; subst; clear H'.
    apply H3; auto.
  - pose lin_indep_add_invrF2 as H'.
    apply mat_prop_col_add_convF2 in H2; auto.
  - rewrite <- IHelem_col_ops_chainF2_2, <- IHelem_col_ops_chainF2_1; auto.
  - rewrite IHelem_col_ops_chainF2_1, IHelem_col_ops_chainF2_2; auto.
Qed.

Lemma elem_col_ops_chainF2_preserves_lin_dep : forall {m n : nat} (M M' : MatrixF2 m n), 
    elem_col_ops_chainF2 M M' -> (linearly_dependentF2 M <-> linearly_dependentF2 M').
Proof. intros m n M M' H.
  induction H; split; intros; auto.
  - pose lin_dep_swap_invrF2 as H'; inversion H'; subst; clear H'.
    apply H2; auto.
  - pose lin_dep_swap_invrF2 as H'.
    apply mat_prop_col_swap_convF2 in H1; auto.
  - pose lin_dep_add_invrF2 as H'; inversion H'; subst; clear H'.
    apply H3; auto.
  - pose lin_dep_add_invrF2 as H'.
    apply mat_prop_col_add_convF2 in H2; auto.
  - rewrite <- IHelem_col_ops_chainF2_2, <- IHelem_col_ops_chainF2_1; auto.
  - rewrite IHelem_col_ops_chainF2_1, IHelem_col_ops_chainF2_2; auto.
Qed.

Lemma elem_col_ops_chainF2_col_add_rec : 
  forall {m n : nat} (M : MatrixF2 m n) (c : nat) (cols : list nat),
    ~ In c cols -> (c < n)%nat -> incl cols (List.seq 0%nat n) ->
    elem_col_ops_chainF2 M (col_add_rec M c cols).
Proof. intros m n M c cols H H0 H1. 
  gen M c. induction cols; intros; try constructor; simpl.
  apply concatColOpsChain with (M' := (col_addF2 M a c 1)); auto.
  - constructor; auto.
    + rewrite not_in_cons in H; destruct H; auto.
    + assert (In a (a :: cols)) by (simpl; auto).
      apply H1 in H2. rewrite in_seq in H2. lia.
  - apply IHcols; auto.
    + apply incl_cons_inv in H1; destruct H1; auto.
    + rewrite not_in_cons in H; destruct H; auto.
Qed.

Lemma not_in_col_search_ones_right : forall {m n : nat} (M : MatrixF2 m n) (r c : nat),
    ~ In c (col_search_ones_right M r (S c)).
Proof. intros m n M r c.
  unfold col_search_ones_right.
  intro H.
  rewrite filter_In in H.
  destruct H.
  rewrite in_seq in H.
  lia.
Qed.

Lemma incl_col_search_ones_right_seq : forall {m n : nat} (M : MatrixF2 m n) (r c : nat),
    incl (col_search_ones_right M r (S c)) (List.seq 0%nat n).
Proof. intros m n M r c.
  unfold col_search_ones_right.
  unfold incl; intros.
  rewrite filter_In in H.
  destruct H.
  rewrite in_seq in H.
  rewrite in_seq.
  lia.
Qed.

Lemma elem_col_ops_chainF2_col_add_right_ones : 
  forall {m n : nat} (M : MatrixF2 m n) (r c : nat),
    (c < n)%nat -> elem_col_ops_chainF2 M (col_add_right_ones M r c).
Proof. intros m n M r c H.
  unfold col_add_right_ones.
  apply elem_col_ops_chainF2_col_add_rec; auto.
  apply not_in_col_search_ones_right.
  apply incl_col_search_ones_right_seq.
Qed.

Lemma elem_col_ops_chainF2_gaussian_elimination_transposed_rec : 
  forall {m n : nat} (M : MatrixF2 m n) (row_count col : nat),
    elem_col_ops_chainF2 M (gaussian_elimination_transposed_rec M row_count col).
Proof. intros m n M row_count col.
  gen M col. induction row_count; intros;
    unfold gaussian_elimination_transposed_rec;
    try constructor.
  destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; auto.
  bdestruct_all.
  - fold (@gaussian_elimination_transposed_rec m n).
    apply concatColOpsChain with (M' := (col_add_right_ones (col_swapF2 M col n0) (m - S row_count) col)); auto.
    unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
    apply hd_error_some_nil in E; contradiction.
    simpl in E. inversion E; subst; clear E.
    assert (H' : In n0 (n0 :: l)) by (simpl; auto).
    rewrite <- E' in H'.
    rewrite filter_In in H'; destruct H' as [H' H''].
    rewrite in_seq in H'.
    apply concatColOpsChain with (M' := (col_swapF2 M col n0)).
    constructor; lia.
    apply elem_col_ops_chainF2_col_add_right_ones; lia.
  - fold (@gaussian_elimination_transposed_rec m n).
    apply concatColOpsChain with (M' := (col_add_right_ones M (m - S row_count) col)); auto.
    unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
    apply hd_error_some_nil in E; contradiction.
    simpl in E. inversion E; subst; clear E.
    assert (H' : In n0 (n0 :: l)) by (simpl; auto).
    rewrite <- E' in H'.
    rewrite filter_In in H'; destruct H' as [H' H''].
    rewrite in_seq in H'.
    apply elem_col_ops_chainF2_col_add_right_ones; lia.
Qed.

Lemma gaussian_elimination_transposed_rec_preserves_lin_indep : 
  forall {m n : nat} (M : MatrixF2 m n) (row_count col : nat), 
    linearly_independentF2 M <-> linearly_independentF2 (gaussian_elimination_transposed_rec M row_count col).
Proof. intros m n M row_count col.
  apply elem_col_ops_chainF2_preserves_lin_indep.
  apply elem_col_ops_chainF2_gaussian_elimination_transposed_rec.
Qed.

Lemma gaussian_elimination_transposed_rec_preserves_lin_dep : 
  forall {m n : nat} (M : MatrixF2 m n) (row_count col : nat), 
    linearly_dependentF2 M <-> linearly_dependentF2 (gaussian_elimination_transposed_rec M row_count col).
Proof. intros m n M row_count col.
  apply elem_col_ops_chainF2_preserves_lin_dep.
  apply elem_col_ops_chainF2_gaussian_elimination_transposed_rec.
Qed.

Lemma elem_col_ops_chainF2_gaussian_elimination_transposed : 
  forall {m n : nat} (M : MatrixF2 m n),
    elem_col_ops_chainF2 M (gaussian_elimination_transposed M).
Proof. intros; apply elem_col_ops_chainF2_gaussian_elimination_transposed_rec. Qed.

Lemma gaussian_elimination_transposed_preserves_lin_indep : 
  forall {m n : nat} (M : MatrixF2 m n), 
    linearly_independentF2 M <-> linearly_independentF2 (gaussian_elimination_transposed M).
Proof. intros m n M.
  apply elem_col_ops_chainF2_preserves_lin_indep.
  apply elem_col_ops_chainF2_gaussian_elimination_transposed.
Qed.

Lemma gaussian_elimination_transposed_preserves_lin_dep : 
  forall {m n : nat} (M : MatrixF2 m n), 
    linearly_dependentF2 M <-> linearly_dependentF2 (gaussian_elimination_transposed M).
Proof. intros m n M.
  apply elem_col_ops_chainF2_preserves_lin_dep.
  apply elem_col_ops_chainF2_gaussian_elimination_transposed.
Qed.


Fixpoint gaussian_elimination_transposed_rec_get_pivot_row {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col : nat) {struct row_count} : (MatrixF2 m n) * option nat :=
  match row_count with
  | 0%nat => (M, None)
  | Datatypes.S row_count' => 
      match hd_error (col_search_ones_right M (m - row_count) col) with
      | None => gaussian_elimination_transposed_rec_get_pivot_row M row_count' col pivot_col
      | Some c => if (col <? pivot_col)
                 then
                   if (col <? c)
                   then gaussian_elimination_transposed_rec_get_pivot_row
                          (col_add_right_ones (col_swapF2 M col c) (m - row_count) col)
                          row_count' (Datatypes.S col) pivot_col
                   else gaussian_elimination_transposed_rec_get_pivot_row
                          (col_add_right_ones M (m - row_count) col)
                          row_count' (Datatypes.S col) pivot_col
                 else
                   if (col <? c)
                   then ((col_add_right_ones (col_swapF2 M col c) (m - row_count) col), Some (m - row_count)%nat)
                   else ((col_add_right_ones M (m - row_count) col), Some (m - row_count)%nat)
      end
  end. 

Lemma WF_col_add_rec : forall {m n : nat} (M : MatrixF2 m n) (c : nat) (cols : list nat),
     incl cols (seq 0 n) -> WF_MatrixF2 M -> WF_MatrixF2 (col_add_rec M c cols).
Proof. intros m n M c cols H H0.
  gen M c. induction cols; intros; simpl; auto.
  apply IHcols.
  - unfold incl. intros a0 H1.
    assert (In a0 (a :: cols)) by (simpl; auto).
    apply H in H2. auto.
  - apply F2Module.WF_col_add; auto.
    assert (In a (seq 0 n)).
    { assert (In a (a :: cols)) by (simpl; auto). 
      apply H in H1. auto. }
    rewrite in_seq in H1; lia.
Qed.

Lemma WF_col_add_right_ones : forall {m n : nat} (M : MatrixF2 m n) (r c : nat),
   (c < n)%nat -> WF_MatrixF2 M -> WF_MatrixF2 (col_add_right_ones M r c).
  intros m n M r c H H0.
  unfold col_add_right_ones.
  apply WF_col_add_rec; auto.
  unfold incl. intros a H1.
  unfold col_search_ones_right in H1.
  apply filter_In in H1. destruct H1.
  rewrite in_seq in H1.
  rewrite in_seq. lia.
Qed.

Lemma WF_fst_gaussian_elimination_transposed_rec_get_pivot_row : 
  forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col : nat),
    WF_MatrixF2 M -> WF_MatrixF2 (fst (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col)).
Proof. intros m n M row_count col pivot_col H.
  unfold WF_MatrixF2.
  intros x y H0.
  gen M col pivot_col x y. induction row_count; intros; auto.
  simpl.
  destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E.
  - unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
    apply hd_error_some_nil in E; contradiction.
    simpl in E. inversion E; subst; clear E.
    assert (H' : In n0 (n0 :: l)) by (simpl; auto).
    rewrite <- E' in H'.
    rewrite filter_In in H'; destruct H' as [H' H''].
    rewrite in_seq in H'.
    bdestruct_all.
    + apply IHrow_count; try lia; auto.
      apply WF_col_add_right_ones; try lia; auto.
      apply F2Module.WF_col_swap; try lia; auto.
    + apply IHrow_count; try lia; auto.
      apply WF_col_add_right_ones; try lia; auto.
    + simpl.
      assert (WF_MatrixF2 (col_add_right_ones (col_swapF2 M col n0) (m - S row_count) col)).
      { apply WF_col_add_right_ones; try lia; auto.
        apply F2Module.WF_col_swap; try lia; auto. }
      rewrite H3; auto.
    + simpl. 
      assert (WF_MatrixF2 (col_add_right_ones M (m - S row_count) col)).
      { apply WF_col_add_right_ones; try lia; auto. }
      rewrite H3; auto.
  - apply IHrow_count; try lia; auto.
Qed.

Lemma gaussian_elimination_transposed_rec_col_overflow : 
  forall {m n : nat} (M : MatrixF2 m n) (row_count col : nat),
    (col >= n)%nat ->
  gaussian_elimination_transposed_rec M row_count col = M.
Proof. intros m n M row_count col H.
  gen M col. induction row_count; intros; auto. simpl.
  destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E.
  unfold col_search_ones_right in E.
  destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
  apply hd_error_some_nil in E; contradiction.
  simpl in E. inversion E; subst; clear E.
  assert (H' : In n0 (n0 :: l)) by (simpl; auto).
  rewrite <- E' in H'.
  rewrite filter_In in H'; destruct H' as [H' H''].
  rewrite in_seq in H'.
  bdestruct_all; try lia.
  apply IHrow_count; auto.
Qed.

Lemma gaussian_elimination_transposed_rec_get_pivot_row_saturated :
  forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col : nat),
    (pivot_col >= n - 1)%nat ->
    gaussian_elimination_transposed_rec M row_count col =
      fst (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col).
Proof. intros m n M row_count col pivot_col H.
  gen M pivot_col col. induction row_count; intros; auto; simpl. 
  destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E.
  - unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
    apply hd_error_some_nil in E; contradiction.
    simpl in E. inversion E; subst; clear E.
    assert (H' : In n0 (n0 :: l)) by (simpl; auto).
    rewrite <- E' in H'.
    rewrite filter_In in H'; destruct H' as [H' H''].
    rewrite in_seq in H'.
    bdestruct_all; try apply IHrow_count with (pivot_col := n); auto; simpl; try lia. 
    bdestruct (pivot_col =? col)%nat; try lia. subst.
    bdestruct (col =? n-1)%nat; try lia. subst. simpl.
    rewrite gaussian_elimination_transposed_rec_col_overflow; auto; lia.
  - apply IHrow_count; auto.
Qed.

Lemma WF_gaussian_elimination_transposed : forall {m n : nat} (M : MatrixF2 m n),
    WF_MatrixF2 M -> WF_MatrixF2 (gaussian_elimination_transposed M).
Proof. intros m n M H.
  unfold gaussian_elimination_transposed.
  rewrite gaussian_elimination_transposed_rec_get_pivot_row_saturated with (pivot_col := (n - 1)%nat); try lia; auto.
  apply WF_fst_gaussian_elimination_transposed_rec_get_pivot_row; auto.
Qed.

Definition col_slice_one_hd_error {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col : nat) :=
  let GM := gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col in
  hd_error (filter (fun r : nat => ((fst GM) r pivot_col =? one)%F2) (List.seq (m - row_count) row_count)).

Lemma col_add_rec_one_bool_true : 
  forall {m n : nat} (M : MatrixF2 m n) (c c' r' : nat) (cols : list nat),
    (c' < c)%nat -> (c < n)%nat -> (M r' c' =? 1) = true ->
    ~ In c cols -> NoDup cols -> incl cols (seq c (n - c)) ->
    (forall i : nat, (c' < i < n)%nat -> (M r' i =? 1) = false) ->
    (col_add_rec M c cols r' c' =? 1) = true.
Proof. intros m n M c c' r' cols H H0 H1 H2 H3 H4 H5.
  gen M c c' r'. induction cols; intros; auto.
  simpl. apply IHcols; try lia; auto.
  - rewrite NoDup_cons_iff in H3. destruct H3. auto.
  - rewrite not_in_cons in H2. destruct H2. auto.
  - unfold incl. intros a0 H6.
    assert (H' : In a0 (a :: cols)) by (simpl; auto).
    apply H4 in H'. auto.
  - unfold col_addF2.
    bdestruct_all; auto.
    rewrite F2_beq_true_iff in H1.
    rewrite ! H1.
    assert ((M r' c =? 1) = false).
    { apply H5; lia. }
    rewrite F2_beq_false_iff in H7.
    destruct (M r' c) eqn:E; try contradiction.
    F2simpl. auto.
  - intros i H6.
    unfold col_addF2.
    bdestruct_all; subst; auto.
    assert ((M r' c =? 1) = false).
    { apply H5; lia. }
    assert ((M r' a =? 1) = false).
    { apply H5; lia. }
    rewrite F2_beq_false_iff in H7, H8.
    destruct (M r' c) eqn:E; try contradiction.
    destruct (M r' a) eqn:E'; try contradiction.
    F2simpl. auto.
Qed.

Lemma col_add_right_ones_one_bool_true :
  forall {m n : nat} (M : MatrixF2 m n) (r r' c c'  : nat),
    (c' < c)%nat -> (c < n)%nat -> (M r' c' =? 1) = true ->
    (forall i : nat, (c' < i < n)%nat -> (M r' i =? 1) = false) ->
    (col_add_right_ones M r c r' c' =? 1) = true.
Proof. intros m n M r r' c c' H H0 H1 H2. 
  unfold col_add_right_ones.
  unfold col_search_ones_right.
  apply col_add_rec_one_bool_true; try lia; auto.
  - intro H3. rewrite filter_In in H3. destruct H3.
    rewrite in_seq in H3. lia.
  - apply NoDup_filter. apply seq_NoDup.
  - unfold incl. intros a H3. rewrite filter_In in H3. destruct H3.
    rewrite in_seq in H3. rewrite in_seq. lia.
Qed.

Lemma col_add_right_ones_col_swapF2_one_bool_true :
  forall {m n : nat} (M : MatrixF2 m n) (r r' c c' k  : nat),
    (c' < c)%nat -> (c < k)%nat -> (k < n)%nat -> (M r' c' =? 1) = true ->
    (forall i : nat, (c' < i < n)%nat -> (M r' i =? 1) = false) ->
    (col_add_right_ones (col_swapF2 M c k) r c r' c' =? 1) = true.
Proof. intros m n M r r' c c' k H H0 H1 H2 H3.
  apply col_add_right_ones_one_bool_true; try lia; auto.
  unfold col_swapF2. bdestruct_all; subst; auto.
  intros i H4. unfold col_swapF2. bdestruct_all; auto; apply H3; try lia.
Qed.

Lemma col_add_rec_one_bool_false : 
  forall {m n : nat} (M : MatrixF2 m n) (c c' r' i : nat) (cols : list nat),
    (c' < c)%nat -> (c < n)%nat -> (c' < i < n)%nat -> (M r' i =? 1) = false ->
    (forall i : nat, (c' < i < n)%nat -> (M r' i =? 1) = false) ->
    ~ In c cols -> NoDup cols -> incl cols (seq c (n - c)) ->
    (col_add_rec M c cols r' i =? 1) = false.
Proof. intros m n M c c' r' i cols H H0 H1 H2 H3 H4 H5 H6. 
  gen M c c' r' i. induction cols; intros; auto.
 apply IHcols with (c' := c'); try lia; auto.
  - rewrite NoDup_cons_iff in H5. destruct H5. auto.
  - rewrite not_in_cons in H4. destruct H4. auto.
  - unfold incl. intros a0 H7.
    assert (H' : In a0 (a :: cols)) by (simpl; auto).
    apply H6 in H'. auto.
  - intros i0 H7.
    unfold col_addF2.
    bdestruct_all; subst; auto.
    assert ((M r' c =? 1) = false).
    { apply H3; lia. }
    assert ((M r' a =? 1) = false).
    { apply H3; lia. }
    rewrite F2_beq_false_iff in H8, H9.
    destruct (M r' c) eqn:E; try contradiction.
    destruct (M r' a) eqn:E'; try contradiction.
    F2simpl. auto.
  - unfold col_addF2.
    bdestruct_all; subst; auto.
    rewrite F2_beq_false_iff in H2.
    destruct (M r' a) eqn:E; try contradiction.
    assert ((M r' c =? 1) = false).
    { apply H3; lia. }
    rewrite F2_beq_false_iff in H7.
    destruct (M r' c) eqn:E'; try contradiction.
    F2simpl. auto.
Qed.

Lemma col_add_right_ones_one_bool_false : 
  forall {m n : nat} (M : MatrixF2 m n) (r r' c c'  : nat),
    (c' < c)%nat -> (c < n)%nat -> (forall i : nat, (c' < i < n)%nat -> (M r' i =? 1) = false) ->
    (forall i : nat, (c' < i < n)%nat -> (col_add_right_ones M r c r' i =? 1) = false).
Proof. intros m n M r r' c c' H H0 H1 i H2.
  unfold col_add_right_ones.
  unfold col_search_ones_right.
  apply col_add_rec_one_bool_false with (c' := c'); try lia; auto.
  - intro H3. rewrite filter_In in H3. destruct H3.
    rewrite in_seq in H3. lia.
  - apply NoDup_filter. apply seq_NoDup.
  - unfold incl. intros a H3. rewrite filter_In in H3. destruct H3.
    rewrite in_seq in H3. rewrite in_seq. lia.
Qed.

Lemma col_add_right_ones_col_swapF2_one_bool_false :
  forall {m n : nat} (M : MatrixF2 m n) (r r' c c' k  : nat),
    (c' < c)%nat -> (c < k)%nat -> (k < n)%nat -> (forall i : nat, (c' < i < n)%nat -> (M r' i =? 1) = false) ->
    (forall i : nat, (c' < i < n)%nat -> (col_add_right_ones (col_swapF2 M c k) r c r' i =? 1) = false).
Proof. intros m n M r r' c c' k H H0 H1 H2 i H3.
  apply col_add_right_ones_one_bool_false with (c' := c'); try lia; auto.
  intros i0 H4. unfold col_swapF2. bdestruct_all; auto; apply H2; try lia.
Qed.

Lemma fst_gaussian_elimination_transposed_rec_get_pivot_row_above_one_false :
  forall {m n : nat} (M : MatrixF2 m n) (r c pc r' c' : nat),
    (r < r' <= m)%nat -> (c' < c)%nat -> (c <= pc < n)%nat -> (M (m - r')%nat c' =? 1) = true -> 
    (forall i : nat, (c' < i < n)%nat -> (M (m - r')%nat i =? 1) = false) ->
    (fst (gaussian_elimination_transposed_rec_get_pivot_row M r c pc) (m - r')%nat pc =? 1) = false. 
Proof. intros m n M r c pc r' c' H H0 H1 H2 H3. 
  gen M c pc r' c'. induction r; intros; simpl.
  - apply H3; lia.
  - destruct (hd_error (col_search_ones_right M (m - S r) c)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S r)%nat i =? 1) (seq c (n - c))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * rewrite IHr with (c' := c'); auto; try lia.
        -- apply col_add_right_ones_col_swapF2_one_bool_true; try lia; auto.
        -- apply col_add_right_ones_col_swapF2_one_bool_false; try lia; auto.
      * rewrite IHr with (c' := c'); auto; try lia.
        -- apply col_add_right_ones_one_bool_true; try lia; auto.
        -- apply col_add_right_ones_one_bool_false; try lia; auto.
      * apply col_add_right_ones_col_swapF2_one_bool_false with (c' := c'); try lia; auto.
      * apply col_add_right_ones_one_bool_false with (c' := c'); try lia; auto.
    + bdestruct_all; try lia; simpl.
      rewrite IHr with (c' := c'); auto; try lia.
Qed.

Lemma col_addF2_one_bool_true_true : forall {m n : nat} (M : MatrixF2 m n) (r c a : nat),
    c <> a -> (M r c =? 1) = true -> (M r a =? 1) = true -> ((col_addF2 M a c 1) r c =? 1) = true.
Proof. intros m n M r c a H H0 H1.
  rewrite F2_beq_true_iff in H0, H1.
  rewrite F2_beq_true_iff.
  unfold col_addF2.
  bdestruct_all; auto.
Qed.

Lemma col_add_rec_one_bool_preserve : forall {m n : nat} (M : MatrixF2 m n) (r c : nat) (cols : list nat),
    NoDup cols -> (forall a : nat, In a cols -> (M r a =? 1) = true) ->
    ~ In c cols -> (M r c =? 1) = true -> ((col_add_rec M c cols) r c =? 1) = true.
Proof. intros m n M r c cols H H0 H1 H2.
  rewrite F2_beq_true_iff in H2.
  rewrite F2_beq_true_iff.
  gen M r c. induction cols; intros; auto.
  simpl. 
  rewrite not_in_cons in H1.
  destruct H1.
  rewrite NoDup_cons_iff in H.
  destruct H.
  apply IHcols; auto.
  - intros a0 H5. 
    assert (In a0 (a :: cols)) by (simpl; auto).
    apply H0 in H6.
    rewrite F2_beq_true_iff in H6.
    rewrite F2_beq_true_iff.
    unfold col_addF2.
    bdestruct_all; auto.
    subst. contradiction.
  - rewrite <- F2_beq_true_iff.
    apply col_addF2_one_bool_true_true; auto.
    rewrite F2_beq_true_iff; auto.
    apply H0; simpl; auto.
Qed.

Lemma col_add_right_ones_one_bool_preserve : forall {m n : nat} (M : MatrixF2 m n) (r c : nat),
    (M r c =? 1) = true -> ((col_add_right_ones M r c) r c =? 1) = true.
Proof. intros m n M r c H.
  unfold col_add_right_ones.
  unfold col_search_ones_right.
  simpl.
  apply col_add_rec_one_bool_preserve; auto.
  - apply NoDup_filter.
    apply seq_NoDup.
  - intros a H0.
    rewrite filter_In in H0.
    destruct H0; auto.
  - intro.
    rewrite filter_In in H0.
    destruct H0.
    rewrite in_seq in H0.
    lia.
Qed.

Lemma col_swapF2_one_bool_preserve : forall {m n : nat} (M : MatrixF2 m n) (r c i : nat),
    (M r i =? 1) = true -> ((col_swapF2 M c i) r c =? 1) = true.
Proof. intros m n M r c i H.
  rewrite F2_beq_true_iff in H.
  rewrite F2_beq_true_iff.
  unfold col_swapF2.
  bdestruct_all; auto.
Qed.

Lemma col_add_right_ones_col_swapF2_one_bool_preserve : 
  forall {m n : nat} (M : MatrixF2 m n) (r c i : nat),
    (M r i =? 1) = true -> ((col_add_right_ones (col_swapF2 M c i) r c) r c =? 1) = true.
Proof. intros m n M r c i H.
  apply col_add_right_ones_one_bool_preserve.
  apply col_swapF2_one_bool_preserve; auto.
Qed.


Lemma col_add_rec_zero_bool_preserve :
  forall {m n : nat} (M : MatrixF2 m n) (r c : nat) (cols : list nat),
    (c < n)%nat -> NoDup cols -> ~ In c cols -> incl cols (seq c (n - c)) ->
    (forall i : nat, (c < i < n)%nat -> ((M r i =? 1) = true <-> In i cols)) -> (M r c =? 1) = true ->
    (forall i : nat, (c < i < n)%nat -> (col_add_rec M c cols r i =? 1) = false).
Proof. intros m n M r c cols H H0 H1 H2 H3 H4 i H5. 
  gen M r c. induction cols; intros; simpl.
  - rewrite F2_beq_false_iff. intro H6. rewrite <- F2_beq_true_iff in H6.
    rewrite H3 in H6; auto.
  - apply IHcols; auto.
    + rewrite NoDup_cons_iff in H0.
      destruct H0. auto.
    + rewrite not_in_cons in H1.
      destruct H1. auto.
    + unfold incl. intros a0 H6.
      assert (In a0 (a :: cols)) by (simpl; auto).
      apply H2 in H7. auto.
    + intros i0 H6. split; intros H7.
      * assert ((M r i0 =? 1) = true).
        { rewrite F2_beq_true_iff. 
          destruct (M r i0) eqn:E; auto.
          rewrite F2_beq_true_iff in H7. 
          destruct (col_addF2 M a c 1 r i0) eqn:E'; auto.
          contradict E'. unfold col_addF2.
          bdestruct_all; subst.
          - assert (In a (a :: cols)) by (simpl; auto).
            rewrite <- H3 in H8; auto.
            rewrite F2_beq_true_iff in H8.
            rewrite E in H8.
            discriminate.
          - rewrite E. intro. discriminate. }
        remember H8 as H'. clear HeqH'.
        rewrite H3 in H8; auto.
        destruct H8; auto.
        subst.
        rewrite F2_beq_true_iff in H7.
        contradict H7.
        unfold col_addF2.
        bdestruct_all; subst; auto.
        rewrite F2_beq_true_iff in H4, H'.
        rewrite H4, H'.
        F2simpl. simpl. intro. discriminate.
      * unfold col_addF2.
        bdestruct_all; subst; auto.
        -- rewrite NoDup_cons_iff in H0. destruct H0. auto.
        -- rewrite H3; simpl; auto.
    + unfold col_addF2.
      bdestruct_all; subst; auto.
      assert (In a (a :: cols)) by (simpl; auto).
      contradiction.
Qed.

Lemma col_add_right_ones_zero_bool_preserve : 
  forall {m n : nat} (M : MatrixF2 m n) (r c : nat),
    (c < n)%nat -> (M r c =? 1) = true ->
    (forall i : nat, (c < i < n)%nat -> ((col_add_right_ones M r c) r i =? 1) = false).
Proof. intros m n M r c H H0 i H1. 
  unfold col_add_right_ones.
  unfold col_search_ones_right.
  apply col_add_rec_zero_bool_preserve; auto.
  - apply NoDup_filter. apply seq_NoDup.
  - intro H2. rewrite filter_In in H2. destruct H2. 
    rewrite in_seq in H2. lia. 
  - unfold incl. intros a H2. 
    rewrite filter_In in H2. destruct H2.
    rewrite in_seq in H2. rewrite in_seq. lia.
  - intros i0 H2. split; intros H3.
    + rewrite filter_In. split; auto.
      rewrite in_seq; lia.
    + rewrite filter_In in H3. destruct H3. auto.
Qed.

Lemma col_add_right_ones_col_swapF2_zero_bool_preserve : 
  forall {m n : nat} (M : MatrixF2 m n) (r c k : nat),
    (M r k =? 1) = true -> (c < n)%nat -> (c < k < n)%nat ->
    (forall i : nat, (c < i < n)%nat -> (col_add_right_ones (col_swapF2 M c k) r c r i =? 1) = false).
Proof. intros m n M r c k H H0 H1 i H2.
  apply col_add_right_ones_zero_bool_preserve; auto.
  unfold col_swapF2.
  bdestruct_all; subst; auto.
Qed. 


Lemma col_add_rec_one_bool_false_inclusive_domain : 
  forall {m n : nat} (M : MatrixF2 m n) (r c i : nat) (cols : list nat),
    (c < i < n)%nat -> (forall i : nat, (c <= i < n)%nat -> (M r i =? 1) = false) ->
    NoDup cols -> ~ In c cols -> incl cols (seq c (n - c)) ->
    (col_add_rec M c cols r i =? 1) = false.
Proof. intros m n M r c i cols H H0 H1 H2 H3.
  gen M r c i. induction cols; intros; simpl.
  - apply H0; lia.
  - apply IHcols; try lia; auto.
    + rewrite NoDup_cons_iff in H1.
      destruct H1. auto.
    + intros i0 H4.
      unfold col_addF2.
      bdestruct_all; subst; auto.
      assert (M r a = zero).
      { destruct (M r a) eqn:E; auto.
        contradict E.
        rewrite <- F2_beq_false_iff.
        apply H0. lia. }
      assert (M r c = zero).
      { destruct (M r c) eqn:E; auto.
        contradict E.
        rewrite <- F2_beq_false_iff.
        apply H0. lia. }
      rewrite H5, H6.
      F2simpl. auto.
    + rewrite not_in_cons in H2.
      destruct H2. auto.
    + unfold incl. intros a0 H4.
      assert (In a0 (a :: cols)) by (simpl; auto).
      apply H3 in H5. auto.
Qed.

Lemma col_add_right_ones_one_bool_false_inclusive_domain : 
  forall {m n : nat} (M : MatrixF2 m n) (r r' c i : nat),
    (forall i : nat, (c <= i < n)%nat -> (M r' i =? 1) = false) -> (c < i < n)%nat ->
    (col_add_right_ones M r c r' i =? 1) = false.
Proof. intros m n M r r' c i H H0. 
  unfold col_add_right_ones.
  unfold col_search_ones_right.
  apply col_add_rec_one_bool_false_inclusive_domain; try lia; auto.
  - apply NoDup_filter. apply seq_NoDup.
  - intro H1. rewrite filter_In in H1. destruct H1. 
    rewrite in_seq in H1. lia. 
  - unfold incl. intros a H1. 
    rewrite filter_In in H1. destruct H1.
    rewrite in_seq in H1. rewrite in_seq. lia.
Qed.

Lemma col_add_right_ones_col_swapF2_one_bool_false_inclusive_domain : 
  forall {m n : nat} (M : MatrixF2 m n) (r r' c k i : nat),
    (forall i : nat, (c <= i < n)%nat -> (M r' i =? 1) = false) ->
    (c < k < n)%nat -> (c < i < n)%nat ->
    (col_add_right_ones (col_swapF2 M c k) r c r' i =? 1) = false.
Proof. intros m n M r r' c k i H H0 H1. 
   apply col_add_right_ones_one_bool_false_inclusive_domain; try lia; auto.
   - intros i0 H2. unfold col_swapF2.
     bdestruct_all; subst; apply H; try lia.
Qed.

Lemma col_add_rec_one_bool_false_pivot_col_is_col_inclusive_domain : 
  forall {m n : nat} (M : MatrixF2 m n) (r c : nat) (cols : list nat),
    (c < n)%nat -> (forall i : nat, (c <= i < n)%nat -> (M r i =? 1) = false) ->
    NoDup cols -> ~ In c cols -> incl cols (seq c (n - c)) ->
    (col_add_rec M c cols r c =? 1) = false.
Proof. intros m n M r c cols H H0 H1 H2 H3.
  gen M r c. induction cols; intros; simpl.
  - apply H0; lia.
  - apply IHcols; try lia; auto.
    + rewrite NoDup_cons_iff in H1.
      destruct H1. auto.
    + intros i0 H4.
      unfold col_addF2.
      bdestruct_all; subst; auto.
      assert (M r a = zero).
      { destruct (M r a) eqn:E; auto.
        contradict E.
        rewrite <- F2_beq_false_iff.
        apply H0. lia. }
      assert (M r c = zero).
      { destruct (M r c) eqn:E; auto.
        contradict E.
        rewrite <- F2_beq_false_iff.
        apply H0. lia. }
      rewrite H5, H6.
      F2simpl. auto.
    + rewrite not_in_cons in H2.
      destruct H2. auto.
    + unfold incl. intros a0 H4.
      assert (In a0 (a :: cols)) by (simpl; auto).
      apply H3 in H5. auto.
Qed.

Lemma col_add_right_ones_one_bool_false_pivot_col_is_col_inclusive_domain : forall {m n : nat} (M : MatrixF2 m n) (r r' c : nat),
    (forall i : nat, (c <= i < n)%nat -> (M r' i =? 1) = false) -> (c < n)%nat ->
    (col_add_right_ones M r c r' c =? 1) = false.
Proof. intros m n M r r' c H H0. 
  unfold col_add_right_ones.
  unfold col_search_ones_right.
  apply col_add_rec_one_bool_false_pivot_col_is_col_inclusive_domain; try lia; auto.
  - apply NoDup_filter. apply seq_NoDup.
  - intro H1. rewrite filter_In in H1. destruct H1. 
    rewrite in_seq in H1. lia. 
  - unfold incl. intros a H1. 
    rewrite filter_In in H1. destruct H1.
    rewrite in_seq in H1. rewrite in_seq. lia.
Qed.

Lemma col_add_right_ones_col_swapF2_one_bool_false_pivot_col_is_col_inclusive_domain : forall {m n : nat} (M : MatrixF2 m n) (r r' c k : nat),
    (r <= m)%nat -> (r' < r)%nat -> (forall i : nat, (c <= i < n)%nat -> (M r' i =? 1) = false) -> (c < k < n)%nat ->
    (M r k =? 1) = true -> (col_add_right_ones (col_swapF2 M c k) r c r' c =? 1) = false.
Proof. intros m n M r r' c k H H0 H1 H2 H3.
  apply col_add_right_ones_one_bool_false_pivot_col_is_col_inclusive_domain; try lia; auto.
  - intros i H4. unfold col_swapF2.
     bdestruct_all; subst; apply H1; try lia.
Qed.

Lemma fst_gaussian_elimination_transposed_rec_get_pivot_row_one_bool_empty_false :
  forall {m n : nat} (M : MatrixF2 m n) (r r' c pc : nat),
    (r' <= m)%nat -> (c <= pc < n)%nat -> (r < r')%nat -> 
    (forall i : nat, (c <= i < n)%nat -> (M (m - r')%nat i =? 1) = false) ->
    (fst (gaussian_elimination_transposed_rec_get_pivot_row M r c pc)
       (m - r')%nat pc =? 1) = false.
Proof. intros m n M r r' c pc H H0 H1 H2.
  gen M r' c pc. induction r; intros; auto; simpl.
  - destruct (hd_error (col_search_ones_right M (m - S r) c)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S r)%nat i =? 1) (seq c (n - c))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * rewrite IHr; auto; try lia. intros i H5. 
        apply col_add_right_ones_col_swapF2_one_bool_false_inclusive_domain; try lia; auto.
      * rewrite IHr; auto; try lia. intros i H5. 
        assert (n0 = c) by lia; subst.
        apply col_add_right_ones_one_bool_false_inclusive_domain; try lia; auto.
      * assert (pc = c) by lia; subst.
        apply col_add_right_ones_col_swapF2_one_bool_false_pivot_col_is_col_inclusive_domain; try lia; auto.
      * assert (n0 = c) by lia; subst.
        assert (pc = c) by lia; subst.
        apply col_add_right_ones_one_bool_false_pivot_col_is_col_inclusive_domain; try lia; auto.
    + rewrite IHr; auto; try lia.
Qed.

Lemma col_slice_one_hd_error_is_gaussian_elimination_transposed_rec_get_pivot_row :
  forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col : nat),
    (row_count <= m)%nat -> (col <= pivot_col < n)%nat ->
    col_slice_one_hd_error M row_count col pivot_col = snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col).
Proof. intros m n M row_count col pivot_col H H0.
  gen M col pivot_col. induction row_count; intros; auto.
  unfold col_slice_one_hd_error.
  simpl.
  destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
  - unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
    apply hd_error_some_nil in E; contradiction.
    simpl in E. inversion E; subst; clear E.
    assert (H' : In n0 (n0 :: l)) by (simpl; auto).
    rewrite <- E' in H'.
    rewrite filter_In in H'; destruct H' as [H' H''].
    rewrite in_seq in H'.
    bdestruct_all; try lia; simpl.
    + rewrite <- IHrow_count; try lia.
      unfold col_slice_one_hd_error.
      rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_above_one_false with (c' := col); try lia; auto.
      * replace (S (m - S row_count))%nat with (m - row_count)%nat by lia; auto.
      * apply col_add_right_ones_col_swapF2_one_bool_preserve; try lia; auto.
      * intros i H3. apply col_add_right_ones_col_swapF2_zero_bool_preserve; try lia; auto.
    + assert (n0 = col) by lia; subst.
      rewrite <- IHrow_count; try lia.
      unfold col_slice_one_hd_error.
      rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_above_one_false with (c' := col); try lia; auto.
      * replace (S (m - S row_count))%nat with (m - row_count)%nat by lia; auto.
      * apply col_add_right_ones_one_bool_preserve; try lia; auto.
      * intros i H3. apply col_add_right_ones_zero_bool_preserve; try lia; auto.
    + assert (pivot_col = col) by lia; subst.
      rewrite col_add_right_ones_col_swapF2_one_bool_preserve; auto.
    + assert (n0 = col) by lia; subst.
      assert (pivot_col = col) by lia; subst.
      rewrite col_add_right_ones_one_bool_preserve; auto.
  - rewrite <- IHrow_count; try lia.
    unfold col_slice_one_hd_error.
    unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E';
      simpl in E; try discriminate. clear E.
    assert (forall i : nat, (col <= i < n)%nat -> (M (m - S row_count)%nat i =? 1) = false).
    { intros i H1.
      assert (~ In i (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col)))).
      { intros H2. rewrite E' in H2. inversion H2. }
      rewrite filter_In in H2.
      rewrite in_seq in H2.
      destruct (M (m - S row_count)%nat i =? 1) eqn:E''; auto.
      assert ((col <= i < col + (n - col))%nat /\ true = true).
      { split; auto; try lia. }
      apply H2 in H3. contradiction. }
    rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_one_bool_empty_false; try lia; auto.
    replace (S (m - S row_count))%nat with (m - row_count)%nat by lia; auto.
Qed.


Definition col_slice_one_hd_error_original {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col : nat) :=
  let GM := gaussian_elimination_transposed_rec M row_count col in
  hd_error (filter (fun r : nat => (GM r pivot_col =? one)%F2) (List.seq (m - row_count) row_count)).

Lemma gaussian_elimination_transposed_rec_above_one_false :
  forall {m n : nat} (M : MatrixF2 m n) (r c pc r' c' : nat),
    (r < r' <= m)%nat -> (c' < c)%nat -> (c' < pc < n)%nat -> (M (m - r')%nat c' =? 1) = true -> 
    (forall i : nat, (c' < i < n)%nat -> (M (m - r')%nat i =? 1) = false) ->
    ((gaussian_elimination_transposed_rec M r c) (m - r')%nat pc =? 1) = false. 
Proof. intros m n M r c pc r' c' H H0 H1 H2 H3. 
  gen M c pc r' c'. induction r; intros; simpl.
  - apply H3; try lia.
  - destruct (hd_error (col_search_ones_right M (m - S r) c)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S r)%nat i =? 1) (seq c (n - c))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * rewrite IHr with (c' := c'); auto; try lia.
        -- apply col_add_right_ones_col_swapF2_one_bool_true; try lia; auto.
        -- apply col_add_right_ones_col_swapF2_one_bool_false; try lia; auto.
      * rewrite IHr with (c' := c'); auto; try lia.
        -- apply col_add_right_ones_one_bool_true; try lia; auto.
        -- apply col_add_right_ones_one_bool_false; try lia; auto.
    + bdestruct_all; try lia; simpl.
      rewrite IHr with (c' := c'); auto; try lia.
Qed.

Lemma col_add_rec_one_bool_false_inclusive_domain_previous : 
  forall {m n : nat} (M : MatrixF2 m n) (r c c' i : nat) (cols : list nat),
    (c' <= i < n)%nat -> (forall i : nat, (c' <= i < n)%nat -> (M r i =? 1) = false) -> (c' <= c < n)%nat ->
    NoDup cols -> ~ In c cols -> incl cols (seq c (n - c)) ->
    (col_add_rec M c cols r i =? 1) = false.
Proof. intros m n M r c c' i cols H H0 H1 H2 H3 H4.
  gen M r c i. induction cols; intros; simpl.
  - apply H0; lia.
  - apply IHcols; try lia; auto.
    + rewrite NoDup_cons_iff in H2.
      destruct H2. auto.
    + intros i0 H5.
      unfold col_addF2.
      bdestruct_all; subst; auto.
      assert (M r a = zero).
      { destruct (M r a) eqn:E; auto.
        contradict E.
        rewrite <- F2_beq_false_iff.
        apply H0. lia. }
      assert (M r c = zero).
      { destruct (M r c) eqn:E; auto.
        contradict E.
        rewrite <- F2_beq_false_iff.
        apply H0. lia. }
      rewrite H6, H7.
      F2simpl. auto.
    + rewrite not_in_cons in H3.
      destruct H3. auto.
    + unfold incl. intros a0 H5.
      assert (In a0 (a :: cols)) by (simpl; auto).
      apply H4 in H6. auto.
Qed.

Lemma col_add_right_ones_one_bool_false_inclusive_domain_previous : 
  forall {m n : nat} (M : MatrixF2 m n) (r r' c c' i : nat),
    (forall i : nat, (c' <= i < n)%nat -> (M r' i =? 1) = false) -> (c' <= c < n)%nat -> (c' <= i < n)%nat ->
    (col_add_right_ones M r c r' i =? 1) = false.
Proof. intros m n M r r' c c' i H H0 H1. 
  unfold col_add_right_ones.
  unfold col_search_ones_right.
  apply col_add_rec_one_bool_false_inclusive_domain_previous with (c' := c'); try lia; auto. 
  - apply NoDup_filter. apply seq_NoDup.
  - intro H2. rewrite filter_In in H2. destruct H2. 
    rewrite in_seq in H2. lia. 
  - unfold incl. intros a H2. 
    rewrite filter_In in H2. destruct H2.
    rewrite in_seq in H2. rewrite in_seq. lia.
Qed.

Lemma col_add_right_ones_col_swapF2_one_bool_false_inclusive_domain_previous : 
  forall {m n : nat} (M : MatrixF2 m n) (r r' c c' k i : nat),
    (forall i : nat, (c' <= i < n)%nat -> (M r' i =? 1) = false) -> (c' <= c < n)%nat ->
    (c < k < n)%nat -> (c' <= i < n)%nat ->
    (col_add_right_ones (col_swapF2 M c k) r c r' i =? 1) = false.
Proof. intros m n M r r' c c' k i H H0 H1 H2. 
   apply col_add_right_ones_one_bool_false_inclusive_domain_previous with (c' := c'); try lia; auto.
   - intros i0 H3. unfold col_swapF2.
     bdestruct_all; subst; apply H; try lia.
Qed.

Lemma gaussian_elimination_transposed_rec_one_bool_empty_false :
  forall {m n : nat} (M : MatrixF2 m n) (r r' c c' pc : nat),
    (r < r' <= m)%nat -> (c' <= pc < n)%nat -> (c' <= c)%nat -> 
    (forall i : nat, (c' <= i < n)%nat -> (M (m - r')%nat i =? 1) = false) ->
    ((gaussian_elimination_transposed_rec M r c)
       (m - r')%nat pc =? 1) = false.
Proof. intros m n M r r' c c' pc H H0 H1 H2.
  gen M r' c c' pc. induction r; intros; auto; simpl.
  - destruct (hd_error (col_search_ones_right M (m - S r) c)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S r)%nat i =? 1) (seq c (n - c))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * rewrite IHr with (c' := c'); auto; try lia. intros i H5. 
        apply col_add_right_ones_col_swapF2_one_bool_false_inclusive_domain_previous with (c' := c'); try lia; auto.
      * rewrite IHr with (c' := c'); auto; try lia. intros i H5. 
        assert (n0 = c) by lia; subst.
        apply col_add_right_ones_one_bool_false_inclusive_domain_previous with (c' := c'); try lia; auto.
    + rewrite IHr with (c' := c'); auto; try lia.
Qed.

Lemma gaussian_elimination_transposed_rec_one_bool_true : forall {m n : nat} (M : MatrixF2 m n) (r r' c c' : nat),
    (r < r' <= m)%nat -> (c' < c)%nat -> (M (m - r')%nat c' =? 1) = true ->
    (forall i : nat, (c' < i < n)%nat -> (M (m - r')%nat i =? 1) = false) ->
    (gaussian_elimination_transposed_rec M r c (m - r')%nat c' =? 1) = true.
Proof. intros m n M r r' c c' H H0 H1 H2.
  gen M r' c c'. induction r; intros; auto; simpl.
  destruct (hd_error (col_search_ones_right M (m - S r) c)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S r)%nat i =? 1) (seq c (n - c))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * apply IHr; try lia; auto.
        apply col_add_right_ones_col_swapF2_one_bool_true; try lia; auto.
        intros i H4. apply col_add_right_ones_col_swapF2_one_bool_false with (c' := c'); try lia; auto.
      * apply IHr; try lia; auto.
        apply col_add_right_ones_one_bool_true; try lia; auto.
        intros i H4. apply col_add_right_ones_one_bool_false with (c' := c'); try lia; auto.
    + apply IHr; try lia; auto.
Qed.

Lemma gaussian_elimination_transposed_rec_col_add_right_ones_one_bool_true : forall {m n : nat} (M : MatrixF2 m n) (r r' c c' : nat),
(r < r' <= m)%nat -> (c' < c)%nat -> (M (m - r')%nat c' =? 1) = true -> 
(gaussian_elimination_transposed_rec
        (col_add_right_ones M (m - r') c') r c (m - r')%nat c' =? 1) = true.
Proof. intros m n M r r' c c' H H0 H1.
  apply gaussian_elimination_transposed_rec_one_bool_true; try lia; auto.
  - apply col_add_right_ones_one_bool_preserve; try lia; auto.
  - intros i H2. apply col_add_right_ones_zero_bool_preserve; try lia; auto. 
Qed.

Lemma gaussian_elimination_transposed_rec_col_add_right_ones_col_swapF2_one_bool_true : forall {m n : nat} (M : MatrixF2 m n) (r r' c c' k : nat),
(r < r' <= m)%nat -> (c' < c < n)%nat -> (M (m - r')%nat k =? 1) = true -> (c' < k < n)%nat ->
(gaussian_elimination_transposed_rec
        (col_add_right_ones (col_swapF2 M c' k) (m - r') c') r c (m - r')%nat c' =? 1) = true.
Proof. intros m n M r r' c c' k H H0 H1 H2.
  apply gaussian_elimination_transposed_rec_col_add_right_ones_one_bool_true; try lia; auto.
  apply col_swapF2_one_bool_preserve; try lia; auto.
Qed.

Lemma col_slice_one_hd_error_original_eq :
  forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col : nat),
    (row_count <= m)%nat -> (col <= pivot_col < n)%nat ->
    col_slice_one_hd_error M row_count col pivot_col = col_slice_one_hd_error_original M row_count col pivot_col.
Proof. intros m n M row_count col pivot_col H H0.
  gen M col pivot_col. induction row_count; intros; auto.
  unfold col_slice_one_hd_error, col_slice_one_hd_error_original in *.
  simpl. bdestruct_all. 
  - destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_above_one_false with (c' := col); try lia; auto.
        rewrite gaussian_elimination_transposed_rec_above_one_false with (c' := col); try lia; auto.
        replace (S (m - S row_count))%nat with (m - row_count)%nat by lia.
        apply IHrow_count; try lia; auto.
        apply col_add_right_ones_col_swapF2_one_bool_preserve; try lia; auto.
        intros i H3. apply col_add_right_ones_col_swapF2_zero_bool_preserve; try lia; auto. 
        apply col_add_right_ones_col_swapF2_one_bool_preserve; try lia; auto.
        intros i H3. apply col_add_right_ones_col_swapF2_zero_bool_preserve; try lia; auto.
      * assert (n0 = col) by lia; subst.
        rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_above_one_false with (c' := col); try lia; auto.
        rewrite gaussian_elimination_transposed_rec_above_one_false with (c' := col); try lia; auto.
        replace (S (m - S row_count))%nat with (m - row_count)%nat by lia.
        apply IHrow_count; try lia; auto.
        apply col_add_right_ones_one_bool_preserve; try lia; auto.
        intros i H3. apply col_add_right_ones_zero_bool_preserve; try lia; auto. 
        apply col_add_right_ones_one_bool_preserve; try lia; auto.
        intros i H3. apply col_add_right_ones_zero_bool_preserve; try lia; auto.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E';
        simpl in E; try discriminate. clear E.
      assert (forall i : nat, (col <= i < n)%nat -> (M (m - S row_count)%nat i =? 1) = false).
      { intros i H2.
        assert (~ In i (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col)))).
        { intros H3. rewrite E' in H3. inversion H3. }
        rewrite filter_In in H3.
        rewrite in_seq in H3.
        destruct (M (m - S row_count)%nat i =? 1) eqn:E''; auto.
        assert ((col <= i < col + (n - col))%nat /\ true = true).
        { split; auto; try lia. }
        apply H3 in H4. contradiction. }
      rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_one_bool_empty_false; try lia; auto.
      rewrite gaussian_elimination_transposed_rec_one_bool_empty_false with (c' := col); try lia; auto.
      replace (S (m - S row_count))%nat with (m - row_count)%nat by lia; auto.
      apply IHrow_count; try lia; auto.
  - assert (pivot_col = col) by lia; subst.
    destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * rewrite col_add_right_ones_col_swapF2_one_bool_preserve; try lia; auto.
        rewrite gaussian_elimination_transposed_rec_col_add_right_ones_col_swapF2_one_bool_true; try lia; auto.
      * assert (n0 = col) by lia; subst.
        rewrite col_add_right_ones_one_bool_preserve; try lia; auto.
        rewrite gaussian_elimination_transposed_rec_col_add_right_ones_one_bool_true; try lia; auto.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E';
        simpl in E; try discriminate. clear E.
      assert (forall i : nat, (col <= i < n)%nat -> (M (m - S row_count)%nat i =? 1) = false).
      { intros i H2.
        assert (~ In i (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col)))).
        { intros H3. rewrite E' in H3. inversion H3. }
        rewrite filter_In in H3.
        rewrite in_seq in H3.
        destruct (M (m - S row_count)%nat i =? 1) eqn:E''; auto.
        assert ((col <= i < col + (n - col))%nat /\ true = true).
        { split; auto; try lia. }
        apply H3 in H4. contradiction. }
      rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_one_bool_empty_false; try lia; auto.
      rewrite gaussian_elimination_transposed_rec_one_bool_empty_false with (c' := col); try lia; auto.
      replace (S (m - S row_count))%nat with (m - row_count)%nat by lia; auto.
      apply IHrow_count; try lia; auto.
Qed.

(* if pivot_col1 < pivot_col2 /\ pivot_row(pivot_col1) = None
then pivot_row(pivot_col2) = None *)
Lemma gaussian_elimination_transposed_rec_get_pivot_row_preserves_pivot_ordering_None : forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col1 pivot_col2 : nat),
    (pivot_col1 < pivot_col2)%nat -> 
    (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col1) = None) ->
    (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col2) = None).
Proof. intros m n M row_count col pivot_col1 pivot_col2 H H0 (*H1 H2*). 
  gen M col pivot_col1 pivot_col2. induction row_count; intros; auto.
  simpl in *. bdestruct_all.
  - destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * apply IHrow_count with (pivot_col1 := pivot_col1); try lia; auto.
        bdestruct (col <? pivot_col1)%nat; subst; auto.
        simpl in H0. inversion H0.
      * apply IHrow_count with (pivot_col1 := pivot_col1); try lia; auto.
        bdestruct (col <? pivot_col1)%nat; subst; auto.
        simpl in H0. inversion H0.
    + apply IHrow_count with (pivot_col1 := pivot_col1); try lia; auto.
  - destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl;
        bdestruct (col <? pivot_col1)%nat; subst; try lia; auto.
    + apply IHrow_count with (pivot_col1 := pivot_col1); try lia; auto.
Qed.

Lemma gaussian_elimination_transposed_rec_get_pivot_row_greater_than : forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col k : nat),
snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col) = Some k -> (row_count < m)%nat -> (m - S row_count < k)%nat.
Proof. intros m n M row_count col pivot_col k H H0.
  gen M col pivot_col k. induction row_count; intros; auto.
  - simpl in *. discriminate.
  - simpl in *.
    destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct (col <? pivot_col)%nat; try lia.
      * bdestruct (col <? n0)%nat; try lia.
        -- apply IHrow_count in H; try lia.
        -- apply IHrow_count in H; try lia.
      * bdestruct (col <? n0)%nat; simpl in *; try lia.
        -- inversion H; try lia.
        -- inversion H; try lia.
    + apply IHrow_count in H; try lia.
Qed.

Lemma gaussian_elimination_transposed_rec_get_pivot_row_preserves_pivot_ordering_Some : forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col1 pivot_col2 k1 k2 : nat),
    (col <= pivot_col1 < pivot_col2)%nat -> (row_count <= m)%nat ->
    (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col2) = Some k2) ->
    (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col1) = Some k1) -> (k1< k2)%nat.
Proof. intros m n M row_count col pivot_col1 pivot_col2 k1 k2 H H0 H1 H2.
  gen col pivot_col1 pivot_col2 k1 k2. gen M. induction row_count; intros; auto.
  - simpl in *. discriminate.
  - simpl in *. 
    destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct (col <? pivot_col1)%nat.
      * bdestruct (col <? pivot_col2)%nat; try lia.
        bdestruct (col <? n0)%nat; try lia.
        -- apply IHrow_count with (M := (col_add_right_ones (col_swapF2 M col n0) (m - S row_count) col)) (col := S col) (pivot_col1 := pivot_col1) (pivot_col2 := pivot_col2); try lia; auto.
        -- apply IHrow_count with (M := (col_add_right_ones M (m - S row_count) col)) (col := S col) (pivot_col1 := pivot_col1) (pivot_col2 := pivot_col2); try lia; auto.
      * bdestruct (col <? pivot_col2)%nat; try lia.
        -- bdestruct (col <? n0)%nat; try lia.
           ++ simpl in *.
              apply gaussian_elimination_transposed_rec_get_pivot_row_greater_than in H1; try lia; auto.
              inversion H2; auto.
           ++ simpl in *.
              apply gaussian_elimination_transposed_rec_get_pivot_row_greater_than in H1; try lia; auto.
              inversion H2; auto.
    + apply IHrow_count with (M := M) (col := col) (pivot_col1 := pivot_col1) (pivot_col2 := pivot_col2); try lia; auto.
Qed.

Lemma gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_ordering_Some : forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col1 pivot_col2 k2 : nat),
    (col <= pivot_col1 < pivot_col2)%nat -> (row_count <= m)%nat ->
    (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col2) = Some k2) ->
    (exists k1 : nat, (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col1) = Some k1) /\ (k1< k2)%nat).
Proof. intros m n M row_count col pivot_col1 pivot_col2 k2 H H0 H1. 
  destruct (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col1)) eqn:E. 
  2:{apply gaussian_elimination_transposed_rec_get_pivot_row_preserves_pivot_ordering_None with (pivot_col2 := pivot_col2) in E; auto. rewrite E in H1. discriminate. lia. }
  exists n0. split; auto.
  apply @gaussian_elimination_transposed_rec_get_pivot_row_preserves_pivot_ordering_Some with (m := m) (n := n) (M := M) (row_count := row_count) (col := col) (pivot_col1 := pivot_col1) (pivot_col2 := pivot_col2) (k1 := n0) (k2 := k2); try lia; auto.
Qed.

(* if pivot_col1 < pivot_col2
then either 
pivot_row(pivot_col2) = None
or
pivot_row(pivot_col1) < pivot_row(pivot_col2) *)
Lemma gaussian_elimination_transposed_rec_get_pivot_row_None_or_preserves_pivot_ordering  : forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col1 pivot_col2 : nat),
    (col <= pivot_col1 < pivot_col2)%nat -> (row_count <= m)%nat ->
    ((snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col2) = None) \/
       (exists k1 k2 : nat, ((snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col1)) = Some k1) /\ 
          ((snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col2)) = Some k2) /\
          (k1 < k2)%nat)).
Proof. intros m n M row_count col pivot_col1 pivot_col2  H H0.
  destruct (snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col2)) eqn:E.
  - right. apply gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_ordering_Some with (pivot_col1 := pivot_col1) in E; try lia; auto.
   destruct E. destruct H1.
   eexists. eexists. split. apply H1. split; auto.
  - left; auto.
Qed.

Lemma fst_gaussian_elimination_transposed_rec_get_pivot_row_M_vector :
  forall {m : nat} (M : VectorF2 m) (row_count : nat),
    fst (gaussian_elimination_transposed_rec_get_pivot_row M row_count 0%nat 0%nat) = M.
Proof. intros m M row_count.
  gen m M. induction row_count; intros; auto; simpl. 
  destruct (hd_error (col_search_ones_right M (m - S row_count) 0%nat)) eqn:E; simpl.
  + unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq 0%nat (1 - 0)%nat)) eqn:E'.
    apply hd_error_some_nil in E; contradiction.
    simpl in E. inversion E; subst; clear E.
    assert (H' : In n (n :: l)) by (simpl; auto).
    rewrite <- E' in H'.
    rewrite filter_In in H'; destruct H' as [H' H''].
    rewrite in_seq in H'.
    assert (n = 0%nat) by lia; subst.
    bdestruct_all. simpl.
    unfold col_add_right_ones.
    unfold col_search_ones_right.
    simpl. auto.
  + apply IHrow_count.
Qed.

Lemma snd_gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_implies_pivot_col_one : forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col k : nat),
    (col <= pivot_col < n)%nat -> (row_count <= m)%nat ->
    snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col) =
      Some k ->
    (gaussian_elimination_transposed_rec M row_count col) k pivot_col = one.
Proof. intros m n M row_count col pivot_col k H H0 H1.
  gen M col pivot_col k. induction row_count; intros.
  - simpl in *; try discriminate.
  - simpl in *.
    destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
    + unfold col_search_ones_right in E.
      destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In n0 (n0 :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      bdestruct_all; try lia; simpl.
      * bdestruct (col <? pivot_col)%nat.
        -- try apply IHrow_count; try lia; auto.
        -- assert (pivot_col = col)%nat by lia; subst.
           simpl in *.
           inversion H1; subst.
           rewrite <- F2_beq_true_iff.
           apply gaussian_elimination_transposed_rec_col_add_right_ones_col_swapF2_one_bool_true; try lia; auto.
      * assert (n0 = col) by lia; subst.
        bdestruct (col <? pivot_col)%nat.
        -- try apply IHrow_count; try lia; auto.
        -- assert (pivot_col = col)%nat by lia; subst.
           simpl in *.
           inversion H1; subst.
           rewrite <- F2_beq_true_iff.
           apply gaussian_elimination_transposed_rec_col_add_right_ones_one_bool_true; try lia; auto.
    + apply IHrow_count; try lia; auto.
Qed.

Lemma snd_gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_implies_right_zero : forall {m n : nat} (M : MatrixF2 m n) (row_count col pivot_col k y : nat),
    (col <= pivot_col < n)%nat -> (row_count <= m)%nat ->
    snd (gaussian_elimination_transposed_rec_get_pivot_row M row_count col pivot_col) =
      Some k ->
    (pivot_col < y < n)%nat ->
    (gaussian_elimination_transposed_rec M row_count col) k y = zero.
Proof. intros m n M row_count col pivot_col k y H H0.
  gen M col pivot_col k y. induction row_count; intros; simpl in *; try discriminate.
  destruct (hd_error (col_search_ones_right M (m - S row_count) col)) eqn:E; simpl.
  - unfold col_search_ones_right in E.
    destruct (filter (fun i : nat => M (m - S row_count)%nat i =? 1) (seq col (n - col))) eqn:E'.
    apply hd_error_some_nil in E; contradiction.
    simpl in E. inversion E; subst; clear E.
    assert (H' : In n0 (n0 :: l)) by (simpl; auto).
    rewrite <- E' in H'.
    rewrite filter_In in H'; destruct H' as [H' H''].
    rewrite in_seq in H'.
    bdestruct_all; try lia; simpl.
    * bdestruct (col <? pivot_col)%nat.
      -- apply IHrow_count with (pivot_col := pivot_col); try lia; auto.
      -- assert (pivot_col = col)%nat by lia; subst.
         simpl in *.
         inversion H1; subst.
         rewrite <- F2_neq1_iff_eq0.
         rewrite <- F2_beq_false_iff.
         apply gaussian_elimination_transposed_rec_above_one_false with (c' := col); try lia; auto.
         ++ apply col_add_right_ones_col_swapF2_one_bool_preserve; try lia; auto.
         ++ intros i H5. apply col_add_right_ones_col_swapF2_zero_bool_preserve; try lia; auto.
    * assert (n0 = col) by lia; subst.
      bdestruct (col <? pivot_col)%nat.
      -- apply IHrow_count with (pivot_col := pivot_col); try lia; auto.
      -- assert (pivot_col = col)%nat by lia; subst.
         simpl in *.
         inversion H1; subst.
         rewrite <- F2_neq1_iff_eq0.
         rewrite <- F2_beq_false_iff.
         apply gaussian_elimination_transposed_rec_above_one_false with (c' := col); try lia; auto.
         ++ apply col_add_right_ones_one_bool_preserve; try lia; auto.
         ++ intros i H5. apply col_add_right_ones_zero_bool_preserve; try lia; auto.
  - apply IHrow_count with (pivot_col := pivot_col); try lia; auto.
Qed.

(** i in declaration, i < n in precondition **)
Lemma gaussian_elimination_transposed_rec_get_pivot_row_lin_indep_zero_coef : forall {m n : nat} (M : MatrixF2 m n) (a : VectorF2 n) (k i j : nat),
    (0 < n)%nat -> WF_MatrixF2 M -> WF_MatrixF2 a ->
    (snd (gaussian_elimination_transposed_rec_get_pivot_row M m 0%nat (n - 1)%nat) = Some k) -> 
    ((fst (gaussian_elimination_transposed_rec_get_pivot_row M m 0%nat (n - 1)%nat)) × a) = ZeroF2 -> (i <= j < n)%nat -> (a i 0%nat = zero).
Proof. intros m n M a k i j H H0 H1 H2 H3 H4. 
  gen M a k i. induction j; intros; simpl; auto.
  - assert (i = 0)%nat by lia; subst.
    bdestruct (n =? 1)%nat; subst; simpl in *.
    + rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_M_vector in H3.
      rewrite <- col_slice_one_hd_error_is_gaussian_elimination_transposed_rec_get_pivot_row in H2; try lia.
      unfold col_slice_one_hd_error in H2.
      rewrite fst_gaussian_elimination_transposed_rec_get_pivot_row_M_vector in H2.
      replace (m - m)%nat with 0%nat in H2 by lia.
      destruct (hd_error (filter (fun r : nat => M r 0%nat =? 1) (seq 0 m))) eqn:E; simpl;
        try discriminate.
      inversion H2; subst.
      destruct (filter (fun r : nat => M r 0%nat =? 1) (seq 0 m)) eqn:E'.
      apply hd_error_some_nil in E; contradiction.
      simpl in E. inversion E; subst; clear E.
      assert (H' : In k (k :: l)) by (simpl; auto).
      rewrite <- E' in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      unfold MmultF2 in H3.
      apply f_equal_inv with (x := k) in H3.
      apply f_equal_inv with (x := 0%nat) in H3.
      simpl in H3.
      rewrite F2_beq_true_iff in H''.
      rewrite H'' in H3.
      rewrite F2mult_1_l in H3.
      destruct (a 0%nat 0%nat) eqn:E''; try discriminate; auto.
    + destruct (gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_ordering_Some M m 0%nat 0%nat (n - 1)%nat k) as [k' [H6 H7]]; try lia; auto.
      remember H6 as H6'; clear HeqH6'.
      rewrite <- col_slice_one_hd_error_is_gaussian_elimination_transposed_rec_get_pivot_row in H6; try lia.
      rewrite col_slice_one_hd_error_original_eq in H6; try lia.
      unfold col_slice_one_hd_error_original in H6.
      rewrite gaussian_elimination_transposed_rec_get_pivot_row_saturated with (pivot_col := (n - 1)%nat) in H6; try lia.
      replace (m - m)%nat with 0%nat in H6 by lia.
      destruct (filter
                  (fun r : nat =>
                     fst (gaussian_elimination_transposed_rec_get_pivot_row M m 0 (n - 1)%nat) r
                       0%nat =? 1) (seq 0 m)) eqn:E; try discriminate.
      simpl in *. inversion H6; subst.
      assert (H' : In k' (k' :: l)) by (simpl; auto).
      rewrite <- E in H'.
      rewrite filter_In in H'; destruct H' as [H' H''].
      rewrite in_seq in H'.
      rewrite F2_beq_true_iff in H''.
      unfold MmultF2 in H3.
      apply f_equal_inv with (x := k') in H3.
      apply f_equal_inv with (x := 0%nat) in H3.
      simpl in H3.
      rewrite <- gaussian_elimination_transposed_rec_get_pivot_row_saturated in *; try lia.
      destruct n.
      * simpl in *. rewrite H2 in H6'. inversion H6'; subst. lia.
      * rewrite <- big_sum_extend_l in H3.
        rewrite H'' in H3.
        rewrite F2mult_1_l in H3.
        simpl in H3.
        assert (Σ2 (fun x : nat => 
                      gaussian_elimination_transposed_rec M m 0 k' (S x) · a (S x) 0%nat) n = 0).
        { rewrite big_sum_0_bounded; auto. intros x H8.
          rewrite snd_gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_implies_right_zero with (pivot_col := 0%nat); try lia; auto.
          rewrite F2mult_0_l. auto. }
        unfold big_sum in *.
        rewrite H8 in H3.
        rewrite F2plus_0_r in H3.
        auto.
  - bdestruct (i =? S j)%nat; subst.
    assert (n > 1)%nat by lia.
    + bdestruct (n =? S (S j))%nat; subst.
      * simpl in *.
        remember H3 as H3'; clear HeqH3'.
        unfold MmultF2 in H3.
        apply f_equal_inv with (x := k) in H3.
        apply f_equal_inv with (x := 0%nat) in H3.
        rewrite <- big_sum_extend_r in H3.
        rewrite <- gaussian_elimination_transposed_rec_get_pivot_row_saturated in *; try lia.
        rewrite snd_gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_implies_pivot_col_one in H3; try lia; auto.
        rewrite F2mult_1_l in H3.
        assert ((Σ2 (fun y : nat => ((gaussian_elimination_transposed_rec M m 0 k y) · (a y 0%nat))%F2) (S j)) = 0).
        { rewrite big_sum_0_bounded; auto. intros x H6.
          rewrite IHj with (M := M) (k := k); try lia; auto.
          simpl. rewrite F2mult_0_r. auto.
          rewrite <- gaussian_elimination_transposed_rec_get_pivot_row_saturated in *; try lia.
          auto. }
        simpl in H3, H6.
        rewrite H6 in H3.
        rewrite F2plus_0_l in H3.
        auto.
      * destruct (gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_ordering_Some M m 0%nat (S j) (n - 1)%nat k) as [k' [H7 H8]]; try lia; auto. 
        rewrite <- gaussian_elimination_transposed_rec_get_pivot_row_saturated in *; try lia.
        remember H3 as H3'; clear HeqH3'.
        unfold MmultF2 in H3.
        apply f_equal_inv with (x := k') in H3.
        apply f_equal_inv with (x := 0%nat) in H3.
        replace n with (S (S j) + (n - S (S j)))%nat in H3 by lia.
        rewrite big_sum_sum in H3.
        rewrite <- big_sum_extend_r in H3.
        assert (Σ2 (fun y : nat => gaussian_elimination_transposed_rec M m 0 k' y · a y 0%nat) 
                  (S j) = 0)%F2.
        { rewrite big_sum_0_bounded; auto. intros x H9.
          rewrite IHj with (M := M) (k := k); try lia; auto.
          rewrite F2mult_0_r. auto.
          rewrite <- gaussian_elimination_transposed_rec_get_pivot_row_saturated in *; try lia.
          auto. }
        assert (Σ2 (fun x : nat => gaussian_elimination_transposed_rec M m 0 k' (S (S j) + x)%nat ·
                                a (S (S j) + x)%nat 0%nat) (n - S (S j)) = 0)%F2.
        { rewrite big_sum_0_bounded; auto. intros x H10.
          rewrite snd_gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_implies_right_zero with (pivot_col := S j); try lia; auto.
          rewrite F2mult_0_l. auto. }
        simpl in *.
        replace (S (S (j + (n - S (S j)))))%nat with n in H3 by lia.
        rewrite H10, H9 in H3.
        rewrite F2plus_0_l, F2plus_0_r in H3.
        rewrite snd_gaussian_elimination_transposed_rec_get_pivot_row_exists_pivot_implies_pivot_col_one in H3; try lia; auto.
        rewrite F2mult_1_l in H3. 
        auto.
    + apply IHj with (M := M) (k := k); try lia; auto.
Qed.

Lemma gaussian_elimination_transposed_rec_get_pivot_row_lin_indep : forall {m n : nat} (M : MatrixF2 m n) (a : VectorF2 n) (k : nat),
    (0 < n)%nat -> WF_MatrixF2 M ->
    (snd (gaussian_elimination_transposed_rec_get_pivot_row M m 0%nat (n - 1)%nat) = Some k) -> 
    linearly_independentF2 (fst (gaussian_elimination_transposed_rec_get_pivot_row M m 0%nat (n - 1)%nat)).
Proof. intros m n M a k H H0 H1.
  unfold linearly_independentF2.
  intros a0 H2 H3.
  prep_matrix_equality. simpl.
  bdestruct (y =? 0)%nat; subst.
  - bdestruct (x <? n)%nat.
    + rewrite @gaussian_elimination_transposed_rec_get_pivot_row_lin_indep_zero_coef with (m := m) (n := n) (M := M) (k := k) (j := x); try lia; auto.
    + rewrite H2; try lia; auto. 
  - rewrite H2; try lia; auto.
Qed.

Lemma last_col_zero_lin_dep : forall {m n : nat} (M : MatrixF2 m n),
    WF_MatrixF2 M -> (n > 0)%nat ->
    hd_error (filter (fun r : nat => M r (n - 1)%nat =? 1) (seq 0%nat m)) = None ->
    linearly_dependentF2 M.
Proof. intros m n M H H0 H1.
  unfold linearly_dependentF2.
  assert (forall i : nat, In i (seq 0 m) -> M i (n - 1)%nat = zero).
  { intros i H2.
    destruct (filter (fun r : nat => M r (n - 1)%nat =? 1) (seq 0 m)) eqn:E; 
      simpl in H1; try discriminate.
    rewrite <- F2_neq1_iff_eq0.
    intro H3.
    assert (In i []).
    { rewrite <- E.
     rewrite filter_In.
     split; auto.
     rewrite F2_beq_true_iff.
     auto. }
    inversion H4. }
  exists (fun r c : nat => if (r =? n-1)%nat && (c =? 0)%nat then 1 else 0).
  split.
  - unfold WF_MatrixF2.
    intros x y H3.
    bdestruct_all; simpl; auto.
  - split.
    + intro H3.
      apply f_equal_inv with (x := (n - 1)%nat) in H3.
      apply f_equal_inv with (x := 0%nat) in H3.
      rewrite ! Nat.eqb_refl in H3.
      simpl in H3.
      discriminate.
    + unfold MmultF2.
      prep_matrix_equality.
      simpl.
      rewrite big_sum_0_bounded; auto.
      intros x0 H3.
      bdestruct_all; simpl;
        try rewrite F2mult_0_r; auto.
      subst.
      bdestruct (x <? m)%nat.
      rewrite H2; try rewrite in_seq; try lia; rewrite F2mult_0_l; auto. 
      rewrite H; try lia; auto.
Qed.

Definition last_col_pivot_row_hd_error_gaussian_elimination_transposed {m n : nat} (M : MatrixF2 m n) : option nat :=
  let GM := gaussian_elimination_transposed M in
  hd_error (filter (fun r : nat => GM r (n - 1)%nat =? 1) (seq 0%nat m)).

Lemma last_col_pivot_row_hd_error_gaussian_elimination_transposed_None_lin_dep :
  forall {m n : nat} (M : MatrixF2 m n),
    WF_MatrixF2 M -> (n > 0)%nat ->
    last_col_pivot_row_hd_error_gaussian_elimination_transposed M = None ->
    linearly_dependentF2 M.
Proof. intros m n M H H0 H1.
  unfold last_col_pivot_row_hd_error_gaussian_elimination_transposed in H1.
  rewrite gaussian_elimination_transposed_preserves_lin_dep.
  apply last_col_zero_lin_dep; auto.
  apply WF_gaussian_elimination_transposed; auto.
Qed.

Lemma last_col_pivot_row_hd_error_gaussian_elimination_transposed_Some_lin_indep :
  forall {m n : nat} (M : MatrixF2 m n) (k : nat),
    WF_MatrixF2 M -> (n > 0)%nat ->
    last_col_pivot_row_hd_error_gaussian_elimination_transposed M = Some k ->
    linearly_independentF2 M.
Proof. intros m n M k H H0 H1.
  unfold last_col_pivot_row_hd_error_gaussian_elimination_transposed in H1.
  rewrite gaussian_elimination_transposed_preserves_lin_indep.
  unfold gaussian_elimination_transposed in *.
  rewrite gaussian_elimination_transposed_rec_get_pivot_row_saturated with (pivot_col := (n - 1)%nat); try lia; auto.
  apply gaussian_elimination_transposed_rec_get_pivot_row_lin_indep with (k := k); try lia; auto.
  rewrite <- col_slice_one_hd_error_is_gaussian_elimination_transposed_rec_get_pivot_row; try lia; auto.
  rewrite col_slice_one_hd_error_original_eq; try lia; auto.
  unfold col_slice_one_hd_error_original.
  replace (m - m)%nat with 0%nat by lia. auto.
Qed.

Lemma no_col_WF_MatrixF2_lin_indep : forall {m : nat} (M : MatrixF2 m 0%nat),
    WF_MatrixF2 M -> linearly_independentF2 M.
Proof. intros m M H.
  unfold linearly_independentF2.
  intros a H0 H1.
  prep_matrix_equality.
  rewrite H0; try lia; auto.
Qed.

Definition linearly_independentF2_bool {m n : nat} (M : MatrixF2 m n) : bool :=
  if (n =? 0)%nat then true else
    match last_col_pivot_row_hd_error_gaussian_elimination_transposed M with
    | None => false
    | Some k => true
    end.

Lemma linearly_independentF2_bool_true_iff_lin_indepF2 : forall {m n : nat} (M : MatrixF2 m n),
    WF_MatrixF2 M ->
    ((linearly_independentF2_bool M) = true <-> linearly_independentF2 M).
Proof. intros m n M H. split; intros H0.
  - bdestruct (n =? 0)%nat; subst.
    + apply no_col_WF_MatrixF2_lin_indep; auto.
    + unfold linearly_independentF2_bool in H0.
      remember H1 as H1'; clear HeqH1'.
      rewrite <- Nat.eqb_neq in H1.
      rewrite H1 in H0; simpl in H0.
      destruct (last_col_pivot_row_hd_error_gaussian_elimination_transposed M) eqn:E;
        try discriminate.
      apply last_col_pivot_row_hd_error_gaussian_elimination_transposed_Some_lin_indep with (k := n0); try lia; auto.
  - destruct (linearly_independentF2_bool M) eqn:E; auto.
    contradict H0.
    apply lindep_implies_not_linindepF2.
    unfold linearly_independentF2_bool in E.
    bdestruct (n =? 0)%nat; try discriminate.
    destruct (last_col_pivot_row_hd_error_gaussian_elimination_transposed M) eqn:E';
      try discriminate.
    apply last_col_pivot_row_hd_error_gaussian_elimination_transposed_None_lin_dep;
      try lia; auto.
Qed.


(** ** Example calculation of Gaussian elimination ** **)

Definition set_F2matrix (m n : nat) (LLz : list (list F2)) : MatrixF2 m n := 
  (fun r c : nat => nth c (nth r LLz (repeat zero n)) zero).

(** col_count := n, acc := [] **)
Fixpoint print_F2matrix_row_rec {m n : nat} (M : MatrixF2 m n) (row col : nat) (acc : list F2) {struct col} : list F2 :=
  match col with
  | 0%nat => acc
  | S col' => print_F2matrix_row_rec M row col' ((M row col') :: acc)
  end.

Definition print_F2matrix_row {m n : nat} (M : MatrixF2 m n) (row : nat) :=
  print_F2matrix_row_rec M row n [].
  
(** row_count := m, acc := [] **)
Fixpoint print_F2matrix_rec {m n : nat} (M : MatrixF2 m n) (row : nat) (acc : list (list F2)) {struct row} : list (list F2) :=
  match row with
  | 0%nat => acc
  | S row' => print_F2matrix_rec M row' ((print_F2matrix_row M row') :: acc)
  end.

Definition print_F2matrix {m n : nat} (M : MatrixF2 m n) :=
  print_F2matrix_rec M m [].
Compute print_F2matrix (gaussian_elimination_transposed
(set_F2matrix 3%nat 4%nat 
[[1; 0; 1; 1];
 [1; 1; 1; 0];
 [1; 1; 1; 0]]
)).
(** 
[[1; 0; 0; 0];
 [1; 1; 0; 0];
 [1; 1; 0; 0]]
**)


(** ** anticommutative / commutative TTypes ** *)
Open Scope C_scope.
Open Scope matrix_scope.

Definition anticommute_Pauli (A B : Pauli) : Prop :=
  translate_P A × translate_P B = - C1 .* translate_P B × translate_P A.

Definition commute_Pauli (A B : Pauli) : Prop :=
  translate_P A × translate_P B = translate_P B × translate_P A.

Definition anticommute_TType {n : nat} (t1 t2 : TType n) : Prop :=
  let (c1, Ps1) := t1 in
  let (c2, Ps2) := t2 in
  (cBigMul (zipWith gMul_Coef Ps1 Ps2)) = (- (cBigMul (zipWith gMul_Coef Ps2 Ps1)))%C.

Definition commute_TType {n : nat} (t1 t2 : TType n) : Prop :=
  let (c1, Ps1) := t1 in
  let (c2, Ps2) := t2 in
  (cBigMul (zipWith gMul_Coef Ps1 Ps2)) = (cBigMul (zipWith gMul_Coef Ps2 Ps1)).

Fixpoint anticommute_TType_AType {n : nat} (t : TType n) (a : AType n) : Prop :=
  match a with
  | t1 :: a1 => anticommute_TType t t1 /\ anticommute_TType_AType t a1
  | nil => True
  end. 
  
Fixpoint anticommute_AType_syntactic {n : nat} (a1 a2 : AType n) : Prop :=
  match a1 with
  | t1 :: a1' => anticommute_TType_AType t1 a2 /\ anticommute_AType_syntactic a1' a2
  | nil => True
  end.


Lemma gMul_Coef_comm_anticomm : forall (p1 p2 : Pauli),
    (gMul_Coef p1 p2 = gMul_Coef p2 p1) \/ (gMul_Coef p1 p2 = - gMul_Coef p2 p1)%C.
Proof. intros p1 p2. destruct p1, p2; unfold gMul_Coef; simpl; auto.
  all: right; lca.
Qed.

Lemma gMul_Coef_comm_1 : forall (p1 p2 : Pauli),
    (gMul_Coef p1 p2 = gMul_Coef p2 p1) -> gMul_Coef p1 p2 = C1.
Proof. intros p1 p2 H. destruct p1, p2; unfold gMul_Coef in *; auto.
  all: inversion H; lra.
Qed.

Lemma gMul_Coef_anticomm_plus_minus_i : forall (p1 p2 : Pauli),
    (gMul_Coef p1 p2 = - gMul_Coef p2 p1)%C -> (gMul_Coef p1 p2 = Ci \/ gMul_Coef p1 p2 = (- Ci)%C).
Proof. intros p1 p2 H. destruct p1, p2; unfold gMul_Coef in *; auto.
  all: inversion H; lra.
Qed.


Lemma anticommute_TType_gScaleT : forall {n} (c : Coef) (t1 t2 : TType n),
    anticommute_TType t1 (gScaleT c t2) <->  anticommute_TType t1 t2.
Proof. intros n c t1 t2.
  split; intros; destruct t1, t2; easy.
Qed.
  
Lemma anticommute_TType_AType_gScaleA : forall {n} (c : Coef) (t : TType n) (a : AType n),
    anticommute_TType_AType t (gScaleA c a) <-> anticommute_TType_AType t a.
Proof. intros n c t a.
  split; intros.
  - induction a; auto.
    simpl in *. destruct H.
    specialize (IHa H0).
    split; auto.
    rewrite anticommute_TType_gScaleT in H.
    easy.
  - induction a; auto.
    simpl in *. destruct H.
    specialize (IHa H0).
    split; auto.
    rewrite anticommute_TType_gScaleT.
    easy.
Qed.

Lemma anticommute_AType_syntactic_gScaleA : forall {n} (c : Coef) (a b : AType n),
    anticommute_AType_syntactic a (gScaleA c b) <-> anticommute_AType_syntactic a b.
Proof. intros n c a b.
  split; intros.
  - induction a; auto.
    simpl in *. destruct H.
    specialize (IHa H0).
    split; auto.
    rewrite anticommute_TType_AType_gScaleA in H.
    auto.
  - induction a; auto.
    simpl in *. destruct H.
    specialize (IHa H0).
    split; auto.
    rewrite anticommute_TType_AType_gScaleA.
    auto.
Qed.


Inductive restricted_addition_syntactic {n : nat} : AType n -> Prop :=
| add_restrict_base_syntactic : forall (t : TType n), WF_TType t -> restricted_addition_syntactic [t]
| add_restrict_inductive_syntactic : forall (a1 a2 : AType n),
    restricted_addition_syntactic a1 -> restricted_addition_syntactic a2 ->
    anticommute_AType_syntactic a1 a2  ->
    restricted_addition_syntactic (gScaleA (C1/√2)%C (a1 ++ a2)).

Lemma restricted_addition_syntactic_implies_not_nil : forall {n : nat} (a : AType n),
  restricted_addition_syntactic a -> a <> [].
Proof. intros n a H.
  induction H. 
  intro; discriminate.
  intro. unfold gScaleA in H2.
  apply map_eq_nil in H2.
  apply app_eq_nil in H2.
  destruct H2. auto.
Qed.

Lemma restricted_addition_syntactic_implies_proper_length_AType: forall {n : nat} (a : AType n),
  restricted_addition_syntactic a -> proper_length_AType a.
Proof. intros n a H. induction H.
  - constructor. inversion H. assumption.
  - apply proper_length_AType_gScaleA.
    apply proper_length_AType_App; assumption.
Qed.

Lemma restricted_addition_syntactic_defaultA : forall {n : nat},
    n <> 0%nat -> restricted_addition_syntactic (defaultA_Z n).
Proof. intros n.
  unfold defaultA_Z.
  constructor.
  auto with wf_db.
Qed.

#[export] Hint Resolve restricted_addition_syntactic_defaultA : wf_db.

Inductive WF_AType {n : nat} : AType n -> Prop :=
| WF_A_syntactic (a : AType n) : restricted_addition_syntactic a -> WF_AType a.

Lemma WF_AType_defaultA : forall {n : nat},
    n <> 0%nat -> WF_AType (defaultA_Z n).
Proof. intros n H.
  constructor.
  auto with wf_db.
Qed.

#[export] Hint Resolve WF_AType_defaultA : wf_db.
  
Lemma restricted_addition_syntactic_implies_WF_AType : forall {n} (a : AType n),
    restricted_addition_syntactic a -> WF_AType a.
Proof. intros n a H. constructor. auto. Qed.

Lemma WF_AType_implies_proper_length_AType : forall {n} (a : AType n),
    WF_AType a -> proper_length_AType a.
Proof. intros n a H. destruct H.
  apply restricted_addition_syntactic_implies_proper_length_AType; auto.
Qed.


Lemma proper_length_AType_implies_proper_length_TType : forall {n : nat} (t : TType n) (a : AType n),
    proper_length_AType a -> In t a -> proper_length_TType t.
Proof. intros n t a H H0.
  induction H.
  - inversion H0; subst; clear H0; auto.
    inversion H1.
  - inversion H0; subst; clear H0; auto.
Qed.

Lemma proper_length_AType_gMulA : forall {n} (a a0 : AType n),
    proper_length_AType a -> proper_length_AType a0
    -> proper_length_AType (gMulA a a0).
Proof. intros n a a0 H H0. induction H; simpl in *.
  - rewrite app_nil_r.
    induction H0; simpl in *.
    + constructor.
      apply proper_length_TType_gMulT; auto.
    + constructor; auto.
      apply proper_length_TType_gMulT; auto.
  - apply proper_length_AType_App; auto.
    clear IHproper_length_AType.
    induction H0; simpl in *.
    + constructor.
      apply proper_length_TType_gMulT; auto.
    + constructor; auto.
      apply proper_length_TType_gMulT; auto.
Qed.

Lemma proper_length_TType_gTensorT : forall {n m} (t : TType n) (t0 : TType m),
    proper_length_TType t -> proper_length_TType t0
    -> proper_length_TType (gTensorT t t0).
Proof. intros n m t t0 H H0.
  destruct H, H0.
  destruct t, t0.
  simpl in *.
  constructor.
  - lia.
  - simpl. rewrite app_length.
    rewrite H1, H2. auto.
Qed.

Lemma proper_length_AType_gTensorA : forall {n m} (a : AType n) (a0 : AType m),
    proper_length_AType a -> proper_length_AType a0
    -> proper_length_AType (gTensorA a a0).
Proof. intros n m a a0 H H0.
  induction H; simpl in *.
  - rewrite app_nil_r.
    induction H0; simpl in *.
    + constructor.
      apply proper_length_TType_gTensorT; auto.
    + constructor; auto.
      apply proper_length_TType_gTensorT; auto.
  - apply proper_length_AType_App; auto.
    clear IHproper_length_AType.
    induction H0; simpl in *.
    + constructor.
      apply proper_length_TType_gTensorT; auto.
    + constructor; auto.
      apply proper_length_TType_gTensorT; auto.
Qed.      
  

Lemma anticommute_AType_syntactic_nil_r : forall {n} (a : AType n), anticommute_AType_syntactic a [] <-> True.
Proof. intros n a.
  split.
  - intro.
    induction a; auto.
  - intro.
    induction a; auto.
    simpl.
    rewrite and_comm.
    rewrite kill_true.
    apply IHa.
Qed.

Lemma anticommute_TType_comm : forall {n} (a b : TType n), anticommute_TType a b -> anticommute_TType b a.
Proof. intros n a b H.
  destruct a,b; simpl in *.
  rewrite H.
  lca.
Qed.

Lemma anticommute_AType_syntactic_comm : forall {n} (a b : AType n), anticommute_AType_syntactic a b -> anticommute_AType_syntactic b a.
Proof. intros n a b H.
  induction a.
  - apply anticommute_AType_syntactic_nil_r. auto.
  - simpl in *.
    destruct H. specialize (IHa H0).
    clear H0.
    induction b.
    + simpl. auto.
    + simpl in *.
      destruct H, IHa.
      specialize (IHb H0 H2).
      repeat split; auto.
      apply anticommute_TType_comm.
      auto.
Qed.

Lemma anticommute_TType_AType_app_dist : forall {n} (t : TType n) (a1 a2 : AType n),
    anticommute_TType_AType t (a1 ++ a2) <-> anticommute_TType_AType t a1 /\ anticommute_TType_AType t a2.
Proof. intros n t a1 a2.
  split.
  - intro. split.
    + induction a1.
      * simpl. auto.
      * simpl in *. destruct H.
        specialize (IHa1 H0).
        split; auto.
    + induction a1.
      * simpl in *. auto.
      * simpl in *. destruct H.
        specialize (IHa1 H0).
        auto.
  - intro. destruct H.
    induction a1; auto.
    simpl in *. destruct H.
    specialize (IHa1 H1).
    split; auto.
Qed.

Lemma anticommute_TType_AType_app_comm : forall {n} (t : TType n) (a1 a2 : AType n),
    anticommute_TType_AType t (a1 ++ a2) <->  anticommute_TType_AType t (a2 ++ a1).
Proof. intros n t a1 a2.
  split; intro;
    rewrite anticommute_TType_AType_app_dist;
    rewrite and_comm;
    rewrite <- anticommute_TType_AType_app_dist;
    auto.
Qed.

Lemma anticommute_AType_syntactic_app_dist_l : forall {n} (a b c : AType n), anticommute_AType_syntactic (a ++ b) c <-> anticommute_AType_syntactic a c /\ anticommute_AType_syntactic b c.
Proof. intros n a b c.
  split.
  - intro. split.
    + induction a.
      * simpl. auto.
      * simpl in *. destruct H.
        specialize (IHa H0).
        split; auto.
    + induction a.
      * simpl in *. auto.
      * simpl in *. destruct H.
        apply (IHa H0).
  - intro. destruct H.
    induction a; auto.
    simpl in *. destruct H.
    specialize (IHa H1).
    split; auto.
Qed.

Lemma anticommute_AType_syntactic_app_comm_l : forall {n} (a b c : AType n), anticommute_AType_syntactic (a ++ b) c <-> anticommute_AType_syntactic (b ++ a) c.
Proof. intros n a b c. rewrite ! anticommute_AType_syntactic_app_dist_l. rewrite and_comm.
  split; auto.
Qed.

Lemma anticommute_AType_syntactic_app_dist_r : forall {n} (a b c : AType n), anticommute_AType_syntactic a (b ++ c) <-> anticommute_AType_syntactic a b /\ anticommute_AType_syntactic a c.
Proof. intros n a b c.
  split.
  - intros.
    apply anticommute_AType_syntactic_comm in H.
    rewrite anticommute_AType_syntactic_app_dist_l in H.
    destruct H.
    split; apply anticommute_AType_syntactic_comm; auto.
  - intros [H H0].
    apply anticommute_AType_syntactic_comm.
    rewrite anticommute_AType_syntactic_app_dist_l.
    apply anticommute_AType_syntactic_comm in H.
    apply anticommute_AType_syntactic_comm in H0.
    split; auto.
Qed.

Lemma anticommute_AType_syntactic_app_comm_r : forall {n} (a b c : AType n), anticommute_AType_syntactic a (b ++ c) <-> anticommute_AType_syntactic a (c ++ b).
Proof. intros n a b c. rewrite ! anticommute_AType_syntactic_app_dist_r. rewrite and_comm.
  split; auto.
Qed.



Inductive commute_P (P1 P2 : Pauli) : Prop :=
| commuting_P : P1 = gI \/ P2 = gI \/ P1 = P2 -> commute_P P1 P2.

Inductive anticommute_P (P1 P2 : Pauli) : Prop :=
| anticommuting_P : P1 <> gI -> P2 <> gI -> P1 <> P2 -> anticommute_P P1 P2.

Lemma commute_P_swap : forall (P1 P2 : Pauli),
    commute_P P1 P2 -> commute_P P2 P1.
Proof. intros P1 P2 H0.
  inversion H0.
  constructor.
  destruct H as [H | [H | H]]; auto.
Qed.

Lemma anticommute_P_swap : forall (P1 P2 : Pauli),
    anticommute_P P1 P2 -> anticommute_P P2 P1.
Proof. intros P1 P2 H0.
  inversion H0.
  constructor; auto.
Qed.

Lemma neg_commute_P : forall (P1 P2 : Pauli),
    ~ commute_P P1 P2 <-> anticommute_P P1 P2.
Proof. intros P1 P2.
  split; intros H0.
  - assert (~ (P1 = gI \/ P2 = gI \/ P1 = P2))
      by (intro H1; unfold "~" in H0, H1; apply (commuting_P P1 P2) in H1; auto).
    apply Classical_Prop.not_or_and in H.
    destruct H as [H1 H2].
    apply Classical_Prop.not_or_and in H2.
    destruct H2 as [H2 H3].
    constructor; auto.
  - intro H1.
    inversion H0.
    inversion H1.
    destruct H4 as [H4 | [H4 | H4]]; auto.
Qed.

Lemma neg_anticommute_P : forall (P1 P2 : Pauli),
    ~ anticommute_P P1 P2 <-> commute_P P1 P2.
Proof. intros P1 P2.
  split; intros H0.
  - assert (~ (P1 <> gI /\ P2 <> gI /\ P1 <> P2)).
    { intro H1.
      unfold "~" in H0.
      destruct H1 as [H1 [H2 H3]].
      pose (anticommuting_P P1 P2 H1 H2 H3) as E.
      apply H0 in E.
      auto. }
    do 2 (apply Classical_Prop.not_and_or in H;
          destruct H as [H | H];
          try (apply Classical_Prop.NNPP in H;
               constructor; auto)).
  - intro H1.
    inversion H0.
    inversion H1.
    destruct H as [H | [H | H]]; auto.
Qed.

Lemma anticommute_or_commute_P : forall (P1 P2 : Pauli),
    anticommute_P P1 P2 \/ commute_P P1 P2.
Proof. intros P1 P2.
  destruct (Classical_Prop.classic (commute_P P1 P2)) as [H0 | H0];
    try rewrite neg_commute_P in H0; auto.
Qed.

Lemma anticommute_commute_P_no_middle : forall (P1 P2 : Pauli),
    ~ anticommute_P P1 P2 \/ ~ commute_P P1 P2.
Proof. intros P1 P2.
  apply Classical_Prop.not_and_or.
  intros [H0 H1].
  rewrite <- neg_commute_P in H0.
  contradiction.
Qed.

Inductive commute_listP : list Pauli -> list Pauli -> Prop :=
| commuting_listP_base : forall (P1 P2 : Pauli),
    commute_P P1 P2 -> commute_listP [P1] [P2]
| commuting_listP_commP_commL : forall (P1 P2 : Pauli) (l1 l2 : list Pauli),
    commute_P P1 P2 -> commute_listP l1 l2 -> commute_listP (P1::l1) (P2::l2)
| commuting_listP_anticommP_anticommL : forall (P1 P2 : Pauli) (l1 l2 : list Pauli),
    anticommute_P P1 P2 -> anticommute_listP l1 l2 -> commute_listP (P1::l1) (P2::l2)

with anticommute_listP : list Pauli -> list Pauli -> Prop :=
| anticommuting_listP_base : forall (P1 P2 : Pauli),
    anticommute_P P1 P2 -> anticommute_listP [P1] [P2]
| anticommuting_listP_anticommP_commL : forall (P1 P2 : Pauli) (l1 l2 : list Pauli),
    anticommute_P P1 P2 -> commute_listP l1 l2 -> anticommute_listP (P1::l1) (P2::l2)
| anticommuting_listP_commP_anticommL : forall (P1 P2 : Pauli) (l1 l2 : list Pauli),
    commute_P P1 P2 -> anticommute_listP l1 l2 -> anticommute_listP (P1::l1) (P2::l2).

Scheme commute_listP_ind_dep := Induction for commute_listP Sort Prop
    with anticommute_listP_ind_dep := Induction for anticommute_listP Sort Prop.

Scheme commute_listP_ind' := Minimality for commute_listP Sort Prop
    with anticommute_listP_ind' := Minimality for anticommute_listP Sort Prop.

Lemma commute_listP_length : forall (l1 l2 : list Pauli),
    commute_listP l1 l2 -> length l1 = length l2 /\ l1 <> [].
Proof. intros l1 l2 H.
  induction H using commute_listP_ind' with (P0 := fun l1 l2 => length l1 = length l2 /\ l1 <> []);
    simpl; split; try destruct IHcommute_listP; f_equal; auto; intro H'; inversion H'.
Qed.

Lemma anticommute_listP_length : forall (l1 l2 : list Pauli),
    anticommute_listP l1 l2 -> length l1 = length l2 /\ l1 <> [].
Proof. intros l1 l2 H.
  induction H using anticommute_listP_ind' with (P := fun l1 l2 => length l1 = length l2 /\ l1 <> []);
    simpl; split; try destruct IHanticommute_listP; f_equal; auto; intro H'; inversion H'.
Qed.

Lemma commute_listP_repeat_gI : forall (m : nat) (l : list Pauli),
    length l = m -> l <> [] -> commute_listP l (repeat gI m).
Proof. intros m l H.
  gen l. induction m; intros.
  - rewrite length_zero_iff_nil in H. contradiction.
  - destruct l; try contradiction.
    simpl in *. apply Nat.succ_inj in H.
    destruct l.
    + subst. simpl in *. constructor. constructor. right. left. auto.
    + destruct m; try discriminate.
      assert (p0 :: l <> []) by (intro; discriminate).
      specialize (IHm (p0 :: l) H H1).
      constructor; auto.
      constructor. right. left. auto.
Qed.

Lemma commute_listP_swap : forall (l1 l2 : list Pauli),
    commute_listP l1 l2 -> commute_listP l2 l1.
Proof. intros l1 l2 H0.
  apply commute_listP_ind'
    with (P := fun (l1 l2 : list Pauli) => commute_listP l2 l1)
         (P0 := fun (l1 l2 : list Pauli) => anticommute_listP l2 l1);
    intros; auto;
    try (constructor; try apply commute_P_swap; try apply anticommute_P_swap; easy).
Qed.

Lemma anticommute_listP_swap : forall (l1 l2 : list Pauli),
    anticommute_listP l1 l2 -> anticommute_listP l2 l1.
Proof. intros l1 l2 H0.
  apply anticommute_listP_ind'
    with (P := fun (l1 l2 : list Pauli) => commute_listP l2 l1)
         (P0 := fun (l1 l2 : list Pauli) => anticommute_listP l2 l1);
    intros; auto;
    try (constructor; try apply anticommute_P_swap; try apply commute_P_swap; easy).
Qed.

Lemma anticommute_or_commute_listP : forall (l1 l2 : list Pauli),
    l1 <> [] \/ l2 <> [] -> length l1 = length l2 -> anticommute_listP l1 l2 \/ commute_listP l1 l2.
Proof. intros l1 l2 H0 H1.
  gen l2.
    induction l1 as [ | p1 l1]; intros.
    - simpl in H1.
      symmetry in H1.
      rewrite length_zero_iff_nil in H1.
      subst.
      destruct H0; contradiction.
    - destruct l2 as [ | p2 l2].
      + simpl in H1.
        inversion H1.
      + simpl in H1.
        inversion H1.
        destruct (list_eq_dec eqdec_Pauli l1 []) as [E | E].
        * subst.
        simpl in *.
        symmetry in H2.
        rewrite length_zero_iff_nil in H2.
        subst.
        destruct (anticommute_or_commute_P p1 p2).
           -- left; constructor; auto.
           -- right; constructor; auto.
        * assert (E' : l2 <> []).
           { intro H3; subst; simpl in H2;
               rewrite length_zero_iff_nil in H2; subst; contradiction. }
           assert (EE' : l1 <> [] \/ l2 <> []) by auto.
           destruct (IHl1 l2 EE' H2);
             destruct (anticommute_or_commute_P p1 p2).
           -- right. apply commuting_listP_anticommP_anticommL; auto.
           -- left. apply anticommuting_listP_commP_anticommL; auto.
           -- left. apply anticommuting_listP_anticommP_commL; auto.
           -- right. apply commuting_listP_commP_commL; auto.
Qed.
              
Lemma anticommute_listP_nonempty_equal_len : forall (l1 l2 : list Pauli),
    anticommute_listP l1 l2 -> l1 <> [] /\ l2 <> [] /\ length l1 = length l2.
Proof. intros l1 l2 H0.
  apply anticommute_listP_ind'
    with (P := fun (l1 l2 : list Pauli) =>
                l1 <> [] /\ l2 <> [] /\ length l1 = length l2)
         (P0 := fun (l1 l2 : list Pauli) =>
                l1 <> [] /\ l2 <> [] /\ length l1 = length l2);
    intros; repeat split; auto; try (intro; discriminate); simpl;
    match goal with
    | H' : context [length _ = length _] |- _ =>
        destruct H' as [H'1 [H'2 H'3]]; rewrite H'3; auto
    end.
Qed.

Lemma commute_listP_nonempty_equal_len : forall (l1 l2 : list Pauli),
    commute_listP l1 l2 -> l1 <> [] /\ l2 <> [] /\ length l1 = length l2.
Proof. intros l1 l2 H0.
  apply commute_listP_ind'
    with (P := fun (l1 l2 : list Pauli) =>
                l1 <> [] /\ l2 <> [] /\ length l1 = length l2)
         (P0 := fun (l1 l2 : list Pauli) =>
                l1 <> [] /\ l2 <> [] /\ length l1 = length l2);
    intros; repeat split; auto; try (intro; discriminate); simpl;
    match goal with
    | H' : context [length _ = length _] |- _ =>
        destruct H' as [H'1 [H'2 H'3]]; rewrite H'3; auto
    end.
Qed.

Lemma anticommute_commute_listP_no_middle : forall (l1 l2 : list Pauli),
    ~ anticommute_listP l1 l2 \/ ~ commute_listP l1 l2.
Proof. intros l1 l2.
  apply Classical_Prop.not_and_or.
  intros [H0 H1].
  gen l2.
  induction l1; intros.
  - destruct (anticommute_listP_nonempty_equal_len [] l2 H0) as [H' [H'' H''']];
      contradiction.
  - destruct l2.
    + destruct (anticommute_listP_nonempty_equal_len (a :: l1) [] H0) as [H' [H'' H''']];
        contradiction.
    + apply (IHl1 l2).
      * destruct (anticommute_or_commute_P a p).
        -- inversion H1; subst; auto.
           ++ rewrite <- neg_anticommute_P in H3; contradiction.
           ++ rewrite <- neg_anticommute_P in H5; contradiction.
        -- inversion H0; subst; auto.
           ++ rewrite <- neg_commute_P in H3; contradiction.
           ++ rewrite <- neg_commute_P in H5; contradiction.
      * destruct (anticommute_or_commute_P a p).
        -- inversion H0; subst; auto.
           ++ inversion H1; subst; auto.
              ** rewrite <- neg_anticommute_P in H5; contradiction.
              ** destruct (anticommute_listP_nonempty_equal_len [] [] H8) as [H' [H'' H''']];
                   contradiction.
           ++ rewrite <- neg_anticommute_P in H5; contradiction.
        -- inversion H1; subst; auto.
           ++ inversion H0; subst; auto.
              ** rewrite <- neg_commute_P in H5; contradiction.
              ** destruct (anticommute_listP_nonempty_equal_len [] [] H8) as [H' [H'' H''']];
                   contradiction.
           ++ rewrite <- neg_commute_P in H5; contradiction.
Qed.

Lemma anticommute_commute_listP_app_repeat_right : forall (m : nat) (lp1 lp2 : list Pauli),
    lp1 <> [] -> lp2 <> [] ->
    (commute_listP (lp1 ++ repeat gI m) (lp2 ++ repeat gI m) ->
     commute_listP lp1 lp2) /\ 
      (anticommute_listP (lp1 ++ repeat gI m) (lp2 ++ repeat gI m) ->
       anticommute_listP lp1 lp2).
Proof. intros m lp1 lp2 H H0.
  gen lp2. induction lp1; intros;
    destruct lp2; try discriminate; try contradiction.
  split; intros.
  - remember H1 as H1'. clear HeqH1'.
    apply commute_listP_length in H1'. destruct H1'.
    rewrite ! app_length, ! repeat_length in H2.
    assert (length lp1 = length lp2) by (simpl in *; lia).
    clear H2.
    destruct lp1, lp2; try discriminate.
    + simpl in *. inversion H1; subst; constructor; auto.
      destruct m. inversion H9.
      assert (length (repeat gI (S m)) = S m) by (rewrite repeat_length; auto).
      assert (repeat gI (S m) <> []) by (intro H'; inversion H').
      pose (commute_listP_repeat_gI (S m) (repeat gI (S m)) H2 H5) as H6.
      destruct (anticommute_commute_listP_no_middle (repeat gI (S m)) (repeat gI (S m)));
        try contradiction.
    + simpl in *. apply Nat.succ_inj in H4.
      assert (p0 :: lp1 <> []) by (intro; discriminate).
      assert (p1 :: lp2 <> []) by (intro; discriminate).
      specialize (IHlp1 H2 (p1 :: lp2) H5).
      destruct IHlp1.
      inversion H1; subst.
      apply H6 in H13. apply commuting_listP_commP_commL; auto.
      apply H7 in H13. apply commuting_listP_anticommP_anticommL; auto.
  - remember H1 as H1'. clear HeqH1'.
    apply anticommute_listP_length in H1'. destruct H1'.
    rewrite ! app_length, ! repeat_length in H2.
    assert (length lp1 = length lp2) by (simpl in *; lia).
    clear H2.
    destruct lp1, lp2; try discriminate.
    + simpl in *. inversion H1; subst; constructor; auto.
      destruct m. inversion H9.
      assert (length (repeat gI (S m)) = S m) by (rewrite repeat_length; auto).
      assert (repeat gI (S m) <> []) by (intro H'; inversion H').
      pose (commute_listP_repeat_gI (S m) (repeat gI (S m)) H2 H5) as H6.
      destruct (anticommute_commute_listP_no_middle (repeat gI (S m)) (repeat gI (S m)));
        try contradiction.
    + simpl in *. apply Nat.succ_inj in H4.
      assert (p0 :: lp1 <> []) by (intro; discriminate).
      assert (p1 :: lp2 <> []) by (intro; discriminate).
      specialize (IHlp1 H2 (p1 :: lp2) H5).
      destruct IHlp1.
      inversion H1; subst.
      apply H6 in H13. apply anticommuting_listP_anticommP_commL; auto.
      apply H7 in H13. apply anticommuting_listP_commP_anticommL; auto.
Qed.

Lemma commute_listP_app_repeat_right : forall (m : nat) (lp1 lp2 : list Pauli),
    lp1 <> [] -> lp2 <> [] ->
    commute_listP (lp1 ++ repeat gI m) (lp2 ++ repeat gI m) ->
     commute_listP lp1 lp2.
Proof. intros m lp1 lp2 H0 H1 H2.
  destruct (anticommute_commute_listP_app_repeat_right m lp1 lp2 H0 H1); auto.
Qed.

Lemma anticommute_listP_app_repeat_right : forall (m : nat) (lp1 lp2 : list Pauli),
    lp1 <> [] -> lp2 <> [] ->
    anticommute_listP (lp1 ++ repeat gI m) (lp2 ++ repeat gI m) ->
     anticommute_listP lp1 lp2.
Proof. intros m lp1 lp2 H0 H1 H2.
  destruct (anticommute_commute_listP_app_repeat_right m lp1 lp2 H0 H1); auto.
Qed.

Lemma anticommute_commute_listP_app_repeat_left : forall (n : nat) (lp1 lp2 : list Pauli),
    lp1 <> [] -> lp2 <> [] ->
    (commute_listP (repeat gI n ++ lp1) (repeat gI n ++ lp2) ->
     commute_listP lp1 lp2) /\ 
      (anticommute_listP (repeat gI n ++ lp1) (repeat gI n ++ lp2) ->
       anticommute_listP lp1 lp2).
Proof. intros n lp1 lp2 H H0.
  induction n; simpl; auto.
  destruct IHn.
  split; intros.
  - inversion H3; subst; auto.
    + contradict H.
      rewrite <- length_zero_iff_nil.
      symmetry in H6.
      rewrite <- length_zero_iff_nil in H6.
      rewrite app_length in H6. lia.
    + inversion H7. contradiction.
  - inversion H3; subst; auto.
    + contradict H.
      rewrite <- length_zero_iff_nil.
      symmetry in H6.
      rewrite <- length_zero_iff_nil in H6.
      rewrite app_length in H6. lia.
    + inversion H7. contradiction.
Qed.

Lemma commute_listP_app_repeat_left : forall (n : nat) (lp1 lp2 : list Pauli),
    lp1 <> [] -> lp2 <> [] ->
    commute_listP (repeat gI n ++ lp1) (repeat gI n ++ lp2) ->
     commute_listP lp1 lp2.
Proof. intros n lp1 lp2 H H0 H1.
  destruct (anticommute_commute_listP_app_repeat_left n lp1 lp2 H H0); auto.
Qed.

Lemma anticommute_listP_app_repeat_left : forall (n : nat) (lp1 lp2 : list Pauli),
    lp1 <> [] -> lp2 <> [] ->
    anticommute_listP (repeat gI n ++ lp1) (repeat gI n ++ lp2) ->
     anticommute_listP lp1 lp2.
Proof. intros n lp1 lp2 H H0 H1.
  destruct (anticommute_commute_listP_app_repeat_left n lp1 lp2 H H0); auto.
Qed.

Inductive commute_T {n : nat} (t1 t2 : TType n) : Prop :=
| commuting_T : commute_listP (snd t1) (snd t2) -> commute_T t1 t2.

Lemma commute_T_defaultT_I : forall {n : nat} (t : TType n),
    proper_length_TType t -> commute_T t (defaultT_I n).
Proof. intros n t.
  constructor. destruct t. unfold defaultT_I. simpl.
  destruct H. simpl in H0.
  gen n. induction l; intros. simpl in *. subst. contradiction.
  destruct n. contradiction.
  simpl in *. apply Nat.succ_inj in H0. clear H.
  destruct l. destruct n; simpl in *; try discriminate.
  do 2 constructor. auto.
  constructor. constructor. auto.
  apply IHl; simpl in *; lia.
Qed.

Inductive anticommute_T {n : nat} (t1 t2 : TType n) : Prop :=
| anticommuting_T : anticommute_listP (snd t1) (snd t2) -> anticommute_T t1 t2.

Lemma commute_T_gTensorT_defaultT_I_right : forall {m n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    commute_T (gTensorT t1 (defaultT_I m)) (gTensorT t2 (defaultT_I m)) ->
    commute_T t1 t2.
Proof. intros m n t1 t2 H0 H1 H2.
  inversion H2. clear H2. constructor.
  destruct t1, t2. unfold defaultT_I in H.
  destruct H0, H1.
  simpl in *.
  apply commute_listP_app_repeat_right in H; auto.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
Qed.

Lemma anticommute_T_gTensorT_defaultT_I_right : forall {m n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    anticommute_T (gTensorT t1 (defaultT_I m)) (gTensorT t2 (defaultT_I m)) ->
    anticommute_T t1 t2.
Proof. intros m n t1 t2 H0 H1 H2.
  inversion H2. clear H2. constructor.
  destruct t1, t2. unfold defaultT_I in H.
  destruct H0, H1.
  simpl in *.
  apply anticommute_listP_app_repeat_right in H; auto.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
Qed.

Lemma commute_T_gTensorT_defaultT_I_left : forall {m n : nat} (t1 t2 : TType m),
    proper_length_TType t1 -> proper_length_TType t2 ->
    commute_T (gTensorT(defaultT_I n)  t1) (gTensorT (defaultT_I n) t2) ->
    commute_T t1 t2.
Proof. intros m n t1 t2 H H0 H1.
  inversion H1. clear H1. constructor.
  destruct t1, t2. unfold defaultT_I in H2.
  destruct H, H0.
  simpl in *.
  apply commute_listP_app_repeat_left in H2; auto.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
Qed.

Lemma anticommute_T_gTensorT_defaultT_I_left : forall {m n : nat} (t1 t2 : TType m),
    proper_length_TType t1 -> proper_length_TType t2 ->
    anticommute_T (gTensorT (defaultT_I n) t1) (gTensorT (defaultT_I n) t2) ->
    anticommute_T t1 t2.
Proof. intros m n t1 t2 H H0 H1.
  inversion H1. clear H1. constructor.
  destruct t1, t2. unfold defaultT_I in H2.
  destruct H, H0.
  simpl in *.
  apply anticommute_listP_app_repeat_left in H2; auto.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
  intro. rewrite <- length_zero_iff_nil in H4. lia.
Qed.


Lemma commute_T_swap : forall {n : nat} (t1 t2 : TType n),
    commute_T t1 t2 -> commute_T t2 t1.
Proof. intros n t1 t2 H.
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  constructor. inversion H. simpl in *.
  inversion H0; subst; auto.
  - apply commute_listP_swap; auto.
  - apply commute_P_swap in H1.
    apply commute_listP_swap in H2.
    apply commuting_listP_commP_commL; auto.
  - apply anticommute_P_swap in H1.
    apply anticommute_listP_swap in H2.
    apply commuting_listP_anticommP_anticommL; auto.
Qed.

Lemma anticommute_T_swap : forall {n : nat} (t1 t2 : TType n),
    anticommute_T t1 t2 -> anticommute_T t2 t1.
Proof. intros n t1 t2 H.
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  constructor. inversion H. simpl in *.
  inversion H0; subst; auto.
  - apply anticommute_listP_swap; auto.
  - apply anticommute_P_swap in H1.
    apply commute_listP_swap in H2.
    apply anticommuting_listP_anticommP_commL; auto.
  - apply commute_P_swap in H1.
    apply anticommute_listP_swap in H2.
    apply anticommuting_listP_commP_anticommL; auto.
Qed.

Lemma anticommute_or_commute_T : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    anticommute_T t1 t2 \/ commute_T t1 t2.
Proof. intros n t1 t2 H0 H1.
  destruct H0 as [A0 A1].
  destruct H1 as [B0 B1].
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  simpl in *.
  destruct(list_eq_dec eqdec_Pauli l1 []) as [E | E];
    try (rewrite <- length_zero_iff_nil in E; lia).
  destruct(list_eq_dec eqdec_Pauli l2 []) as [E' | E'];
    try (rewrite <- length_zero_iff_nil in E'; lia).
  rewrite <- B1 in A1.
  assert (H0 : l1 <> [] \/ l2 <> []) by auto.
  destruct (anticommute_or_commute_listP l1 l2 H0 A1);
    try (left; constructor; assumption);
    try (right; constructor; assumption).
Qed.

Lemma anticommute_commute_T_no_middle : forall {n : nat} (t1 t2 : TType n),
    ~ anticommute_T t1 t2 \/ ~ commute_T t1 t2.
Proof. intros n t1 t2.
  apply Classical_Prop.not_and_or.
  intros [H1 H2].
  inversion H1. inversion H2.
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  simpl in *.
  destruct (anticommute_commute_listP_no_middle l1 l2); auto.
Qed.

Inductive commute_AT {n : nat} (a : AType n) (t : TType n) : Prop :=
| termwise_commute_AT : Forall (commute_T t) a -> commute_AT a t.

Inductive anticommute_AT {n : nat} (a : AType n) (t : TType n) : Prop :=
| termwise_anticommute_AT : Forall (anticommute_T t) a -> anticommute_AT a t.


Lemma commute_AT_app : forall {n : nat} (a1 a2 : AType n) (t : TType n),
    commute_AT (a1 ++ a2) t <-> commute_AT a1 t /\ commute_AT a2 t.
Proof. intros n a1 a2 t.
  split; intros.
  - inversion H; subst; clear H.
    split; constructor; rewrite Forall_app in H0; destruct H0; auto.
  - constructor. destruct H.
    inversion H; subst; clear H.
    inversion H0; subst; clear H0.
    assert (Forall (commute_T t) a1 /\ Forall (commute_T t) a2) by auto.
    rewrite <- Forall_app in H0; auto.
Qed.

Lemma anticommute_AT_app : forall {n : nat} (a1 a2 : AType n) (t : TType n),
    anticommute_AT (a1 ++ a2) t <-> anticommute_AT a1 t /\ anticommute_AT a2 t.
Proof. intros n a1 a2 t.
  split; intros.
  - inversion H; subst; clear H.
    split; constructor; rewrite Forall_app in H0; destruct H0; auto.
  - constructor. destruct H.
    inversion H; subst; clear H.
    inversion H0; subst; clear H0.
    assert (Forall (anticommute_T t) a1 /\ Forall (anticommute_T t) a2) by auto.
    rewrite <- Forall_app in H0; auto.
Qed.

Lemma commute_AT_gScaleA : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    commute_AT a t -> commute_AT (gScaleA c a) t.
Proof. intros n a t c H.
  constructor.
  inversion H; subst; clear H.
  induction H0.
  - simpl. constructor.
  - constructor; auto.
    destruct x; destruct t.
    simpl in *.
    constructor.
    inversion H; subst; clear H.
    simpl in *; auto.
Qed.

Lemma anticommute_AT_gScaleA : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    anticommute_AT a t -> anticommute_AT (gScaleA c a) t.
Proof. intros n a t c H.
  constructor.
  inversion H; subst; clear H.
  induction H0.
  - simpl. constructor.
  - constructor; auto.
    destruct x; destruct t.
    simpl in *.
    constructor.
    inversion H; subst; clear H.
    simpl in *; auto.
Qed.

Lemma commute_AT_gScaleA_inv : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    c <> C0 -> commute_AT (gScaleA c a) t -> commute_AT a t.
Proof. intros n a t c H0 H1.
  apply commute_AT_gScaleA with (c := (/c)%C) in H1.
  rewrite gScaleA_merge in H1.
  rewrite Cinv_l in H1; auto.
  rewrite gScaleA_1 in H1; auto.
Qed. 

Lemma anticommute_AT_gScaleA_inv : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    c <> C0 -> anticommute_AT (gScaleA c a) t -> anticommute_AT a t.
Proof. intros n a t c H0 H1.
  apply anticommute_AT_gScaleA with (c := (/c)%C) in H1.
  rewrite gScaleA_merge in H1.
  rewrite Cinv_l in H1; auto.
  rewrite gScaleA_1 in H1; auto.
Qed. 

Lemma commute_AT_gScaleT : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    commute_AT a t -> commute_AT a (gScaleT c t).
Proof. intros n a t c H.
  constructor.
  inversion H; subst; clear H.
  induction H0.
  - simpl. constructor.
  - constructor; auto.
    constructor. inversion H; subst; clear H.
    destruct t; destruct x; simpl; auto.
Qed.

Lemma anticommute_AT_gScaleT : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    anticommute_AT a t -> anticommute_AT a (gScaleT c t).
Proof. intros n a t c H.
  constructor.
  inversion H; subst; clear H.
  induction H0.
  - simpl. constructor.
  - constructor; auto.
    constructor. inversion H; subst; clear H.
    destruct t; destruct x; simpl; auto.
Qed.

Lemma commute_AT_gScaleT_inv : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    c <> C0 -> commute_AT a (gScaleT c t) -> commute_AT a t.
Proof. intros n a t c H H0.
  apply commute_AT_gScaleT with (c := (/c)%C) in H0.
  rewrite gScaleT_merge in H0.
  rewrite Cinv_l in H0; auto.
  rewrite gScaleT_1 in H0; auto.
Qed.

Lemma anticommute_AT_gScaleT_inv : forall {n : nat} (a : AType n) (t : TType n) (c : C),
    c <> C0 -> anticommute_AT a (gScaleT c t) -> anticommute_AT a t.
Proof. intros n a t c H H0.
  apply anticommute_AT_gScaleT with (c := (/c)%C) in H0.
  rewrite gScaleT_merge in H0.
  rewrite Cinv_l in H0; auto.
  rewrite gScaleT_1 in H0; auto.
Qed.
  
Lemma commute_AT_in_iff : forall {n : nat} (a : AType n) (t : TType n),
    commute_AT a t <-> (forall (t' : TType n), In t' a -> commute_T t t').
Proof. intros n a t.
  split; intros.
  - inversion H; subst; clear H.
    gen t'.
    induction H1; intros.
    + inversion H0.
    + inversion H0; subst; clear H0; auto.
  - constructor.
    induction a as [ | t'' a'']; constructor.
    + apply H; simpl; auto.
    + apply IHa''.
      intros t' H1.
      specialize (H t').
      assert (In t' (t'' :: a'')); simpl; auto.
Qed.
  
Lemma anticommute_AT_in_iff : forall {n : nat} (a : AType n) (t : TType n),
    anticommute_AT a t <-> (forall (t' : TType n), In t' a -> anticommute_T t t').
Proof. intros n a t.
  split; intros.
  - inversion H; subst; clear H.
    gen t'.
    induction H1; intros.
    + inversion H0.
    + inversion H0; subst; clear H0; auto.
  - constructor.
    induction a as [ | t'' a'']; constructor.
    + apply H; simpl; auto.
    + apply IHa''.
      intros t' H0.
      specialize (H t').
      assert (In t' (t'' :: a'')); simpl; auto.
Qed.

Inductive commute_A {n : nat} (a1 a2 : AType n) : Prop :=
| termwise_commute_A : Forall (commute_AT a2) a1 -> commute_A a1 a2.

Inductive anticommute_A {n : nat} (a1 a2 : AType n) : Prop :=
| termwise_anticommute_A : Forall (anticommute_AT a2) a1 -> anticommute_A a1 a2.

Lemma commute_A_in_iff : forall {n : nat} (a1 a2 : AType n),
    commute_A a1 a2 <->
    (forall (t1 t2 : TType n), In t1 a1 -> In t2 a2 -> commute_T t1 t2).
Proof. intros n a1 a2.
  split; intros.
  - gen t1 t2 a2. induction a1; intros.
    + inversion H0.
    + inversion H; clear H; auto.
      inversion H0; subst; clear H0.
      * inversion H2; subst; clear H2; auto.
        inversion H3; clear H3.
        inversion H; subst; clear H.
        -- inversion H1.
        -- inversion H1; subst; clear H1; auto.
           clear H4.
           induction H2.
           ++ inversion H.
           ++ inversion H; subst; auto.
      * inversion H2; subst; clear H2.
        apply termwise_commute_A in H5.
        apply (IHa1 t1 H t2 a2 H5 H1).
  - constructor.
    gen a2.
    induction a1 as [ | t3 a3]; intros; constructor.
    + rewrite commute_AT_in_iff.
      intros t' H0.
      apply H; simpl; auto.
    + apply IHa3.
      intros t1 t2 H0 H1.
      apply H; simpl; auto.
Qed.
    
Lemma anticommute_A_in_iff : forall {n : nat} (a1 a2 : AType n),
    anticommute_A a1 a2 <->
    (forall (t1 t2 : TType n), In t1 a1 -> In t2 a2 -> anticommute_T t1 t2).
Proof. intros n a1 a2.
  split; intros.
  - gen t1 t2 a2. induction a1; intros.
    + inversion H0.
    + inversion H; clear H; auto.
      inversion H0; subst; clear H0.
      * inversion H2; subst; clear H2; auto.
        inversion H3; clear H3.
        inversion H; subst; clear H.
        -- inversion H1.
        -- inversion H1; subst; clear H1; auto.
           clear H4.
           induction H2.
           ++ inversion H.
           ++ inversion H; subst; auto.
      * inversion H2; subst; clear H2.
        apply termwise_anticommute_A in H5.
        apply (IHa1 t1 H t2 a2 H5 H1).
  - constructor.
    gen a2.
    induction a1 as [ | t3 a3]; intros; constructor.
    + rewrite anticommute_AT_in_iff.
      intros t' H0.
      apply H; simpl; auto.
    + apply IHa3.
      intros t1 t2 H0 H1.
      apply H; simpl; auto.
Qed.

Lemma commute_A_swap : forall {n : nat} (a1 a2 : AType n),
    commute_A a1 a2 -> commute_A a2 a1.
Proof. intros n a1 a2 H.
  rewrite commute_A_in_iff.
  intros t1 t2 H0 H1.
  apply commute_T_swap.
  inversion H; clear H.
  gen t1 t2 a2.
  induction a1; intros.
  - inversion H1.
  - induction H2; intros.
    + inversion H1.
    + inversion H1; subst; clear H1; auto.
      inversion H; clear H.
      clear IHForall. clear H2.
      induction H1.
      * inversion H0.
      * inversion H0; subst; auto.
Qed.

Lemma anticommute_A_swap : forall {n : nat} (a1 a2 : AType n),
    anticommute_A a1 a2 -> anticommute_A a2 a1.
Proof. intros n a1 a2 H.
  rewrite anticommute_A_in_iff.
  intros t1 t2 H0 H1.
  apply anticommute_T_swap.
  inversion H; clear H.
  gen t1 t2 a2.
  induction a1; intros.
  - inversion H1.
  - induction H2; intros.
    + inversion H1.
    + inversion H1; subst; clear H1; auto.
      inversion H; clear H.
      clear IHForall. clear H2.
      induction H1.
      * inversion H0.
      * inversion H0; subst; auto.
Qed.

Lemma commute_T_helper : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    (commute_T t1 t2 -> commute_TType t1 t2).
Proof. intros n t1 t2 H0 H1 H2.
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  inversion H2.
  gen n.
  apply commute_listP_ind'
    with (P := fun (l1 l2 : list Pauli) =>
                forall n : nat,
                  @proper_length_TType n (c1, l1) ->
                  @proper_length_TType n (c2, l2) ->
                  @commute_T n (c1, l1) (c2, l2) -> @commute_TType n (c1, l1) (c2, l2))
         (P0 := fun (l1 l2 : list Pauli) =>
                 forall n : nat,
                   @proper_length_TType n (c1, l1) ->
                   @proper_length_TType n (c2, l2) ->
                   @anticommute_T n (c1, l1) (c2, l2) -> @anticommute_TType n (c1, l1) (c2, l2));
    intros; simpl in *; auto.
  - destruct H0.
    destruct H0 as [H0 | [H0 | H0]];
      unfold cBigMul, zipWith, gMul_Coef, uncurry;
      destruct P1; destruct P2; simpl; try lca; try discriminate.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (commute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@commute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct H13 as [H13 | [H13 | H13]];
      destruct P1; destruct P2; auto; discriminate.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (anticommute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@anticommute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    rewrite <- Copp_mult_distr_r, Copp_mult_distr_l.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct P1; destruct P2; auto; try contradiction; try lca.
  - destruct H0.
    unfold cBigMul, zipWith, gMul_Coef, uncurry;
      destruct P1; destruct P2; simpl; try lca; try contradiction.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (commute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@commute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    rewrite Copp_mult_distr_l.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct P1; destruct P2; auto; try contradiction; try lca.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (anticommute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@anticommute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    rewrite <- Copp_mult_distr_r, ! Copp_mult_distr_l.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct H13 as [H13 | [H13| H13]];
      destruct P1; destruct P2; auto; try discriminate; try lca.
Qed.

Lemma anticommute_T_helper : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    (anticommute_T t1 t2 -> anticommute_TType t1 t2).
Proof. intros n t1 t2 H0 H1 H2.
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  inversion H2.
  gen n.
  apply anticommute_listP_ind'
    with (P := fun (l1 l2 : list Pauli) =>
                forall n : nat,
                  @proper_length_TType n (c1, l1) ->
                  @proper_length_TType n (c2, l2) ->
                  @commute_T n (c1, l1) (c2, l2) -> @commute_TType n (c1, l1) (c2, l2))
         (P0 := fun (l1 l2 : list Pauli) =>
                 forall n : nat,
                   @proper_length_TType n (c1, l1) ->
                   @proper_length_TType n (c2, l2) ->
                   @anticommute_T n (c1, l1) (c2, l2) -> @anticommute_TType n (c1, l1) (c2, l2));
    intros; simpl in *; auto.
  - destruct H0.
    destruct H0 as [H0 | [H0 | H0]];
      unfold cBigMul, zipWith, gMul_Coef, uncurry;
      destruct P1; destruct P2; simpl; try lca; try discriminate.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (commute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@commute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct H13 as [H13 | [H13 | H13]];
      destruct P1; destruct P2; auto; discriminate.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (anticommute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@anticommute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    rewrite <- Copp_mult_distr_r, Copp_mult_distr_l.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct P1; destruct P2; auto; try contradiction; try lca.
  - destruct H0.
    unfold cBigMul, zipWith, gMul_Coef, uncurry;
      destruct P1; destruct P2; simpl; try lca; try contradiction.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (commute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@commute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    rewrite Copp_mult_distr_l.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct P1; destruct P2; auto; try contradiction; try lca.
  - unfold cBigMul, zipWith, uncurry in *; simpl.
    rewrite ! fold_left_Cmult.
    inversion H3; simpl in *.
    destruct n; try contradiction.
    apply Nat.succ_inj in H7.
    inversion H4; simpl in *.
    apply Nat.succ_inj in H9.
    destruct n.
    rewrite length_zero_iff_nil in H7, H9; subst.
    destruct (anticommute_listP_nonempty_equal_len [] [] H1) as [H' [H'' H''']];
      contradiction.
    assert (@proper_length_TType (S n) (c1, l0))
      by (unfold proper_length_TType; auto).
    assert (@proper_length_TType (S n) (c2, l3))
      by (unfold proper_length_TType; auto).
    assert (@anticommute_T (S n) (c1, l0) (c2, l3)) by (constructor; auto).
    specialize (H2 (S n) H10 H11 H12).
    rewrite H2.
    rewrite <- Copp_mult_distr_r, ! Copp_mult_distr_l.
    f_equal.
    inversion H0.
    unfold gMul_Coef;
      destruct H13 as [H13 | [H13 | H13]];
      destruct P1; destruct P2; auto; try discriminate; try lca.
Qed.

Lemma anticommute_commute_TType_no_middle : forall {n : nat} (t1 t2 : TType n),
    ~ anticommute_TType t1 t2 \/ ~ commute_TType t1 t2.
Proof. intros n t1 t2.
  apply Classical_Prop.not_and_or.
  intros [H0 H1].
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  unfold anticommute_TType, commute_TType in *.
  rewrite H1 in H0.
  destruct (cBigMul (zipWith gMul_Coef l2 l1)) eqn:E0.
  inversion H0.
  assert (r=0%R) by lra.
  assert (r0=0%R) by lra.
  subst. clear H0.
  unfold cBigMul, zipWith, uncurry in *; simpl in *.
  gen l2.
  induction l1; intros.
  - rewrite ! combine_nil in *; simpl in *.
    inversion E0.
    lra.
  -  destruct l2.
     + simpl in *.
       inversion E0.
       lra.
     + simpl in *.
       rewrite fold_left_Cmult in E0, H1.
       destruct (gMul_Coef_comm_anticomm p a).
       * pose (gMul_Coef_comm_1 p a H) as e.
         rewrite e in E0.
         rewrite <- H, e in H1.
         rewrite Cmult_1_l in E0, H1.
         apply (IHl1 l2); auto.
       * pose (gMul_Coef_anticomm_plus_minus_i p a H) as o.
         destruct o.
         -- rewrite H0 in H.
            rewrite <- Copp_opp in H.
            rewrite H0 in E0.
            rewrite <- H in H1.
            replace (0%R, 0%R) with (Ci * C0)%C in E0 by lca.
            apply Cmult_cancel_l in E0; try nonzero.
            replace (0%R, 0%R) with (- Ci * C0)%C in H1 by lca.
            apply Cmult_cancel_l in H1; try nonzero.
            apply (IHl1 l2); auto.
         -- rewrite H0 in H.
            rewrite <- Copp_opp, Copp_involutive in H.
            rewrite H0 in E0.
            rewrite <- H in H1.
            replace (0%R, 0%R) with (- Ci * C0)%C in E0 by lca.
            apply Cmult_cancel_l in E0; try nonzero.
            replace (0%R, 0%R) with (Ci * C0)%C in H1 by lca.
            apply Cmult_cancel_l in H1; try nonzero.
            apply (IHl1 l2); auto.
Qed.

Lemma logical_helper : forall (P1 P2 A A' B B' : Prop),
    (P1 -> P2 -> A -> A')  ->  (P1 -> P2 -> B -> B') ->
      (P1 -> P2 -> A \/ B) -> (~ A \/ ~ B) -> (~ A' \/ ~ B') ->
      (P1 -> P2 -> ((A <-> A') /\ (B <-> B') /\ (~ A <-> B) /\ (~ A' <-> B'))).
Proof. intros P1 P2 A A' B B' H0 H1 H2 H3 H4 H5 H6.
  repeat split; intros; auto.
  - destruct (H2 H5 H6); auto.
    pose (H1 H5 H6 H7); try contradiction.
    destruct H4; try contradiction.
  - destruct (H2 H5 H6); auto.
    pose (H0 H5 H6 H7); try contradiction.
    destruct H4; try contradiction.
  - destruct (H2 H5 H6); try contradiction; auto.
  - destruct H3; auto.
  - destruct (H2 H5 H6); auto.
    pose (H0 H5 H6 H7); try contradiction.
  - destruct H4; auto; try contradiction.
Qed.

Lemma anticommute_commute_T_TType_iff : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    ((anticommute_T t1 t2 <-> anticommute_TType t1 t2) /\
       (commute_T t1 t2 <-> commute_TType t1 t2) /\
       (~ anticommute_T t1 t2 <-> commute_T t1 t2) /\
       (~ anticommute_TType t1 t2 <-> commute_TType t1 t2)).
Proof. intros n t1 t2. 
  apply (logical_helper (proper_length_TType t1) (proper_length_TType t2)
           (anticommute_T t1 t2) (anticommute_TType t1 t2)
           (commute_T t1 t2) (commute_TType t1 t2)
           (anticommute_T_helper t1 t2) (commute_T_helper t1 t2)
           (anticommute_or_commute_T t1 t2)
           (anticommute_commute_T_no_middle t1 t2)
           (anticommute_commute_TType_no_middle t1 t2)).
Qed.

Lemma anticommute_AT_TType_AType_iff : forall {n : nat} (t : TType n) (a : AType n),
    proper_length_TType t -> proper_length_AType_nil a ->
    anticommute_AT a t <-> anticommute_TType_AType t a.
Proof. intros n t a H H0. 
  split; intros.
  - inversion H1. clear H1.
    induction H2; simpl; auto.
    inversion H0; subst; auto.
    split; auto.
    destruct (anticommute_commute_T_TType_iff t x H H5)
      as [H' [H'' [H''' H'''']]].
    rewrite <- H'; auto.
  - constructor.
    induction a.
    + constructor.
    + constructor.
      * simpl in *.
        destruct H1.
        inversion H0; subst; auto.
        destruct (anticommute_commute_T_TType_iff t a H H5)
          as [H' [H'' [H''' H'''']]].
        rewrite H'; auto.
      * apply IHa.
        -- inversion H0; subst; auto.
        -- destruct H1; auto.
Qed.

Lemma anticommute_A_AType_iff : forall {n : nat} (a1 a2 : AType n),
    proper_length_AType_nil a1 -> proper_length_AType_nil a2 ->
    anticommute_A a1 a2 <-> anticommute_AType_syntactic a1 a2.
Proof. intros n a1 a2 H H0.
  split; intros.
  - inversion H1. clear H1.
    induction H2; simpl; auto.
    + split.
      * inversion H; subst; auto.
        rewrite <- (anticommute_AT_TType_AType_iff x a2 H5 H0); auto.
      * apply IHForall.
        inversion H; subst; auto.
  - constructor.
    induction a1.
    + constructor.
    + constructor.
      * simpl in *.
        destruct H1.
        inversion H; subst; auto.
        rewrite (anticommute_AT_TType_AType_iff a a2 H5 H0); auto.
      * apply IHa1.
        -- inversion H; subst; auto.
        -- simpl in *.
           destruct H1; auto.
Qed.

Lemma anticommute_A_scale_l : forall {n : nat} (a1 a2 : AType n) (c : C),
    proper_length_AType_nil a1 -> proper_length_AType_nil a2 ->
    anticommute_A a1 a2 -> anticommute_A (gScaleA c a1) a2.
Proof. intros n a1 a2 c H0 H1 H2.
  remember H0 as H0'. clear HeqH0'.
  rewrite anticommute_A_AType_iff in H2; auto.
  apply (proper_length_AType_nil_gScaleA c a1) in H0.
  apply anticommute_A_swap.
  rewrite anticommute_A_AType_iff; auto.
  rewrite anticommute_AType_syntactic_gScaleA.
  rewrite <- anticommute_A_AType_iff; auto.
  apply anticommute_A_swap.
  rewrite anticommute_A_AType_iff; auto.
Qed.

Lemma anticommute_A_scale_r : forall {n : nat} (a1 a2 : AType n) (c : C),
    proper_length_AType_nil a1 -> proper_length_AType_nil a2 ->
    anticommute_A a1 a2 -> anticommute_A a1 (gScaleA c a2).
Proof. intros n a1 a2 c H0 H1 H2.
  apply anticommute_A_swap.
  apply anticommute_A_scale_l; auto.
  apply anticommute_A_swap; auto.
Qed.

Lemma anticommute_A_scale_inv_l : forall {n : nat} (a1 a2 : AType n) (c : C),
    c <> C0 -> proper_length_AType_nil a1 -> proper_length_AType_nil a2 ->
    anticommute_A (gScaleA c a1) a2 -> anticommute_A a1 a2.
Proof. intros n a1 a2 c H0 H1 H2 H3.
  apply anticommute_A_scale_l with (c := (/c)%C) in H3; auto.
  - rewrite gScaleA_merge in H3.
    rewrite Cinv_l in H3; auto.
    rewrite gScaleA_1 in H3; auto.
  - apply proper_length_AType_nil_gScaleA; auto.
Qed.

Lemma anticommute_A_scale_inv_r : forall {n : nat} (a1 a2 : AType n) (c : C),
    c <> C0 -> proper_length_AType_nil a1 -> proper_length_AType_nil a2 ->
    anticommute_A a1 (gScaleA c a2) -> anticommute_A a1 a2.
Proof. intros n a1 a2 c H0 H1 H2 H3.
  apply anticommute_A_scale_r with (c := (/c)%C) in H3; auto.
  - rewrite gScaleA_merge in H3.
    rewrite Cinv_l in H3; auto.
    rewrite gScaleA_1 in H3; auto.
  - apply proper_length_AType_nil_gScaleA; auto.
Qed.


Lemma WF_AType_anticommute : forall {n : nat} (a : AType n) (t1 t2 : TType n),
    WF_AType a -> In t1  a -> In t2  a -> t1 <> t2 -> anticommute_T t1 t2.
Proof. intros n a t1 t2 H H0 H1 H2.
  inversion H; subst; clear H.
  gen t1 t2.
  induction H3; intros.
  - inversion H0; subst; clear H0;
      inversion H1; subst; clear H1;
      contradiction.
  - rewrite gScaleA_dist_app in H0, H1.
    rewrite in_app_iff in H0, H1.
    destruct H0; destruct H1.
    + assert (C1 / √ 2 * (C1 * √ 2) = C1)%C by (field_simplify_eq; auto; nonzero).
      assert (t1 = gScaleT (C1 / √2)%C (gScaleT (C1 * √2)%C t1)).
      { rewrite gScaleT_merge.
        rewrite H3.
        rewrite gScaleT_1; auto. }
      rewrite H4 in H0.
      apply in_gScaleTA_mult_inv in H0.
      2:{ intro. apply Cmult_r with (c := (C1 * √2)%C) in H5.
          rewrite H3 in H5.
          rewrite Cmult_0_l in H5.
          inversion H5.
          lra. }
      assert (t2 = gScaleT (C1 / √2)%C (gScaleT (C1 * √2)%C t2)).
      { rewrite gScaleT_merge.
        rewrite H3.
        rewrite gScaleT_1; auto. }
      rewrite H5 in H1.
      apply in_gScaleTA_mult_inv in H1.
      2:{ intro. apply Cmult_r with (c := (C1 * √2)%C) in H6.
          rewrite H3 in H6.
          rewrite Cmult_0_l in H6.
          inversion H6.
          lra. }
      assert ((gScaleT (C1 * √ 2)%C t1) <> (gScaleT (C1 * √ 2)%C t2)).
      { intro. contradict H2.
        assert (forall {n : nat} (t1 t2 : TType n),
                   t1 = t2 -> gScaleT (C1 / √ 2)%C t1 = gScaleT (C1 / √ 2)%C t2)
          by (intros n' t' t'' H'; rewrite H'; auto).
        apply H2 in H6.
        rewrite ! gScaleT_merge in H6.
        rewrite ! H3 in H6.
        rewrite ! gScaleT_1 in H6.
        assumption. }
      pose (IHrestricted_addition_syntactic1 (gScaleT (C1 * √ 2)%C t1) H0
              (gScaleT (C1 * √ 2)%C t2) H1 H6) as H7.
      apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
      remember H3_ as H3_'. clear HeqH3_'.
      apply proper_length_AType_implies_proper_length_TType
        with (t := (gScaleT (C1 * √ 2)%C t1)) in H3_; auto.
      apply proper_length_AType_implies_proper_length_TType
        with (t := (gScaleT (C1 * √ 2)%C t2)) in H3_'; auto.
      destruct @anticommute_commute_T_TType_iff
        with (n := n) 
             (t1 := (gScaleT (C1 * √ 2)%C t1)) (t2 := (gScaleT (C1 * √ 2)%C t2))
        as [H' [H'' [H''' H'''']]]; auto.
      remember H7 as H7'. clear HeqH7'. clear H7.
      specialize (IHrestricted_addition_syntactic1
                    (gScaleT (C1 * √ 2)%C t1) H0
                    (gScaleT (C1 * √ 2)%C t2) H1
                    H6).
      rewrite H' in IHrestricted_addition_syntactic1.
      rewrite anticommute_TType_gScaleT in IHrestricted_addition_syntactic1.
      apply anticommute_TType_comm in IHrestricted_addition_syntactic1.
      rewrite anticommute_TType_gScaleT in IHrestricted_addition_syntactic1.
      apply anticommute_TType_comm in IHrestricted_addition_syntactic1.
      apply proper_length_TType_gScaleT
        with (t := (gScaleT (C1 * √ 2)%C t1)) (c := (C1 / √ 2)%C) in H3_.
      rewrite gScaleT_merge in H3_.
      rewrite H3 in H3_.
      rewrite gScaleT_1 in H3_.
      apply proper_length_TType_gScaleT
        with (t := (gScaleT (C1 * √ 2)%C t2)) (c := (C1 / √ 2)%C) in H3_'.
      rewrite gScaleT_merge in H3_'.
      rewrite H3 in H3_'.
      rewrite gScaleT_1 in H3_'.
      destruct @anticommute_commute_T_TType_iff
        with (n := n) 
             (t1 := t1) (t2 := t2)
        as [H0' [H0'' [H0''' H0'''']]]; auto.
      rewrite H0'; auto.
    + apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
      apply proper_length_AType_implies_proper_length_AType_nil in H3_, H3_0.
      rewrite <- anticommute_A_AType_iff in H; auto.
      apply anticommute_A_scale_l with (c := (C1 / √ 2)%C) in H; auto.
      apply anticommute_A_scale_r with (c := (C1 / √ 2)%C) in H; auto.
      2 : apply proper_length_AType_nil_gScaleA; auto.
      rewrite anticommute_A_in_iff in H.
      apply H; auto.
    + apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
      apply proper_length_AType_implies_proper_length_AType_nil in H3_, H3_0.
      rewrite <- anticommute_A_AType_iff in H; auto.
      apply anticommute_A_scale_l with (c := (C1 / √ 2)%C) in H; auto.
      apply anticommute_A_scale_r with (c := (C1 / √ 2)%C) in H; auto.
      2 : apply proper_length_AType_nil_gScaleA; auto.
      apply anticommute_A_swap in H.
      rewrite anticommute_A_in_iff in H.
      apply H; auto.
    + assert (C1 / √ 2 * (C1 * √ 2) = C1)%C by (field_simplify_eq; auto; nonzero).
      assert (t1 = gScaleT (C1 / √2)%C (gScaleT (C1 * √2)%C t1)).
      { rewrite gScaleT_merge.
        rewrite H3.
        rewrite gScaleT_1; auto. }
      rewrite H4 in H0.
      apply in_gScaleTA_mult_inv in H0.
      2:{ intro. apply Cmult_r with (c := (C1 * √2)%C) in H5.
          rewrite H3 in H5.
          rewrite Cmult_0_l in H5.
          inversion H5.
          lra. }
      assert (t2 = gScaleT (C1 / √2)%C (gScaleT (C1 * √2)%C t2)).
      { rewrite gScaleT_merge.
        rewrite H3.
        rewrite gScaleT_1; auto. }
      rewrite H5 in H1.
      apply in_gScaleTA_mult_inv in H1.
      2:{ intro. apply Cmult_r with (c := (C1 * √2)%C) in H6.
          rewrite H3 in H6.
          rewrite Cmult_0_l in H6.
          inversion H6.
          lra. }
      assert ((gScaleT (C1 * √ 2)%C t1) <> (gScaleT (C1 * √ 2)%C t2)).
      { intro. contradict H2.
        assert (forall {n : nat} (t1 t2 : TType n),
                   t1 = t2 -> gScaleT (C1 / √ 2)%C t1 = gScaleT (C1 / √ 2)%C t2)
          by (intros n' t' t'' H'; rewrite H'; auto).
        apply H2 in H6.
        rewrite ! gScaleT_merge in H6.
        rewrite ! H3 in H6.
        rewrite ! gScaleT_1 in H6.
        assumption. }
      pose (IHrestricted_addition_syntactic2 (gScaleT (C1 * √ 2)%C t1) H0
              (gScaleT (C1 * √ 2)%C t2) H1 H6) as H7.
      apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
      remember H3_0 as H3_0'. clear HeqH3_0'.
      apply proper_length_AType_implies_proper_length_TType
        with (t := (gScaleT (C1 * √ 2)%C t1)) in H3_0; auto.
      apply proper_length_AType_implies_proper_length_TType
        with (t := (gScaleT (C1 * √ 2)%C t2)) in H3_0'; auto.
      destruct @anticommute_commute_T_TType_iff
        with (n := n) 
             (t1 := (gScaleT (C1 * √ 2)%C t1)) (t2 := (gScaleT (C1 * √ 2)%C t2))
        as [H' [H'' [H''' H'''']]]; auto.
      remember H7 as H7'. clear HeqH7'. clear H7.
      specialize (IHrestricted_addition_syntactic2
                    (gScaleT (C1 * √ 2)%C t1) H0
                    (gScaleT (C1 * √ 2)%C t2) H1
                    H6).
      rewrite H' in IHrestricted_addition_syntactic2.
      rewrite anticommute_TType_gScaleT in IHrestricted_addition_syntactic2.
      apply anticommute_TType_comm in IHrestricted_addition_syntactic2.
      rewrite anticommute_TType_gScaleT in IHrestricted_addition_syntactic2.
      apply anticommute_TType_comm in IHrestricted_addition_syntactic2.
      apply proper_length_TType_gScaleT
        with (t := (gScaleT (C1 * √ 2)%C t1)) (c := (C1 / √ 2)%C) in H3_0.
      rewrite gScaleT_merge in H3_0.
      rewrite H3 in H3_0.
      rewrite gScaleT_1 in H3_0.
      apply proper_length_TType_gScaleT
        with (t := (gScaleT (C1 * √ 2)%C t2)) (c := (C1 / √ 2)%C) in H3_0'.
      rewrite gScaleT_merge in H3_0'.
      rewrite H3 in H3_0'.
      rewrite gScaleT_1 in H3_0'.
      destruct @anticommute_commute_T_TType_iff
        with (n := n) 
             (t1 := t1) (t2 := t2)
        as [H0' [H0'' [H0''' H0'''']]]; auto.
      rewrite H0'; auto.
Qed.

Lemma self_commute_P : forall (P : Pauli), commute_P P P.
Proof. intros P. constructor. do 2 right; auto. Qed.

Lemma self_commute_listP : forall (l : list Pauli), l <> [] -> commute_listP l l.
Proof. intros l. induction l; intros; try contradiction.
  destruct (list_eq_dec eqdec_Pauli l []).
  - subst. constructor. apply self_commute_P.
  - apply IHl in n.
    apply (commuting_listP_commP_commL a a l l (self_commute_P a) n).
Qed.

Lemma self_commute_T : forall {n : nat} (t : TType n),
    proper_length_TType t -> commute_T t t.
Proof. intros n t H0.
  constructor.
  destruct t as [c l].
  inversion H0.
  simpl in *.
  destruct (list_eq_dec eqdec_Pauli l []) as [H3 | H3].
  - rewrite <- length_zero_iff_nil in H3. lia.
  - apply self_commute_listP; auto.
Qed.

Lemma WF_MulTA_helper : forall {n : nat} (t : TType n) (a : AType n),
    WF_TType t -> WF_AType a -> commute_AT a t -> (forall c : C, a <> [(c, snd t)]) -> 
    Forall (fun t' => snd t' <> snd t) a.
Proof. intros n t a H H0 H1 H2.
  inversion H0; subst; clear H0.
  rewrite Forall_Exists_neg.
  intro.
  gen t.
  induction H3; intros.
  - destruct t as [c l].
    destruct t0 as [c0 l0]. 
    simpl in *.
    specialize (H2 c).
    assert (l <> l0) by (intro; subst; contradiction).
    inversion H3; subst; clear H3; auto.
    inversion H6.
  - clear H2.
    rewrite gScaleA_dist_app in H3.
    rewrite Exists_app in H3.
    destruct H3.
    + rewrite gScaleA_dist_app in H1.
      rewrite commute_AT_app in H1.
      destruct H1.
      rewrite Exists_exists in H2.
      destruct H2 as [t0 [t0_in equal_pauli]].
      destruct t as [c l].
      destruct t0 as [c0 l0].
      simpl in *.
      subst.
      remember H3_0 as H3_0'. clear HeqH3_0'.
      apply restricted_addition_syntactic_implies_proper_length_AType in H3_0'.
      destruct H3_0'.
      * apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
        remember H3_ as H3_'. clear HeqH3_'.
        remember H3_0 as H3_0'. clear HeqH3_0'.
        apply proper_length_AType_implies_proper_length_AType_nil in H3_', H3_0'.
        rewrite <- anticommute_A_AType_iff in H; auto.
        rewrite anticommute_A_in_iff in H.
        apply @in_gScaleTA_mult with (n := n) (c := (C1 * √2)%C) in t0_in; auto.
        rewrite gScaleA_merge in t0_in.
        assert ((C1 * √ 2 * (C1 / √ 2))%C = C1).
        { field_simplify_eq; auto; nonzero. }
        rewrite H4 in t0_in.
        rewrite gScaleA_1 in t0_in.
        assert (In t [t]) by (simpl;auto).
        specialize (H (gScaleT (C1 * √ 2)%C (c0, l)) t t0_in H5).
        assert (anticommute_T (c0,l) t).
        { constructor. inversion H; subst; clear H. destruct t. simpl in *. auto. }
        inversion H3; subst; clear H3.
        inversion H7; subst; clear H7.
        destruct t as [c' l'].
        assert (anticommute_listP l l').
        { inversion H6; subst; clear H6; simpl; auto. }
        assert (commute_listP l l').
        { inversion H9; subst; clear H9; simpl; auto. }
        destruct (anticommute_commute_listP_no_middle l l'); contradiction.
      * apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
        remember H3_ as H3_'. clear HeqH3_'.
        remember H3_0 as H3_00'. clear HeqH3_00'.
        apply proper_length_AType_implies_proper_length_AType_nil in H3_', H3_00'.
        rewrite <- anticommute_A_AType_iff in H; auto.
        rewrite anticommute_A_in_iff in H.
        apply @in_gScaleTA_mult with (n := n) (c := (C1 * √2)%C) in t0_in; auto.
        rewrite gScaleA_merge in t0_in.
        assert ((C1 * √ 2 * (C1 / √ 2))%C = C1).
        { field_simplify_eq; auto; nonzero. }
        rewrite H4 in t0_in.
        rewrite gScaleA_1 in t0_in.
        assert (In t (t :: a)) by (simpl;auto).
        specialize (H (gScaleT (C1 * √ 2)%C (c0, l)) t t0_in H5).
        assert (anticommute_T (c0,l) t).
        { constructor. inversion H; subst; clear H. destruct t. simpl in *. auto. }
        inversion H3; subst; clear H3.
        inversion H7; subst; clear H7.
        destruct t as [c' l'].
        assert (anticommute_listP l l').
        { inversion H6; subst; clear H6; simpl; auto. }
        assert (commute_listP l l').
        { inversion H9; subst; clear H9; simpl; auto. }
        destruct (anticommute_commute_listP_no_middle l l'); contradiction.
    + rewrite gScaleA_dist_app in H1.
      rewrite commute_AT_app in H1.
      destruct H1.
      rewrite Exists_exists in H2.
      destruct H2 as [t0 [t0_in equal_pauli]].
      destruct t as [c l].
      destruct t0 as [c0 l0].
      simpl in *.
      subst.
      remember H3_ as H3_'. clear HeqH3_'.
      apply restricted_addition_syntactic_implies_proper_length_AType in H3_'.
      destruct H3_'.
      * apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
        remember H3_ as H3__'. clear HeqH3__'.
        remember H3_0 as H3_0'. clear HeqH3_0'.
        apply proper_length_AType_implies_proper_length_AType_nil in H3__', H3_0'.
        rewrite <- anticommute_A_AType_iff in H; auto.
        rewrite anticommute_A_in_iff in H.
        apply @in_gScaleTA_mult with (n := n) (c := (C1 * √2)%C) in t0_in; auto.
        rewrite gScaleA_merge in t0_in.
        assert ((C1 * √ 2 * (C1 / √ 2))%C = C1).
        { field_simplify_eq; auto; nonzero. }
        rewrite H4 in t0_in.
        rewrite gScaleA_1 in t0_in.
        assert (In t [t]) by (simpl;auto).
        specialize (H t (gScaleT (C1 * √ 2)%C (c0, l)) H5 t0_in).
        assert (anticommute_T t (c0,l)).
        { constructor. inversion H; subst; clear H. destruct t. simpl in *. auto. }
        inversion H1; subst; clear H1.
        inversion H7; subst; clear H7.
        destruct t as [c' l'].
        assert (anticommute_listP l' l).
        { inversion H6; subst; clear H6; simpl; auto. }
        assert (commute_listP l l').
        { inversion H9; subst; clear H9; simpl; auto. }
        apply commute_listP_swap in H7.
        destruct (anticommute_commute_listP_no_middle l' l); contradiction.
      * apply restricted_addition_syntactic_implies_proper_length_AType in H3_, H3_0.
        remember H3_ as H3__'. clear HeqH3__'.
        remember H3_0 as H3_0'. clear HeqH3_0'.
        apply proper_length_AType_implies_proper_length_AType_nil in H3__', H3_0'.
        rewrite <- anticommute_A_AType_iff in H; auto.
        rewrite anticommute_A_in_iff in H.
        apply @in_gScaleTA_mult with (n := n) (c := (C1 * √2)%C) in t0_in; auto.
        rewrite gScaleA_merge in t0_in.
        assert ((C1 * √ 2 * (C1 / √ 2))%C = C1).
        { field_simplify_eq; auto; nonzero. }
        rewrite H4 in t0_in.
        rewrite gScaleA_1 in t0_in.
        assert (In t (t :: a)) by (simpl;auto).
        specialize (H t (gScaleT (C1 * √ 2)%C (c0, l)) H5 t0_in).
        assert (anticommute_T t (c0,l)).
        { constructor. inversion H; subst; clear H. destruct t. simpl in *. auto. }
        inversion H1; subst; clear H1.
        inversion H7; subst; clear H7.
        destruct t as [c' l'].
        assert (anticommute_listP l' l).
        { inversion H6; subst; clear H6; simpl; auto. }
        assert (commute_listP l l').
        { inversion H9; subst; clear H9; simpl; auto. }
        apply commute_listP_swap in H7.
        destruct (anticommute_commute_listP_no_middle l' l); contradiction.
Qed.

Lemma WF_AType_in_nonzero : forall {n : nat} (a : AType n) (t : TType n),
    WF_AType a -> In t a ->  fst t <> C0.
Proof. intros n a t H H0 H1.
  gen t.
  inversion H; subst; clear H.
  induction H0; intros.
  - inversion H0; subst; clear H0.
    + inversion H; subst; clear H.
      unfold coef_plus_minus_1 in H2.
      rewrite H1 in H2.
      destruct H2 as [H' | H']; inversion H'; lra.
    + inversion H2.
  - apply in_gScaleTA_mult with (c := (C1 * √ 2)%C) in H0.
    rewrite gScaleA_merge in H0.
    assert ((C1 * √ 2 * (C1 / √ 2))%C = C1) by (field_simplify_eq; auto; nonzero).
    rewrite H2 in H0.
    rewrite gScaleA_1 in H0.
    rewrite in_app_iff in H0.
    assert (fst (gScaleT (C1 * √ 2)%C t) = C0).
    { destruct t; simpl in *. rewrite H1. lca. }
    destruct H0.
    + apply (IHrestricted_addition_syntactic1 (gScaleT (C1 * √ 2)%C t)); auto.
    + apply (IHrestricted_addition_syntactic2 (gScaleT (C1 * √ 2)%C t)); auto.
Qed.


(* Just add { Y } T { (Y - X)/√2 } to the core rules instead of proving this.

(*** Admitted. ***)
(** Use the following lemma,
WF_TType_mul_commute':
  forall {n : nat} (a b : TType n), commute_TType a b -> snd a <> snd b ->
  WF_TType n a -> WF_TType n b -> WF_TType n (gMulT a b)

Lemma WF_MulTA_helper : forall {n : nat} (t : TType n) (a : AType n),
    WF_TType n t -> WF_AType n a -> commute_AT a t -> (forall c : C, a <> [(c, snd t)]) -> 
    Forall (fun t' => snd t' <> snd t) a.
 **)
Lemma WF_MulTA_l : forall {n : nat} (t : TType n) (a : AType n),
    WF_TType n t -> WF_AType n a -> commute_AT a t -> (forall c : C, a <> [(c, snd t)]) -> 
    WF_AType n (gMulA [t] a).
Proof. intros n t a H0 H1 H2 H3.
  inversion H1; subst; clear H1.
  gen t.
  induction H4; intros.
  - unfold gMulA; simpl.
    do 2 constructor.
    assert (WF_AType n [t]) by (do 2 constructor; auto).
    pose (WF_MulTA_helper t0 [t] H1 H4 H2 H3) as H'.
    remember H' as H5. clear HeqH5. clear H'.
    inversion H2; subst; clear H2.
    inversion H5; subst; clear H5.
    inversion H6; subst; clear H6.
    apply WF_TType_mul_commute'; auto.
    destruct H0. destruct H1.
    destruct (anticommute_commute_T_TType_iff t0 t H1 H0) as [H' [H'' [H''' H'''']]].
    rewrite <- H''; auto.
  - unfold gMulA. rewrite app_nil_r.
    rewrite gScaleA_dist_app, map_app.
    unfold gScaleA. rewrite ! map_map.
    assert ((fun x : TType n => gMulT t (gScaleT (C1 / √ 2)%C x))
            = (fun x : TType n => gScaleT (C1 / √ 2)%C (gMulT t x))).
    { apply functional_extensionality; intros.
      rewrite <- gMulT_gScaleT_r; auto. }
    rewrite H4, <- ! map_app.
    rewrite <- map_map
      with (g := (fun x : TType n => gScaleT (C1 / √ 2)%C x))
           (f := (fun x : TType n => gMulT t x)).
    replace (map (fun x : TType n => gScaleT (C1 / √ 2)%C x)
               (map (fun x : TType n => gMulT t x) (a1 ++ a2)))
      with (gScaleA (C1 / √ 2)%C (map (fun x : TType n => gMulT t x) (a1 ++ a2)))
      by (unfold gScaleA; auto).
    rewrite map_app.
    apply WF_AType_app.
    




    

    rewrite <- anticommute_A_AType_iff.
    rewrite anticommute_A_in_iff.
    intros. simpl.



    

    assert (proper_length_TType n t1) by admit.
    assert (proper_length_TType n t2) by admit.

    assert (commute_T t t1) by admit.
    assert (commute_T t t2) by admit.
             
    
    apply In_nth with (d := defaultT n) in H5, H6.
    destruct H5 as [n0 [n0_len n0_map]].
    destruct H6 as [n00 [n00_len n00_map]].
    rewrite nth_indep with (d' := (fun x : TType n => gMulT t x) (defaultT n)) in n0_map; auto.
    rewrite nth_indep with (d' := (fun x : TType n => gMulT t x) (defaultT n)) in n00_map; auto.
    rewrite map_nth in n0_map, n00_map.
    
    destruct (anticommute_commute_T_TType_iff t1 t2 H7 H8) as [H' [H'' [H''' H'''']]].
    rewrite H'.

    rewrite anticommute_TType_gMulT_antiswap.

    

    assert (proper_length_TType n t) by admit.

    destruct (anticommute_commute_T_TType_iff t t1 H5 H7) as [H0' [H0'' [H0''' H0'''']]].
    destruct (anticommute_commute_T_TType_iff t t2 H5 H8) as [H1' [H1'' [H1''' H1'''']]].
    
    rewrite H0'' in H9. rewrite H1'' in H10.
    rewrite commute_TType_gMulT_swap in H9.
    rewrite commute_TType_gMulT_swap in H10.


    
    rewrite <- n0_map, <- n00_map.

    
    
    rewrite <- ! gMulT_assoc.

    assert (commute_AT a1 t /\ commute_AT a2 t).
    { admit. (* Use "commute_AT (gScaleA (C1 / √ 2)%C (a1 ++ a2)) t" *) }
    destruct H6.

    assert (In (nth n0 a1 (defaultT n)) a1) by admit.
    assert (In (nth n00 a2 (defaultT n)) a2) by admit.
    
    assert (commute_T t (nth n0 a1 (defaultT n))) by admit. (* Use commute_AT_in_iff *)
    assert (commute_T t (nth n00 a2 (defaultT n))) by admit. (* Use commute_AT_in_iff *)

    assert (gScaleT (- C1)%C (gMulT (nth n00 a2 (defaultT n)) (nth n0 a1 (defaultT n)))
            = (gMulT (nth n0 a1 (defaultT n)) (nth n00 a2 (defaultT n))))
      by admit.

    assert ((gMulT t (nth n0 a1 (defaultT n))) = (gMulT (nth n0 a1 (defaultT n)) t))
      by admit.
    assert ((gMulT t (nth n00 a2 (defaultT n))) = (gMulT (nth n00 a2 (defaultT n)) t))
      by admit.

    setoid_rewrite H17 at 1.
    setoid_rewrite gMulT_assoc at 2.

    rewrite gMulT_inv.
    (*** rewrite gMulT_1_l. ***)
    
Admitted.

  
(*** Admitted. ***)
(** 
WFA A & WFT T
& A T termwise_anticommute
->
WFA (i A*T) (∵ WF_TType_mul_anticommute)

&& 

A T termwise_anticommute
A*T = - T*A



Use the following,
WF_TType_mul_anticommute:
  forall {n : nat} (a b : TType n),
  anticommute_TType a b ->
  WF_TType n a -> WF_TType n b -> WF_TType n (gScaleT Ci (gMulT a b))
**)
*)











Open Scope F2_scope.

(** *** Check Matrix *** **)
Definition toCheckMatrixF2ElementLeftX (a : Pauli) : F2 :=
  match a with
  | gI => zero
  | gX => one
  | gY => one
  | gZ => zero
  end.

Definition toCheckMatrixF2ElementRightZ (a : Pauli) : F2 :=
  match a with
  | gI => zero
  | gX => zero
  | gY => one
  | gZ => one
  end.

Definition toCheckMatrixF2Left (row col : nat) (LLp : list (list Pauli)) : MatrixF2 row col := 
  (fun r c : nat => toCheckMatrixF2ElementLeftX (nth c (nth r LLp (repeat gI col)) gI)).
Definition toCheckMatrixF2Right (row col : nat) (LLp : list (list Pauli)) : MatrixF2 row col := 
  (fun r c : nat => toCheckMatrixF2ElementRightZ (nth c (nth r LLp (repeat gI col)) gI)).

Lemma WF_toCheckMatrixF2Left : forall (row col : nat) (LLp : list (list Pauli)),
    (length LLp <= row)%nat -> Forall (fun Lp : list Pauli => (length Lp <= col)%nat) LLp -> 
    WF_MatrixF2 (toCheckMatrixF2Left row col LLp).
Proof. intros row col LLp H H0. 
  unfold WF_MatrixF2, toCheckMatrixF2Left, toCheckMatrixF2ElementLeftX. 
  intros x y H1.
  destruct H1.
  - rewrite nth_overflow with (d := (repeat gI col)); try lia.
    rewrite nth_repeat. auto.
  - bdestruct (x <? length LLp)%nat.
    + rewrite nth_overflow with (d := gI); auto.
      rewrite Forall_nth in H0.
      specialize (H0 x (repeat gI col) H2). lia.
    + rewrite nth_overflow with (d := (repeat gI col)); try lia.
      rewrite nth_repeat. auto.
Qed.

Lemma toCheckMatrixF2Left_nil : forall (r c : nat), 
    toCheckMatrixF2Left r c [] = ZeroF2.
Proof. intros r c.
  unfold toCheckMatrixF2Left, ZeroF2.
  prep_matrix_equality.
  unfold toCheckMatrixF2ElementLeftX.
  simpl; destruct x; rewrite nth_repeat; auto.
Qed.

Lemma WF_toCheckMatrixF2Right : forall (row col : nat) (LLp : list (list Pauli)),
    (length LLp <= row)%nat -> Forall (fun Lp : list Pauli => (length Lp <= col)%nat) LLp -> 
    WF_MatrixF2 (toCheckMatrixF2Right row col LLp).
Proof. intros row col LLp H H0. 
  unfold WF_MatrixF2, toCheckMatrixF2Right, toCheckMatrixF2ElementRightZ. 
  intros x y H1.
  destruct H1.
  - rewrite nth_overflow with (d := (repeat gI col)); try lia.
    rewrite nth_repeat. auto.
  - bdestruct (x <? length LLp)%nat.
    + rewrite nth_overflow with (d := gI); auto.
      rewrite Forall_nth in H0.
      specialize (H0 x (repeat gI col) H2). lia.
    + rewrite nth_overflow with (d := (repeat gI col)); try lia.
      rewrite nth_repeat. auto.
Qed.

Lemma toCheckMatrixF2Right_nil : forall (r c : nat), 
    toCheckMatrixF2Right r c [] = ZeroF2.
Proof. intros r c.
  unfold toCheckMatrixF2Right, ZeroF2.
  prep_matrix_equality.
  unfold toCheckMatrixF2ElementRightZ.
  simpl; destruct x; rewrite nth_repeat; auto.
Qed.

Definition fromLLpToCheckMatrixF2 (row col : nat) (LLp : list (list Pauli)) : MatrixF2 row (col + col)%nat := 
  F2Module.smash (toCheckMatrixF2Left row col LLp) (toCheckMatrixF2Right row col LLp).

Lemma WF_fromLLpToCheckMatrixF2 : forall (row col : nat) (LLp : list (list Pauli)),
    (length LLp <= row)%nat -> Forall (fun Lp : list Pauli => (length Lp <= col)%nat) LLp -> 
    WF_MatrixF2 (fromLLpToCheckMatrixF2 row col LLp).
Proof. intros row col LLp H H0.
  apply F2Module.WF_smash.
  apply WF_toCheckMatrixF2Left; auto.
  apply WF_toCheckMatrixF2Right; auto.
Qed.

Lemma fromLLpToCheckMatrixF2_nil : forall (r c : nat), 
    fromLLpToCheckMatrixF2 r c [] = ZeroF2.
Proof. intros r c.
  unfold fromLLpToCheckMatrixF2.
  rewrite toCheckMatrixF2Left_nil, toCheckMatrixF2Right_nil.
  unfold F2Module.smash, ZeroF2.
  prep_matrix_equality.
  bdestruct_all; auto.
Qed.
  

Definition elemToVecF2 (z : F2) : VectorF2 1%nat :=
  (fun r c : nat => if (r =? 0)%nat && (c =? 0)%nat then z else zero).

Lemma elemToVecF2_zero : elemToVecF2 0 = ZeroF2.
Proof. unfold elemToVecF2, ZeroF2. prep_matrix_equality. bdestruct_all; auto. Qed.

Lemma elemToVecF2_one00 : elemToVecF2 1%F2 0%nat 0%nat = 1.
Proof. unfold elemToVecF2, ZeroF2. bdestruct_all; auto. Qed.

Lemma elemToVec_innerproduct : forall (z1 z2 : F2),
    elemToVecF2 z1 × transposeF2 (elemToVecF2 z2) = elemToVecF2 (z1 · z2).
Proof. intros z1 z2.
  unfold elemToVecF2, transposeF2, MmultF2.
  prep_matrix_equality.
  bdestruct_all; simpl; auto.
  - destruct (z1 · z2); auto.
  - destruct z1; auto.
  - destruct z2; auto.
Qed.

Lemma toCheckMatrixF2Left_cons : forall (Lp : list Pauli) (p : Pauli),
    toCheckMatrixF2Left 1%nat (S (length Lp)) [p :: Lp] =
      F2Module.smash (elemToVecF2 (toCheckMatrixF2ElementLeftX p)) (toCheckMatrixF2Left 1%nat (length Lp) [Lp]).
Proof. intros Lp p.
  unfold toCheckMatrixF2Left, F2Module.smash, elemToVecF2.
  prep_matrix_equality.
  bdestruct_all; subst; simpl; auto.
  - destruct x; simpl; try lia.
    destruct x; simpl; auto.
  - destruct x; subst; simpl.
    + destruct y; subst; simpl; try lia.
      repeat f_equal; try lia.
    + destruct x; subst; simpl.
      * destruct y; subst; simpl; try lia.
        repeat f_equal; try lia.
      * destruct y; subst; simpl; try lia.
        repeat f_equal; try lia.
Qed.

Lemma toCheckMatrixF2Right_cons : forall (Lp : list Pauli) (p : Pauli),
    toCheckMatrixF2Right 1%nat (S (length Lp)) [p :: Lp] =
      F2Module.smash (elemToVecF2 (toCheckMatrixF2ElementRightZ p)) (toCheckMatrixF2Right 1%nat (length Lp) [Lp]).
Proof. intros Lp p.
  unfold toCheckMatrixF2Right, F2Module.smash, elemToVecF2.
  prep_matrix_equality.
  bdestruct_all; subst; simpl; auto.
  - destruct x; simpl; try lia.
    destruct x; simpl; auto.
  - destruct x; subst; simpl.
    + destruct y; subst; simpl; try lia.
      repeat f_equal; try lia.
    + destruct x; subst; simpl.
      * destruct y; subst; simpl; try lia.
        repeat f_equal; try lia.
      * destruct y; subst; simpl; try lia.
        repeat f_equal; try lia.
Qed.

(** Λ **)
Definition checkLambdaF2 (n : nat) : MatrixF2 (n + n)%nat (n + n)%nat :=
  (fun r c : nat =>
     if (r <? (n + n))%nat && (c <? (n + n))%nat && ((c =? r + n)%nat || (r =? c + n)%nat) 
     then 1 else 0).

Lemma WF_checkLambdaF2 : forall {n : nat},
    WF_MatrixF2 (checkLambdaF2 n).
Proof. intros n.
  unfold WF_MatrixF2.
  intros x y H.
  destruct H; unfold checkLambdaF2; bdestruct_all; simpl; auto.
Qed.

Lemma checkLambdaF2_inv : forall (n : nat),
    (checkLambdaF2 n) × (checkLambdaF2 n) = IF2 (n + n)%nat.
Proof. intros n. 
  unfold checkLambdaF2, IF2, MmultF2.
  prep_matrix_equality.
  bdestruct_all; subst; simpl.
  - bdestruct (y <? n).
    + apply big_sum_unique.
      exists (y + n)%nat. split; try lia. split.
      * bdestruct_all. auto.
      * intros x' H2 H3. bdestruct_all. auto.
    + apply big_sum_unique.
      exists (y - n)%nat. split; try lia. split.
      * bdestruct_all. auto.
      * intros x' H2 H3. bdestruct_all. auto.
  - rewrite big_sum_0_bounded; auto.
    intros x0 H2. bdestruct_all; auto.
  - rewrite big_sum_0_bounded; auto.
    intros x0 H2. bdestruct_all; auto.
  - rewrite big_sum_0_bounded; auto.
    intros x0 H2. bdestruct_all; auto.
  - rewrite big_sum_0_bounded; auto.
    intros x0 H2. bdestruct_all; auto.
  - rewrite big_sum_0_bounded; auto.
    intros x0 H2. bdestruct_all; auto.
Qed.

Lemma checkLambdaF2_switch_right : forall (n : nat) (a b : MatrixF2 1%nat n),
    WF_MatrixF2 a ->
    (checkLambdaF2 n) × (F2Module.smash a b)⊤ = (F2Module.smash b a)⊤.
Proof. intros n a b H.
  unfold checkLambdaF2, F2Module.smash, transposeF2, MmultF2.
  prep_matrix_equality.
  bdestruct_all; subst; simpl.
  - apply big_sum_unique.
    exists (x + n)%nat. split; try lia. split.
    + bdestruct_all. F2simpl. f_equal. lia.
    + intros x' H2 H3. bdestruct_all; rewrite F2mult_0_l; simpl; auto.
  - apply big_sum_unique.
    exists (x - n)%nat. split; try lia. split.
    + bdestruct_all. rewrite F2mult_1_l. auto.
    + intros x' H2 H3. bdestruct_all; rewrite F2mult_0_l; auto.
  - rewrite H; auto; try lia.
    rewrite big_sum_0_bounded; auto.
    intros x0 H2. destruct (if x0 <? n then a y x0 else b y (x0 - n)%nat); auto.
Qed.

Lemma smash_innerproduct : forall (n m : nat) (a a' : MatrixF2 1%nat n) (b b' : MatrixF2 1%nat m),
    F2Module.smash a b × (F2Module.smash a' b')⊤ = a × a'⊤ .+ b × b'⊤.
Proof. intros n m a a' b b'.
  unfold F2Module.smash, transposeF2, MmultF2, MplusF2.
  prep_matrix_equality.
  rewrite big_sum_sum.
  simpl.
  f_equal.
  - apply big_sum_eq_bounded.
    intros x0 H.
    bdestruct_all.
    auto.
  - apply big_sum_eq_bounded.
    intros x0 H.
    bdestruct_all.
    replace (n + x0 - n)%nat with x0 by lia.
    auto.
Qed.

(* Exercise 10.33: Show that g and g′ commute if and only if r(g)Λr(g′)T = 0. (In the check matrix representation, arithmetic is done modulo two.) *)
Lemma fromLLpToCheckMatrixF2_checkLambdaF2_comm_anticomm : forall (Lp1 Lp2 : list Pauli),
    length Lp1 = length Lp2 -> (length Lp1 > 0)%nat ->
    (((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp1]) × (checkLambdaF2 (length Lp1)) × ((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp2]) ⊤)) 0%nat 0%nat = 0 -> commute_listP Lp1 Lp2) /\
      (((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp1]) × (checkLambdaF2 (length Lp1)) × ((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp2]) ⊤)) 0%nat 0%nat = 1 -> anticommute_listP Lp1 Lp2).
Proof. intros Lp1 Lp2 H H0. gen Lp2. induction Lp1; intros. simpl in *; try lia.
  destruct Lp2 as [| b Lp2]. inversion H.
  simpl in H. apply Nat.succ_inj in H. clear H0.
  unfold fromLLpToCheckMatrixF2.
  rewrite ! F2Module.GMmult_assoc.
  rewrite ! checkLambdaF2_switch_right.
  2:{ apply WF_toCheckMatrixF2Left; auto. constructor. simpl; lia. constructor. }
  rewrite ! smash_innerproduct.
  replace (length (a :: Lp1)) with (S (length Lp1)) by auto.
  rewrite ! toCheckMatrixF2Left_cons, ! toCheckMatrixF2Right_cons.
  rewrite ! H.
  rewrite ! toCheckMatrixF2Left_cons, ! toCheckMatrixF2Right_cons.
  replace (S (length Lp2)) with (1 + (length Lp2))%nat by lia.
  rewrite ! smash_innerproduct.
  rewrite ! elemToVec_innerproduct.
  rewrite <- ! H.
  destruct Lp1.
  clear IHLp1. simpl in *. symmetry in H. rewrite length_zero_iff_nil in H. subst.
  unfold toCheckMatrixF2Left, toCheckMatrixF2Right,
    toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ,
    transposeF2, MmultF2, MplusF2; 
    destruct a, b; simpl; split; intros H'; constructor; try constructor; auto;
    repeat match goal with
    | Hyp: 0 = 1 |- _ => symmetry in Hyp
    | Hyp: 1 = 0 |- _ => contradict Hyp; apply F2_1_neq_0
    end;
    match goal with
    | Hyp: _ |- _ <> _ => intro H''; try discriminate
    end.
  destruct Lp2 as [| q Lp2]. inversion H.
  assert (length (p :: Lp1) > 0)%nat by (simpl; lia).
  specialize (IHLp1 H0 (q :: Lp2) H). clear H0.
  unfold fromLLpToCheckMatrixF2 in IHLp1.
  rewrite ! F2Module.GMmult_assoc in IHLp1.
  rewrite ! checkLambdaF2_switch_right in IHLp1.
  2:{ apply WF_toCheckMatrixF2Left; auto. constructor. simpl in *; try lia. constructor. }
  rewrite ! smash_innerproduct in IHLp1.
  destruct IHLp1.
  split; intro H2.
  destruct a, b;
    try match goal with
      | Hyp : _ |- commute_listP (gI :: _) (_) => 
          apply commuting_listP_commP_commL; [constructor; auto | apply H0];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- commute_listP (_) (gI :: _) => 
          apply commuting_listP_commP_commL; [constructor; auto | apply H0];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- commute_listP (gX :: _) (gX :: _) => 
          apply commuting_listP_commP_commL; [constructor; auto | apply H0];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- commute_listP (gY :: _) (gY :: _) => 
          apply commuting_listP_commP_commL; [constructor; auto | apply H0];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- commute_listP (gZ :: _) (gZ :: _) => 
          apply commuting_listP_commP_commL; [constructor; auto | apply H0];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      end.

  4: { try rewrite ! F2mult_1_l in H2; try rewrite ! F2mult_1_r in H2.
       unfold MplusF2 in H2.
       rewrite ! elemToVecF2_one00 in H2.
       rewrite <- H2.
       unfold MplusF2. rewrite ! F2plus_assoc.
       setoid_rewrite F2plus_comm at 5. rewrite ! F2plus_assoc.
       F2simpl. auto. }  

  1-6: apply commuting_listP_anticommP_anticommL; 
  [constructor; intro H''; discriminate | apply H1];
  unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
  try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2;
  try rewrite ! F2mult_1_l in H2; try rewrite ! F2mult_1_r in H2;
  try rewrite ! elemToVecF2_zero in H2;
  try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2;
  unfold MplusF2 in H2; unfold MplusF2;
  rewrite ! elemToVecF2_one00 in H2;
  try rewrite <- ! F2plus_assoc in H2;
  try apply F2plus_flip_l_0 in H2;
  try rewrite <- H2; auto.
 
  1-3: try rewrite F2plus_comm in H2 at 1;
  try rewrite <- ! F2plus_assoc in H2;
  try apply F2plus_flip_l_0 in H2;
  try rewrite <- H2; auto; try rewrite F2plus_comm at 1; auto.

  destruct a, b;
    try match goal with
      | Hyp : _ |- anticommute_listP (gI :: _) (_) => 
          apply anticommuting_listP_commP_anticommL; [constructor; auto | apply H1];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- anticommute_listP (_) (gI :: _) => 
          apply anticommuting_listP_commP_anticommL; [constructor; auto | apply H1];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- anticommute_listP (gX :: _) (gX :: _) => 
          apply anticommuting_listP_commP_anticommL; [constructor; auto | apply H1];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- anticommute_listP (gY :: _) (gY :: _) => 
          apply anticommuting_listP_commP_anticommL; [constructor; auto | apply H1];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      | Hyp : _ |- anticommute_listP (gZ :: _) (gZ :: _) => 
          apply anticommuting_listP_commP_anticommL; [constructor; auto | apply H1];
          unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
          try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2; 
          try rewrite ! elemToVecF2_zero in H2;
          try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2; 
          auto
      end.
 
  4: { try rewrite ! F2mult_1_l in H2; try rewrite ! F2mult_1_r in H2.
       unfold MplusF2 in H2.
       rewrite ! elemToVecF2_one00 in H2.
       rewrite <- H2.
       unfold MplusF2. rewrite ! F2plus_assoc.
       setoid_rewrite F2plus_comm at 5. rewrite ! F2plus_assoc.
       F2simpl. auto. }  
  
  1-6: apply anticommuting_listP_anticommP_commL; 
  [constructor; intro H''; discriminate | apply H0];
  unfold toCheckMatrixF2ElementLeftX, toCheckMatrixF2ElementRightZ in H2;
  try rewrite ! F2mult_0_l in H2; try rewrite ! F2mult_0_r in H2;
  try rewrite ! F2mult_1_l in H2; try rewrite ! F2mult_1_r in H2;
  try rewrite ! elemToVecF2_zero in H2;
  try rewrite ! F2Module.GMplus_0_l in H2; try rewrite ! F2Module.GMplus_0_r in H2;
  unfold MplusF2 in H2; unfold MplusF2;
  rewrite ! elemToVecF2_one00 in H2;
  try rewrite <- ! F2plus_assoc in H2;
  try apply F2plus_flip_l_1 in H2;
  try rewrite <- H2; auto.
  
  1-3: try rewrite F2plus_comm in H2 at 1;
  try rewrite <- ! F2plus_assoc in H2;
  try apply F2plus_flip_l_1 in H2;
  try rewrite <- H2; auto; try rewrite F2plus_comm at 1; auto.
Qed.

Lemma fromLLpToCheckMatrixF2_checkLambdaF2_comm_iff : forall (Lp1 Lp2 : list Pauli),
    length Lp1 = length Lp2 -> (length Lp1 > 0)%nat ->
    ((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp1]) × (checkLambdaF2 (length Lp1)) × ((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp2]) ⊤)) 0%nat 0%nat = 0 <-> commute_listP Lp1 Lp2.
Proof. intros Lp1 Lp2 H H0.
  destruct (fromLLpToCheckMatrixF2_checkLambdaF2_comm_anticomm Lp1 Lp2 H H0).
  split; auto.
  intros H3.
  rewrite <- F2_neq1_iff_eq0.
  intro H4.
  destruct (anticommute_commute_listP_no_middle Lp1 Lp2); try contradiction.
  contradict H5.
  apply H2; auto.
Qed.

Lemma fromLLpToCheckMatrixF2_checkLambdaF2_anticomm_iff : forall (Lp1 Lp2 : list Pauli),
    length Lp1 = length Lp2 -> (length Lp1 > 0)%nat ->
    ((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp1]) × (checkLambdaF2 (length Lp1)) × ((fromLLpToCheckMatrixF2 1%nat (length Lp1) [Lp2]) ⊤)) 0%nat 0%nat = 1 <-> anticommute_listP Lp1 Lp2.
Proof. intros Lp1 Lp2 H H0.
  destruct (fromLLpToCheckMatrixF2_checkLambdaF2_comm_anticomm Lp1 Lp2 H H0).
  split; auto.
  intros H3.
  rewrite <- F2_neq0_iff_eq1.
  intro H4.
  destruct (anticommute_commute_listP_no_middle Lp1 Lp2); try contradiction.
  contradict H5.
  apply H1; auto.
Qed.

Lemma rowF2_fromLLpToCheckMatrixF2 : forall {n i : nat} {LLp : list (list Pauli)},
  Forall (fun Lp : list Pauli => length Lp = n) LLp -> LLp <> [] -> (n > 0)%nat ->
  get_rowF2 (fromLLpToCheckMatrixF2 (length LLp) n LLp) i = 
    fromLLpToCheckMatrixF2 1 n [nth i LLp (repeat gI n)].
Proof. intros n i LLp H H0 H1.
  unfold get_rowF2, fromLLpToCheckMatrixF2.
  unfold F2Module.smash.
  prep_matrix_equality.
  bdestruct_all; subst;
    unfold toCheckMatrixF2Left, toCheckMatrixF2ElementLeftX,
    toCheckMatrixF2Right, toCheckMatrixF2ElementRightZ; auto;
    rewrite nth_overflow with (n := x); try rewrite nth_repeat;
    simpl; try lia; auto.
Qed.

Lemma get_rowF2_e_iF2_hit : forall {i m : nat},
    (i < m)%nat -> (get_rowF2 (@e_iF2 m i) i) 0%nat 0%nat = 1%F2.
Proof. intros i m H.
  unfold get_rowF2, e_iF2; bdestruct_all; simpl; auto.
Qed.

Lemma get_rowF2_e_iF2_miss : forall {i j m : nat},
    (i < m)%nat -> (j < m)%nat -> (i <> j)%nat -> (get_rowF2 (@e_iF2 m i) j) 0%nat 0%nat = 0%F2.
Proof. intros i j m H H0 H1. 
  unfold get_rowF2, e_iF2; bdestruct_all; simpl; auto.
Qed.

Lemma existsCheckMatrixF2Vector : forall (n : nat) (LLp : list (list Pauli)),
    Forall (fun Lp : list Pauli => length Lp = n) LLp -> LLp <> [] -> (n > 0)%nat ->
    linearly_independentF2 ((fromLLpToCheckMatrixF2 (length LLp) n LLp) ⊤) ->
    (forall i : nat, (i < length LLp)%nat -> (exists v : VectorF2 (n + n), WF_MatrixF2 v /\ 
        (fromLLpToCheckMatrixF2 (length LLp) n LLp) × checkLambdaF2 n × v = e_iF2 i /\
             (fromLLpToCheckMatrixF2 1%nat n [nth i LLp (repeat gI n)] × checkLambdaF2 n × v) 0%nat 0%nat = 1%F2 /\
        (forall j : nat, (j < length LLp)%nat -> j <> i -> 
             (fromLLpToCheckMatrixF2 1%nat n [nth j LLp (repeat gI n)] × checkLambdaF2 n × v) 0%nat 0%nat = 0%F2))). 
Proof. intros n LLp H H0 H1 H2 i H3.
  assert (WF_MatrixF2 (fromLLpToCheckMatrixF2 (length LLp) n LLp)).
  { apply WF_fromLLpToCheckMatrixF2; auto.
    apply Forall_impl with (P := (fun Lp : list Pauli => length Lp = n)); intros; auto; lia. }
  assert (WF_MatrixF2 (@e_iF2 (length LLp) i)).
  { apply F2Module.WF_e_i. }
  destruct (F2Module.lin_indep_rows_implies_exists_sol
          (fromLLpToCheckMatrixF2 (length LLp) n LLp) (e_iF2 i) H4 H5 H2)
    as [v [WFv Avb]].
  assert ((IF2 (n + n)%nat) × v = v).
  { rewrite F2Module.GMmult_1_l; auto. }
  rewrite <- checkLambdaF2_inv in H6.
  rewrite F2Module.GMmult_assoc in H6.
  exists (checkLambdaF2 n × v).
  repeat split.
  - apply F2Module.WF_mult; auto. apply WF_checkLambdaF2.
  - rewrite F2Module.GMmult_assoc.
    rewrite H6. auto.
  - rewrite ! F2Module.GMmult_assoc. rewrite H6.
    assert (F2Module.get_row (fromLLpToCheckMatrixF2 (length LLp) n LLp × v) i =
              F2Module.get_row (@e_iF2 (length LLp) i) i).
    { rewrite Avb. auto. }
    rewrite F2Module.matrix_by_basis_transpose in H7; try lia.
    rewrite <- F2Module.GMmult_assoc in H7.
    rewrite <- F2Module.matrix_by_basis_transpose in H7; try lia.
    rewrite rowF2_fromLLpToCheckMatrixF2 in H7; auto.
    rewrite H7. rewrite get_rowF2_e_iF2_hit ; auto.
  - intros j H7 H8. 
    rewrite ! F2Module.GMmult_assoc. rewrite H6.
    assert (F2Module.get_row (fromLLpToCheckMatrixF2 (length LLp) n LLp × v) j =
              F2Module.get_row (@e_iF2 (length LLp) i) j).
    { rewrite Avb. auto. }
    rewrite F2Module.matrix_by_basis_transpose in H9; try lia.
    rewrite <- F2Module.GMmult_assoc in H9.
    rewrite <- F2Module.matrix_by_basis_transpose in H9; try lia.
    rewrite rowF2_fromLLpToCheckMatrixF2 in H9; auto.
    rewrite H9. rewrite get_rowF2_e_iF2_miss; auto.
Qed.

Definition fromF2PairToPauli (x z : F2) : Pauli :=
  match x, z with
  | 0, 0 => gI
  | 1, 0 => gX
  | 0, 1 => gZ
  | 1, 1 => gY
  end.

Fixpoint fromCheckMatrixF2RowToLp_rec 
  {m n : nat} (M : MatrixF2 m (n + n)) (row col_count : nat) (acc : list Pauli) : list Pauli :=
  match col_count with
  | 0%nat => acc
  | S col_count' => fromCheckMatrixF2RowToLp_rec M row col_count'
                     ((fromF2PairToPauli (M row col_count') (M row (n + col_count')%nat)) :: acc)
  end.

Definition fromCheckMatrixF2RowToLp {m n : nat} (M : MatrixF2 m (n + n)) (row : nat) : list Pauli :=
  fromCheckMatrixF2RowToLp_rec M row n [].

Fixpoint fromCheckMatrixF2ToLLp_rec 
  {m n : nat} (M : MatrixF2 m (n + n)) (row_count : nat) (acc : list (list Pauli)) : list (list Pauli) :=
  match row_count with
  | 0%nat => acc
  | S row_count' => fromCheckMatrixF2ToLLp_rec M row_count'
                     ((fromCheckMatrixF2RowToLp M row_count') :: acc)
  end.

Definition fromCheckMatrixF2ToLLp {m n : nat} (M : MatrixF2 m (n + n)) : list (list Pauli) :=
  fromCheckMatrixF2ToLLp_rec M m [].


Lemma fromCheckMatrixF2RowToLp_rec_acc_app : 
  forall {m n : nat} (M : MatrixF2 m (n + n)) (row col_count : nat) (acc : list Pauli),
    fromCheckMatrixF2RowToLp_rec M row col_count acc =
      (fromCheckMatrixF2RowToLp_rec M row col_count []) ++ acc.
Proof. intros m n M row col_count acc.
  gen acc. induction col_count; intros; auto.
  simpl. setoid_rewrite IHcol_count. 
  rewrite <- app_assoc. auto.
Qed.

Lemma fromCheckMatrixF2ToLLp_rec_acc_app : 
  forall {m n : nat} (M : MatrixF2 m (n + n)) (row_count : nat) (acc : list (list Pauli)),
    fromCheckMatrixF2ToLLp_rec M row_count acc =
      (fromCheckMatrixF2ToLLp_rec M row_count []) ++ acc.
Proof. intros m n M row_count acc.
  gen acc. induction row_count; intros; auto.
  simpl. setoid_rewrite IHrow_count.
  rewrite <- app_assoc. auto.
Qed.

Lemma fromCheckMatrixF2RowToLp_rec_reduce_row : 
  forall {m n : nat} (M : MatrixF2 (S m) (n + n)) (row row' col_count : nat) (acc : list Pauli),
    (row' < row)%nat ->
    fromCheckMatrixF2RowToLp_rec M row' col_count acc =
      fromCheckMatrixF2RowToLp_rec (reduce_rowF2 M row) row' col_count acc.
Proof. intros m n M row row' col_count acc H. 
  gen acc. induction col_count; intros; auto.
  simpl. setoid_rewrite IHcol_count; auto. f_equal.
  unfold reduce_rowF2. bdestruct_all; auto.
Qed.

Lemma fromCheckMatrixF2ToLLp_rec_reduce_row : 
  forall {m n : nat} (M : MatrixF2 (S m) (n + n)) (row row_count : nat) (acc : list (list Pauli)),
    (row_count <= row)%nat ->
    fromCheckMatrixF2ToLLp_rec M row_count acc =
      fromCheckMatrixF2ToLLp_rec (reduce_rowF2 M row) row_count acc.
Proof. intros m n M row row_count acc H.
  gen n m M row acc. induction row_count; intros; auto.
  simpl. rewrite IHrow_count with (row := row); try lia.
  do 2 f_equal. unfold fromCheckMatrixF2RowToLp.
  rewrite fromCheckMatrixF2RowToLp_rec_reduce_row with (row := row); auto; try lia.
Qed.

Lemma fromCheckMatrixF2ToLLp_rec_length_row :
  forall {m n : nat} (M : MatrixF2 m (n + n)) (row_count : nat) (acc : list (list Pauli)),
    length (fromCheckMatrixF2ToLLp_rec M row_count acc) = (row_count + length acc)%nat.
Proof. intros m n M row_count acc.
  gen acc. induction row_count; intros; auto.
  simpl. rewrite IHrow_count. auto.
Qed.

Lemma fromCheckMatrixF2RowToLp_rec_length :
  forall {m n : nat} (M : MatrixF2 m (n + n)) (row col_count : nat) (acc : list Pauli),
    length (fromCheckMatrixF2RowToLp_rec M row col_count acc) =
      (col_count + length acc)%nat.
Proof. intros m n M row col_count acc. 
  gen acc. induction col_count; intros; auto.
  simpl. rewrite IHcol_count. auto.
Qed.

Lemma fromCheckMatrixF2ToLLp_rec_length_col :
  forall {m n : nat} (M : MatrixF2 m (n + n)) (row_count : nat) (acc : list (list Pauli)),
    Forall (fun Lp : list Pauli => length Lp = n) acc ->
    Forall (fun Lp : list Pauli => length Lp = n) (fromCheckMatrixF2ToLLp_rec M row_count acc).
Proof. intros m n M row_count acc H.
  gen acc. induction row_count; intros; auto.
  simpl. apply IHrow_count; auto.
  rewrite Forall_forall. intros x H0.
  destruct H0.
  - subst. unfold fromCheckMatrixF2RowToLp.
    rewrite fromCheckMatrixF2RowToLp_rec_length. auto.
  - rewrite Forall_forall in H.
    apply H; auto.
Qed.

Lemma toCheckMatrixF2ElementLeftX_nth_fromCheckMatrixF2RowToLp_rec :
  forall {m n : nat} (M : MatrixF2 m (n + n)) (r y col_count : nat), 
    WF_MatrixF2 M -> (y < col_count)%nat ->
    toCheckMatrixF2ElementLeftX (nth y (fromCheckMatrixF2RowToLp_rec M r col_count []) gI) = M r y.
Proof. intros m n M r y col_count H H0.
  gen m n M r y. 
  induction col_count; intros; try lia. simpl. 
  rewrite fromCheckMatrixF2RowToLp_rec_acc_app.
  bdestruct (y =? col_count)%nat.
  - subst. 
    assert (length (fromCheckMatrixF2RowToLp_rec M r col_count []) = col_count).
    { rewrite fromCheckMatrixF2RowToLp_rec_length. simpl. auto. }
    rewrite <- H1 at 1.
    rewrite nth_middle.
    unfold toCheckMatrixF2ElementLeftX, fromF2PairToPauli.
    destruct (M r col_count); destruct (M r (n + col_count)%nat); auto.
  - rewrite <- nth_firstn with (i := y) (n := col_count); try lia.
    rewrite firstn_app.
    rewrite fromCheckMatrixF2RowToLp_rec_length.
    simpl. replace (col_count - (col_count + 0))%nat with 0%nat by lia. simpl.
    rewrite app_nil_r.
    rewrite firstn_all2 at 1.
    + apply IHcol_count; auto; lia.
    + rewrite fromCheckMatrixF2RowToLp_rec_length; simpl; lia.
Qed.

Lemma toCheckMatrixF2ElementRightZ_nth_fromCheckMatrixF2RowToLp_rec :
  forall {m n : nat} (M : MatrixF2 m (n + n)) (r y col_count : nat), 
    WF_MatrixF2 M -> (y < col_count)%nat ->
    toCheckMatrixF2ElementRightZ (nth y (fromCheckMatrixF2RowToLp_rec M r col_count []) gI) = M r (n + y)%nat.
Proof. intros m n M r y col_count H H0.
  gen m n M r y. 
  induction col_count; intros; try lia. simpl. 
  rewrite fromCheckMatrixF2RowToLp_rec_acc_app.
  bdestruct (y =? col_count)%nat.
  - subst. 
    assert (length (fromCheckMatrixF2RowToLp_rec M r col_count []) = col_count).
    { rewrite fromCheckMatrixF2RowToLp_rec_length. simpl. auto. }
    rewrite <- H1 at 1.
    rewrite nth_middle.
    unfold toCheckMatrixF2ElementRightZ, fromF2PairToPauli.
    destruct (M r col_count); destruct (M r (n + col_count)%nat); auto.
  - rewrite <- nth_firstn with (i := y) (n := col_count); try lia.
    rewrite firstn_app.
    rewrite fromCheckMatrixF2RowToLp_rec_length.
    simpl. replace (col_count - (col_count + 0))%nat with 0%nat by lia. simpl.
    rewrite app_nil_r.
    rewrite firstn_all2 at 1.
    + apply IHcol_count; auto; lia.
    + rewrite fromCheckMatrixF2RowToLp_rec_length; simpl; lia.
Qed.

Lemma fromCheckMatrixF2ToLLpToCheckMatrixF2 : 
  forall {m n : nat} (M : MatrixF2 m (n + n)),
    WF_MatrixF2 M -> 
    fromLLpToCheckMatrixF2 m n (fromCheckMatrixF2ToLLp M) = M.
Proof. intros m n M H.
  unfold fromLLpToCheckMatrixF2.
  unfold F2Module.smash, toCheckMatrixF2Left, toCheckMatrixF2Right.
  prep_matrix_equality.
  bdestruct_all.
  - unfold fromCheckMatrixF2ToLLp. 
    gen n M x y. induction m; intros.
    + simpl. destruct x; rewrite nth_repeat; rewrite H; auto; try lia.
    + simpl. rewrite fromCheckMatrixF2ToLLp_rec_acc_app.
      bdestruct (x <? m)%nat.
      * rewrite fromCheckMatrixF2ToLLp_rec_reduce_row with (row := m); auto.
        rewrite <- nth_firstn with (i := x) (n := m); auto.
        rewrite firstn_app.
        rewrite fromCheckMatrixF2ToLLp_rec_length_row.
        rewrite firstn_all2 at 1.
        -- simpl. replace (m - (m + 0))%nat with 0%nat by lia. simpl.
           rewrite app_nil_r.
           assert (M x y = (reduce_rowF2 M m) x y).
           { unfold reduce_rowF2. bdestruct_all. auto. }
           rewrite H2.
           apply IHm; auto.
           apply F2Module.WF_reduce_row; auto.
        -- rewrite fromCheckMatrixF2ToLLp_rec_length_row. simpl. lia.
      * bdestruct (x =? m)%nat.
        -- subst. 
           assert (length (fromCheckMatrixF2ToLLp_rec M m []) = m).
           { rewrite fromCheckMatrixF2ToLLp_rec_length_row. simpl. auto. }
           rewrite <- H2 at 1.
           rewrite nth_middle.
           clear IHm H1 H2.
           unfold fromCheckMatrixF2RowToLp.
           rewrite toCheckMatrixF2ElementLeftX_nth_fromCheckMatrixF2RowToLp_rec;
             auto.
        -- rewrite nth_overflow with (n := x).
           ++ rewrite nth_repeat. unfold toCheckMatrixF2ElementLeftX. rewrite H; auto; lia.
           ++ rewrite app_length. rewrite fromCheckMatrixF2ToLLp_rec_length_row. simpl. lia.
  - unfold fromCheckMatrixF2ToLLp. 
    gen n M x y. induction m; intros.
    + simpl. destruct x; rewrite nth_repeat; rewrite H; auto; try lia.
    + simpl. rewrite fromCheckMatrixF2ToLLp_rec_acc_app.
      bdestruct (x <? m)%nat.
      * rewrite fromCheckMatrixF2ToLLp_rec_reduce_row with (row := m); auto.
        rewrite <- nth_firstn with (i := x) (n := m); auto.
        rewrite firstn_app.
        rewrite fromCheckMatrixF2ToLLp_rec_length_row.
        rewrite firstn_all2 at 1.
        -- simpl. replace (m - (m + 0))%nat with 0%nat by lia. simpl.
           rewrite app_nil_r.
           assert (M x y = (reduce_rowF2 M m) x y).
           { unfold reduce_rowF2. bdestruct_all. auto. }
           rewrite H2.
           apply IHm; auto.
           apply F2Module.WF_reduce_row; auto.
        -- rewrite fromCheckMatrixF2ToLLp_rec_length_row. simpl. lia.
      * bdestruct (x =? m)%nat.
        -- subst. 
           assert (length (fromCheckMatrixF2ToLLp_rec M m []) = m).
           { rewrite fromCheckMatrixF2ToLLp_rec_length_row. simpl. auto. }
           rewrite <- H2 at 1.
           rewrite nth_middle.
           clear IHm H1 H2.
           unfold fromCheckMatrixF2RowToLp.
           bdestruct (y <? n + n)%nat.
           ++ rewrite toCheckMatrixF2ElementRightZ_nth_fromCheckMatrixF2RowToLp_rec;
                auto; f_equal; lia.
           ++ rewrite nth_overflow with (n := (y - n)%nat).
              ** unfold toCheckMatrixF2ElementRightZ.
                 rewrite H; auto; lia.
              ** rewrite fromCheckMatrixF2RowToLp_rec_length. simpl. lia.
        -- rewrite nth_overflow with (n := x).
           ++ rewrite nth_repeat. unfold toCheckMatrixF2ElementLeftX. rewrite H; auto; lia.
           ++ rewrite app_length. rewrite fromCheckMatrixF2ToLLp_rec_length_row. simpl. lia.
Qed.

Lemma exists_commute_anticommute_Lp : forall (n : nat) (LLp : list (list Pauli)),
    Forall (fun Lp : list Pauli => length Lp = n) LLp -> LLp <> [] -> (n > 0)%nat ->
    linearly_independentF2 ((fromLLpToCheckMatrixF2 (length LLp) n LLp) ⊤) ->
    (forall i : nat, (i < length LLp)%nat -> (exists Lp : list Pauli, length Lp = n /\ 
       anticommute_listP (nth i LLp (repeat gI n)) Lp /\
       (forall j : nat, (j < length LLp)%nat -> j <> i -> commute_listP (nth j LLp (repeat gI n)) Lp))).
Proof. intros n LLp H H0 H1 H2 i H3.
  destruct (existsCheckMatrixF2Vector n LLp H H0 H1 H2 i H3)
    as [v [WFv [v_to_e_i [to_one to_zero]]]].
  assert (WFvt: WF_MatrixF2 v ⊤). { apply F2Module.WF_transpose. auto. }
  pose (fromCheckMatrixF2ToLLpToCheckMatrixF2 (v⊤) WFvt) as e.
  assert ((fromLLpToCheckMatrixF2 1 n (fromCheckMatrixF2ToLLp (v) ⊤)) ⊤ = ((v) ⊤) ⊤).
  { rewrite e. auto. }
  rewrite F2Module.transpose_involutive in H4.
  rewrite <- H4 in to_one, to_zero.
  exists (nth 0%nat (fromCheckMatrixF2ToLLp (v) ⊤) (repeat gI n)).
  repeat split.
  - simpl. unfold fromCheckMatrixF2RowToLp. 
    rewrite fromCheckMatrixF2RowToLp_rec_length.
    simpl. auto.
  - rewrite <- fromLLpToCheckMatrixF2_checkLambdaF2_anticomm_iff. 
    + assert (length (nth i LLp (repeat gI n)) = n).
      { bdestruct (i <? length LLp).
        - rewrite Forall_nth in H. apply H; auto.
        - rewrite nth_overflow; auto; rewrite repeat_length; auto. }
      rewrite ! H5. apply to_one.
    + simpl. unfold fromCheckMatrixF2RowToLp.
      rewrite  fromCheckMatrixF2RowToLp_rec_length. simpl.
      bdestruct (i <? length LLp).
      * rewrite Forall_nth in H. rewrite H; auto.
      * rewrite nth_overflow; auto; rewrite repeat_length; auto.
    + rewrite Forall_nth in H. rewrite H; auto.
  - intros j H5 H6.
    rewrite <- fromLLpToCheckMatrixF2_checkLambdaF2_comm_iff. 
    + assert (length (nth j LLp (repeat gI n)) = n).
      { bdestruct (j <? length LLp).
        - rewrite Forall_nth in H. apply H; auto.
        - rewrite nth_overflow; auto; rewrite repeat_length; auto. }
      rewrite ! H7. apply to_zero; auto.
    + simpl. unfold fromCheckMatrixF2RowToLp.
      rewrite  fromCheckMatrixF2RowToLp_rec_length. simpl.
      bdestruct (j <? length LLp).
      * rewrite Forall_nth in H. rewrite H; auto.
      * rewrite nth_overflow; auto; rewrite repeat_length; auto.
    + rewrite Forall_nth in H. rewrite H; auto.
Qed.

Local Close Scope F2_scope.
Local Open Scope genmatrix_scope.
Local Open Scope matrix_scope.

Declare Module CField : FieldModule
  with Definition F := C
  with Definition R0 := C_is_monoid
  with Definition R1 := C_is_group
  with Definition R2 := C_is_comm_group
  with Definition R3 := C_is_ring
  with Definition R4 := C_is_comm_ring
  with Definition R5 := C_is_field.

Module CM := SubspacesOverField CField.



Definition stabilizeByListT
  {n : nat} (P : Vector (2 ^ n)%nat -> Prop) (Lt : list (TType n)) (v : Vector (2 ^ n)%nat) := 
  P v /\ (forall t : TType n, In t Lt -> (@Mmult (2 ^ n)%nat (2 ^ n)%nat 1%nat (translate t) v = v)).

Lemma stabilizeByListT_is_subspace : 
  forall {n : nat} (P : Vector (2 ^ n)%nat -> Prop) (Lt : list (TType n)),
    @CM.subspace (2 ^ n)%nat P ->
    @CM.subspace (2 ^ n)%nat (stabilizeByListT P Lt).
Proof. intros n P Lt H. 
  unfold stabilizeByListT in *.
  unfold CM.subspace in *.
 split; [idtac | split; [idtac | split]]; intros.
 - destruct H0.
   destruct H as [H2 [H3 [H4 H5]]].
   apply H2; auto.
 - destruct H as [H0 [H1 [H2 H3]]].
   split; auto. intros t H.
   rewrite Mmult_0_r. lma'.
 - destruct H as [H [H2 [H3 H4]]].
   destruct H0, H1.
   split.
   + apply H3; auto.
   + intros t H7.
     rewrite Mmult_plus_distr_l.
     f_equal.
     * intros. rewrite <- H10 at 2. rewrite <- H11 at 2.
       lma.
     * apply H5; auto.
     * apply H6; auto.
 - destruct H as [H [H2 [H3 H4]]].
   destruct H0.
   split; auto.
   intros t H5.
   rewrite Mscale_mult_dist_r.
   f_equal. intros. rewrite H9. auto.
   apply H1; auto.
Qed.

Lemma stabilizeByListT_app : 
  forall {n : nat} (P : Vector (2 ^ n)%nat -> Prop) (Lt1 Lt2 : list (TType n)),
    (forall v : Vector (2 ^ n)%nat, stabilizeByListT P (Lt1 ++ Lt2) v <->
                               stabilizeByListT P Lt1 v /\ stabilizeByListT P Lt2 v).
Proof. intros n P Lt1 Lt2 v. 
  unfold stabilizeByListT in *. 
  split; intros.
  - destruct H.
    repeat (split; auto); intros.
    + apply H0.
      rewrite in_app_iff.
      left. auto.
    + apply H0.
      rewrite in_app_iff.
      right. auto.
  - destruct H as [[H H0] [H1 H2]].
    split; auto; intros.
    rewrite in_app_iff in H3.
    destruct H3.
    + apply H0; auto.
    + apply H2; auto.
Qed.

Lemma stabilizeByListT_app_comm : 
  forall {n : nat} (P : Vector (2 ^ n)%nat -> Prop) (Lt1 Lt2 : list (TType n)),
    (forall v : Vector (2 ^ n)%nat, stabilizeByListT P (Lt1 ++ Lt2) v <->
                               stabilizeByListT P (Lt2 ++ Lt1) v).
Proof. intros n P Lt1 Lt2 v.
  split; intros;
  rewrite stabilizeByListT_app; 
    rewrite and_comm; 
    rewrite <- stabilizeByListT_app;
    auto.
Qed.

Lemma stabilizeByListT_cons : 
  forall {n : nat} (P : Vector (2 ^ n)%nat -> Prop) (Lt : list (TType n)) (t : TType n),
    (forall v : Vector (2 ^ n)%nat, stabilizeByListT P (t :: Lt) v <->
                               stabilizeByListT P [t] v /\ stabilizeByListT P Lt v).
Proof. intros n P Lt t v.
  replace (t :: Lt) with ([t] ++ Lt) by (simpl; auto).
  rewrite stabilizeByListT_app; split; auto.
Qed.

Lemma stabilizeByListT_Permutation : 
  forall {n : nat} (P : Vector (2 ^ n)%nat -> Prop) (Lt1 Lt2 : list (TType n)),
    Permutation Lt1 Lt2 ->
    (forall v : Vector (2^n)%nat, stabilizeByListT P Lt1 v -> stabilizeByListT P Lt2 v).
Proof. intros n P Lt1 Lt2 H v H0.
  induction H; auto.
  - rewrite stabilizeByListT_cons.
    assert ((stabilizeByListT P [x] v /\ stabilizeByListT P l v) ->
            (stabilizeByListT P [x] v /\ stabilizeByListT P l' v)).
    { intros H1. destruct H1. split; auto. }
    apply H1.
    rewrite <- stabilizeByListT_cons; auto.
  - rewrite stabilizeByListT_cons in H0.
    destruct H0.
    rewrite stabilizeByListT_cons in H0.
    destruct H0. 
    rewrite stabilizeByListT_cons. split; auto.
    rewrite stabilizeByListT_cons. split; auto.
Qed.

Lemma stabilizeByListT_nil : forall {n : nat} (P : Vector (2 ^ n)%nat -> Prop),
    (forall v : Vector (2^n)%nat, stabilizeByListT P [] v <-> P v).
Proof. intros n P v.
  unfold stabilizeByListT.
  split; intros.
  - destruct H; auto.
  - split; auto. intros. inversion H0.
Qed.


Lemma translate_defaultT_I_comm : forall {n : nat} (t : TType n),
    proper_length_TType t ->
    (translate (defaultT_I n) × translate t = translate t × translate (defaultT_I n))%M.
Proof. intros n t H.
  rewrite ! translate_defaultT_I.
  rewrite Mmult_1_l, Mmult_1_r; auto.
  all : apply WF_translate; auto.
Qed.


Lemma anticommute_commute_T_translate : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    (anticommute_T t1 t2 -> translate(t1) × translate(t2) = -C1 .* (translate(t2) × translate(t1))) /\
    (commute_T t1 t2 -> translate(t1) × translate(t2) = translate(t2) × translate(t1)).
Proof. intros n t1 t2 H H0. 
  destruct t1, t2, H, H0; unfold translate; simpl in *.
  split; intros.
  - inversion H3; clear H3; simpl in *.
    gen n.
    apply anticommute_listP_ind' with 
      (P0 := fun l l0 : list Pauli => forall n : nat, n <> 0%nat -> length l = n -> n <> 0%nat -> length l0 = n -> @Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c .* (⨂ map translate_P l)) (c0 .* (⨂ map translate_P l0)) = - C1 .* (@Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c0 .* (⨂ map translate_P l0)) (c .* (⨂ map translate_P l))))
      (P := fun l l0 : list Pauli => forall n : nat, n <> 0%nat -> length l = n -> n <> 0%nat -> length l0 = n -> @Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c .* (⨂ map translate_P l)) (c0 .* (⨂ map translate_P l0)) = @Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c0 .* (⨂ map translate_P l0)) (c .* (⨂ map translate_P l))) in H4; intros.
    + apply H4; auto.
    + inversion H.
      destruct H5 as [H5 | [H5 | H5]]; subst;
        try destruct P1; try destruct P2; simpl in *; lma'.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *. 
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite kron_mixed_product'; auto.
      f_equal.
      * inversion H.
        destruct H3 as [H3 | [H3 | H3]]; subst;
        try destruct P1; try destruct P2; simpl in *; lma'.
      * destruct l1, l2; inversion H0; subst; simpl in *.
        -- rewrite ! Matrix.kron_1_r in *.
           apply (H1 1%nat); lia.
        -- apply (H1 (S (length l1))); lia.
        -- apply (H1 (S (length l1))); lia.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *. 
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite kron_mixed_product'; auto.
      assert (translate_P P2 × translate_P P1 = -C1 .* (translate_P P1 × translate_P P2)).
      { inversion H. destruct P1, P2; try contradiction; simpl; lma'. }
      rewrite H3.
      setoid_rewrite Mscale_kron_dist_l.
      setoid_rewrite <- Mscale_kron_dist_r.
      f_equal.
      apply anticommute_listP_nonempty_equal_len in H0.
      destruct H0. destruct H7.
      apply H1; auto;
        intro H'; rewrite length_zero_iff_nil in H'; contradiction.
    + simpl in *.
      inversion H.
      rewrite ! Matrix.kron_1_r in *.
      subst. rewrite ! Mscale_mult_dist_l, ! Mscale_mult_dist_r.
      rewrite ! Mscale_assoc.
      replace (- C1 * c0 * c) with (c * c0 * - C1) by lca.
      rewrite <- ! Mscale_assoc.
      do 2 f_equal.
      destruct P1, P2; try contradiction; simpl; lma'.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *.
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite <- Mscale_mult_dist_l.
      setoid_rewrite <- Mscale_kron_dist_l.
      setoid_rewrite kron_mixed_product'; auto.
      f_equal.
      * inversion H.
        destruct P1, P2; try contradiction; simpl; lma'. 
      * destruct l1, l2; inversion H0; subst; simpl in *.
        -- rewrite ! Matrix.kron_1_r in *.
           apply (H1 1%nat); lia.
        -- apply (H1 (S (length l1))); lia.
        -- apply (H1 (S (length l1))); lia.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *.
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite <- Mscale_mult_dist_l.
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite kron_mixed_product'; auto.
      f_equal.
      * inversion H.
        destruct H3 as [H3 | [H3 | H3]]; subst;
        try destruct P1; try destruct P2; simpl in *; lma'.
      * apply anticommute_listP_nonempty_equal_len in H0.
        destruct H0. destruct H3.
        setoid_rewrite Mscale_mult_dist_l with (x := -C1).
        apply H1; auto;
          intro H'; rewrite length_zero_iff_nil in H'; contradiction.
  - inversion H3; clear H3; simpl in *.
    gen n.
    apply commute_listP_ind' with 
      (P0 := fun l l0 : list Pauli => forall n : nat, n <> 0%nat -> length l = n -> n <> 0%nat -> length l0 = n -> @Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c .* (⨂ map translate_P l)) (c0 .* (⨂ map translate_P l0)) = - C1 .* (@Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c0 .* (⨂ map translate_P l0)) (c .* (⨂ map translate_P l))))
      (P := fun l l0 : list Pauli => forall n : nat, n <> 0%nat -> length l = n -> n <> 0%nat -> length l0 = n -> @Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c .* (⨂ map translate_P l)) (c0 .* (⨂ map translate_P l0)) = @Mmult (2 ^ n)%nat (2 ^ n)%nat (2 ^ n)%nat (c0 .* (⨂ map translate_P l0)) (c .* (⨂ map translate_P l))) in H4; intros.
    + apply H4; auto.
    + inversion H.
      destruct H5 as [H5 | [H5 | H5]]; subst;
        try destruct P1; try destruct P2; simpl in *; lma'.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *. 
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite kron_mixed_product'; auto.
      f_equal.
      * inversion H.
        destruct H3 as [H3 | [H3 | H3]]; subst;
        try destruct P1; try destruct P2; simpl in *; lma'.
      * destruct l1, l2; inversion H0; subst; simpl in *.
        -- rewrite ! Matrix.kron_1_r in *.
           apply (H1 1%nat); lia.
        -- apply (H1 (S (length l1))); lia.
        -- apply (H1 (S (length l1))); lia.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *. 
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite kron_mixed_product'; auto.
      assert (translate_P P2 × translate_P P1 = -C1 .* (translate_P P1 × translate_P P2)).
      { inversion H. destruct P1, P2; try contradiction; simpl; lma'. }
      rewrite H3.
      setoid_rewrite Mscale_kron_dist_l.
      setoid_rewrite <- Mscale_kron_dist_r.
      f_equal.
      apply anticommute_listP_nonempty_equal_len in H0.
      destruct H0. destruct H7.
      apply H1; auto;
        intro H'; rewrite length_zero_iff_nil in H'; contradiction.
    + simpl in *.
      inversion H.
      rewrite ! Matrix.kron_1_r in *.
      subst. rewrite ! Mscale_mult_dist_l, ! Mscale_mult_dist_r.
      rewrite ! Mscale_assoc.
      replace (- C1 * c0 * c) with (c * c0 * - C1) by lca.
      rewrite <- ! Mscale_assoc.
      do 2 f_equal.
      destruct P1, P2; try contradiction; simpl; lma'.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *.
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite <- Mscale_mult_dist_l.
      setoid_rewrite <- Mscale_kron_dist_l.
      setoid_rewrite kron_mixed_product'; auto.
      f_equal.
      * inversion H.
        destruct P1, P2; try contradiction; simpl; lma'. 
      * destruct l1, l2; inversion H0; subst; simpl in *.
        -- rewrite ! Matrix.kron_1_r in *.
           apply (H1 1%nat); lia.
        -- apply (H1 (S (length l1))); lia.
        -- apply (H1 (S (length l1))); lia.
    + simpl in *. destruct n; try contradiction.
      apply Nat.succ_inj in H3, H6.
      rewrite ! map_length in *. subst. rewrite ! H6 in *.
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite <- Mscale_mult_dist_l.
      setoid_rewrite <- Mscale_kron_dist_r.
      setoid_rewrite kron_mixed_product'; auto.
      f_equal.
      * inversion H.
        destruct H3 as [H3 | [H3 | H3]]; subst;
        try destruct P1; try destruct P2; simpl in *; lma'.
      * apply anticommute_listP_nonempty_equal_len in H0.
        destruct H0. destruct H3.
        setoid_rewrite Mscale_mult_dist_l with (x := -C1).
        apply H1; auto;
          intro H'; rewrite length_zero_iff_nil in H'; contradiction.
Qed.

Lemma anticommute_T_translate_anticomm : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    anticommute_T t1 t2 -> translate(t1) × translate(t2) = -C1 .* (translate(t2) × translate(t1)).
Proof. intros n t1 t2 H H0 H1.
  destruct (anticommute_commute_T_translate t1 t2 H H0); auto.
Qed.

Lemma commute_T_translate_comm : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    commute_T t1 t2 -> translate(t1) × translate(t2) = translate(t2) × translate(t1).
Proof. intros n t1 t2 H H0 H1.
  destruct (anticommute_commute_T_translate t1 t2 H H0); auto.
Qed.


Definition commutingListT {n : nat} (Lt : list (TType n)) :=
  forall t1 t2 : TType n, In t1 Lt -> In t2 Lt -> commute_T t1 t2.

Definition Lt_to_LLp {n : nat} (Lt : list (TType n)) : list (list Pauli) := map snd Lt.

Definition fromLtToCheckMatrixF2 {n : nat} (Lt : list (TType n)) := 
  fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt).

Lemma WF_fromLtToCheckMatrixF2 : forall {n : nat} (Lt : list (TType n)),
  Forall proper_length_TType Lt ->
  WF_MatrixF2 (fromLtToCheckMatrixF2 Lt).
Proof. intros n Lt H.
  unfold fromLtToCheckMatrixF2.
  apply WF_fromLLpToCheckMatrixF2.
  unfold Lt_to_LLp. rewrite map_length. auto.
  unfold Lt_to_LLp.
  rewrite Forall_forall in *.
  intros x H0.
  rewrite in_map_iff in H0.
  destruct H0 as [[c lp] [H0 H1]].
  simpl in *; subst.
  specialize (H (c, x) H1).
  destruct H. simpl in H0.
  lia.
Qed.

Lemma exists_commute_anticommute_T : forall {n : nat} (Lt : list (TType n)),
    Forall proper_length_TType Lt -> Lt <> [] -> n <> 0%nat ->
    linearly_independentF2 ((fromLtToCheckMatrixF2 Lt) ⊤)%F2 ->
    (forall i : nat, (i < length Lt)%nat -> (exists t : TType n, proper_length_TType t /\
       coef_plus_minus_1 t /\ anticommute_T (nth i Lt (defaultT_I n)) t /\
       (forall j : nat, (j < length Lt)%nat -> j <> i -> commute_T (nth j Lt (defaultT_I n)) t))).
Proof. intros n Lt H H0 H1 H2 i H3.
  pose exists_commute_anticommute_Lp as E.
  assert (Forall (fun Lp : list Pauli => length Lp = n) (Lt_to_LLp Lt)).
  { unfold Lt_to_LLp. rewrite Forall_map.
    apply Forall_impl with (P := proper_length_TType); auto.
    intros a H4. destruct H4; auto. }
  assert (Lt_to_LLp Lt <> []).
  { unfold Lt_to_LLp. intro. destruct Lt; try contradiction.
    destruct t. simpl in *. discriminate. }
  assert (n > 0)%nat by lia.
  assert (linearly_independentF2 (transposeF2
           (fromLLpToCheckMatrixF2 (length (Lt_to_LLp Lt)) n (Lt_to_LLp Lt)))).
  { unfold fromLtToCheckMatrixF2 in H2. unfold Lt_to_LLp in *.
    rewrite map_length. auto. }
  assert (i < length (Lt_to_LLp Lt))%nat.
  { unfold Lt_to_LLp. rewrite map_length. auto. }
  specialize (E n (Lt_to_LLp Lt) H4 H5 H6 H7 i H8).
  destruct E as [Lp [lenLp [anticomm_i comm_j]]].
  exists (C1, Lp).
  repeat split; auto; try lia.
  - unfold coef_plus_minus_1. left. auto.
  - simpl. unfold Lt_to_LLp in anticomm_i.
    assert (snd (defaultT_I n) = repeat gI n).
    { unfold defaultT_I. auto. }
    rewrite <- H9 in anticomm_i.
    rewrite map_nth in anticomm_i. auto.
  - simpl. unfold Lt_to_LLp in comm_j.
    assert (snd (defaultT_I n) = repeat gI n).
    { unfold defaultT_I. auto. }
    rewrite map_length in comm_j.
    specialize (comm_j j H9 H10).
    rewrite <- H11 in comm_j.
    rewrite map_nth in comm_j. auto.
Qed.

Lemma commutingListT_iff_checkLambdaF2_is_Zero : forall {n : nat} (Lt : list (TType n)),
    Forall proper_length_TType Lt ->
    (commutingListT Lt <-> 
       ((fromLtToCheckMatrixF2 Lt) ×
         (checkLambdaF2 n) ×
         ((fromLtToCheckMatrixF2 Lt) ⊤) = ZeroF2)%F2).
Proof. intros n Lt H. 
  unfold fromLtToCheckMatrixF2.
  split; intros.
  - unfold commutingListT in H0.
    assert (WF_MatrixF2 (fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt) × checkLambdaF2 n × transposeF2 (fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt)))%F2).
    { apply F2Module.WF_mult. apply F2Module.WF_mult.
      apply WF_fromLLpToCheckMatrixF2.
      unfold Lt_to_LLp. inversion H; auto. simpl. rewrite map_length. auto.
      unfold Lt_to_LLp. clear H0. induction H; auto. simpl. constructor; auto.
      inversion H. lia.
      apply WF_checkLambdaF2.
      apply F2Module.WF_transpose.
      apply WF_fromLLpToCheckMatrixF2.
      unfold Lt_to_LLp. inversion H; auto. simpl. rewrite map_length. auto.
      unfold Lt_to_LLp. clear H0. induction H; auto. simpl. constructor; auto.
      inversion H. lia. }
    prep_matrix_equality.
    bdestruct (x <? (length Lt)).
    + bdestruct (y <? (length Lt)).
      * unfold ZeroF2.
        inversion H.
        -- subst; clear H; simpl in *; lia.
        -- rewrite H6. 
           assert ((fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt) × checkLambdaF2 n
   × transposeF2 (fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt)))%F2 x y =
                  (get_colF2 (get_rowF2 ((fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt) × checkLambdaF2 n
   × transposeF2 (fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt)))%F2) x) y) 0%nat 0%nat).
        { unfold get_rowF2, get_colF2. bdestruct_all. auto. }
        rewrite H7.
        rewrite F2Module.GMmult_assoc.
        rewrite <- F2Module.get_row_mult.
        rewrite <- F2Module.GMmult_assoc.
        rewrite <- F2Module.get_col_mult.
        rewrite <- F2Module.get_row_transpose.
        setoid_rewrite rowF2_fromLLpToCheckMatrixF2.
        pose fromLLpToCheckMatrixF2_checkLambdaF2_comm_iff as e.
        specialize (e (nth x (Lt_to_LLp Lt) (repeat gI n)) (nth y (Lt_to_LLp Lt) (repeat gI n))).        
        assert (length (nth x (Lt_to_LLp Lt) (repeat gI n)) = n).
        { unfold Lt_to_LLp.
          assert (snd (defaultT_I n) = repeat gI n).
          { unfold defaultT_I. auto. }
          rewrite <- H8.
          rewrite map_nth.
          assert (In (nth x Lt (defaultT_I n)) Lt) by (apply nth_In; auto).
          rewrite Forall_forall in H.
          specialize (H (nth x Lt (defaultT_I n)) H9).
          inversion H. auto. }
        assert (length (nth y (Lt_to_LLp Lt) (repeat gI n)) = n).
        { unfold Lt_to_LLp.
          assert (snd (defaultT_I n) = repeat gI n).
          { unfold defaultT_I. auto. }
          rewrite <- H9.
          rewrite map_nth.
          assert (In (nth y Lt (defaultT_I n)) Lt) by (apply nth_In; auto).
          rewrite Forall_forall in H.
          specialize (H (nth y Lt (defaultT_I n)) H10).
          inversion H. auto. }
        rewrite H8, H9 in e.
        rewrite e; auto.
        specialize (H0 (nth x Lt (defaultT_I n)) (nth y Lt (defaultT_I n))).
        assert (In (nth x Lt (defaultT_I n)) Lt).
        { apply nth_In; auto. }
        assert (In (nth y Lt (defaultT_I n)) Lt).
        { apply nth_In; auto. }
        specialize (H0 H10 H11).
        inversion H0.
        unfold Lt_to_LLp.
        setoid_rewrite <- map_nth in H12.
        assert (snd (defaultT_I n) = repeat gI n).
        { unfold defaultT_I. auto. }
        rewrite ! H13 in H12. auto.
        inversion H4; lia.
        unfold Lt_to_LLp.
        rewrite Forall_map.
        apply Forall_impl with (P := proper_length_TType); auto.
        intros a H8.
        inversion H8; auto.
        rewrite <- H6. unfold Lt_to_LLp. simpl. intro H8. inversion H8.
        inversion H4; lia.
        unfold Lt_to_LLp.
        rewrite Forall_map.
        apply Forall_impl with (P := proper_length_TType); auto.
        intros a H8.
        inversion H8; auto.
        rewrite <- H6. unfold Lt_to_LLp. simpl. intro H8. inversion H8.
        inversion H4; lia.
      * rewrite H1; auto.
    + rewrite H1; auto.
  - unfold commutingListT. 
    intros t1 t2 H1 H2.
    inversion H. subst. inversion H1.
    constructor.
    destruct t1, t2; simpl.
    rewrite <- fromLLpToCheckMatrixF2_checkLambdaF2_comm_iff.
    apply In_nth with (d := defaultT_I n) in H1, H2.
    destruct H1 as [a [H1 H6]].
    destruct H2 as [b [H2 H7]].
    unfold ZeroF2 in *.
    apply f_equal_inv with (x := a) in H0.
    apply f_equal_inv with (x := b) in H0.
    assert ((fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt) × checkLambdaF2 n
   × transposeF2 (fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt)))%F2 a b =
                  (get_colF2 (get_rowF2 ((fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt) × checkLambdaF2 n
   × transposeF2 (fromLLpToCheckMatrixF2 (length Lt) n (Lt_to_LLp Lt)))%F2) a) b) 0%nat 0%nat).
        { unfold get_rowF2, get_colF2. bdestruct_all. auto. }
        rewrite H8 in H0.
        rewrite F2Module.GMmult_assoc in H0.
        rewrite <- F2Module.get_row_mult in H0.
        rewrite <- F2Module.GMmult_assoc in H0.
        rewrite <- F2Module.get_col_mult in H0.
        rewrite <- F2Module.get_row_transpose in H0.
        setoid_rewrite rowF2_fromLLpToCheckMatrixF2 in H0.
        unfold Lt_to_LLp in H0.
        assert (snd (defaultT_I n) = repeat gI n).
        { unfold defaultT_I. auto. }
        rewrite <- ! H9 in H0.
        rewrite ! map_nth in H0.
        setoid_rewrite H6 in H0.
        setoid_rewrite H7 in H0.
        simpl in *.
        assert (length l0 = n).
        { assert (In (nth a Lt (defaultT_I n)) Lt) by (apply nth_In; auto).
          rewrite Forall_forall in H.
          specialize (H (nth a Lt (defaultT_I n)) H10).
          inversion H.
          rewrite H6 in H12.
          simpl in H12. auto. }
        rewrite ! H10.
        auto.
        unfold Lt_to_LLp. rewrite Forall_map. 
        apply Forall_impl with (P := proper_length_TType); auto. intros a0 H9.
        inversion H9. auto.
        unfold Lt_to_LLp. rewrite <- H5. simpl. intro H9. inversion H9.
        inversion H3. lia.
        unfold Lt_to_LLp. rewrite Forall_map. 
        apply Forall_impl with (P := proper_length_TType); auto. intros a0 H9.
        inversion H9. auto.
        unfold Lt_to_LLp. rewrite <- H5. simpl. intro H9. inversion H9.
        inversion H3. lia.
        rewrite Forall_forall in H.
        remember H as H'. clear HeqH'.
        specialize (H (c, l0) H1).
        destruct H. simpl in H6.
        specialize (H' (c0, l1) H2).
        destruct H'. simpl in H8.
        subst; lia.
        rewrite Forall_forall in H.
        remember H as H'. clear HeqH'.
        specialize (H (c, l0) H1).
        destruct H. simpl in H6.
        lia.
Qed.


Lemma commutingListT_cons : forall {n : nat} (Lt : list (TType n)) (t : TType n),
    commutingListT (t :: Lt) -> ((forall t' : TType n, In t' Lt -> commute_T t t') /\ commutingListT Lt).
Proof. intros n Lt t. unfold commutingListT. split; intros; apply H; simpl; auto. Qed.

Lemma commutingListT_cons_iff : forall {n : nat} (Lt : list (TType n)) (t : TType n),
    proper_length_TType t ->
    (commutingListT (t :: Lt) <-> ((forall t' : TType n, In t' Lt -> commute_T t t') /\ commutingListT Lt)).
Proof. intros n Lt t H. split. apply commutingListT_cons.
  intros H0. destruct H0.
  unfold commutingListT in *. intros t1 t2 H2 H3. 
  destruct H2, H3; subst; auto.
  - apply self_commute_T; auto.
  - apply commute_T_swap. auto.
Qed.

Lemma commutingListT_Permutation : forall {n : nat} (Lt1 Lt2 : list (TType n)),
    commutingListT Lt1 -> Permutation Lt1 Lt2 -> commutingListT Lt2.
Proof. intros n Lt1 Lt2 H H0.
  unfold commutingListT in *.
  intros t1 t2 H1 H2.
  apply Permutation_sym in H0.
  apply (Permutation_in t1 H0) in H1.
  apply (Permutation_in t2 H0) in H2.
  auto.
Qed.

Lemma fold_right_Mmult_map_translate_Permutation :
  forall {n : nat} (Lt1 Lt2 : list (TType n)),
    commutingListT Lt1 -> Forall proper_length_TType Lt1 -> Permutation Lt1 Lt2 -> 
    fold_right Mmult (I (2 ^ n)%nat) (map translate Lt1) = 
      fold_right Mmult (I (2 ^ n)%nat) (map translate Lt2).
Proof. intros n Lt1 Lt2 H H0 H1.
  induction H1; auto.
  - simpl. f_equal.
    apply commutingListT_cons in H. destruct H.
    rewrite Forall_cons_iff in H0. destruct H0.
    apply IHPermutation; auto.
  - simpl. rewrite <- ! Mmult_assoc.
    apply commutingListT_cons in H. destruct H.
    apply commutingListT_cons in H1. destruct H1.
    rewrite Forall_cons_iff in H0. destruct H0.
    rewrite Forall_cons_iff in H3. destruct H3.
    rewrite commute_T_translate_comm; auto.
    apply H; simpl; auto.
  - rewrite IHPermutation1; auto.
    pose (commutingListT_Permutation l l' H H1_) as H'.
    rewrite IHPermutation2; auto.
    rewrite Forall_forall.
    intros x H1.
    clear H'.
    apply Permutation_sym in H1_.
    apply (Permutation_in x H1_) in H1.
    gen x. rewrite <- Forall_forall. auto.
Qed.


(* (-1)^z *)
Definition neg_powF2 (z : F2) : C :=
  match z with
  | zero => C1
  | one => (- C1)%C
  end.

Lemma neg_powF2_idempotent : forall (z : F2),
    (neg_powF2 z) * (neg_powF2 z) = C1.
Proof. intros z. destruct z; lca. Qed.


Definition projectorT {n : nat} (z : F2) (t : TType n) : Square (2 ^ n) :=
  Matrix.scale (1 / C2) (Matrix.Mplus (translate (defaultT_I n)) (neg_powF2 z .* (translate t))).

Lemma WF_projectorT : forall {n : nat} (z : F2) (t : TType n),
    proper_length_TType t -> WF_Matrix (projectorT z t).
Proof. intros n z t H.
  unfold projectorT.
  apply WF_scale.
  apply WF_plus.
  apply WF_translate.
  unfold proper_length_TType, defaultT_I in *.
  simpl in *. destruct H. split; auto. apply repeat_length.
  apply WF_scale.
  apply WF_translate; auto.
Qed.

Lemma projectorT_comm : forall {n : nat} (z1 z2 : F2) (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    commute_T t1 t2 -> 
    (projectorT z1 t1) × (projectorT z2 t2) = (projectorT z2 t2) × (projectorT z1 t1).
Proof. intros n z1 z2 t1 t2 H H0 H1.
  unfold projectorT. 
  distribute_scale. f_equal.
  distribute_plus. 
  rewrite <- ! Mplus_assoc. f_equal. 
  rewrite ! Mplus_assoc. f_equal.
  rewrite Mplus_comm. f_equal.
  rewrite ! translate_defaultT_I; rewrite ! Mmult_1_l, ! Mmult_1_r; auto with wf_db.
  rewrite ! translate_defaultT_I; rewrite ! Mmult_1_l, ! Mmult_1_r; auto with wf_db.
  distribute_scale.
  rewrite commute_T_translate_comm; auto. f_equal. lca.
Qed.

Lemma projectorT_idempotent : forall {n : nat} (z : F2) (t : TType n),
    proper_length_TType t -> coef_plus_minus_1 t ->
    (projectorT z t) × (projectorT z t) = (projectorT z t).
Proof. intros n z t H H0.
  unfold projectorT.
  distribute_scale. rewrite <- Mscale_assoc.
  f_equal. distribute_plus. distribute_scale.
  rewrite neg_powF2_idempotent. rewrite ! translate_mult_inv; auto.
  rewrite Mscale_1_l. rewrite translate_defaultT_I.
  rewrite Mmult_1_l, Mmult_1_r. lma'.
  apply WF_scale. apply WF_plus.
  apply WF_plus; auto with wf_db.
  apply WF_plus; auto with wf_db.
  auto with wf_db. auto with wf_db.
  apply proper_length_TType_defaultT_I. destruct H; auto.
  apply coef_plus_minus_1_defaultT_I.
Qed.


Definition projectorListT {n : nat} (Lz : list F2) (Lt : list (TType n)) : Square (2 ^ n) :=
  fold_right Mmult (I (2 ^ n)%nat) (zipWith projectorT Lz Lt).

Lemma projectorListT_commutingListT_Permutation :
  forall {n : nat} (Lz1 Lz2 : list F2) (Lt1 Lt2 : list (TType n)),
    commutingListT Lt1 -> Forall proper_length_TType Lt1 -> 
    length Lz1 = length Lt1 -> length Lz2 = length Lt2 -> 
    Permutation (combine Lz1 Lt1) (combine Lz2 Lt2) -> 
    projectorListT Lz1 Lt1 = projectorListT Lz2 Lt2.
Proof. intros n Lz1 Lz2 Lt1 Lt2 H H0 H1 H2 H3.
  unfold projectorListT.
  dependent induction H3.
  - destruct Lz1, Lt1; destruct Lz2, Lt2; simpl in *;
      try reflexivity; try discriminate.
  - unfold zipWith.
    destruct Lz1, Lt1; destruct Lz2, Lt2; simpl in *;
      try discriminate.
    f_equal.
    inversion x1. inversion x. subst. inversion H7; subst. auto.
    apply IHPermutation; auto.
    apply commutingListT_cons in H; destruct H; auto.
    rewrite Forall_cons_iff in H0; destruct H0; auto.
    inversion x1. auto.
    inversion x. auto.
  - destruct Lz1, Lt1; destruct Lz2, Lt2; simpl in *;
      try discriminate.
    destruct Lz1, Lt1; destruct Lz2, Lt2; simpl in *;
      try discriminate.
    unfold uncurry; simpl. rewrite <- ! Mmult_assoc.
    rewrite (projectorT_comm f f1 t t1).
    inversion x1. inversion x. subst. 
    inversion H7. inversion H8. subst. rewrite H9. auto.
    rewrite Forall_cons_iff in H0. destruct H0.
    rewrite Forall_cons_iff in H3. destruct H3. auto.
    rewrite Forall_cons_iff in H0. destruct H0.
    rewrite Forall_cons_iff in H3. destruct H3. auto.
    apply commutingListT_cons in H. destruct H. apply H; simpl; auto.
  - destruct (split l') eqn:E.
    rewrite <- (split_combine l' E) in *; auto.
    rewrite IHPermutation1 with (Lz2 := l) (Lt2 := l0); auto.
    rewrite IHPermutation2 with (Lz2 := Lz2) (Lt2 := Lt2); auto.
    remember H3_ as H3_'. clear HeqH3_'. 
    apply Permutation_map with (f := snd) in H3_'.
    rewrite ! map_snd_combine in H3_'; auto. apply Permutation_sym in H3_'.
    unfold commutingListT in *. intros t1 t2 H3 H4. apply H.
    apply Permutation_in with (l := l0); auto.
    apply Permutation_in with (l := l0); auto.
    pose (split_length_l l') as e1. rewrite E in e1. simpl in e1.
    pose (split_length_r l') as e2. rewrite E in e2. simpl in e2. rewrite e1, e2; auto.
    remember H3_ as H3_'. clear HeqH3_'. 
    apply Permutation_map with (f := snd) in H3_'.
    rewrite ! map_snd_combine in H3_'; auto. apply Permutation_sym in H3_'.
    rewrite Forall_forall in *. intros x H3. apply H0. apply Permutation_in with (l := l0); auto.
    pose (split_length_l l') as e1. rewrite E in e1. simpl in e1.
    pose (split_length_r l') as e2. rewrite E in e2. simpl in e2. rewrite e1, e2; auto.
    pose (split_length_l l') as e1. rewrite E in e1. simpl in e1.
    pose (split_length_r l') as e2. rewrite E in e2. simpl in e2. rewrite e1, e2; auto.
    pose (split_length_l l') as e1. rewrite E in e1. simpl in e1.
    pose (split_length_r l') as e2. rewrite E in e2. simpl in e2. rewrite e1, e2; auto.
Qed.

Lemma WF_projectorListT : forall {n : nat} (Lz : list F2) (Lt : list (TType n)),
    length Lz = length Lt -> Forall proper_length_TType Lt ->
    WF_Matrix (projectorListT Lz Lt).
Proof. intros n Lz Lt H H0.
  unfold projectorListT.
  unfold zipWith, uncurry.
  gen Lz. induction Lt as [| t Lt]; intros.
  - simpl in *. rewrite length_zero_iff_nil in H. subst. simpl. auto with wf_db.
  - destruct Lz as [| z Lz]. inversion H.
    simpl in *.
    rewrite Forall_cons_iff in H0. destruct H0.
    apply Nat.succ_inj in H.
    specialize (IHLt H1 Lz H).
    apply WF_mult; auto.
    apply WF_projectorT; auto.
Qed.

Lemma projectorListT_cons : forall {n : nat} (Lz : list F2) (Lt : list (TType n)) (z : F2) (t : TType n),
    (projectorListT (z :: Lz) (t :: Lt)) = (projectorT z t) × (projectorListT Lz Lt).
Proof. intros n Lz Lt z t.
  unfold projectorListT. auto.
Qed.

Lemma projectorListT_singleton : forall {n : nat} (z : F2) (t : TType n),
    proper_length_TType t -> projectorListT [z] [t] = projectorT z t.
Proof. intros n z t H.
  unfold projectorListT.
  unfold zipWith, uncurry. simpl.
  rewrite Mmult_1_r; auto.
  apply WF_projectorT; auto.
Qed.

Lemma projectorListT_app : forall {n : nat} (Lz1 Lz2 : list F2) (Lt1 Lt2 : list (TType n)),
    length Lz1 = length Lt1 -> length Lz2 = length Lt2 ->
    Forall proper_length_TType Lt2 ->
    (projectorListT (Lz1 ++ Lz2) (Lt1 ++ Lt2)) = 
      (projectorListT Lz1 Lt1) × (projectorListT Lz2 Lt2).
Proof. intros n Lz1 Lz2 Lt1 Lt2 H H0 H1.
  unfold projectorListT.
  unfold zipWith. rewrite combine_app; auto.
  rewrite map_app.
  rewrite fold_right_Mmult_I_app; auto.
  clear H Lz1 Lt1.
  gen Lz2. induction Lt2; intros.
  - rewrite combine_nil. simpl. constructor.
  - destruct Lz2; try discriminate.
    rewrite Forall_cons_iff in H1. destruct H1.
    simpl. constructor.
    + unfold uncurry. simpl. 
      apply WF_projectorT. auto.
    + apply IHLt2; auto.
Qed.

Lemma projector_span_stabilized_space : forall {n : nat} (t : TType n),
    proper_length_TType t -> coef_plus_minus_1 t -> n <> 0%nat ->
    (forall v : Vector (2 ^ n)%nat, 
        @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorT zero t) v <-> 
          stabilizeByListT (fun v => WF_Matrix v) [t] v).
Proof. intros n t H H0 H1 v. 
  unfold CM.span, stabilizeByListT.
  unfold projectorT.
  unfold neg_powF2; simpl.
  rewrite Mscale_1_l.
  split; intros.
  - destruct H2 as [a [WFa H2]].
    split; auto; intros.
    + assert (CM.WF_GenMatrix a = @WF_Matrix (2 ^ n)%nat 1%nat a) by auto.
      assert (CM.GMmult (C1 / C2 .* (translate (defaultT_I n) .+ translate t)) a =
                Mmult (C1 / C2 .* (translate (defaultT_I n) .+ translate t)) a) by auto.
      rewrite H2, H4. rewrite H3 in WFa.
      apply WF_mult; auto. apply WF_scale; auto. apply WF_plus; auto.
      all: apply WF_translate; auto. unfold defaultT_I. 
      split; simpl; auto. rewrite repeat_length; auto.
    + destruct H3; subst; try contradiction.
    rewrite translate_defaultT_I.
    assert (@CM.GMmult (2 ^ n) (2 ^ n) 1%nat (C1 / C2 .* (I (2 ^ n) .+ translate t0)) a = 
              @Mmult (2 ^ n) (2 ^ n) 1%nat (C1 / C2 .* (I (2 ^ n) .+ translate t0)) a)
      by auto.
    rewrite H2.
    rewrite <- Mmult_assoc. f_equal.
    distribute_scale. f_equal.
    rewrite Mmult_plus_distr_l.
    rewrite translate_mult_inv; auto.
    rewrite Mmult_1_r. apply Mplus_comm.
    apply WF_translate; auto.
  - destruct H2 as [WFv H2].
    assert (H' : t = t \/ False) by auto.
    specialize (H2 t H'). clear H'.
    unfold proper_length_TType, coef_plus_minus_1 in *.
    destruct H.
    exists v. split.
    assert (CM.WF_GenMatrix v = WF_Matrix v) by auto.
    rewrite H4; auto.
    assert (CM.GMmult (C1 / C2 .* (translate (defaultT_I n) .+ translate t)) v =
              Mmult (C1 / C2 .* (translate (defaultT_I n) .+ translate t)) v) by auto.
    rewrite H4.
    distribute_scale.
    distribute_plus.
    rewrite H2.
    rewrite translate_defaultT_I.
    rewrite Mmult_1_l; auto.
    lma'.
Qed.
  
Lemma projectorListT_span_stabilized_space : forall {n : nat} (Lt : list (TType n)),
    commutingListT Lt ->
    Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt -> n <> 0%nat ->
    (forall v : Vector (2 ^ n)%nat, 
        @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT (repeat zero (length Lt)) Lt) v <-> 
          stabilizeByListT (fun v => WF_Matrix v) Lt v).
Proof. intros n Lt commutingListTLt H H0 H1 v. 
  split; intros.
  - gen v. induction Lt as [| t Lt]; intros.
    + unfold stabilizeByListT, projectorListT in *. simpl in *.
      unfold CM.span in H2.
      destruct H2 as [a [WFa va]].
      assert (CM.WF_GenMatrix a = WF_Matrix a) by auto.
      assert (CM.GMmult (I (2 ^ n)) a = Mmult (I (2 ^ n)) a) by auto.
      rewrite H3 in va. rewrite H2 in WFa.
      rewrite Mmult_1_l in va; auto. subst.
      split; auto. intros t H4. contradiction. 
    + simpl in *. unfold CM.span in H2.
      destruct H2 as [a [WFa va]].
      assert (CM.WF_GenMatrix a = WF_Matrix a) by auto.
      assert (CM.GMmult (projectorListT (0%F2 :: repeat 0%F2 (length Lt)) (t :: Lt)) a =
                Mmult (projectorListT (0%F2 :: repeat 0%F2 (length Lt)) (t :: Lt)) a) by auto.
      rewrite H2 in WFa. rewrite H3 in va. clear H2 H3.
      remember H as proper_length_TType_Lt'. clear Heqproper_length_TType_Lt'.
      rewrite Forall_cons_iff in H. destruct H.
      remember H0 as coef_plus_minus_1_Lt'. clear Heqcoef_plus_minus_1_Lt'.
      rewrite Forall_cons_iff in H0. destruct H0.
      remember commutingListTLt as commutingListTLt'. clear HeqcommutingListTLt'.
      apply commutingListT_cons in commutingListTLt. 
      destruct commutingListTLt as [commute_t commutingListTLt].
      specialize (IHLt commutingListTLt H2 H3).
      unfold CM.span in IHLt.
      split.
      * rewrite projectorListT_cons in va.
        rewrite va. apply WF_mult; auto.
        apply WF_mult.
        apply WF_projectorT; auto.
        apply WF_projectorListT; auto.
        rewrite repeat_length; auto.
      * intros t0 H4. destruct H4; subst.
        -- rewrite projectorListT_cons.
           pose (projector_span_stabilized_space t0 H H0 H1) as e.
           unfold CM.span in e.
           specialize (e (projectorT 0%F2 t0 × projectorListT (repeat 0%F2 (length Lt)) Lt × a)).
           assert (exists a0 : CM.GenMatrix (2 ^ n) 1,
                      CM.WF_GenMatrix a0 /\
                        @Mmult (2 ^ n) (2 ^ n) 1 (@Mmult (2 ^ n) (2 ^ n) 1 (projectorT 0%F2 t0) (projectorListT (repeat 0%F2 (length Lt)) Lt)) a =
         @CM.GMmult (2 ^ n) (2 ^ n) 1 (projectorT 0%F2 t0) a0).
           { exists (@Mmult (2 ^ n) (2 ^ n) 1 (projectorListT (repeat 0%F2 (length Lt)) Lt) a).
             split.
             - assert (CM.WF_GenMatrix (@Mmult (2 ^ n) (2 ^ n) 1 (projectorListT (repeat 0%F2 (length Lt)) Lt) a) = 
                         WF_Matrix (projectorListT (repeat 0%F2 (length Lt)) Lt × a)) by auto.
               rewrite H4. apply WF_mult; auto.
               apply WF_projectorListT; auto. rewrite repeat_length; auto.
             - assert (CM.GMmult (projectorT 0%F2 t0) (@Mmult (2 ^ n) (2 ^ n) 1 (projectorListT (repeat 0%F2 (length Lt)) Lt) a) = Mmult (projectorT 0%F2 t0) (projectorListT (repeat 0%F2 (length Lt)) Lt × a)) by auto.
               rewrite H4. rewrite <- Mmult_assoc. auto. }
           rewrite e in H4.
           unfold stabilizeByListT in H4.
           destruct H4. specialize (H5 t0). apply H5; simpl; auto.
        -- remember H4 as t0_in_Lt. clear Heqt0_in_Lt.
          apply In_nth with (d := defaultT_I n) in H4.
           destruct H4 as [k [k_bounded nth_k_Lt]].
           rewrite (nth_inc k Lt (defaultT_I n)) at 2; auto.
           rewrite (nth_inc k Lt (defaultT_I n)) at 6; auto.
           rewrite nth_k_Lt.
           assert (Permutation (combine (0%F2 :: repeat 0%F2 (length Lt))
                                        (t :: firstn k Lt ++ [t0] ++ skipn (S k) Lt))
                     (combine (0%F2 :: repeat 0%F2 (length Lt))
                              (t0 :: firstn k Lt ++ [t] ++ skipn (S k) Lt))).
           { replace (length Lt) with (k + (1%nat + ((length Lt) - (S k))))%nat by lia.
             rewrite ! repeat_app. rewrite ! combine_cons. rewrite ! combine_app.
             setoid_rewrite cons_conc at 1. setoid_rewrite cons_conc at 7.
             rewrite ! app_assoc. apply Permutation_app_tail.
             rewrite <- ! app_assoc. apply Permutation_app_middle.
             apply Permutation_app_comm.
             auto. rewrite repeat_length. rewrite firstn_length_le; try lia.
             rewrite repeat_length. auto.
             rewrite repeat_length. rewrite firstn_length_le; try lia. }
           rewrite projectorListT_commutingListT_Permutation
             with (Lz2 := (0%F2 :: repeat 0%F2 (length Lt)))
                  (Lt2 := (t0 :: firstn k Lt ++ [t] ++ skipn (S k) Lt)); auto.
           rewrite projectorListT_cons.
           pose (projector_span_stabilized_space t0) as E.
           assert (proper_length_TType t0).
           { rewrite Forall_forall in H2. apply H2; auto. }
           assert (coef_plus_minus_1 t0).
           { rewrite Forall_forall in H3. apply H3; auto. }
           specialize (E H5 H6 H1 
                         (projectorT 0%F2 t0 × projectorListT (repeat 0%F2 (length Lt))
                            (firstn k Lt ++ [t] ++ skipn (S k) Lt) × a)).
           assert (@CM.span (2 ^ n) (2 ^ n) (projectorT 0%F2 t0)
                     (@Mmult (2 ^ n) (2 ^ n) 1%nat 
                        (@Mmult (2 ^ n) (2 ^ n) (2 ^ n) (projectorT 0%F2 t0)
                        (projectorListT (repeat 0%F2 (length Lt))
                        (firstn k Lt ++ [t] ++ skipn (S k) Lt))) a)).
           { unfold CM.span. 
             exists (@Mmult (2 ^ n) (2 ^ n) 1%nat (projectorListT (repeat 0%F2 (length Lt))
                  (firstn k Lt ++ [t] ++ skipn (S k) Lt)) a).
             split.
             assert ((@CM.WF_GenMatrix (2 ^ n) 1%nat
                       (@Mmult (2 ^ n) (2 ^ n) 1%nat (projectorListT (repeat 0%F2 (length Lt))
                          (firstn k Lt ++ [t] ++ skipn (S k) Lt)) a)) = 
                      @WF_Matrix (2 ^ n) 1%nat
                        (@Mmult (2 ^ n) (2 ^ n) 1%nat (projectorListT (repeat 0%F2 (length Lt))
                           (firstn k Lt ++ [t] ++ skipn (S k) Lt)) a)) by auto.
             rewrite H7. apply WF_mult; auto.
             apply WF_projectorListT.
             rewrite repeat_length. rewrite ! app_length.
             rewrite firstn_length_le; try lia. rewrite skipn_length. simpl. lia.
             rewrite ! Forall_app.
             rewrite (nth_inc k Lt (defaultT_I n)) in H2; auto.
             rewrite ! Forall_app in H2.
             destruct H2 as [H2 [H2' H2'']]. auto.
             assert (@CM.GMmult (2 ^ n) (2 ^ n) 1%nat (projectorT 0%F2 t0)
                       (@Mmult (2 ^ n) (2 ^ n) 1%nat (projectorListT (repeat 0%F2 (length Lt))
                          (firstn k Lt ++ [t] ++ skipn (S k) Lt)) a) =
                       Mmult (projectorT 0%F2 t0)
                       (projectorListT (repeat 0%F2 (length Lt))
                          (firstn k Lt ++ [t] ++ skipn (S k) Lt) × a)) by auto.
             rewrite H7. rewrite <- Mmult_assoc. auto. }
           rewrite E in H7.
           unfold stabilizeByListT in H7.
           destruct H7.
           assert (In t0 [t0]) by (simpl; auto).
           specialize (H8 t0 H9). auto.
           rewrite <- nth_k_Lt. rewrite <- nth_inc; auto.
           rewrite <- nth_k_Lt. rewrite <- nth_inc; auto.
           rewrite <- nth_k_Lt. rewrite <- nth_inc; auto.
           simpl. rewrite repeat_length; lia.
           simpl. f_equal.  rewrite app_length. simpl. 
           rewrite firstn_length_le; try lia.
           replace (match Lt with
             | [] => []
             | _ :: l => skipn k l
             end) with (skipn (S k) Lt) by auto.
           rewrite skipn_length. rewrite repeat_length. lia.
  - unfold stabilizeByListT in *.
    destruct H2.
    unfold CM.span.
    gen v. induction Lt; intros.
    + unfold projectorListT.
      simpl. exists v. split.
      assert (CM.WF_GenMatrix v = WF_Matrix v) by auto.
      rewrite H4; auto.
      assert (CM.GMmult (I (2 ^ n)) v = Mmult (I (2 ^ n)) v) by auto.
      rewrite H4. rewrite Mmult_1_l; auto.
    + remember H3 as H3'. clear HeqH3'.
      assert (In a (a :: Lt)) by (simpl; auto).
      specialize (H3' a H4).
      pose (projector_span_stabilized_space a) as E.
      remember commutingListTLt as commutingListTLt'. clear HeqcommutingListTLt'.
      apply commutingListT_cons in commutingListTLt'. destruct commutingListTLt'.
      remember H as H'. clear HeqH'.
      rewrite Forall_cons_iff in H'. destruct H'.
      remember H0 as H0'. clear HeqH0'.
      rewrite Forall_cons_iff in H0'. destruct H0'.
      specialize (E H7 H9 H1 v).
      assert (stabilizeByListT (fun v : Vector (2 ^ n) => WF_Matrix v) [a] v).
      { unfold stabilizeByListT. split; auto. intros t H11.
        apply H3. simpl in *. destruct H11; try contradiction. auto. }
      rewrite <- E in H11.
      unfold CM.span in H11.
      destruct H11 as [b [WFb vb]].
      assert (CM.WF_GenMatrix b = WF_Matrix b) by auto.
      rewrite H11 in WFb.
      assert (CM.GMmult (projectorT 0%F2 a) b =
                Mmult (projectorT 0%F2 a) b) by auto.
      remember vb as vb'. clear Heqvb'.
      rewrite H12 in vb, vb'.
      rewrite <- projectorT_idempotent in vb; auto.
      rewrite Mmult_assoc in vb.
      rewrite <- vb' in vb.
      assert (forall t : TType n, In t Lt -> translate t × v = v).
      { intros t H13. apply H3; simpl; auto. }
      specialize (IHLt H6 H8 H10 v H2 H13).
      destruct IHLt as [u [WFu vu]].
      exists u. split; auto.
      assert (CM.GMmult (projectorListT (repeat 0%F2 (length (a :: Lt))) (a :: Lt)) u = 
                Mmult (projectorListT (repeat 0%F2 (length (a :: Lt))) (a :: Lt)) u) by auto.
      rewrite H14.
      simpl. rewrite projectorListT_cons. 
      assert (CM.GMmult (projectorListT (repeat 0%F2 (length Lt)) Lt) u =
                Mmult (projectorListT (repeat 0%F2 (length Lt)) Lt) u) by auto.
      rewrite H15 in vu.
      rewrite Mmult_assoc.
      rewrite <- vu; auto.
Qed.

Lemma anticommute_T_flipF2_projectorT : forall {n : nat} (z : F2) (t t' : TType n),
    proper_length_TType t -> proper_length_TType t' ->
    coef_plus_minus_1 t -> anticommute_T t t' ->
    (translate t) × (projectorT z t') × (translate t)† = projectorT (z+1)%F2 t'.
Proof. intros n z t t' H H0 H1 H2.
  unfold projectorT.
  rewrite translate_adjoint_eq; auto.
  apply anticommute_T_translate_anticomm in H2; auto.
  distribute_scale. f_equal.
  distribute_plus. distribute_scale. rewrite H2. distribute_scale.
  rewrite <- translate_defaultT_I_comm; auto.
  rewrite ! Mmult_assoc. rewrite ! translate_mult_inv; auto.
  rewrite ! Mmult_1_r. f_equal. f_equal.
  unfold neg_powF2. destruct z; simpl; lca.
  apply WF_translate; auto.
  apply WF_translate. apply proper_length_TType_defaultT_I.
  destruct H; auto.
Qed.

Lemma commute_T_projectorT_commute : forall {n : nat} (z : F2) (t t' : TType n),
    proper_length_TType t -> proper_length_TType t' -> commute_T t t' ->
    (translate t) × (projectorT z t') = (projectorT z t') × (translate t).
Proof. intros n z t t' H H0 H1.
  unfold projectorT.
  apply commute_T_translate_comm in H1; auto.
  distribute_scale. f_equal.
  distribute_plus. distribute_scale. rewrite H1.
  rewrite <- translate_defaultT_I_comm; auto.
Qed.

Lemma commute_T_commute_projectorListT : 
  forall {n : nat} (t : TType n) (Lz : list F2) (Lt : list (TType n)),
    length Lz = length Lt -> (forall t' : TType n, In t' Lt -> commute_T t t') ->
    Forall proper_length_TType Lt ->
    proper_length_TType t -> coef_plus_minus_1 t ->
    (forall j : nat, (j < length Lt)%nat -> commute_T (nth j Lt (defaultT_I n)) t) ->
    (translate t) × (projectorListT Lz Lt) = (projectorListT Lz Lt) × (translate t).
Proof. intros n t Lz Lt H H0 H1 H2 H3.
  gen Lz. induction Lt; intros.
  - destruct Lz; try discriminate. unfold projectorListT, projectorT. simpl.
    rewrite Mmult_1_l, Mmult_1_r; auto.
    all : apply WF_translate; auto.
  - destruct Lz; try discriminate. simpl in H.
    apply Nat.succ_inj in H.
    rewrite projectorListT_cons.
    remember H0 as H0'. clear HeqH0'.
    assert (In a (a :: Lt)) by (simpl; auto).
    specialize (H0' a H5).
    remember H1 as H1'. clear HeqH1'.
    rewrite Forall_cons_iff in H1'. destruct H1'.
    apply commute_T_translate_comm in H0'; auto.
    rewrite <- Mmult_assoc.
    rewrite commute_T_projectorT_commute; auto.
    rewrite ! Mmult_assoc. f_equal.
    apply IHLt; auto.
    + intros t' H8. apply H0. simpl; auto.
    + intros j H8. assert (S j < length (a :: Lt))%nat by (simpl; lia).
      specialize (H4 (S j) H9). simpl in H4. auto.
Qed.

Lemma exists_commute_anticommute_T_flip_nthF2_projectorListT : 
  forall {n : nat} (k : nat) (Lz : list F2) (Lt : list (TType n)),
    (k < length Lt)%nat -> length Lz = length Lt -> Forall proper_length_TType Lt ->
(forall i : nat, (i < length Lt)%nat -> (exists t : TType n, proper_length_TType t /\
       coef_plus_minus_1 t /\ anticommute_T (nth i Lt (defaultT_I n)) t /\
       (forall j : nat, (j < length Lt)%nat -> j <> i -> commute_T (nth j Lt (defaultT_I n)) t))) ->
(exists t : TType n,
    proper_length_TType t /\
      coef_plus_minus_1 t /\ anticommute_T (nth k Lt (defaultT_I n)) t /\
      (forall j : nat, (j < length Lt)%nat -> j <> k -> commute_T (nth j Lt (defaultT_I n)) t) /\
    projectorListT (firstn k Lz) (firstn k Lt)
    × (projectorT (nth k Lz 0 + 1)%F2 (nth k Lt (defaultT_I n))
       × projectorListT (skipn (S k) Lz) (skipn (S k) Lt)) =
    translate t
    × (projectorListT (firstn k Lz) (firstn k Lt)
       × (projectorT (nth k Lz 0%F2) (nth k Lt (defaultT_I n))
          × projectorListT (skipn (S k) Lz) (skipn (S k) Lt))) × 
    (translate t)†).
Proof. intros n k Lz Lt H H0 H1 H2. 
  destruct  (H2 k H) as [t [pltT [coefT [anticommT commT]]]].
  exists t. rewrite translate_adjoint_eq; auto.
  repeat (split; auto).
  rewrite ! Mmult_assoc.
  rewrite <- commute_T_commute_projectorListT; auto.
  rewrite <- ! Mmult_assoc.
  rewrite commute_T_commute_projectorListT; auto.
  assert (projectorListT (firstn k Lz) (firstn k Lt) × translate t
  × projectorT (nth k Lz 0%F2) (nth k Lt (defaultT_I n)) × 
  translate t × projectorListT (skipn (S k) Lz) (skipn (S k) Lt) = 
            projectorListT (firstn k Lz) (firstn k Lt) × (translate t
              × projectorT (nth k Lz 0%F2) (nth k Lt (defaultT_I n)) × 
              translate t) × projectorListT (skipn (S k) Lz) (skipn (S k) Lt)).
  { rewrite ! Mmult_assoc. auto. }
  rewrite H3.
  rewrite <- translate_adjoint_eq at 2; auto.
  rewrite anticommute_T_flipF2_projectorT; auto.
  - apply Forall_nth; auto.
  - apply anticommute_T_swap. auto.
  - rewrite ! firstn_length_le; auto; lia.
  - intros t' H3.  apply In_nth with (d := defaultT_I n) in H3.
    destruct H3 as [j [jbound nthj]].
    rewrite <- nthj.
    rewrite firstn_length in jbound. rewrite nth_firstn; try lia.
    apply commute_T_swap. apply commT; lia.
  - rewrite <- (firstn_skipn k Lt) in H1.
    rewrite Forall_app in H1. destruct H1. auto.
  - intros j H3. rewrite firstn_length in H3.
    rewrite nth_firstn with (d := defaultT_I n); try lia.
    apply commT; try lia.
  - rewrite ! skipn_length. rewrite H0. auto.
  - intros t' H3. apply In_nth with (d := defaultT_I n) in H3.
    destruct H3 as [j [jbound nthj]].
    rewrite nth_skipn in nthj. rewrite <- nthj.
    apply commute_T_swap. 
    rewrite skipn_length in jbound. apply commT; lia.
  - rewrite <- (firstn_skipn (S k) Lt) in H1.
    rewrite Forall_app in H1. destruct H1. auto.
  - intros j H3. rewrite ! skipn_length in H3. 
    rewrite nth_skipn. apply commT; lia.
Qed.

Lemma flip_nthF2_projectorListT : forall {n : nat} (Lz : list F2) (Lt : list (TType n)) (k : nat),
  linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat -> Lt <> [] ->
  length Lz = length Lt -> Forall proper_length_TType Lt -> (k < length Lt)%nat -> 
  exists t : TType n, 
    proper_length_TType t /\
      coef_plus_minus_1 t /\ anticommute_T (nth k Lt (defaultT_I n)) t /\
      (forall j : nat, (j < length Lt)%nat -> j <> k -> commute_T (nth j Lt (defaultT_I n)) t) /\
    projectorListT (firstn k Lz ++ [((nth k Lz zero) + 1)%F2] ++ skipn (S k) Lz) Lt = 
      (translate t) × (projectorListT Lz Lt) × (translate t)†.
Proof. intros n Lz Lt k H H0 H1 H2 H3 H4. 
  setoid_rewrite (nth_inc k Lt (defaultT_I n)) at 4.
  setoid_rewrite (nth_inc k Lt (defaultT_I n)) at 7.
  setoid_rewrite (nth_inc k Lz zero) at 4.
  rewrite ! projectorListT_app.
  rewrite ! projectorListT_singleton.
  apply exists_commute_anticommute_T_flip_nthF2_projectorListT; auto.
  - apply exists_commute_anticommute_T; auto.
  - apply Forall_nth; auto.
  - apply Forall_nth; auto.
  - auto.
  - rewrite ! skipn_length. rewrite H2. auto.
  - rewrite <- (firstn_skipn (S k) Lt) in H3.
    rewrite Forall_app in H3. destruct H3. auto.
  - rewrite ! firstn_length. rewrite H2. auto.
  - rewrite ! app_length, ! skipn_length, H2. auto.
  - rewrite Forall_app. split.
    + constructor. rewrite Forall_nth in H3. apply H3; auto. constructor.
    + rewrite <- (firstn_skipn (S k) Lt) in H3.
      rewrite Forall_app in H3. destruct H3. auto.
  - auto.
  - rewrite ! skipn_length. rewrite H2. auto.
  - rewrite <- (firstn_skipn (S k) Lt) in H3.
    rewrite Forall_app in H3. destruct H3. auto.
  - rewrite ! firstn_length. rewrite H2. auto.
  - rewrite ! app_length, ! skipn_length, H2. auto.
  - rewrite Forall_app. split.
    + constructor. rewrite Forall_nth in H3. apply H3; auto. constructor.
    + rewrite <- (firstn_skipn (S k) Lt) in H3.
      rewrite Forall_app in H3. destruct H3. auto.
  - rewrite H2. auto.
  - auto.
  - auto.
Qed.

Lemma set_nthF2_projectorListT : forall {n : nat} (Lz : list F2) (Lt : list (TType n)) (k : nat) (z : F2),
  linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat -> Lt <> [] ->
  length Lz = length Lt -> Forall proper_length_TType Lt -> (k < length Lt)%nat -> 
  exists t : TType n, 
    proper_length_TType t /\
      coef_plus_minus_1 t /\ 
      (forall j : nat, (j < length Lt)%nat -> j <> k -> commute_T (nth j Lt (defaultT_I n)) t) /\
    projectorListT (firstn k Lz ++ [z] ++ skipn (S k) Lz) Lt = 
      (translate t) × (projectorListT Lz Lt) × (translate t)†.
Proof. intros n Lz Lt k z H H0 H1 H2 H3 H4.
  destruct (F2eq_dec z (nth k Lz zero)) as [e | e].
  - rewrite e. rewrite <- nth_inc. exists (defaultT_I n).
    split; [idtac | split; [idtac | split]].
    + apply proper_length_TType_defaultT_I; auto.
    + apply coef_plus_minus_1_defaultT_I.
    + intros j H5 H6. apply commute_T_defaultT_I.
      apply Forall_nth; auto.
    + rewrite translate_defaultT_I.
      rewrite id_adjoint_eq.
      rewrite Mmult_1_l, Mmult_1_r; auto.
      all: apply WF_projectorListT; auto.
    + rewrite H2. auto.
  - assert (z = (nth k Lz 0) + 1)%F2.
    { destruct z, (nth k Lz 0%F2); auto; contradiction. }
    rewrite H5.
    destruct (flip_nthF2_projectorListT Lz Lt k H H0 H1 H2 H3 H4)
      as [t [H6 [H7 [H8 [H9 H10]]]]].
    exists t. auto.
Qed.

Lemma set_listF2_projectorListT_firstn : forall {n : nat} (Lz : list F2) (Lt : list (TType n)) (k : nat),
  linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat -> Lt <> [] ->
  length Lz = length Lt -> Forall proper_length_TType Lt -> 
  exists t : TType n, proper_length_TType t /\ coef_size_1 t /\
    (projectorListT ((firstn k Lz) ++ (repeat zero ((length Lt) - k)%nat)) Lt) = 
      (translate t) × (projectorListT (repeat zero (length Lt)) Lt) × (translate t)†.
Proof. intros n Lz Lt k H H0 H1 H2 H3. 
  induction k.
  - simpl. rewrite Nat.sub_0_r.
    exists (defaultT_I n). 
    rewrite translate_defaultT_I.
    rewrite id_adjoint_eq.
    rewrite Mmult_1_l, Mmult_1_r; auto.
    all: try apply WF_projectorListT; try rewrite repeat_length; auto.
    split; auto. apply proper_length_TType_defaultT_I; auto.
    split; auto. apply coef_size_1_defaultT_I.
  - destruct IHk as [t [proper_len_t [coef_size_1_t H4]]].
    bdestruct (k <? length Lt).
    + assert (length (firstn k Lz ++ repeat 0%F2 (length Lt - k)) = length Lt).
      { rewrite app_length, firstn_length, repeat_length, H2. minmax_breakdown. lia. }
      destruct (set_nthF2_projectorListT (firstn k Lz ++ repeat 0%F2 (length Lt - k)) Lt k (nth k Lz zero) H H0 H1 H6 H3 H5)
        as [t0 [H7 [H8 [H9 H10]]]].
      assert (firstn k (firstn k Lz ++ repeat 0%F2 (length Lt - k)) ++
           [nth k Lz 0%F2] ++
           skipn (S k) (firstn k Lz ++ repeat 0%F2 (length Lt - k)) = 
                firstn (S k) Lz ++ repeat 0%F2 (length Lt - (S k))).
      { rewrite firstn_app. rewrite skipn_app. rewrite skipn_firstn_comm.
        rewrite firstn_length. minmax_breakdown.
        replace (k - k)%nat with 0%nat by lia.
        replace (k - S k)%nat with 0%nat by lia. 
        replace (S k - k)%nat with 1%nat by lia. 
        replace (length Lt - k)%nat with (1%nat + (length Lt - S k))%nat by lia.
        simpl. rewrite app_nil_r. rewrite cons_conc. rewrite app_assoc. f_equal.
        rewrite firstn_firstn. minmax_breakdown.
        replace (match Lz with
                 | [] => []
                 | a :: l => a :: firstn k l
                 end) with (firstn (S k) Lz) by (simpl; auto).
        apply firstn_last_nth_app; lia. }
      rewrite H11 in H10.
      exists (gMulT t0 t).
      rewrite ! translate_gMulT_mult; auto.
      rewrite Mmult_adjoint.
      assert (translate t0 × translate t × projectorListT (repeat 0%F2 (length Lt)) Lt
                × (adjoint (translate t) × adjoint (translate t0)) = 
                translate t0 × (translate t × projectorListT (repeat 0%F2 (length Lt)) Lt
                  × adjoint (translate t)) × adjoint (translate t0)).
      { rewrite ! Mmult_assoc. auto. }
      rewrite H12.
      rewrite <- H4. rewrite <- H10.
      split; auto. apply proper_length_TType_gMulT; auto.
      split; auto. apply coef_size_1_gMultT_preserve; auto.
      apply coef_plus_minus_1_implies_coef_size_1; auto.
    + exists t. rewrite ! firstn_all2; try lia. rewrite <- H4. 
      rewrite firstn_all2; try lia.
      replace (length Lt - S k)%nat with 0%nat by lia.
      replace (length Lt - k)%nat with 0%nat by lia.
      split; auto.
Qed.

Lemma set_listF2_projectorListT : forall {n : nat} (Lz : list F2) (Lt : list (TType n)),
  linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat -> Lt <> [] ->
  length Lz = length Lt -> Forall proper_length_TType Lt -> 
  exists t : TType n, proper_length_TType t /\ coef_size_1 t /\
    (projectorListT Lz Lt) = 
      (translate t) × (projectorListT (repeat zero (length Lt)) Lt) × (translate t)†.
Proof. intros n Lz Lt H H0 H1 H2 H3.
  destruct (set_listF2_projectorListT_firstn Lz Lt (length Lz) H H0 H1 H2 H3)
    as [t [proper_len_t H4]].
  rewrite firstn_all in H4. rewrite H2 in H4.
  replace (length Lt - length Lt)%nat with 0%nat in H4 by lia. simpl in H4.
  rewrite app_nil_r in H4.
  exists t. split; auto.
Qed.

Lemma projectorListT_equal_rank : forall {n : nat} (d : nat) (Lz : list F2) (Lt : list (TType n)),
  linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat -> Lt <> [] ->
  length Lz = length Lt -> Forall proper_length_TType Lt -> 
    @CM.rank (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz Lt) d <->
      @CM.rank (2 ^ n)%nat (2 ^ n)%nat (projectorListT (repeat zero (length Lt)) Lt) d.
Proof. intros. unfold CM.rank. split; intros.
  - constructor.
    inversion H4; clear H4.
    destruct (set_listF2_projectorListT Lz Lt H H0 H1 H2 H3)
      as [t [proper_len_t [coef_size_1_t H4]]].
    rewrite H4 in H5.
    rewrite @CM.swap_equivalent_subspace_in_dimension
      with (P2 := @CM.span (2 ^ n)%nat (2 ^ n)%nat 
                   (translate t × projectorListT (repeat 0%F2 (length Lt)) Lt)) in H5; auto.
    2: { intros v. symmetry. apply CM.invertible_right_mult_span_preserve.
         apply WF_adjoint. apply WF_translate; auto. 
         apply translate_adjoint_invertible; auto. }
    rewrite <- CM.invertible_left_mult_dim_preserve in H5; auto.
    apply WF_translate; auto.
    apply WF_projectorListT; auto. rewrite repeat_length; auto.
    apply translate_invertible; auto.
  - constructor.
    inversion H4; clear H4.
    destruct (set_listF2_projectorListT Lz Lt H H0 H1 H2 H3)
      as [t [proper_len_t [coef_size_1_t H4]]].
    rewrite H4.
    rewrite @CM.swap_equivalent_subspace_in_dimension
      with (P2 := @CM.span (2 ^ n)%nat (2 ^ n)%nat 
                   (translate t × projectorListT (repeat 0%F2 (length Lt)) Lt)); auto.
    2: { intros v. symmetry. apply CM.invertible_right_mult_span_preserve.
         apply WF_adjoint. apply WF_translate; auto. 
         apply translate_adjoint_invertible; auto. }
    rewrite <- CM.invertible_left_mult_dim_preserve; auto.
    apply WF_translate; auto.
    apply WF_projectorListT; auto. rewrite repeat_length; auto.
    apply translate_invertible; auto.
Qed.

(** orthogonal subspaces **)
Inductive orthogonal_subspaces {n : nat} (P1 P2 : Vector n -> Prop) :=
| OrthSubspace : @CM.subspace n P1 -> @CM.subspace n P2 ->
                 (forall u v : Vector n, P1 u -> P2 v -> ((u †) × v) 0%nat 0%nat = C0) ->
                 orthogonal_subspaces P1 P2.

Lemma orthogonal_subspaces_sym : forall {n : nat} (P1 P2 : Vector n -> Prop),
    orthogonal_subspaces P1 P2 -> orthogonal_subspaces P2 P1.
Proof. intros n P1 P2 H.
  inversion H. constructor; auto.
  intros u v H3 H4.
  specialize (H2 v u H4 H3).
  unfold Mmult, adjoint in *.
  assert ((Σ (fun y : nat => (v y 0%nat) ^* * u y 0%nat) n)^* = C0).
  { rewrite H2. lca. }
  rewrite big_sum_func_distr in H5. 
  2: intros; lca.
  rewrite <- H5.
  apply big_sum_eq_bounded.
  intros x H6. lca.
Qed.

Lemma differentF2_projectorT_orth : forall {n : nat} (z1 z2 : F2) (t : TType n),
    z1 <> z2 -> coef_plus_minus_1 t -> proper_length_TType t ->
    adjoint (projectorT z1 t) × (projectorT z2 t) = Zero.
Proof. intros n z1 z2 t H H0 H1.
  unfold projectorT.
  distribute_adjoint.
  distribute_scale.
  distribute_plus.
  rewrite ! translate_defaultT_I.
  rewrite id_adjoint_eq.
  rewrite ! Mmult_1_l, ! Mmult_1_r.
  distribute_scale.
  rewrite translate_adjoint_mult_inv.
  assert ((neg_powF2 z1) ^* * neg_powF2 z2 = - C1).
  { destruct z1, z2; try contradiction; unfold neg_powF2; simpl; lca. }
  rewrite H2.
  assert ((neg_powF2 z1) ^* = - (neg_powF2 z2)).
  { destruct z1, z2; try contradiction; unfold neg_powF2; simpl; lca. }
  rewrite H3. 
  assert ((I (2 ^ n) .+ - neg_powF2 z2 .* adjoint (translate t)
      .+ (neg_powF2 z2 .* translate t .+ - C1 .* I (2 ^ n))) = Zero).
  { rewrite translate_adjoint_eq; auto. lma'. }
  rewrite H4. lma'.
  all: auto with wf_db.
  apply coef_plus_minus_1_implies_coef_size_1; auto.
Qed.

Lemma differentF2_projectorListT_orth : 
  forall {n : nat} (k : nat) (Lz1 Lz2 : list F2) (Lt  : list (TType n)),
    Forall coef_plus_minus_1 Lt -> Forall proper_length_TType Lt ->
    commutingListT Lt ->
    (k < length Lz1)%nat -> length Lz1 = length Lt -> length Lz2 = length Lt ->
    nth k Lz1 0%F2 <> nth k Lz2 0%F2 ->
    (adjoint (projectorListT Lz1 Lt) × projectorListT Lz2 Lt) = Zero.
Proof. intros. 
  rewrite (nth_inc k Lz1 zero); try lia.
  rewrite (nth_inc k Lz2 zero); try lia.
  rewrite (nth_inc k Lt (defaultT_I n)); try lia.
  rewrite projectorListT_commutingListT_Permutation 
    with (Lz1 := (firstn k Lz1 ++ [nth k Lz1 0%F2] ++ skipn (S k) Lz1))
         (Lt1 := (firstn k Lt ++ [nth k Lt (defaultT_I n)] ++ skipn (S k) Lt))
         (Lz2 := ([nth k Lz1 0%F2] ++ firstn k Lz1 ++ skipn (S k) Lz1))
         (Lt2 := ([nth k Lt (defaultT_I n)] ++ firstn k Lt ++ skipn (S k) Lt)); auto.
   rewrite projectorListT_commutingListT_Permutation 
    with (Lz1 := (firstn k Lz2 ++ [nth k Lz2 0%F2] ++ skipn (S k) Lz2))
         (Lt1 := (firstn k Lt ++ [nth k Lt (defaultT_I n)] ++ skipn (S k) Lt))
         (Lz2 := ([nth k Lz2 0%F2] ++ firstn k Lz2 ++ skipn (S k) Lz2))
         (Lt2 := ([nth k Lt (defaultT_I n)] ++ firstn k Lt ++ skipn (S k) Lt)); auto.
  rewrite ! projectorListT_app; try lia.
  rewrite ! projectorListT_singleton.
  distribute_adjoint.
  rewrite ! Mmult_assoc.
  assert (H' : adjoint (projectorListT (skipn (S k) Lz1) (skipn (S k) Lt))
  × (adjoint (projectorListT (firstn k Lz1) (firstn k Lt))
     × (adjoint (projectorT (nth k Lz1 0%F2) (nth k Lt (defaultT_I n)))
        × (projectorT (nth k Lz2 0%F2) (nth k Lt (defaultT_I n))
           × (projectorListT (firstn k Lz2) (firstn k Lt)
              × projectorListT (skipn (S k) Lz2) (skipn (S k) Lt))))) =
            adjoint (projectorListT (skipn (S k) Lz1) (skipn (S k) Lt))
              × (adjoint (projectorListT (firstn k Lz1) (firstn k Lt))
                   × ((adjoint (projectorT (nth k Lz1 0%F2) (nth k Lt (defaultT_I n))))
                        × (projectorT (nth k Lz2 0%F2) (nth k Lt (defaultT_I n))))
                             × (projectorListT (firstn k Lz2) (firstn k Lt)
                                  × projectorListT (skipn (S k) Lz2) (skipn (S k) Lt)))).
  { rewrite ! Mmult_assoc. auto. }
  rewrite H'.
  rewrite differentF2_projectorT_orth.
  rewrite ! Mmult_0_r, ! Mmult_0_l, ! Mmult_0_r; auto.
  all: auto.
  all: try (rewrite <- ! nth_inc; auto; lia).
  all: try rewrite ! firstn_length; try lia.
  all: try rewrite ! skipn_length; try lia.
  all: try (apply Forall_nth; auto; lia).
  all: try (try rewrite ! Forall_app; rewrite (nth_inc k Lt (defaultT_I n)) in H0; try lia;
            rewrite ! Forall_app in H0; destruct H0 as [H0 [H0' H0'']]; easy).
  all: try (rewrite ! app_length; rewrite ! firstn_length; rewrite ! skipn_length; simpl; lia).
  all: rewrite ! combine_app, ! app_assoc;
    try apply Permutation_app_tail;
    try apply Permutation_app_comm;
    simpl; try rewrite ! firstn_length; lia.
Qed. 

Lemma orthogonal_projectorListT : forall {n : nat} (Lz1 Lz2 : list F2) (Lt : list (TType n)),
    Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt ->
    commutingListT Lt ->
    length Lz1 = length Lt -> length Lz2 = length Lt -> Lz1 <> Lz2 ->
    @orthogonal_subspaces (2 ^ n)%nat
      (@CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz1 Lt)) 
      (@CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz2 Lt)).
Proof. intros n Lz1 Lz2 Lt H H0 H1 H2 H3 H4. 
  constructor; try apply CM.span_is_subspace;
    try apply WF_projectorListT; auto.
  intros u v H5 H6. unfold CM.span in H5, H6.
  destruct H5 as [a [WFa H5]].
  destruct H6 as [b [WFb H6]].
  assert (length Lz1 = length Lz2) by lia.
  pose (nth_ext Lz1 Lz2 zero zero H7) as e.
  rewrite <- Decidable.contrapositive in e; auto.
  2: unfold Decidable.decidable;
  destruct (list_eq_dec F2eq_dec Lz1 Lz2); auto.
  specialize (e H4).
  apply Classical_Pred_Type.not_all_ex_not in e.
  destruct e as [k e].
  apply Classical_Prop.imply_to_and in e.
  destruct e.
  assert (CM.WF_GenMatrix a = WF_Matrix a) by auto.
  rewrite H10 in WFa.
  assert (CM.WF_GenMatrix b = WF_Matrix b) by auto.
  rewrite H11 in WFb.
  assert (CM.GMmult (projectorListT Lz1 Lt) a = Mmult (projectorListT Lz1 Lt) a) by auto.
  rewrite H12 in H5.
  assert (CM.GMmult (projectorListT Lz2 Lt) b = Mmult (projectorListT Lz2 Lt) b) by auto.
  rewrite H13 in H6.
  rewrite H5, H6.
  rewrite Mmult_adjoint.
  rewrite ! Mmult_assoc.
  assert ((@Mmult 1%nat (2 ^ n) 1%nat (adjoint a) (@Mmult (2 ^ n) (2 ^ n) 1%nat (adjoint (projectorListT Lz1 Lt)) (@Mmult (2 ^ n) (2 ^ n) 1%nat (projectorListT Lz2 Lt) b))) = 
            (a) † × ((adjoint (projectorListT Lz1 Lt)) × (projectorListT Lz2 Lt)) × b).
  { rewrite ! Mmult_assoc. auto. }
  rewrite H14.
  rewrite differentF2_projectorListT_orth with (k := k); auto.
  rewrite Mmult_0_r, Mmult_0_l. auto.
Qed.


(* orthogonal subspaces implies internal direct sum *)
Lemma orthogonal_subspaces_implies_no_subspace_overlap : 
  forall {n : nat} (P1 P2 : Vector n -> Prop),
    orthogonal_subspaces P1 P2 -> @CM.no_subspace_overlap n P1 P2.
Proof. intros n P1 P2 H.
  inversion H.
  unfold CM.no_subspace_overlap.
  intros v H3 H4.
  specialize (H2 v v H3 H4).
  prep_matrix_equality.
  unfold CM.Zero.
  pose (CM.WF_subspace H0 H3) as H5.
  assert (CM.WF_GenMatrix v = WF_Matrix v) by auto.
  rewrite H6 in H5.
  bdestruct (x <? n).
  - bdestruct (y =? 0).
    subst.
    + setoid_rewrite inner_product_zero_iff_zero in H2; auto.
      rewrite H2; auto.
    + rewrite H5; auto; lia.
  - rewrite H5; auto; lia.
  Qed.


Definition multi_orthogonal_subspaces {n : nat} (Ps : list (Vector n -> Prop)) :=
  (forall i j : nat, (i < length Ps)%nat -> (j < length Ps)%nat -> i <> j ->
              orthogonal_subspaces
                (nth i Ps (fun v : Vector n => v = Zero)) 
                (nth j Ps (fun v : Vector n => v = Zero))).

Lemma multi_orthogonal_subspaces_cons :
  forall {n : nat} (P : Vector n -> Prop) (Ps : list (Vector n -> Prop)),
    multi_orthogonal_subspaces (P :: Ps) <->
      (forall i : nat, (i < length Ps)%nat -> 
                orthogonal_subspaces P (nth i Ps (fun v : Vector n => v = Zero))) /\
        multi_orthogonal_subspaces Ps.
Proof. intros n P Ps.
  unfold multi_orthogonal_subspaces in *.
  split; intros.
  - split; intros. 
    + specialize (H 0%nat (S i)).
      simpl in H. apply H; simpl; lia.
    + specialize (H (S i) (S j)).
      simpl in H. apply H; simpl; lia.
  - destruct H.
    bdestruct (i =? 0)%nat; subst.
    + replace (nth 0 (P :: Ps) (fun v : Vector n => v = Zero)) with P by auto.
      destruct j; simpl in *; try contradiction. apply H; lia.
    + bdestruct (j =? 0)%nat; subst.
      * replace (nth 0 (P :: Ps) (fun v : Vector n => v = Zero)) with P by auto.
        apply orthogonal_subspaces_sym.
        destruct i; simpl in *; try contradiction. apply H; lia.
      * destruct i, j; simpl in *; try contradiction. apply H3; lia.
Qed.

Lemma multi_orthogonal_subspaces_cons_orthogonal_subspaces_multi_subspace_sum : 
  forall {n : nat} (P : Vector n -> Prop) (Ps : list (Vector n -> Prop)),
    @CM.subspace n P -> Forall (@CM.subspace n) Ps ->
    multi_orthogonal_subspaces (P :: Ps) ->
    orthogonal_subspaces P (@CM.multi_subspace_sum n Ps).
Proof. intros n P Ps H H0 H1.
  rewrite multi_orthogonal_subspaces_cons in H1. destruct H1.
  constructor; auto.
  apply CM.multi_subspace_sum_is_subspace; auto.
  gen P. induction Ps; intros.
  - simpl in *. rewrite H4. rewrite Mmult_0_r. unfold Zero. auto.
  - rewrite Forall_cons_iff in H0. destruct H0.
    rewrite multi_orthogonal_subspaces_cons in H2. destruct H2. 
    assert (forall i : nat, (i < length Ps)%nat ->
          orthogonal_subspaces P (nth i Ps (fun v : Vector n => v = Zero))).
    { intros i H7. specialize (H1 (S i)). apply H1; simpl; lia. }
    simpl in H4.
    destruct H4 as [vh [vt [avh [Psvt vvhvt]]]].
    replace (CM.GMplus vh vt) with (@Mplus n 1 vh vt) in vvhvt by auto.
    specialize (IHPs H5 H6 P H H7 u vt H3 Psvt).
    assert (orthogonal_subspaces P a).
    { specialize (H1 0%nat). simpl in H1. apply H1; lia. }
    inversion H4.
    specialize (H10 u vh H3 avh).
    rewrite vvhvt.
    distribute_plus.
    unfold Mplus.
    rewrite H10, IHPs.
    lca.
Qed.

Lemma multi_orthogonal_subspaces_implies_multi_no_subspace_overlap :
  forall {n : nat} (Ps : list (Vector n -> Prop)),
    Forall (@CM.subspace n) Ps ->
    multi_orthogonal_subspaces Ps -> @CM.multi_no_subspace_overlap n Ps.
Proof. intros n Ps H H0. 
  induction Ps; simpl; auto.
  rewrite multi_orthogonal_subspaces_cons in H0. destruct H0.
  rewrite Forall_cons_iff in H. destruct H.
  split; auto.
  specialize (IHPs H2 H1).
  induction Ps.
  - simpl. unfold CM.no_subspace_overlap. intros; auto.
  - rewrite Forall_cons_iff in H2. destruct H2.
    rewrite multi_orthogonal_subspaces_cons in H1. destruct H1.
    simpl in IHPs. destruct IHPs.
    assert (forall i : nat, (i < length Ps)%nat ->
           orthogonal_subspaces a (nth i Ps (fun v : Vector n => v = Zero))).
    { intros i H7. specialize (H0 (S i)). apply H0; simpl; lia. }
    specialize (IHPs0 H3 H7 H4 H6).
    apply orthogonal_subspaces_implies_no_subspace_overlap.
    apply multi_orthogonal_subspaces_cons_orthogonal_subspaces_multi_subspace_sum; auto.
    rewrite ! multi_orthogonal_subspaces_cons; split; auto.
Qed.

Lemma multi_orthogonal_subspaces_projectorListT :
  forall {n : nat} (LzList : list (list F2)) (Lt : list (TType n)),
    NoDup LzList -> Forall proper_length_TType Lt -> 
    Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    Forall (fun Lz => length Lz = length Lt) LzList ->
    @multi_orthogonal_subspaces (2 ^ n)%nat
      (map (fun Lz => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz Lt)) LzList).
Proof. intros n LzList Lt H H0 H1 H2 H3.
  induction LzList; simpl; auto.
  - unfold multi_orthogonal_subspaces. intros i j H4 H5 H6. simpl in *. lia.
  - rewrite NoDup_cons_iff in H. destruct H.
    rewrite Forall_cons_iff in H3. destruct H3.
    specialize (IHLzList H4 H5).
    rewrite multi_orthogonal_subspaces_cons.
    split; intros; auto.
    rewrite nth_indep 
      with (d' := @CM.span (2^n) (2^n)  (projectorListT (repeat zero (length Lt)) Lt)); auto.
    rewrite map_nth with (d := (repeat zero (length Lt))).
    rewrite map_length in H6.
    apply orthogonal_projectorListT; auto.
    + rewrite Forall_nth in H5. apply H5. auto.
    + intro. subst. contradict H. apply nth_In. auto.
Qed.

(* https://math.stackexchange.com/questions/1227031/do-commuting-matrices-share-the-same-eigenvectors *)
Lemma nonzero_invariant_subspace_exists_eigenvector :
  forall {n : nat} (M : Square n) (P : Vector n -> Prop) (d : nat),
    WF_Matrix M ->
    @CM.subspace n P -> @CM.dimension n P d -> d <> 0%nat ->
    (forall v : Vector n, P v -> P (M × v)) ->
    exists (c : C) (v : Vector n), WF_Matrix v /\ v <> Zero /\ M × v = c .* v /\ P v.
Proof. intros n M P d H H0 H1 H2 H3.
  unfold CM.dimension in H1.
  destruct H1 as [B [WFB basisB]].
  pose (CM.subspace_is_basis_span basisB) as H1.
  assert (forall i, (i < d)%nat -> CM.span B (@CM.get_col n d (@Mmult n n d M B) i)).
  { intros i H4. 
    rewrite matrix_by_basis; auto.
    rewrite <- H1.
    rewrite Mmult_assoc.
    apply H3.
    rewrite H1.
    unfold CM.span.
    exists (@e_i d i).
    split; auto with wf_db.
    apply WF_e_i. }
  assert (@CM.WF_GenMatrix n d (@Mmult n n d M B)).
  { apply WF_mult; auto. }
  destruct (CM.collect_columns_in_span H5 WFB H4) as [A [WFA MBBA]].
  replace (CM.GMmult B A) with (@Mmult n d d B A) in MBBA by auto.
  replace (CM.WF_GenMatrix A) with (@WF_Matrix d d A) in WFA by auto.
  destruct d; try contradiction.
  destruct (exists_eigenvector d A WFA) as [c [v [WFv [v_nonzero cv_eigenpair]]]].
  exists c. exists (B × v). repeat split; auto with wf_db.
  - intro. contradict v_nonzero.
    unfold CM.basis in basisB. destruct basisB as [H' [H'' [H''' H'''']]].
    unfold CM.linearly_independent in H''''.
    apply H''''; auto with wf_db.
  - rewrite <- Mmult_assoc, MBBA, Mmult_assoc, cv_eigenpair.
    distribute_scale. auto.
  - rewrite H1.
    unfold CM.span.
    exists v. split; auto with wf_db.
Qed.

(* https://math.stackexchange.com/questions/2025842/common-eigenvectors-of-commuting-operators *)
Lemma Hermitian_commutative_exists_common_eigenvector : 
  forall {n : nat} (A B : Square (S n)),
    WF_Matrix A -> WF_Matrix B ->
    A = A † -> B = B † -> A × B = B × A -> 
    exists (c1 c2 : C) (v : Vector (S n)), WF_Matrix v /\ v <> Zero /\ A × v = c1 .* v /\ B × v = c2 .* v.
Proof. intros n A B H H0 H1 H2 H3.
  destruct (exists_eigenvector n A H) as [c [v [WFv [v_nonzero cv_eigenpair]]]].
  assert (@CM.subspace (S n) (fun v : Vector (S n) => WF_Matrix v /\ A × v = c .* v)).
  { unfold CM.subspace. repeat split; intros.
    - destruct H4; auto.
    - rewrite Mmult_0_r. rewrite Mscale_0_r. auto.
    - destruct H4, H5. auto with wf_db.
    - replace (CM.GMplus v0 w) with (@Mplus (S n) 1 v0 w) by auto.
      distribute_plus. destruct H4, H5.
      rewrite H6, H7. rewrite Mscale_plus_distr_r. auto.
    - destruct H4. auto with wf_db.
    - replace (CM.scale c0 v0) with (@Matrix.scale (S n) 1 c0 v0) by auto.
      destruct H4. distribute_scale. rewrite H5. lma'. }
  destruct (CM.exists_dimension H4) as [d [dimd dbound]].
  destruct d.
  - unfold CM.dimension in dimd.
    destruct dimd as [M [WFM basisM]].
    assert (M = @Zero (S n) 0).
    { prep_matrix_equality. rewrite WFM; auto; lia. }
    pose (CM.subspace_is_basis_span basisM) as H6.
    assert (CM.span M v).
    { rewrite <- H6. split; auto. }
    rewrite H5 in H7.
    unfold CM.span in H7.
    destruct H7 as [a [WFa vZero]].
    rewrite Mmult_0_l in vZero.
    contradiction.
  - assert (forall v : Vector n, (fun v : Vector (S n) => WF_Matrix v /\ A × v = c .* v) v -> 
                            (fun v : Vector (S n) => WF_Matrix v /\ A × v = c .* v) (B × v)).
    { intros v0 H5. destruct H5. split; auto with wf_db.
      rewrite <- Mmult_assoc, H3, Mmult_assoc, H6.
      distribute_scale. auto. }
    assert (S d <> 0%nat) by lia.
    destruct (nonzero_invariant_subspace_exists_eigenvector
                B (fun v : Vector (S n) => WF_Matrix v /\ A × v = c .* v) (S d)
                H0 H4 dimd H6 H5) as [c' [v' [WFv' [v'_nonzero [eigenpair in_subspace]]]]].
    destruct in_subspace.
    exists c. exists c'. exists v'. repeat split; auto.
Qed.

Lemma projectorT_Hermitian : forall {n : nat} (z : F2) (t : TType n),
    proper_length_TType t -> coef_plus_minus_1 t ->
    adjoint (projectorT z t) = projectorT z t.
Proof. intros n z t H H0.
  unfold projectorT.
  distribute_adjoint.
  rewrite ! Mscale_plus_distr_r. 
  rewrite ! translate_defaultT_I.
  rewrite id_adjoint_eq.
  assert ((C1 / C2) ^* = (C1 / C2)) by lca.
  rewrite ! H1. do 2 f_equal.
  assert ((neg_powF2 z) ^* = (neg_powF2 z)).
  { destruct z; unfold neg_powF2; simpl; lca. }
  rewrite ! H2. f_equal.
  apply translate_Hermitian; auto.
Qed.

Lemma projectorT_projectorListT_comm : 
  forall {n : nat} (z : F2) (t : TType n) (Lz : list F2) (Lt : list (TType n)),
    length Lz = length Lt -> Forall proper_length_TType Lt -> proper_length_TType t ->
    Forall coef_plus_minus_1 Lt -> coef_plus_minus_1 t -> commutingListT (t :: Lt) ->
    projectorT z t × projectorListT Lz Lt = projectorListT Lz Lt × projectorT z t.
Proof. intros n z t Lz Lt H H0 H1 H2 H3 H4.
  gen Lz. induction Lt; intros.
  - destruct Lz; try discriminate.
    unfold projectorListT. simpl. 
    rewrite Mmult_1_l, Mmult_1_r; auto; apply WF_projectorT; auto.
  - destruct Lz; try discriminate.
    rewrite Forall_cons_iff in H0. destruct H0.
    rewrite Forall_cons_iff in H2. destruct H2.
    apply commutingListT_cons in H4. destruct H4.
    apply commutingListT_cons in H7. destruct H7.
    assert (forall t' : TType n, In t' Lt -> commute_T t t').
    { intros t' H9. apply H4. simpl. auto. } 
    assert (commutingListT (t :: Lt)).
    { rewrite commutingListT_cons_iff; auto. }
    inversion H.
    specialize (IHLt H5 H6 H10 Lz H12).
    rewrite projectorListT_cons.
    rewrite Mmult_assoc.
    rewrite <- IHLt.
    rewrite <- ! Mmult_assoc.
    f_equal. apply projectorT_comm; auto.
    apply H4. simpl. auto.
Qed.

Lemma projectorListT_Hermitian : forall {n : nat} (Lz : list F2) (Lt : list (TType n)),
    length Lz = length Lt -> Forall proper_length_TType Lt -> 
    Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    adjoint (projectorListT Lz Lt) = projectorListT Lz Lt.
Proof. intros n Lz Lt H H0 H1 H2.
  gen Lz. induction Lt; intros.
  - destruct Lz; try discriminate.
    unfold projectorListT. simpl.
    rewrite id_adjoint_eq. auto.
  - destruct Lz; try discriminate.
    rewrite projectorListT_cons.
    distribute_adjoint.
    rewrite Forall_cons_iff in H0. destruct H0.
    rewrite Forall_cons_iff in H1. destruct H1.
    remember H2 as H2'. clear HeqH2'.
    apply commutingListT_cons in H2. destruct H2.
    rewrite projectorT_Hermitian; auto.
    rewrite projectorT_projectorListT_comm; auto.
    f_equal.
    apply IHLt; auto.
Qed.

Lemma adjoint_projectorListT_projectorListT : forall {n : nat} (Lz : list F2) (Lt : list (TType n)),
    length Lz = length Lt -> Forall proper_length_TType Lt -> 
    Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    (adjoint (projectorListT Lz Lt) × projectorListT Lz Lt) = projectorListT Lz Lt.
Proof. intros n Lz Lt H H0 H1 H2.
  gen Lz. induction Lt; intros.
  - simpl in *. apply length_zero_iff_nil in H. subst.
    unfold projectorListT. simpl. rewrite id_adjoint_eq. rewrite Mmult_1_r; auto; apply WF_I.
  - destruct Lz; try discriminate.
    rewrite projectorListT_cons.
    distribute_adjoint.
    rewrite ! Mmult_assoc.
    assert (adjoint (projectorListT Lz Lt) × (adjoint (projectorT f a) 
                        × (projectorT f a × projectorListT Lz Lt)) =
           adjoint (projectorListT Lz Lt) × (adjoint (projectorT f a) 
                        × (projectorT f a)) × projectorListT Lz Lt)
             by (rewrite ! Mmult_assoc; auto).
    rewrite H3.
    rewrite Forall_cons_iff in H0. destruct H0.
    rewrite Forall_cons_iff in H1. destruct H1.
    remember H2 as H2'. clear HeqH2'.
    apply commutingListT_cons in H2. destruct H2.
    inversion H.
    rewrite projectorT_Hermitian; auto.
    rewrite projectorT_idempotent; auto.
    rewrite Mmult_assoc.
    rewrite ! projectorT_projectorListT_comm; auto.
    rewrite <- Mmult_assoc.
    f_equal.
    apply IHLt; auto.
Qed.

Lemma projectorListT_idempotent : forall {n : nat} (Lz : list F2) (Lt : list (TType n)),
    length Lz = length Lt -> Forall proper_length_TType Lt -> 
    Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    projectorListT Lz Lt × projectorListT Lz Lt = projectorListT Lz Lt.
Proof. intros n Lz Lt H H0 H1 H2.
  rewrite <- projectorListT_Hermitian at 1; auto.
  apply adjoint_projectorListT_projectorListT; auto.
Qed.


Lemma multi_no_subspace_overlap_projectorListT :
  forall {n : nat} (LzList : list (list F2)) (Lt : list (TType n)),
    NoDup LzList -> Forall proper_length_TType Lt -> 
    Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    Forall (fun Lz => length Lz = length Lt) LzList ->
    @CM.multi_no_subspace_overlap (2 ^ n)%nat
      (map (fun Lz => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz Lt)) LzList).
Proof. intros n LzList Lt H H0 H1 H2 H3.
  apply multi_orthogonal_subspaces_implies_multi_no_subspace_overlap.
  - rewrite Forall_forall. intros x H4.
    apply In_nth 
      with (d := @CM.span (2^n) (2^n) (projectorListT (repeat zero (length Lt)) Lt)) in H4.
    destruct H4 as [k [kbound kth]]. subst. rewrite map_nth with (d := repeat zero (length Lt)).
    apply CM.span_is_subspace.
    apply WF_projectorListT; auto.
    rewrite Forall_nth in H3. apply H3. rewrite map_length in kbound. auto.
  - apply multi_orthogonal_subspaces_projectorListT; auto.
Qed.


Lemma projectorT_F2_sum : forall {n : nat} (t : TType n),
    proper_length_TType t ->
    projectorT 0%F2 t .+ projectorT 1%F2 t = I (2 ^ n)%nat.
Proof. intros n t H.
  unfold projectorT.
  unfold neg_powF2.
  rewrite ! translate_defaultT_I.
  lma'. 
  apply WF_plus; apply WF_scale; 
    apply WF_plus; auto with wf_db.
Qed.

Lemma projectorListT_split_F2 : forall {n : nat} (t : TType n) (Lz : list F2) (Lt : list (TType n)),
  proper_length_TType t -> length Lz = length Lt -> Forall proper_length_TType Lt ->
  projectorListT Lz Lt = 
    projectorListT (0%F2 :: Lz) (t :: Lt) .+ projectorListT (1%F2 :: Lz) (t :: Lt).
Proof. intros n t Lz Lt H H0 H1.
  rewrite ! projectorListT_cons.
  assert (projectorT 0%F2 t × projectorListT Lz Lt
            .+ projectorT 1%F2 t × projectorListT Lz Lt = 
            (projectorT 0%F2 t .+ projectorT 1%F2 t  ) × projectorListT Lz Lt).
  { distribute_plus. auto. }
  rewrite H2.
  rewrite projectorT_F2_sum; auto.
  rewrite Mmult_1_l; auto.
  apply WF_projectorListT; auto.
Qed.

Fixpoint F2ListList (n : nat) : list (list F2) :=
  match n with
  | 0%nat => [[]]
  | S n' => (map (cons 0%F2) (F2ListList n')) ++ (map (cons 1%F2) (F2ListList n'))
  end.

Lemma F2ListList_length : forall (n : nat),
    length (F2ListList n) = (2 ^ n)%nat.
Proof. intros n.
  induction n; auto.
  simpl. rewrite app_length, ! map_length, IHn; lia.
Qed.

Lemma Forall_length_F2ListList : forall (n : nat),
    Forall (fun Lz : list F2 => length Lz = n) (F2ListList n).
Proof. intros n.
  induction n; simpl.
  - constructor; auto.
  - rewrite Forall_app. rewrite ! Forall_forall. split.
    + intros Lz H.
      rewrite in_map_iff in H.
      destruct H as [Lz' [eqLz In_x]].
      subst. simpl.
      apply In_nth with (d := repeat zero n) in In_x.
      destruct In_x as [k [kbound kth]].
      rewrite <- kth.
      f_equal.
      rewrite Forall_nth in IHn.
      apply IHn. auto.
    + intros Lz H.
      rewrite in_map_iff in H.
      destruct H as [Lz' [eqLz In_x]].
      subst. simpl.
      apply In_nth with (d := repeat zero n) in In_x.
      destruct In_x as [k [kbound kth]].
      rewrite <- kth.
      f_equal.
      rewrite Forall_nth in IHn.
      apply IHn. auto.
Qed.

Lemma NoDup_F2ListList : forall (n : nat), NoDup (F2ListList n).
Proof. intros n.
  induction n.
  - simpl. constructor; auto. constructor.
  - simpl. rewrite NoDup_nth with (d := zero :: (repeat zero (2 ^ n)%nat)).
    intros i j H H0 H1.
    rewrite app_length in H, H0.
    rewrite ! map_length in H, H0.
    rewrite ! F2ListList_length in H, H0.
    bdestruct (i <? 2 ^ n)%nat; bdestruct (j <? 2 ^ n)%nat.
    + rewrite app_nth1 in H1 at 1. rewrite app_nth1 in H1 at 1.
      rewrite ! map_nth in H1.
      inversion H1.
      rewrite NoDup_nth in IHn.
      Unshelve.
      4: apply (repeat zero (2 ^ n)%nat).
      apply IHn; auto.
      all: try rewrite ! map_length;
        try rewrite ! F2ListList_length; 
        lia.
    + rewrite app_nth1 in H1 at 1. rewrite app_nth2 in H1 at 1.
      rewrite (nth_indep (map (cons 1%F2) (F2ListList n)) 
                 (0%F2 :: repeat 0%F2 (2 ^ n))
                 (1%F2 :: repeat 1%F2 (2 ^ n))) in H1.
      rewrite ! map_nth in H1.
      inversion H1.
      all:  try rewrite ! map_length;
        try rewrite ! F2ListList_length; 
        lia.
    + rewrite app_nth2 in H1 at 1. rewrite app_nth1 in H1 at 1.
      rewrite (nth_indep (map (cons 1%F2) (F2ListList n)) 
                 (0%F2 :: repeat 0%F2 (2 ^ n))
                 (1%F2 :: repeat 1%F2 (2 ^ n))) in H1.
      rewrite ! map_nth in H1.
      inversion H1.
      all:  try rewrite ! map_length;
        try rewrite ! F2ListList_length; 
        lia.
    + rewrite app_nth2 in H1 at 1. rewrite app_nth2 in H1 at 1.
      rewrite ! (nth_indep (map (cons 1%F2) (F2ListList n)) 
                 (0%F2 :: repeat 0%F2 (2 ^ n))
                 (1%F2 :: repeat 1%F2 (2 ^ n))) in H1.
      rewrite ! map_nth in H1.
      inversion H1.
      rewrite NoDup_nth in IHn.
      Unshelve.
      6: apply (repeat one (2 ^ n)%nat).
      assert (i - 2 ^ n  = j - 2 ^ n)%nat.
      apply IHn; auto.
      all: try rewrite ! map_length in *;
        try rewrite ! F2ListList_length in *; 
        try lia; auto.
Qed.

Lemma fold_right_Mplus_Zero_app : forall {m n : nat} (Lm1 Lm2 : list (Matrix m n)),
    fold_right Mplus Zero (Lm1 ++ Lm2) = 
      (fold_right Mplus Zero Lm1) .+ (fold_right Mplus Zero Lm2).
Proof. intros m n Lm1 Lm2.
  induction Lm1; simpl.
  - rewrite Mplus_0_l. auto.
  - rewrite Mplus_assoc. f_equal. auto.
Qed.

Lemma fold_right_Mplus_Zero_map_Mmult_distr : 
  forall {m n o : nat} (M : Matrix m n) (Lm : list (Matrix n o)),
  fold_right Mplus Zero (map (fun m => M × m) Lm) = M × fold_right Mplus Zero Lm.
Proof. intros m n o M Lm.
  induction Lm; simpl.
  - rewrite Mmult_0_r. auto.
  - distribute_plus. f_equal. auto.
Qed.

Lemma fold_right_Mplus_map_projectorListT_F2ListList :
  forall {n : nat} (Lt : list (TType n)),
    Forall proper_length_TType Lt ->
    fold_right Mplus Zero (map (fun Lz : list F2 => projectorListT Lz Lt) (F2ListList (length Lt))) 
    = I (2 ^ n)%nat.
Proof. intros n Lt H.
  induction Lt as [ | t Lt]; simpl.
  - unfold projectorListT. simpl. rewrite Mplus_0_r. auto.
  - rewrite ! map_app, ! map_map.
    rewrite Forall_cons_iff in H. destruct H.
    rewrite fold_right_Mplus_Zero_app.
    assert ((fun x : list F2 => projectorListT (0%F2 :: x) (t :: Lt)) =
              (fun x : list F2 => projectorT 0%F2 t × projectorListT x Lt)).
    { apply functional_extensionality. intros. apply projectorListT_cons. }
    rewrite H1.
    assert ((fun x : list F2 => projectorListT (1%F2 :: x) (t :: Lt)) =
              (fun x : list F2 => projectorT 1%F2 t × projectorListT x Lt)).
    { apply functional_extensionality. intros. apply projectorListT_cons. }
    rewrite H2.
    assert ((map (fun x : list F2 => projectorT 0%F2 t × projectorListT x Lt)
       (F2ListList (length Lt))) = 
             (map (fun x => projectorT 0%F2 t × x ) 
                (map (fun x : list F2 => projectorListT x Lt) (F2ListList (length Lt))))).
    { rewrite map_map. auto. }
    rewrite H3.
    assert ((map (fun x : list F2 => projectorT 1%F2 t × projectorListT x Lt)
       (F2ListList (length Lt))) = 
             (map (fun x => projectorT 1%F2 t × x ) 
                (map (fun x : list F2 => projectorListT x Lt) (F2ListList (length Lt))))).
    { rewrite map_map. auto. }
    rewrite H4.
    rewrite ! fold_right_Mplus_Zero_map_Mmult_distr.
    rewrite <- Mmult_plus_distr_r.
    rewrite projectorT_F2_sum; auto.
    rewrite IHLt; auto.
    rewrite Mmult_1_l; auto with wf_db.
Qed.

Lemma orthogonal_projectorListT_multi_subspace_sum_cons :
  forall {n : nat} (Lz : list F2) (LzList : list (list F2)) (Lt : list (TType n)),
    Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    length Lz = length Lt -> Forall (fun Lz : list F2 => length Lz = length Lt) LzList ->
    ~ In Lz LzList -> 
    @multi_orthogonal_subspaces (2 ^ n)%nat
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) LzList) ->
    @multi_orthogonal_subspaces (2 ^ n)%nat
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (Lz :: LzList)).
Proof. intros n Lz LzList Lt H H0 H1 H2 H3 H4 H5. 
  simpl. rewrite multi_orthogonal_subspaces_cons.
  split; intros; auto.
  rewrite nth_indep with (d := (fun v : Vector (2 ^ n) => v = Zero))
                         (d' := (fun Lz' : list F2 => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt))
                                 (repeat zero (length Lt))); auto.
  rewrite map_nth with (d := (repeat zero (length Lt))).
  apply orthogonal_projectorListT; auto.
  - rewrite Forall_nth in H3. apply H3. rewrite map_length in H6. auto.
  - intro. subst. contradict H4. apply nth_In. rewrite map_length in H6. auto.
Qed.

Lemma multi_no_subspace_overlap_projectorListT_cons :
  forall {n : nat} (Lz : list F2) (LzList : list (list F2)) (Lt : list (TType n)),
    Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    length Lz = length Lt -> Forall (fun Lz : list F2 => length Lz = length Lt) LzList ->
    ~ In Lz LzList -> 
    @multi_orthogonal_subspaces (2 ^ n)%nat
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) LzList) ->
    CM.multi_no_subspace_overlap 
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (Lz :: LzList)).
Proof. intros n Lz LzList Lt H H0 H1 H2 H3 H4 H5. 
  apply multi_orthogonal_subspaces_implies_multi_no_subspace_overlap.
  - simpl. rewrite Forall_cons_iff. split.
    + apply CM.span_is_subspace. apply WF_projectorListT; auto.
    + rewrite Forall_forall. intros x H6.
      apply In_nth with (d := @CM.span (2 ^ n) (2 ^ n) (projectorListT (repeat zero (length Lt)) Lt)) in H6. 
      destruct H6 as [k [kbound kth]]. subst.
      rewrite map_nth with (d := repeat zero (length Lt)).
      apply CM.span_is_subspace. apply WF_projectorListT; auto.
      rewrite Forall_nth in H3. apply H3. rewrite map_length in kbound. auto.
  - apply orthogonal_projectorListT_multi_subspace_sum_cons; auto.
Qed.

Lemma multi_orthogonal_subspaces_projectorListT_F2ListList : forall {n : nat} (Lt : list (TType n)),
    Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    @multi_orthogonal_subspaces (2 ^ n)%nat
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (F2ListList (length Lt))).
Proof. intros n Lt H H0 H1.
  apply multi_orthogonal_subspaces_projectorListT; auto.
  apply NoDup_F2ListList.
  apply Forall_length_F2ListList.
Qed.

Lemma multi_no_subspace_overlap_projectorListT_F2ListList : forall {n : nat} (Lt : list (TType n)),
    Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt -> commutingListT Lt ->
    CM.multi_no_subspace_overlap 
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (F2ListList (length Lt))).
Proof. intros n Lt H H0 H1.
  apply multi_orthogonal_subspaces_implies_multi_no_subspace_overlap.
  - rewrite Forall_forall. intros x H2.
    apply In_nth with (d := @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT (repeat zero (length Lt)) Lt))in H2.
    destruct H2 as [k [kbound kth]]. subst.
    rewrite map_nth with (d := (repeat zero (length Lt))).
    apply CM.span_is_subspace.
    apply WF_projectorListT; auto. 
    pose (Forall_length_F2ListList (length Lt)) as H2.
    rewrite Forall_nth in H2.
    apply H2. rewrite map_length in kbound. auto.
  - apply multi_orthogonal_subspaces_projectorListT_F2ListList; auto.
Qed.


Lemma multi_subspace_sum_projectorListT_F2ListList_total_space_necessary : 
  forall {n : nat} (Lt : list (TType n)) (v : Vector (2 ^ n)%nat),
    Forall proper_length_TType Lt -> WF_Matrix v -> 
    CM.multi_subspace_sum
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (F2ListList (length Lt))) v.
Proof. intros n Lt v H H0. 
  gen v. induction Lt as [ | t Lt]; intros.
  - simpl. unfold projectorListT. simpl. exists v. exists (@Zero (2 ^ n) 1). repeat split; auto. 
    + unfold CM.span. exists v.  split; auto. rewrite Mmult_1_l; auto.
    + rewrite Mplus_0_r. auto.
  - simpl. rewrite map_app, ! map_map.
    rewrite CM.multi_subspace_sum_app.
    unfold CM.subspace_sum.
    assert ((fun x : list F2 => @CM.span (2^n) (2^n) (projectorListT (0%F2 :: x) (t :: Lt))) =
              (fun x : list F2 => @CM.span (2^n) (2^n) (projectorT 0%F2 t × projectorListT x Lt))).
    { apply functional_extensionality. intros. rewrite projectorListT_cons. auto. }
    rewrite H1.
    assert ((fun x : list F2 => @CM.span (2^n) (2^n) (projectorListT (1%F2 :: x) (t :: Lt))) =
              (fun x : list F2 => @CM.span (2^n) (2^n) (projectorT 1%F2 t × projectorListT x Lt))).
    { apply functional_extensionality. intros. rewrite projectorListT_cons. auto. }
    rewrite H2.
    rewrite Forall_cons_iff in H. destruct H.
    specialize (IHLt H3 v H0).
    exists (projectorT 0%F2 t × v). exists (projectorT 1%F2 t × v).
    clear H1 H2.
    repeat split.
    + assert ((map (fun x : list F2 => @CM.span (2^n) (2^n) (projectorT 0%F2 t × projectorListT x Lt))
       (F2ListList (length Lt))) = 
                (map (fun m : Square (2^n) => @CM.span (2^n) (2^n) (projectorT 0%F2 t × m)) (map (fun x : list F2 =>  projectorListT x Lt)
       (F2ListList (length Lt))))).
      { rewrite map_map. auto. }
      rewrite H1.
      apply CM.multi_subspace_sum_span_left_Mmult.
      rewrite map_map. auto.
    + assert ((map (fun x : list F2 => @CM.span (2^n) (2^n) (projectorT 1%F2 t × projectorListT x Lt))
       (F2ListList (length Lt))) = 
                (map (fun m : Square (2^n) => @CM.span (2^n) (2^n) (projectorT 1%F2 t × m)) (map (fun x : list F2 =>  projectorListT x Lt)
       (F2ListList (length Lt))))).
      { rewrite map_map. auto. }
      rewrite H1.
      apply CM.multi_subspace_sum_span_left_Mmult.
      rewrite map_map. auto.
    + replace (CM.GMplus (projectorT 0%F2 t × v) (projectorT 1%F2 t × v))
        with (Mplus (projectorT 0%F2 t × v) (projectorT 1%F2 t × v)) by auto.
      rewrite <- Mmult_plus_distr_r.
      rewrite projectorT_F2_sum; auto. rewrite Mmult_1_l; auto.
Qed.

Lemma multi_subspace_sum_projectorListT_F2ListList_total_space_sufficient : 
  forall {n : nat} (Lt : list (TType n)) (v : Vector (2 ^ n)%nat),
    Forall proper_length_TType Lt ->
    CM.multi_subspace_sum
      (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (F2ListList (length Lt))) v -> WF_Matrix v.
Proof. intros n Lt v H H0.
  pose @CM.multi_subspace_sum_is_subspace as E.
  specialize (E (2^n)%nat (map (fun Lz' : list F2 => @CM.span (2^n) (2^n) (projectorListT Lz' Lt)) (F2ListList (length Lt)))).
  assert (Forall CM.subspace (map (fun Lz' : list F2 => @CM.span (2^n) (2^n) (projectorListT Lz' Lt)) (F2ListList (length Lt)))).
  { rewrite Forall_forall. intros x H1.
    apply In_nth with (d := @CM.span (2^n) (2^n) (projectorListT (repeat zero (length Lt)) Lt)) in H1.
    destruct H1 as [k [kbound kth]]. subst.
    rewrite map_nth with (d := (repeat zero (length Lt))).
    apply CM.span_is_subspace.
    apply WF_projectorListT; auto. rewrite Forall_nth in H.
    pose (Forall_length_F2ListList (length Lt)) as E'.
    rewrite Forall_nth in E'. apply E'. rewrite map_length in kbound. auto. }
  specialize (E H1).
  apply (CM.WF_subspace E H0).
Qed.

Lemma multi_subspace_sum_projectorListT_F2ListList_total_space_iff :
  forall {n : nat} (Lt : list (TType n)),
    Forall proper_length_TType Lt ->
    (forall v : Vector (2 ^ n)%nat,
        CM.multi_subspace_sum
          (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (F2ListList (length Lt))) v <-> WF_Matrix v).
Proof. intros n Lt H v. split; intros.
  - apply (multi_subspace_sum_projectorListT_F2ListList_total_space_sufficient Lt v); auto.
  - apply (multi_subspace_sum_projectorListT_F2ListList_total_space_necessary Lt v); auto.
Qed.

Lemma dimension_multi_subspace_sum_span_projectorListT_F2ListList_fold_right_plus_repeat :
  forall {n : nat} (d : nat) (Lt : list (TType n)),
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat ->
    Lt <> [] -> Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt ->
    commutingListT Lt ->
    @CM.rank (2 ^ n)%nat (2 ^ n)%nat (projectorListT (repeat zero (length Lt)) Lt) d ->
    CM.dimension (CM.multi_subspace_sum (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (F2ListList (length Lt)))) (fold_right plus 0%nat (repeat d (2 ^ (length Lt))%nat)).
Proof. intros n d Lt H H0 H1 H2 H3 H4 H5. 
  apply CM.multi_subspace_sum_dimension.
  - rewrite map_length, F2ListList_length, repeat_length. auto.
  - rewrite Forall_forall. intros x H6. 
    apply In_nth with (d := (@CM.span (2^n)%nat (2^n)%nat (projectorListT (repeat zero (length Lt)) Lt), d)) in H6.
    destruct H6 as [k [kbound kth]]. subst.
    rewrite ! combine_nth.
    2: rewrite map_length, F2ListList_length, repeat_length; auto.
    simpl. rewrite map_nth with (d := (repeat 0%F2 (length Lt))).
    rewrite nth_repeat.
    rewrite <- (projectorListT_equal_rank d (nth k (F2ListList (length Lt)) (repeat 0%F2 (length Lt))) Lt) in H5; auto.
    2: { pose (Forall_length_F2ListList (length Lt)) as E.
        rewrite Forall_nth in E. apply E. 
        rewrite combine_length in kbound.
        rewrite map_length, F2ListList_length, repeat_length in kbound. 
        minmax_breakdown_context. 
        rewrite F2ListList_length. auto. }
    inversion H5. auto.
  - apply multi_no_subspace_overlap_projectorListT_F2ListList; auto.
Qed.

Lemma dimension_stabilizeByListT :
  forall {n : nat} (d : nat) (Lt : list (TType n)),
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat ->
    Lt <> [] -> Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt ->
    commutingListT Lt -> (length Lt <= n)%nat ->
    @CM.dimension (2^n)%nat (stabilizeByListT (fun v => WF_Matrix v) Lt) d ->
    d = (2 ^ (n - (length Lt)))%nat.
Proof. intros n d Lt H H0 H1 H2 H3 H4 H5 H6. 
  assert ((2^n)%nat = (d * (2 ^ (length Lt)))%nat).
  { apply @CM.unique_dimension with (P := (CM.multi_subspace_sum (map (fun Lz' => @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT Lz' Lt)) (F2ListList (length Lt))))).
    - rewrite @CM.swap_equivalent_subspace_in_dimension with (P2 := (fun v : Vector (2^n)%nat => WF_Matrix v)).
      apply CM.dimension_totalspace.
      intros v. apply multi_subspace_sum_projectorListT_F2ListList_total_space_iff; auto.
    - assert ((fold_right plus 0%nat (repeat d (2 ^ (length Lt))%nat)) = (d * 2 ^ length Lt)%nat).
      { clear - Lt. induction Lt.
        - simpl. lia.
        - simpl. rewrite <- repeat_combine, fold_right_add_0_app.
          rewrite Nat.add_0_r. rewrite ! IHLt. lia. }
      rewrite <- H7.
      apply dimension_multi_subspace_sum_span_projectorListT_F2ListList_fold_right_plus_repeat; auto.
      rewrite <- @CM.swap_equivalent_subspace_in_dimension with (P1 := @CM.span (2 ^ n)%nat (2 ^ n)%nat (projectorListT (repeat zero (length Lt)) Lt)) in H6.
      2: intros; apply projectorListT_span_stabilized_space; auto.
      constructor. auto. }
  rewrite Nat.pow_sub_r; auto. rewrite H7. rewrite Nat.div_mul; auto.
  apply Nat.pow_nonzero. lia.
Qed.


Definition smash_rowF2 {m1 m2 n : nat} (M1 : MatrixF2 m1 n) (M2 : MatrixF2 m2 n) : MatrixF2 (m1 + m2) n :=
  fun i j : nat => if (i <? m1)%nat then M1 i j else M2 (i - m1)%nat j.

Lemma WF_smash_rowF2 : forall {m1 m2 n : nat} (M1 : MatrixF2 m1 n) (M2 : MatrixF2 m2 n),
    WF_MatrixF2 M1 -> WF_MatrixF2 M2 -> WF_MatrixF2 (smash_rowF2 M1 M2).
Proof. intros m1 m2 n M1 M2 H H0.
  unfold smash_rowF2, WF_MatrixF2.
  intros x y H1.
  destruct H1.
  - bdestruct_all; rewrite H0; auto; lia.
  - bdestruct_all; try rewrite H; try rewrite H0; auto; lia.
Qed.

Lemma smashF2_transposeF2_smash_rowF2 : forall {m1 m2 n : nat} (M1 : MatrixF2 m1 n) (M2 : MatrixF2 m2 n),
    transposeF2 (smash_rowF2 M1 M2) =
      smashF2 (transposeF2 M1) (transposeF2 M2).
Proof. intros m1 m2 n M1 M2.
  unfold transposeF2, smashF2, smash_rowF2.
  prep_matrix_equality. auto.
Qed.

Lemma smash_rowF2_transposeF2_smashF2 : forall {m n1 n2 : nat} (M1 : MatrixF2 m n1) (M2 : MatrixF2 m n2),
    transposeF2 (smashF2 M1 M2) =
      smash_rowF2 (transposeF2 M1) (transposeF2 M2).
Proof. intros m1 m2 n M1 M2.
  unfold transposeF2, smashF2, smash_rowF2.
  prep_matrix_equality. auto.
Qed.

Lemma smashF2_smash_rowF2_comm : forall {m1 m2 n1 n2} (UL : MatrixF2 m1 n1) (UR : MatrixF2 m1 n2) (DL : MatrixF2 m2 n1) (DR : MatrixF2 m2 n2),
    smashF2 (smash_rowF2 UL DL) (smash_rowF2 UR DR) = 
      smash_rowF2 (smashF2 UL UR) (smashF2 DL DR).
Proof. intros m1 m2 n1 n2 UL UR DL DR.
  unfold smashF2, smash_rowF2.
  prep_matrix_equality.
  bdestruct_all; auto.
Qed.

Lemma toCheckMatrixF2Left_split_smash_rowF2 : forall {n : nat} {LLp1 LLp2 : list (list Pauli)},
    (toCheckMatrixF2Left (length (LLp1 ++ LLp2)) n (LLp1 ++ LLp2)) =
      smash_rowF2 (toCheckMatrixF2Left (length LLp1) n LLp1)
                  (toCheckMatrixF2Left (length LLp2) n LLp2).
Proof. intros n LLp1 LLp2.
  unfold smash_rowF2, toCheckMatrixF2Left.
  prep_matrix_equality.
  bdestruct_all.
  - rewrite app_nth1; auto.
  - rewrite app_nth2; auto.
Qed.

Lemma toCheckMatrixF2Right_split_smash_rowF2 : forall {n : nat} {LLp1 LLp2 : list (list Pauli)},
    (toCheckMatrixF2Right (length (LLp1 ++ LLp2)) n (LLp1 ++ LLp2)) =
      smash_rowF2 (toCheckMatrixF2Right (length LLp1) n LLp1)
                  (toCheckMatrixF2Right (length LLp2) n LLp2).
Proof. intros n LLp1 LLp2.
  unfold smash_rowF2, toCheckMatrixF2Right.
  prep_matrix_equality.
  bdestruct_all.
  - rewrite app_nth1; auto.
  - rewrite app_nth2; auto.
Qed.

Lemma linearly_independentF2_transposeF2_fromLtToCheckMatrixF2_app_split :
  forall {n : nat} (Lt1 Lt2 : list (TType n)),
    Forall proper_length_TType Lt1 -> Forall proper_length_TType Lt2 -> 
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 (Lt1 ++ Lt2))) ->
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt1)) /\
      linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt2)).
Proof. intros n Lt1 Lt2 properLt1 properLt2 H. split. 
  - unfold fromLtToCheckMatrixF2 in *.
    unfold fromLLpToCheckMatrixF2 in *.
    unfold Lt_to_LLp in *.
    rewrite ! map_app in H.
    assert (length (Lt1 ++ Lt2) = length (map snd Lt1 ++ map snd Lt2)).
    { rewrite ! app_length, ! map_length; auto. }
    rewrite ! H0 in H.
    rewrite toCheckMatrixF2Left_split_smash_rowF2 in H.
    rewrite toCheckMatrixF2Right_split_smash_rowF2 in H.
    setoid_rewrite smashF2_smash_rowF2_comm in H.
    setoid_rewrite smashF2_transposeF2_smash_rowF2 in H.
    rewrite ! app_length, ! map_length in *.
    apply @F2Module.lin_indep_smash_left with (A2 := (transposeF2
              (smashF2 (toCheckMatrixF2Left (length Lt2) n (map snd Lt2))
                 (toCheckMatrixF2Right (length Lt2) n (map snd Lt2)))))
                                              (n2 := (length Lt2)). auto.
  - unfold fromLtToCheckMatrixF2 in *.
    unfold fromLLpToCheckMatrixF2 in *.
    unfold Lt_to_LLp in *.
    rewrite ! map_app in H.
    assert (length (Lt1 ++ Lt2) = length (map snd Lt1 ++ map snd Lt2)).
    { rewrite ! app_length, ! map_length; auto. }
    rewrite ! H0 in H.
    rewrite toCheckMatrixF2Left_split_smash_rowF2 in H.
    rewrite toCheckMatrixF2Right_split_smash_rowF2 in H.
    setoid_rewrite smashF2_smash_rowF2_comm in H.
    setoid_rewrite smashF2_transposeF2_smash_rowF2 in H.
    rewrite ! app_length, ! map_length in *.
    apply @F2Module.lin_indep_smash_right with (A1 := (transposeF2
              (smashF2 (toCheckMatrixF2Left (length Lt1) n (map snd Lt1))
                 (toCheckMatrixF2Right (length Lt1) n (map snd Lt1)))))
                                              (n1 := (length Lt1)); auto.
    + apply F2Module.WF_transpose. apply F2Module.WF_smash.
      * apply WF_toCheckMatrixF2Left. 
        -- rewrite map_length; auto.
        -- rewrite Forall_forall in *. intros x H1.
           rewrite in_map_iff in H1.
           destruct H1 as [t [sndt int]].
           specialize (properLt1 t int).
           destruct properLt1.
           rewrite sndt in H2.
           lia.
      * apply WF_toCheckMatrixF2Right. 
        -- rewrite map_length; auto.
        -- rewrite Forall_forall in *. intros x H1.
           rewrite in_map_iff in H1.
           destruct H1 as [t [sndt int]].
           specialize (properLt1 t int).
           destruct properLt1.
           rewrite sndt in H2.
           lia.
    + apply F2Module.WF_transpose. apply F2Module.WF_smash.
      * apply WF_toCheckMatrixF2Left. 
        -- rewrite map_length; auto.
        -- rewrite Forall_forall in *. intros x H1.
           rewrite in_map_iff in H1.
           destruct H1 as [t [sndt int]].
           specialize (properLt2 t int).
           destruct properLt2.
           rewrite sndt in H2.
           lia.
      * apply WF_toCheckMatrixF2Right. 
        -- rewrite map_length; auto.
        -- rewrite Forall_forall in *. intros x H1.
           rewrite in_map_iff in H1.
           destruct H1 as [t [sndt int]].
           specialize (properLt2 t int).
           destruct properLt2.
           rewrite sndt in H2.
           lia.
Qed.


Lemma toCheckMatrixF2Left_ExtendQubitsToRight_smashF2_ZeroF2 :
  forall (row col m : nat) (LLp : list (list Pauli)),
    length LLp = row -> Forall (fun Lp => length Lp = col) LLp ->
    toCheckMatrixF2Left row (col + m) (map (fun Lp => Lp ++ (repeat gI m)) LLp) =
      smashF2 (toCheckMatrixF2Left row col LLp) (@ZeroF2 row m).
Proof. intros row col m LLp lenLLP lenLp.
  prep_matrix_equality.
  assert (WF_Ext : WF_MatrixF2 (toCheckMatrixF2Left row (col + m)
    (map (fun Lp : list Pauli => Lp ++ repeat gI m) LLp))).
  { apply WF_toCheckMatrixF2Left.
    - rewrite map_length; lia.
    - rewrite Forall_forall in *. intros x0 H.
      rewrite in_map_iff in H. destruct H as [x1 [x1app inx1]].
      specialize (lenLp x1 inx1).
      rewrite <- x1app.
      rewrite app_length, repeat_length.
      lia. }
  assert (WF_sm : WF_MatrixF2 (smashF2 (toCheckMatrixF2Left row col LLp) (@ZeroF2 row m))).
  { apply WF_smashF2. 2: apply F2Module.WF_Zero.
    apply WF_toCheckMatrixF2Left; try lia.
    rewrite Forall_forall in *.
    intros x0 H.
    rewrite lenLp; auto. }
  bdestruct (x <? row)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  bdestruct (y <? col + m)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  unfold toCheckMatrixF2Left, smashF2.
  bdestruct_all.
  - f_equal.
    assert ((repeat gI col) ++ (repeat gI m) = repeat gI (col + m)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    rewrite app_nth1; auto.
    rewrite Forall_forall in lenLp.
    assert (In (nth x LLp (repeat gI col)) LLp).
    { apply nth_In; lia. }
    rewrite lenLp; auto.
  - assert ((repeat gI col) ++ (repeat gI m) = repeat gI (col + m)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    assert (length (nth x LLp (repeat gI col)) = col).
    { rewrite Forall_forall in *.
      assert (In (nth x LLp (repeat gI col)) LLp).
      { apply nth_In; lia. }
      rewrite lenLp; auto. }
    rewrite app_nth2; try lia.
    rewrite nth_repeat.
    simpl. unfold ZeroF2. auto.
Qed.

Lemma toCheckMatrixF2Right_ExtendQubitsToRight_smashF2_ZeroF2 :
  forall (row col m : nat) (LLp : list (list Pauli)),
    length LLp = row -> Forall (fun Lp => length Lp = col) LLp ->
    toCheckMatrixF2Right row (col + m) (map (fun Lp => Lp ++ (repeat gI m)) LLp) =
      smashF2 (toCheckMatrixF2Right row col LLp) (@ZeroF2 row m).
Proof. intros row col m LLp lenLLP lenLp.
  prep_matrix_equality.
  assert (WF_Ext : WF_MatrixF2 (toCheckMatrixF2Right row (col + m)
    (map (fun Lp : list Pauli => Lp ++ repeat gI m) LLp))).
  { apply WF_toCheckMatrixF2Right.
    - rewrite map_length; lia.
    - rewrite Forall_forall in *. intros x0 H.
      rewrite in_map_iff in H. destruct H as [x1 [x1app inx1]].
      specialize (lenLp x1 inx1).
      rewrite <- x1app.
      rewrite app_length, repeat_length.
      lia. }
  assert (WF_sm : WF_MatrixF2 (smashF2 (toCheckMatrixF2Right row col LLp) (@ZeroF2 row m))).
  { apply WF_smashF2. 2: apply F2Module.WF_Zero.
    apply WF_toCheckMatrixF2Right; try lia.
    rewrite Forall_forall in *.
    intros x0 H.
    rewrite lenLp; auto. }
  bdestruct (x <? row)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  bdestruct (y <? col + m)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  unfold toCheckMatrixF2Right, smashF2.
  bdestruct_all.
  - f_equal.
    assert ((repeat gI col) ++ (repeat gI m) = repeat gI (col + m)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    rewrite app_nth1; auto.
    rewrite Forall_forall in lenLp.
    assert (In (nth x LLp (repeat gI col)) LLp).
    { apply nth_In; lia. }
    rewrite lenLp; auto.
  - assert ((repeat gI col) ++ (repeat gI m) = repeat gI (col + m)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    assert (length (nth x LLp (repeat gI col)) = col).
    { rewrite Forall_forall in *.
      assert (In (nth x LLp (repeat gI col)) LLp).
      { apply nth_In; lia. }
      rewrite lenLp; auto. }
    rewrite app_nth2; try lia.
    rewrite nth_repeat.
    simpl. unfold ZeroF2. auto.
Qed.

Lemma fromLtToCheckMatrixF2_ExtendQubitsToRight_smashF2 :
  forall {n m : nat} (Lt1 : list (TType n)),
       Forall proper_length_TType Lt1 ->
  (fromLtToCheckMatrixF2
     (map (uncurry gTensorT)
        (combine Lt1 (repeat (defaultT_I m) (length Lt1))))) =

smashF2 (smashF2 (toCheckMatrixF2Left (length Lt1) n (Lt_to_LLp Lt1)) (@ZeroF2 (length Lt1) m))
(smashF2 (toCheckMatrixF2Right (length Lt1) n (Lt_to_LLp Lt1)) (@ZeroF2 (length Lt1) m)).
Proof. intros n m Lt1 H.
  unfold fromLtToCheckMatrixF2.
  unfold fromLLpToCheckMatrixF2.
  unfold Lt_to_LLp.
  rewrite ! map_map.
  assert ((map (fun x : TType n * TType m => snd (uncurry gTensorT x))
          (combine Lt1 (repeat (defaultT_I m) (length Lt1)))) =
            (map (fun x : list Pauli => x ++ (repeat gI m)) (map snd Lt1))).
  { apply nth_ext with (d := snd (uncurry gTensorT (defaultT_I n, defaultT_I m))) (d' := (repeat gI n) ++ (repeat gI m)).
     - rewrite ! map_length, combine_length, repeat_length. minmax_breakdown. auto.
     - intros n0 H0.
       rewrite map_nth with (d := (defaultT_I n, defaultT_I m)).
       rewrite map_nth with (d := repeat gI n).
       unfold gTensorT, uncurry. 
       rewrite combine_nth.
       simpl. 
       2: rewrite repeat_length; auto.
       destruct (nth n0 Lt1 (defaultT_I n)) eqn:E1.
       destruct (nth n0 (repeat (defaultT_I m) (length Lt1)) (defaultT_I m)) eqn:E2.
       simpl. 
       rewrite nth_repeat in E2.
       unfold defaultT_I in E2.
       inversion E2.
       f_equal.
       assert (l = snd (nth n0 Lt1 (defaultT_I n))).
       { rewrite E1. auto. }
       rewrite H1.
       assert (snd (defaultT_I n) = repeat gI n).
       { unfold defaultT_I. auto. }
       rewrite <- H4.
       rewrite map_nth. auto. }
  rewrite H0.
  assert ((length
          (map (uncurry gTensorT)
             (combine Lt1 (repeat (defaultT_I m) (length Lt1))))) =
            length Lt1).
  { rewrite map_length, combine_length, repeat_length. minmax_breakdown. auto. }
  rewrite H1.
  rewrite (toCheckMatrixF2Left_ExtendQubitsToRight_smashF2_ZeroF2
             (length Lt1) n m (map snd Lt1)).
  rewrite (toCheckMatrixF2Right_ExtendQubitsToRight_smashF2_ZeroF2
             (length Lt1) n m (map snd Lt1)).
  auto.
  all : try rewrite map_length; auto.
  rewrite Forall_forall in *.
  intros x H2.
  rewrite in_map_iff in H2.
  destruct H2 as [x0 [sndx0 inx0]].
  specialize (H x0 inx0).
  destruct H.
  rewrite sndx0 in H2.
  auto.
  rewrite Forall_forall in *.
  intros x H2.
  rewrite in_map_iff in H2.
  destruct H2 as [x0 [sndx0 inx0]].
  specialize (H x0 inx0).
  destruct H.
  rewrite sndx0 in H2.
  auto.
Qed.

Lemma toCheckMatrixF2Left_ExtendQubitsToLeft_smashF2_ZeroF2 :
  forall (row col n : nat) (LLp : list (list Pauli)),
    length LLp = row -> Forall (fun Lp => length Lp = col) LLp ->
    toCheckMatrixF2Left row (n + col) (map (fun Lp => (repeat gI n) ++ Lp) LLp) =
      smashF2 (@ZeroF2 row n) (toCheckMatrixF2Left row col LLp).
Proof. intros row col n LLp lenLLP lenLp.
  prep_matrix_equality.
  assert (WF_Ext : WF_MatrixF2 (toCheckMatrixF2Left row (n + col)
    (map (fun Lp : list Pauli => repeat gI n ++ Lp) LLp))).
  { apply WF_toCheckMatrixF2Left.
    - rewrite map_length; lia.
    - rewrite Forall_forall in *. intros x0 H.
      rewrite in_map_iff in H. destruct H as [x1 [x1app inx1]].
      specialize (lenLp x1 inx1).
      rewrite <- x1app.
      rewrite app_length, repeat_length.
      lia. }
  assert (WF_sm : WF_MatrixF2 (smashF2 (@ZeroF2 row n) (toCheckMatrixF2Left row col LLp))).
  { apply WF_smashF2. apply F2Module.WF_Zero.
    apply WF_toCheckMatrixF2Left; try lia.
    rewrite Forall_forall in *.
    intros x0 H.
    rewrite lenLp; auto. }
  bdestruct (x <? row)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  bdestruct (y <? n + col)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  unfold toCheckMatrixF2Left, smashF2, ZeroF2.
  bdestruct_all.
  - assert ((repeat gI n) ++ (repeat gI col) = repeat gI (n + col)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    rewrite app_nth1; auto.
    rewrite nth_repeat.
    simpl. auto.
    rewrite repeat_length; auto.
  - assert ((repeat gI n) ++ (repeat gI col) = repeat gI (n + col)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    rewrite app_nth2; try lia.
    all: rewrite repeat_length; auto.
Qed.

Lemma toCheckMatrixF2Right_ExtendQubitsToLeft_smashF2_ZeroF2 :
  forall (row col n : nat) (LLp : list (list Pauli)),
    length LLp = row -> Forall (fun Lp => length Lp = col) LLp ->
    toCheckMatrixF2Right row (n + col) (map (fun Lp => (repeat gI n) ++ Lp) LLp) =
      smashF2 (@ZeroF2 row n) (toCheckMatrixF2Right row col LLp).
Proof. intros row col n LLp lenLLP lenLp.
  prep_matrix_equality.
  assert (WF_Ext : WF_MatrixF2 (toCheckMatrixF2Right row (n + col)
    (map (fun Lp : list Pauli => repeat gI n ++ Lp) LLp))).
  { apply WF_toCheckMatrixF2Right.
    - rewrite map_length; lia.
    - rewrite Forall_forall in *. intros x0 H.
      rewrite in_map_iff in H. destruct H as [x1 [x1app inx1]].
      specialize (lenLp x1 inx1).
      rewrite <- x1app.
      rewrite app_length, repeat_length.
      lia. }
  assert (WF_sm : WF_MatrixF2 (smashF2 (@ZeroF2 row n) (toCheckMatrixF2Right row col LLp))).
  { apply WF_smashF2. apply F2Module.WF_Zero.
    apply WF_toCheckMatrixF2Right; try lia.
    rewrite Forall_forall in *.
    intros x0 H.
    rewrite lenLp; auto. }
  bdestruct (x <? row)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  bdestruct (y <? n + col)%nat.
  2: rewrite WF_Ext, WF_sm; auto; lia.
  unfold toCheckMatrixF2Right, smashF2, ZeroF2.
  bdestruct_all.
  - assert ((repeat gI n) ++ (repeat gI col) = repeat gI (n + col)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    rewrite app_nth1; auto.
    rewrite nth_repeat.
    simpl. auto.
    rewrite repeat_length; auto.
  - assert ((repeat gI n) ++ (repeat gI col) = repeat gI (n + col)).
    { rewrite repeat_app; auto. }
    rewrite <- H2.
    rewrite map_nth with (d := repeat gI col).
    rewrite app_nth2; try lia.
    all: rewrite repeat_length; auto.
Qed.

Lemma fromLtToCheckMatrixF2_ExtendQubitsToLeft_smashF2 :
  forall {n m : nat} (Lt2 : list (TType m)),
       Forall proper_length_TType Lt2 ->
  (fromLtToCheckMatrixF2
     (map (uncurry gTensorT)
        (combine (repeat (defaultT_I n) (length Lt2)) Lt2))) =

smashF2 (smashF2 (@ZeroF2 (length Lt2) n) (toCheckMatrixF2Left (length Lt2) m (Lt_to_LLp Lt2)))
(smashF2 (@ZeroF2 (length Lt2) n) (toCheckMatrixF2Right (length Lt2) m (Lt_to_LLp Lt2))).
Proof. intros n m Lt2 H. 
  unfold fromLtToCheckMatrixF2.
  unfold fromLLpToCheckMatrixF2.
  unfold Lt_to_LLp.
  rewrite ! map_map.
  assert ((map (fun x : TType n * TType m => snd (uncurry gTensorT x))
          (combine (repeat (defaultT_I n) (length Lt2)) Lt2)) =
            (map (fun x : list Pauli => (repeat gI n) ++ x) (map snd Lt2))).
  { apply nth_ext with (d := snd (uncurry gTensorT (defaultT_I n, defaultT_I m))) (d' := (repeat gI n) ++ (repeat gI m)).
     - rewrite ! map_length, combine_length, repeat_length. minmax_breakdown. auto.
     - intros n0 H0.
       rewrite map_nth with (d := (defaultT_I n, defaultT_I m)).
       rewrite map_nth with (d := repeat gI m).
       unfold gTensorT, uncurry. 
       rewrite combine_nth.
       simpl. 
       2: rewrite repeat_length; auto.
       destruct (nth n0 Lt2 (defaultT_I m)) eqn:E1.
       destruct (nth n0 (repeat (defaultT_I n) (length Lt2)) (defaultT_I n)) eqn:E2.
       simpl. 
       rewrite nth_repeat in E2.
       unfold defaultT_I in E2.
       inversion E2.
       f_equal.
       assert (l = snd (nth n0 Lt2 (defaultT_I m))).
       { rewrite E1. auto. }
       rewrite H1.
       assert (snd (defaultT_I m) = repeat gI m).
       { unfold defaultT_I. auto. }
       rewrite <- H4.
       rewrite map_nth. auto. }
  rewrite H0.
  assert ((length
          (map (uncurry gTensorT)
             (combine (repeat (defaultT_I n) (length Lt2)) Lt2))) =
            length Lt2).
  { rewrite map_length, combine_length, repeat_length. minmax_breakdown. auto. }
  rewrite H1.
  rewrite (toCheckMatrixF2Left_ExtendQubitsToLeft_smashF2_ZeroF2
             (length Lt2) m n (map snd Lt2)).
  rewrite (toCheckMatrixF2Right_ExtendQubitsToLeft_smashF2_ZeroF2
             (length Lt2) m n (map snd Lt2)).
  auto.
  all : try rewrite map_length; auto.
  rewrite Forall_forall in *.
  intros x H2.
  rewrite in_map_iff in H2.
  destruct H2 as [x0 [sndx0 inx0]].
  specialize (H x0 inx0).
  destruct H.
  rewrite sndx0 in H2.
  auto.
  rewrite Forall_forall in *.
  intros x H2.
  rewrite in_map_iff in H2.
  destruct H2 as [x0 [sndx0 inx0]].
  specialize (H x0 inx0).
  destruct H.
  rewrite sndx0 in H2.
  auto.
Qed.

Lemma smash_rowF2_assoc : forall {n m1 m2 m3 : nat} (M1 : MatrixF2 m1 n) (M2 : MatrixF2 m2 n) (M3 : MatrixF2 m3 n),
    smash_rowF2 (smash_rowF2 M1 M2) M3 = smash_rowF2 M1 (smash_rowF2 M2 M3).
Proof. intros n m1 m2 m3 M1 M2 M3.
  unfold smash_rowF2.
  prep_matrix_equality.
  bdestruct_all; auto.
  replace (x - (m1 + m2))%nat with (x - m1 - m2)%nat by lia.
  auto.
Qed.

Lemma linearly_independentF2_smash_rowF2_swap : 
  forall {n m1 m2 : nat} (M1 : MatrixF2 m1 n) (M2 : MatrixF2 m2 n),
    WF_MatrixF2 M1 -> WF_MatrixF2 M2 ->
    linearly_independentF2 (smash_rowF2 M1 M2) ->
    linearly_independentF2 (smash_rowF2 M2 M1).
Proof. intros n m1 m2 M1 M2 WFM1 WFM2 H.
  unfold linearly_independentF2 in *.
  intros a H0 H1.
  apply H; auto.
  unfold smash_rowF2, MmultF2, ZeroF2.
  unfold smash_rowF2, MmultF2, ZeroF2 in H1.
  prep_matrix_equality.
  bdestruct (x <? m1 + m2)%nat.
  2: { apply big_sum_0_bounded.
       intros x0 H3. bdestruct_all.
       rewrite WFM2; auto; try lia. F2simpl. auto. }
  bdestruct (x <? m1)%nat.
  - apply f_equal_inv with (x := (x + m2)%nat) in H1.
    apply f_equal_inv with (x := y) in H1.
    rewrite <- H1.
    apply big_sum_eq_bounded.
    intros x0 H4.
    bdestruct_all.
    replace (x + m2 - m2)%nat with x by lia.
    auto.
  - apply f_equal_inv with (x := (x - m1)%nat) in H1.
    apply f_equal_inv with (x := y) in H1.
    rewrite <- H1.
    apply big_sum_eq_bounded.
    intros x0 H4.
    bdestruct_all.
    auto.
Qed.

Lemma linearly_independentF2_smash_rowF2_swap_iff : 
  forall {n m1 m2 : nat} (M1 : MatrixF2 m1 n) (M2 : MatrixF2 m2 n),
    WF_MatrixF2 M1 -> WF_MatrixF2 M2 ->
    (linearly_independentF2 (smash_rowF2 M1 M2) <->
    linearly_independentF2 (smash_rowF2 M2 M1)).
Proof. intros n m1 m2 M1 M2 H H0. split; intros;
  apply linearly_independentF2_smash_rowF2_swap; auto.
Qed.
    
Lemma smash_rowF2_ZeroF2_right_preserves_linearly_independentF2 :
  forall {n m1 m2 : nat} (M : MatrixF2 m1 n),
    WF_MatrixF2 M ->
    (linearly_independentF2 (smash_rowF2 M (@ZeroF2 m2 n)) <-> 
      linearly_independentF2 M).
Proof. intros n m1 m2 M WFM.
  split; intros.
  - unfold linearly_independentF2 in *.
    intros a H0 H1.
    apply H; auto.
    unfold ZeroF2, MmultF2 in H1.
    unfold smash_rowF2, ZeroF2, MmultF2.
    prep_matrix_equality.
    apply f_equal_inv with (x := x) in H1.
    apply f_equal_inv with (x := y) in H1.
    setoid_rewrite <- H1 at 2.
    apply big_sum_eq_bounded.
    intros x0 H2. simpl.
    bdestruct_all; auto.
    rewrite WFM; auto; lia.
  - unfold linearly_independentF2 in *.
    intros a H0 H1.
    specialize (H a H0).
    apply H.
    unfold ZeroF2, MmultF2.
    unfold smash_rowF2, ZeroF2, MmultF2 in H1.
    prep_matrix_equality.
    apply f_equal_inv with (x := x) in H1.
    apply f_equal_inv with (x := y) in H1.
    setoid_rewrite <- H1 at 1.
    apply big_sum_eq_bounded.
    intros x0 H2. simpl.
    bdestruct_all; auto.
    rewrite WFM; auto; lia.
Qed.


Lemma linearly_independentF2_transposeF2_fromLtToCheckMatrixF2_ExtendQubitsToRight : 
  forall {n m : nat} (Lt1 : list (TType n)),
    (n <> 0)%nat -> Lt1 <> [] -> length Lt1 = n -> Forall proper_length_TType Lt1 ->
    linearly_independentF2
         (transposeF2
            (fromLtToCheckMatrixF2
               (map (uncurry gTensorT)
                  (combine Lt1 (repeat (defaultT_I m) (length Lt1)))))) ->
     linearly_independentF2
         (transposeF2
            (fromLtToCheckMatrixF2 Lt1)).
Proof. intros n m Lt1 H H0 H1 H2 H3.
  rewrite fromLtToCheckMatrixF2_ExtendQubitsToRight_smashF2 in H3; auto.
  setoid_rewrite smash_rowF2_transposeF2_smashF2
    with (M1 := (smashF2 (toCheckMatrixF2Left (length Lt1) n (Lt_to_LLp Lt1)) ZeroF2))
         (M2 := (smashF2 (toCheckMatrixF2Right (length Lt1) n (Lt_to_LLp Lt1)) ZeroF2))
    in H3.
  setoid_rewrite smash_rowF2_transposeF2_smashF2
    with (M1 := (toCheckMatrixF2Left (length Lt1) n (Lt_to_LLp Lt1)))
    in H3.
  setoid_rewrite smash_rowF2_transposeF2_smashF2
    with (M1 := (toCheckMatrixF2Right (length Lt1) n (Lt_to_LLp Lt1)))
    in H3.
  setoid_rewrite F2Module.zero_transpose_eq in H3.
  setoid_rewrite <- smash_rowF2_assoc in H3.
  rewrite ! map_length, ! combine_length, ! repeat_length in H3.
  minmax_breakdown_context.
  rewrite smash_rowF2_ZeroF2_right_preserves_linearly_independentF2
    with (M := (@smash_rowF2 (Init.Nat.add n m) n (@length (TType n) Lt1)
               (@smash_rowF2 n m (@length (TType n) Lt1)
                  (@F2Module.transpose (@length (TType n) Lt1) n
                     (toCheckMatrixF2Left (@length (TType n) Lt1) n
                        (@Lt_to_LLp n Lt1)))
                  (@F2Module.Zero m (@length (TType n) Lt1)))
               (@F2Module.transpose (@length (TType n) Lt1) n
                  (toCheckMatrixF2Right (@length (TType n) Lt1) n
                     (@Lt_to_LLp n Lt1)))))
    in H3.
  apply linearly_independentF2_smash_rowF2_swap in H3.
  rewrite <- smash_rowF2_assoc in H3.
  rewrite smash_rowF2_ZeroF2_right_preserves_linearly_independentF2
    with (M := (@smash_rowF2 n n (@length (TType n) Lt1)
               (@F2Module.transpose (@length (TType n) Lt1) n
                  (toCheckMatrixF2Right (@length (TType n) Lt1) n
                     (@Lt_to_LLp n Lt1)))
               (@F2Module.transpose (@length (TType n) Lt1) n
                  (toCheckMatrixF2Left (@length (TType n) Lt1) n (@Lt_to_LLp n Lt1)))))
    in H3.
  apply linearly_independentF2_smash_rowF2_swap in H3.
  unfold fromLtToCheckMatrixF2, fromLLpToCheckMatrixF2.
  rewrite smash_rowF2_transposeF2_smashF2. auto.
  - apply F2Module.WF_transpose.
    apply WF_toCheckMatrixF2Right.
    unfold Lt_to_LLp.
    rewrite map_length; auto.
    rewrite Forall_forall in *.
    intros x H4. unfold Lt_to_LLp in H4.
    rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
    destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
  - apply F2Module.WF_transpose.
    apply WF_toCheckMatrixF2Left.
    unfold Lt_to_LLp.
    rewrite map_length; auto.
    rewrite Forall_forall in *.
    intros x H4. unfold Lt_to_LLp in H4.
    rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
    destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
  - apply WF_smash_rowF2.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Right.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Left.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
  - apply WF_smash_rowF2.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Left.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
    + apply F2Module.WF_Zero.
  - apply F2Module.WF_transpose.
    apply WF_toCheckMatrixF2Right.
    unfold Lt_to_LLp.
    rewrite map_length; auto.
    rewrite Forall_forall in *.
    intros x H4. unfold Lt_to_LLp in H4.
    rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
    destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
  - apply WF_smash_rowF2.
    + apply WF_smash_rowF2.
      * apply F2Module.WF_transpose.
        apply WF_toCheckMatrixF2Left.
        unfold Lt_to_LLp.
        rewrite map_length; auto.
        rewrite Forall_forall in *.
        intros x H4. unfold Lt_to_LLp in H4.
        rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
        destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
      * apply F2Module.WF_Zero.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Right.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
Qed.

Lemma linearly_independentF2_transposeF2_fromLtToCheckMatrixF2_ExtendQubitsToLeft : 
  forall {n m : nat} (Lt2 : list (TType m)),
    (m <> 0)%nat -> Lt2 <> [] -> length Lt2 = m -> Forall proper_length_TType Lt2 ->
    linearly_independentF2
         (transposeF2
            (fromLtToCheckMatrixF2
               (map (uncurry gTensorT)
                  (combine (repeat (defaultT_I n) (length Lt2)) Lt2)))) ->
     linearly_independentF2
         (transposeF2
            (fromLtToCheckMatrixF2 Lt2)).
Proof. intros n m Lt2 H H0 H1 H2 H3. 
  rewrite fromLtToCheckMatrixF2_ExtendQubitsToLeft_smashF2 in H3; auto.
  setoid_rewrite smash_rowF2_transposeF2_smashF2
    with (M1 := (smashF2 ZeroF2 (toCheckMatrixF2Left (length Lt2) m (Lt_to_LLp Lt2))))
         (M2 := (smashF2 ZeroF2 (toCheckMatrixF2Right (length Lt2) m (Lt_to_LLp Lt2))))
    in H3.
  setoid_rewrite smash_rowF2_transposeF2_smashF2
    with (M2 := (toCheckMatrixF2Left (length Lt2) m (Lt_to_LLp Lt2)))
    in H3.
  setoid_rewrite smash_rowF2_transposeF2_smashF2
    with (M2 := (toCheckMatrixF2Right (length Lt2) m (Lt_to_LLp Lt2)))
    in H3.
  setoid_rewrite F2Module.zero_transpose_eq in H3.
  setoid_rewrite <- smash_rowF2_assoc in H3.
  rewrite ! map_length, ! combine_length, ! repeat_length in H3.
  minmax_breakdown_context.
  rewrite linearly_independentF2_smash_rowF2_swap_iff 
          with (M1 := (@smash_rowF2 (Init.Nat.add n m) n (@length (TType m) Lt2)
               (@smash_rowF2 n m (@length (TType m) Lt2)
                  (@F2Module.Zero n (@length (TType m) Lt2))
                  (@F2Module.transpose (@length (TType m) Lt2) m
                     (toCheckMatrixF2Left (@length (TType m) Lt2) m
                        (@Lt_to_LLp m Lt2))))
               (@F2Module.Zero n (@length (TType m) Lt2))))
          (M2 := (@F2Module.transpose (@length (TType m) Lt2) m
               (toCheckMatrixF2Right (@length (TType m) Lt2) m (@Lt_to_LLp m Lt2))))
    in H3.
  setoid_rewrite <- smash_rowF2_assoc in H3.
  rewrite smash_rowF2_ZeroF2_right_preserves_linearly_independentF2
    with (M := (@smash_rowF2 m (Init.Nat.add n m) (@length (TType m) Lt2)
               (@F2Module.transpose (@length (TType m) Lt2) m
                  (toCheckMatrixF2Right (@length (TType m) Lt2) m
                     (@Lt_to_LLp m Lt2)))
               (@smash_rowF2 n m (@length (TType m) Lt2)
                  (@F2Module.Zero n (@length (TType m) Lt2))
                  (@F2Module.transpose (@length (TType m) Lt2) m
                     (toCheckMatrixF2Left (@length (TType m) Lt2) m
                        (@Lt_to_LLp m Lt2))))))
    in H3.
  setoid_rewrite <- smash_rowF2_assoc in H3.
  rewrite linearly_independentF2_smash_rowF2_swap_iff 
    with (M1 := (@smash_rowF2 m n (@length (TType m) Lt2)
               (@F2Module.transpose (@length (TType m) Lt2) m
                  (toCheckMatrixF2Right (@length (TType m) Lt2) m
                     (@Lt_to_LLp m Lt2)))
               (@F2Module.Zero n (@length (TType m) Lt2))))
         (M2 := (@F2Module.transpose (@length (TType m) Lt2) m
               (toCheckMatrixF2Left (@length (TType m) Lt2) m (@Lt_to_LLp m Lt2))))
    in H3.
  rewrite <- smash_rowF2_assoc in H3.
  rewrite smash_rowF2_ZeroF2_right_preserves_linearly_independentF2
    with (M := (@smash_rowF2 m m (@length (TType m) Lt2)
               (@F2Module.transpose (@length (TType m) Lt2) m
                  (toCheckMatrixF2Left (@length (TType m) Lt2) m (@Lt_to_LLp m Lt2)))
               (@F2Module.transpose (@length (TType m) Lt2) m
                  (toCheckMatrixF2Right (@length (TType m) Lt2) m
                     (@Lt_to_LLp m Lt2)))))
    in H3.
  unfold fromLtToCheckMatrixF2, fromLLpToCheckMatrixF2.
  rewrite smash_rowF2_transposeF2_smashF2. auto.
  - apply WF_smash_rowF2.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Left.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Right.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
  - apply WF_smash_rowF2.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Right.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
    + apply F2Module.WF_Zero.
  - apply F2Module.WF_transpose.
    apply WF_toCheckMatrixF2Left.
    unfold Lt_to_LLp.
    rewrite map_length; auto.
    rewrite Forall_forall in *.
    intros x H4. unfold Lt_to_LLp in H4.
    rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
    destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
  - apply WF_smash_rowF2.
    + apply F2Module.WF_transpose.
      apply WF_toCheckMatrixF2Right.
      unfold Lt_to_LLp.
      rewrite map_length; auto.
      rewrite Forall_forall in *.
      intros x H4. unfold Lt_to_LLp in H4.
      rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
      destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
    + apply WF_smash_rowF2.
      * apply F2Module.WF_Zero.
      * apply F2Module.WF_transpose.
        apply WF_toCheckMatrixF2Left.
        unfold Lt_to_LLp.
        rewrite map_length; auto.
        rewrite Forall_forall in *.
        intros x H4. unfold Lt_to_LLp in H4.
        rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
        destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
  - apply WF_smash_rowF2.
    + apply WF_smash_rowF2.
      * apply F2Module.WF_Zero.
      * apply F2Module.WF_transpose.
        apply WF_toCheckMatrixF2Left.
        unfold Lt_to_LLp.
        rewrite map_length; auto.
        rewrite Forall_forall in *.
        intros x H4. unfold Lt_to_LLp in H4.
        rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
        destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
    + apply F2Module.WF_Zero.
  - apply F2Module.WF_transpose.
    apply WF_toCheckMatrixF2Right.
    unfold Lt_to_LLp.
    rewrite map_length; auto.
    rewrite Forall_forall in *.
    intros x H4. unfold Lt_to_LLp in H4.
    rewrite in_map_iff in H4. destruct H4 as [x0 [sndx0 inx0]].
    destruct (H2 x0 inx0). rewrite sndx0 in H5. lia.
Qed.


Close Scope genmatrix_scope.
Open Scope matrix_scope.


Definition anticommute_AType_semantic {n : nat} (a1 a2 : AType n) : Prop :=
  (translateA a1)×(translateA a2) = -C1 .* (translateA a2)×(translateA a1).

Inductive restricted_addition_semantic {n : nat}: AType n -> Prop :=
| add_restrict_base_semantic : forall (t : TType n), WF_TType t -> restricted_addition_semantic [t]
| add_restrict_inductive_semantic : forall (a1 a2 : AType n),
    restricted_addition_semantic a1 -> restricted_addition_semantic a2 ->
    anticommute_AType_semantic a1 a2 -> 
    restricted_addition_semantic (gScaleA (1/√2) (a1 ++ a2)).


Lemma restricted_addition_semantic_implies_proper_length_AType: forall {n : nat} (a : AType n),
  restricted_addition_semantic a -> proper_length_AType a.
Proof. intros n a H. induction H.
  - constructor. inversion H. assumption.
  - apply proper_length_AType_gScaleA.
    apply proper_length_AType_App; assumption.
Qed.



Lemma Pauli_anticomm_cons_comm_anticomm : forall (p p0 : Pauli) (l l0 : list Pauli),
    length l = length l0 ->
    cBigMul (zipWith gMul_Coef (p :: l) (p0 :: l0)) =
      (- cBigMul (zipWith gMul_Coef (p0 :: l0) (p :: l)))%C ->
    (gMul_Coef p p0 = (- gMul_Coef p0 p)%C ->
     cBigMul (zipWith gMul_Coef l l0) =
       cBigMul (zipWith gMul_Coef l0 l)) /\
      (gMul_Coef p p0 = gMul_Coef p0 p ->
       cBigMul (zipWith gMul_Coef l l0) =
         (- cBigMul (zipWith gMul_Coef l0 l))%C).
Proof. intros p p0 l l0 H H0. split.
  - intros H1. destruct p, p0; simpl in H1; inversion H1; try (contradict H1; lra);
      unfold cBigMul, gMul_Coef, zipWith, uncurry in *; simpl in *;
      rewrite ! fold_left_Cmult in H0; rewrite Copp_mult_distr_l in *;
      try rewrite ! Copp_involutive in H0; apply C_inv_l in H0; try nonzero; try easy; apply C0_snd_neq; simpl; lra.
  - intros H1. destruct p, p0; simpl in H1; inversion H1; try (contradict H1; lra);
      unfold cBigMul, gMul_Coef, zipWith, uncurry in *; simpl in *;
      rewrite ! fold_left_Cmult in H0; rewrite ! Cmult_1_l in H0; easy.
Qed.

Lemma Pauli_comm_cons_comm_anticomm : forall (p p0 : Pauli) (l l0 : list Pauli),
    length l = length l0 ->
    cBigMul (zipWith gMul_Coef (p :: l) (p0 :: l0)) =
      cBigMul (zipWith gMul_Coef (p0 :: l0) (p :: l)) ->
    (gMul_Coef p p0 =  gMul_Coef p0 p ->
     cBigMul (zipWith gMul_Coef l l0) =
       cBigMul (zipWith gMul_Coef l0 l)) /\
      (gMul_Coef p p0 = (- gMul_Coef p0 p)%C ->
       cBigMul (zipWith gMul_Coef l l0) =
         (- cBigMul (zipWith gMul_Coef l0 l))%C).
Proof. intros p p0 l l0 H H0. split.
  - intros H1. destruct p, p0; simpl in H1; inversion H1; try (contradict H1; lra);
      unfold cBigMul, gMul_Coef, zipWith, uncurry in *; simpl in *;
      rewrite ! fold_left_Cmult in H0; try rewrite ! Copp_involutive in H0;
      apply C_inv_l in H0; try nonzero; try easy; apply C0_snd_neq; simpl; lra.
  - intros H1. destruct p, p0; simpl in H1; inversion H1; try lra;
      unfold cBigMul, zipWith, uncurry in *; simpl in *;
      rewrite ! fold_left_Cmult in H0; try rewrite ! Cmult_1_l in H0;
      try rewrite <- ! Copp_mult_distr_l in H0; try rewrite ! Copp_mult_distr_r in H0;
      try apply C_inv_l in H0;
      try easy; try nonzero; try apply Copp_opp in H0; try easy.
Qed.

Lemma Pauli_comm_syntactic_implies_semantic : forall (p1 p2 : Pauli),
    gMul_Coef p1 p2 = gMul_Coef p2 p1 -> translate_P p1 × translate_P p2 = translate_P p2 × translate_P p1.
Proof. intros. destruct p1, p2; simpl in *; try lma'; inversion H; lra. Qed.

Lemma Pauli_anticomm_syntactic_implies_semantic : forall (p1 p2 : Pauli),
    gMul_Coef p1 p2 = (- gMul_Coef p2 p1)%C -> translate_P p1 × translate_P p2 = -C1 .* translate_P p2 × translate_P p1.
Proof. intros. destruct p1, p2; simpl in *; try lma'; inversion H; lra. Qed.

Lemma Pauli_comm_or_anticomm_syntactic : forall (p1 p2 : Pauli),
    gMul_Coef p1 p2 = gMul_Coef p2 p1 \/ gMul_Coef p1 p2 = (- gMul_Coef p2 p1)%C. 
Proof. intros. destruct p1, p2; simpl;
     [ left | left | left | left |
    left | left | right | right |
    left | right | left | right |
       left | right | right | left ];
    lca.
Qed.

Lemma Pauli_comm_or_anticomm_semantic : forall (p1 p2 : Pauli),
    translate_P p1 × translate_P p2 = translate_P p2 × translate_P p1
    \/
      translate_P p1 × translate_P p2 = -C1 .* translate_P p2 × translate_P p1.
Proof. intros. destruct p1, p2; simpl;
  [ left | left | left | left |
    left | left | right | right |
    left | right | left | right |
    left | right | right | left ];
    lma'.
Qed.

Lemma anticommute_commute_TType_syntactic_implies_semantic_nil : forall {n : nat} (t1 t2 : TType n),
    length (snd t1) = length (snd t2) ->
    proper_length_TType_nil t1 -> proper_length_TType_nil t2 ->
    ((anticommute_TType t1 t2 ->
      translate t1 × translate t2 .+ translate t2 × translate t1 = Zero)
     /\ (commute_TType t1 t2 ->
        translate t1 × translate t2 = translate t2 × translate t1)).
Proof. intros n t1 t2 H H0 H1. unfold anticommute_TType, commute_TType.
  destruct t1, t2.
  simpl in *.
  unfold translate. simpl.
  rewrite ! map_length.

  rewrite ! H.
  inversion H1.
  setoid_rewrite Mscale_mult_dist_l at 1.
  setoid_rewrite Mscale_mult_dist_r at 2.
  setoid_rewrite Mscale_mult_dist_l at 1.
  setoid_rewrite Mscale_mult_dist_r at 1.
  setoid_rewrite Mscale_mult_dist_l at 1.
  setoid_rewrite Mscale_mult_dist_r at 2.
  setoid_rewrite Mscale_mult_dist_l at 1.
  setoid_rewrite Mscale_mult_dist_r at 1.
  distribute_scale.
  setoid_rewrite <- Mscale_plus_distr_r.
  clear H2.

  gen n.
  gen l0. gen l.
  induction l; intros; simpl in *.
  - symmetry in H. rewrite length_zero_iff_nil in H. rewrite H.
    split; intros; lma'.
    unfold cBigMul, zipWith, gMul_Coef, uncurry in *; simpl in *.
    inversion H2. lra.
  - destruct l0; try discriminate.
    simpl in *.
    split; intros; simpl in *.
    + apply Pauli_anticomm_cons_comm_anticomm in H2; auto.
      destruct H2.
      destruct (Pauli_comm_or_anticomm_syntactic a p).
      * remember H4 as H5. clear HeqH5.
        apply H3 in H4.
        apply Pauli_comm_syntactic_implies_semantic in H5.
        inversion H.
        rewrite ! map_length. 
        rewrite ! H7.
        setoid_rewrite kron_mixed_product.
        rewrite H5.
        setoid_rewrite <- kron_plus_distr_l.
        assert (@proper_length_TType_nil (length l0) (c, l)). { easy. }
        assert (@proper_length_TType_nil (length l0) (c, l0)). { easy. }
        pose (IHl l0 H7  (length l0) H6 H8).
        destruct a0.
        apply H9 in H4.
        setoid_rewrite <- Mscale_kron_dist_r.
        rewrite H4.
        rewrite kron_0_r.
        reflexivity.
      * remember H4 as H5. clear HeqH5.
        apply H2 in H4.
        apply Pauli_anticomm_syntactic_implies_semantic in H5.
        inversion H.
        rewrite ! map_length. 
        rewrite ! H7.
        setoid_rewrite kron_mixed_product.
        rewrite H5.
        distribute_scale.
        rewrite <- Mscale_kron_dist_r.
        setoid_rewrite <- kron_plus_distr_l.
        assert (@proper_length_TType_nil (length l0) (c, l)). { easy. }
        assert (@proper_length_TType_nil (length l0) (c, l0)). { easy. }
        pose (IHl l0 H7  (length l0) H6 H8).
        destruct a0.
        apply H10 in H4.
        setoid_rewrite <- Mscale_kron_dist_r.
        rewrite Mscale_plus_distr_r.
        setoid_rewrite Mscale_assoc at 1.
        setoid_rewrite Cmult_comm at 1.
        setoid_rewrite <- Mscale_assoc at 1.
        rewrite H4.
        rewrite Mplus_opp_l.
        rewrite kron_0_r.
        reflexivity.
        apply WF_scale.
        apply WF_mult.
        rewrite <- map_length with (f := translate_P).
        apply WF_Matrix_Big_Pauli.
        rewrite <- H7.
        rewrite <- map_length with (f := translate_P).
        apply WF_Matrix_Big_Pauli.
    + apply Pauli_comm_cons_comm_anticomm in H2; auto.
      destruct H2.
      destruct (Pauli_comm_or_anticomm_syntactic a p).
      * remember H4 as H5. clear HeqH5.
        apply H2 in H4.
        apply Pauli_comm_syntactic_implies_semantic in H5.
        inversion H.
        rewrite ! map_length. 
        rewrite ! H7.
        setoid_rewrite kron_mixed_product.
        rewrite H5.
        assert (@proper_length_TType_nil (length l0) (c, l)). { easy. }
        assert (@proper_length_TType_nil (length l0) (c, l0)). { easy. }
        pose (IHl l0 H7  (length l0) H6 H8).
        destruct a0.
        apply H10 in H4.
        setoid_rewrite <- Mscale_kron_dist_r.
        rewrite H4.
        reflexivity.
      * remember H4 as H5. clear HeqH5.
        apply H3 in H4.
        apply Pauli_anticomm_syntactic_implies_semantic in H5.
        inversion H.
        rewrite ! map_length. 
        rewrite ! H7.
        setoid_rewrite kron_mixed_product.
        rewrite H5.
        distribute_scale.
        rewrite <- Mscale_kron_dist_r.
        assert (@proper_length_TType_nil (length l0) (c, l)). { easy. }
        assert (@proper_length_TType_nil (length l0) (c, l0)). { easy. }
        pose (IHl l0 H7  (length l0) H6 H8).
        destruct a0.
        apply H9 in H4.
        setoid_rewrite <- Mscale_kron_dist_r.
        setoid_rewrite Mscale_assoc at 1.
        setoid_rewrite Cmult_comm at 1.
        setoid_rewrite <- Mscale_assoc at 1.
        rewrite Mscale_plus_distr_r in H4.
        rewrite Mplus_comm in H4.
        rewrite Mplus_zero_iff_equals_minus in H4.
        rewrite <- H4.
        reflexivity.
        apply WF_scale.
        apply WF_mult.
        rewrite <- H7.
        rewrite <- map_length with (f := translate_P).
        apply WF_Matrix_Big_Pauli.
        rewrite <- map_length with (f := translate_P).
        apply WF_Matrix_Big_Pauli.
Qed.

Lemma anticommute_commute_TType_syntactic_implies_semantic: forall {n : nat} (t1 t2 : TType n),
    length (snd t1) = length (snd t2) ->
    proper_length_TType t1 -> proper_length_TType t2 ->
    ((anticommute_TType t1 t2 ->
      translate t1 × translate t2 .+ translate t2 × translate t1 = Zero)
     /\ (commute_TType t1 t2 ->
        translate t1 × translate t2 = translate t2 × translate t1)).
Proof. intros. apply proper_length_TType_implies_proper_length_TType_nil in H0.
  apply proper_length_TType_implies_proper_length_TType_nil in H1.
  apply anticommute_commute_TType_syntactic_implies_semantic_nil; auto.
Qed.

Lemma anticommute_AType_implies_semantic_anticommute_nil : forall {n : nat} (a1 a2 : AType n),
    proper_length_AType_nil a1 -> proper_length_AType_nil a2 ->
    anticommute_AType_syntactic a1 a2 -> anticommute_AType_semantic a1 a2.
Proof. intros n a1 a2 G1 G2 H. unfold anticommute_AType_semantic.
  induction a1.
  - unfold translateA. simpl in *. rewrite Mmult_0_l, Mmult_0_r. reflexivity.
  - unfold translateA in *. simpl in *.
    destruct H.
    inversion G1; subst.
    apply IHa1 in H0; auto.
    rewrite ! fold_left_Mplus. rewrite ! Mmult_plus_distr_l, ! Mmult_plus_distr_r.
    rewrite H0. f_equal.
    clear IHa1. clear H3. clear H4. clear H0.
    induction a2.
    + simpl in *. distribute_scale. rewrite Mmult_0_l, Mmult_0_r, Mscale_0_r. reflexivity.
    + simpl in *.
      destruct H.
      inversion G2; subst.
      apply IHa2 in H0; auto.
      rewrite ! fold_left_Mplus. distribute_scale.
      rewrite ! Mmult_plus_distr_l, ! Mmult_plus_distr_r.
      rewrite H0. rewrite Mscale_plus_distr_r, Mscale_mult_dist_l.
      f_equal.
      inversion G1; inversion G2.
      clear - n a a0 H H5 H9.
      inversion H5. inversion H9. rewrite <- H3 in H1.
      destruct (anticommute_commute_TType_syntactic_implies_semantic a a0 H1 H5 H9).
      apply H4 in H.
      rewrite <- Mplus_zero_iff_equals_minus.
      assumption.
      auto with wf_db.
Qed.

Lemma anticommute_AType_implies_semantic_anticommute : forall {n : nat} (a1 a2 : AType n),
    proper_length_AType a1 -> proper_length_AType a2 ->
    anticommute_AType_syntactic a1 a2 -> anticommute_AType_semantic a1 a2.
Proof. intros. apply proper_length_AType_implies_proper_length_AType_nil in H.
  apply proper_length_AType_implies_proper_length_AType_nil in H0.
  apply anticommute_AType_implies_semantic_anticommute_nil; auto.
Qed.

Lemma restricted_addition_syntactic_implies_semantic : forall {n : nat} (A : AType n),
    restricted_addition_syntactic A -> restricted_addition_semantic A.
Proof.
  intros n A H. induction H.
  - constructor. assumption.
  - constructor; try easy.
    apply restricted_addition_syntactic_implies_proper_length_AType in H.
    apply restricted_addition_syntactic_implies_proper_length_AType in H0.
    apply anticommute_AType_implies_semantic_anticommute in H1; auto.
Qed.
    

Lemma restricted_addition_semantic_implies_trace_zero : forall {n : nat} (A : AType n),
    restricted_addition_semantic A -> trace (translateA A) = C0.
Proof. intros. induction H.
  - do 2 destruct H. unfold translateA.
    destruct t. unfold translate.
    simpl in *. rewrite Mplus_0_l.
    rewrite map_length.
    rewrite H2.
    rewrite trace_mult_dist.
    rewrite <- H2.
    rewrite <- map_length with (f := translate_P).
    rewrite trace_zero_syntax_implies_trace_zero; auto; lca.
  - rewrite translateA_gScaleA.
    rewrite trace_mult_dist.
    rewrite translateA_app.
    rewrite trace_plus_dist.
    rewrite IHrestricted_addition_semantic1.
    rewrite IHrestricted_addition_semantic2.
    rewrite Cplus_0_l, Cmult_0_r.
    reflexivity.
    apply proper_length_AType_App.
    apply restricted_addition_semantic_implies_proper_length_AType in H.
    assumption.
    apply restricted_addition_semantic_implies_proper_length_AType in H0.
    assumption.
Qed.

Lemma restricted_addition_semantic_implies_Hermitian : forall {n : nat} (A : AType n),
    restricted_addition_semantic A -> (translateA A) † = (translateA A).
Proof. intros. 
  induction H.
  - unfold translateA. unfold translate. destruct t. simpl. rewrite ! Mplus_0_l.
    destruct H. simpl in *.
    destruct H0; simpl in H0; rewrite H0.
    + rewrite Mscale_1_l. apply list_Pauli_Hermitian.
    + rewrite map_length. destruct H. simpl in *.
      rewrite H2.
      rewrite Mscale_adj.
      replace  ((- C1) ^* ) with  (- C1)%C by lca.
      f_equal. apply list_Pauli_Hermitian.
  - rewrite translateA_gScaleA.
    rewrite Mscale_adj.
    replace ((C1 / √ 2) ^* ) with (C1 / √ 2) by lca.
    f_equal.
    rewrite translateA_app.
    rewrite Mplus_adjoint.
    rewrite IHrestricted_addition_semantic1.
    rewrite IHrestricted_addition_semantic2.
    reflexivity.
    apply proper_length_AType_App.
    apply restricted_addition_semantic_implies_proper_length_AType in H.
    assumption.
    apply restricted_addition_semantic_implies_proper_length_AType in H0.
    assumption.
Qed.


Lemma unit_Pauli : forall (p : Pauli), WF_Unitary (translate_P p).
Proof. intros. 
       destruct p; simpl; auto with unit_db.
Qed.

Lemma unit_list_Pauli : forall (l : list Pauli), WF_Unitary (⨂ map translate_P l).
Proof. intros.
  apply big_kron_unitary.
  intros a H.
  rewrite in_map_iff in H.
  do 2 destruct H.
  rewrite <- H.
  apply unit_Pauli.
Qed.

#[export] Hint Resolve unit_Pauli unit_list_Pauli : unit_db.


(* norm of coeff = 1, precondition *)
Lemma uni_TType : forall {n} (A : TType n), fst A * fst A ^* = C1 -> WF_TType A -> WF_Unitary (translate A). 
Proof. intros n A H H0. 
  unfold translate. pose (scale_unitary (2 ^ (length (snd A))) (fst A) (⨂ map translate_P (snd A))) as w.
  destruct A. inversion H0.
  unfold translate.
  rewrite map_length in *.
  destruct H1. simpl in *.
  subst. unfold WF_Unitary in *. show_dimensions.
  apply w.
  - pose (big_kron_unitary 2 (map translate_P l)) as w0.
    rewrite map_length in *.
    apply w0.
    intros a H4. 
    apply in_map_iff in H4.
    do 2 destruct H4.
    rewrite <- H4.
    apply unit_Pauli.
  - assumption.
Qed.

Lemma restricted_addition_semantic_implies_Unitary : forall {n : nat} (A : AType n),
    restricted_addition_semantic A -> WF_Unitary (translateA A).
Proof. intros. induction H.
  - unfold translateA. simpl. rewrite Mplus_0_l.
    apply uni_TType; auto.
    destruct H.
    destruct H0; rewrite H0; lca.
  - rewrite translateA_gScaleA.
    unfold WF_Unitary.
    split.
    destruct IHrestricted_addition_semantic1.
    destruct IHrestricted_addition_semantic2.
    rewrite translateA_app.
    auto with wf_db.
    destruct IHrestricted_addition_semantic1.
    destruct IHrestricted_addition_semantic2.
    rewrite ! translateA_app.
    setoid_rewrite restricted_addition_semantic_implies_Hermitian in H3; auto.
    setoid_rewrite restricted_addition_semantic_implies_Hermitian in H5; auto.
    rewrite Mscale_adj.
    replace ((C1 / √ 2) ^* ) with (C1 / √ 2) by lca.
    rewrite Mplus_adjoint.
    setoid_rewrite restricted_addition_semantic_implies_Hermitian; auto.
    distribute_scale.
    assert (C1 / √ 2 * (C1 / √ 2) = C1/C2).
    {  replace (C1 / √ 2) with (/ √ 2) by lca.
       rewrite Cinv_sqrt2_sqrt. lca. }
    rewrite H6.
    distribute_plus.
    rewrite H3, H5.
    unfold anticommute_AType_semantic in H1.
    rewrite H1.
    setoid_rewrite Mplus_comm at 3.
    setoid_rewrite Mplus_assoc.
    setoid_rewrite Mplus_comm at 2.
    setoid_rewrite Mplus_assoc.
    assert (- C1 .* translateA a2 × translateA a1
                .+ translateA a2 × translateA a1 = @Zero (2^n) (2^n)).
    { distribute_scale. apply Mplus_opp_l. auto with wf_db. }
    rewrite H7. rewrite Mplus_0_r.
    lma'.
    apply proper_length_AType_App.
    apply restricted_addition_semantic_implies_proper_length_AType in H.
    assumption.
    apply restricted_addition_semantic_implies_proper_length_AType in H0.
    assumption.
Qed.

(* spectral decomposition *)
Definition WF_Spectral {n : nat} (A : Square n) : Prop :=
  WF_Matrix A /\ (exists (U D: Square n), 
    WF_Diagonal D /\ WF_Unitary U /\ D = U † × A × U).

Theorem unit_implies_spectral : forall {n} (A : Square n),
  WF_Unitary A -> WF_Spectral A.
Proof. intros n A H.
  unfold WF_Spectral.
  unfold WF_Unitary in H.
  destruct H.
  split; auto.
  assert (A † × A = A × A†).
  { rewrite H0. symmetry. apply Minv_flip; auto with wf_db. }
  destruct (Spectral_Theorem A H H1) as [U [WFUU WFDUdAU]].
  exists U. exists (U † × A × U).
  auto.
Qed.

Lemma spectral_eigenpairs_transfer : forall {n} (A D U : Square n),
WF_Matrix A -> WF_Diagonal D -> WF_Unitary U ->
  A = U × D × U† ->
  (forall x, (x < n)%nat -> Eigenpair A (U × (e_i x), D x x)).
Proof. intros n A D U H H0 H1 H2 x H3. destruct H1.
  apply (diagble_eigenpairs_transfer A D (U†) U); auto with wf_db.
  Qed.

Lemma big_sum_double_sum_comm : forall (f : nat -> nat -> C) (n m : nat),
    big_sum (fun x => (big_sum (fun y => f x y) n)) m = big_sum (fun y => (big_sum (fun x => f x y) m)) n.
Proof. induction n as [| n'].
  - setoid_rewrite big_sum_0_bounded; easy.
  - intros.
    destruct m as [| m'].
    + setoid_rewrite big_sum_0_bounded; easy.
    + rewrite 2 big_sum_extend_double.
      rewrite IHn'.
      lca.
Qed.

Lemma trace_cyclic : forall {n m : nat} (A : Matrix n m) (B : Matrix m n),
    trace (A × B) = trace (B × A).
Proof. intros.
  unfold trace, Mmult.
  rewrite big_sum_double_sum_comm.
  f_equal.
  apply functional_extensionality.
  intros.
  f_equal.
  apply functional_extensionality.
  intros.
  lca.
Qed.

Lemma hermitian_implies_real_diagonals : forall {n : nat} (A : Square n),
    A † = A -> (forall (i : nat), (i < n)%nat -> snd (A i i) = 0%R).
Proof. intros.
  unfold adjoint in H.
  apply equal_f with (x := i) in H.
  apply equal_f with (x := i) in H.
  unfold Cconj in H.
  destruct (A i i).
  inversion H.
  simpl in *.
  lra.
Qed.



Lemma Unitary_Hermitian_trace_zero_eigenvalues_plus_minus_1 : forall {n} (A : Square n),
  WF_Unitary A -> A † = A -> trace A = 0 ->
  (exists U D, WF_Diagonal D /\ WF_Unitary U /\ A = U × D × U† /\ trace D = C0 /\
  (forall x, (x < n)%nat -> Eigenpair A (U × (e_i x), D x x) /\ (D x x = C1 \/ D x x = (Copp C1)))).
Proof. intros n A WFUA HA TA.
  remember WFUA as WFSA. clear HeqWFSA.
  apply unit_implies_spectral in WFSA.
  destruct WFSA as [WFA [U [D [WFDD [WFUU H]]]]].
  remember H as  H'. clear HeqH'.
  remember WFUU as WFUU'. clear HeqWFUU'.
  destruct WFUU as [WFU UU].
  apply (@Mmult_inj_l n n n U) in H.
  rewrite <- ! Mmult_assoc in H.
  remember UU as UU'. clear HeqUU'.
  apply Minv_flip in UU'; auto with wf_db.
  rewrite UU' in H.
  rewrite Mmult_1_l in H; auto.
  apply (@Mmult_inj_r n n n (U†)) in H.
  setoid_rewrite Mmult_assoc in H at 2.
  rewrite UU' in H.
  rewrite Mmult_1_r in H; auto.
  remember WFDD as WFDD'. clear HeqWFDD'.
  destruct WFDD as [WFD DD].
  (exists U, D). repeat (split; auto).
  rewrite <- H in TA.
  rewrite trace_cyclic in TA.
  rewrite <- Mmult_assoc in TA.
  rewrite UU in TA.
  rewrite Mmult_1_l in TA; auto with wf_db.
  apply spectral_eigenpairs_transfer; auto.
  remember H' as H''. clear HeqH''.
  apply (@Mmult_inj_r n n n D) in H'.
  rewrite H'' in H' at 3.
  repeat setoid_rewrite <- Mmult_assoc in H'.
  setoid_rewrite Mmult_assoc in H' at 3.
  rewrite UU' in H'.
  rewrite Mmult_1_r in H'; auto with wf_db.
  destruct WFUA as [_ UA].
  rewrite HA in UA.
  setoid_rewrite Mmult_assoc in H' at 2.
  rewrite UA in H'.
  rewrite Mmult_1_r in H'; auto with wf_db.
  rewrite UU in H'.
  do 2 apply equal_f with (x := x) in H'.
  unfold I in H'.
  destruct (blt_reflect x n); try contradiction.
  destruct (beq_reflect x x); try contradiction.
  simpl in H'.
  unfold Mmult in H'.
  assert (H1 : (D x x) * (D x x) = C1).
  { rewrite <- H'. symmetry. apply big_sum_unique.
    (exists x). repeat (split; auto).
    intros.
    rewrite DD; auto.
    rewrite Cmult_0_l.
    reflexivity. }
  assert (H2 : D † = D).
  { rewrite ! H''.
    rewrite ! Mmult_adjoint.
    rewrite adjoint_involutive.
    rewrite HA.
    rewrite ! Mmult_assoc.
    reflexivity. }
  apply hermitian_implies_real_diagonals with (i := x) in H2; auto.
  destruct (D x x).
  simpl in H2.
  subst.
  unfold Cmult, C1 in H1.
  simpl in H1.
  inversion H1.
  autorewrite with R_db in *.
  clear H3.
  assert (r = 1 \/ r = -1).
  { nra. }
  destruct H.
  left. subst. lca.
  right. subst. lca.
Qed.


(** Should be provable from the above. **)
(* List of diagonal of D is balanced, count of positives equal to m1, count of negatives equal to m2, then m1 = m2, otherwise contradiction. so n is even.

exists (L1 L2 : list (Vector n)), forall v in L1 -> A v = v /\ forall w in L2 -> A v = -v /\ length L1 = length L2.
 *)


(** 
Try to express basis as a list of Vectors.
Set, orthonormal **)






(* {P} U {Q}
For both P and Q, the only eigenvalues are +1 and -1, and the dimension of +1-eigenstates equals that of the -1-eigenstates.

Let { v1, v2, ..., vn, w1, w2, ..., wn } be the eigenvectors of P where the vi's are the +1 eigenvectors and the wi's are the -1 eigenvectors.

P = U'† D U' for some diagonal D and unitary U'.
Since there is a spectral decomposition for P, we can make { v1, v2, ..., vn, w1, w2, ..., wn } as an orthonormal basis that spans the whole space.

Consider { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn }.
Since unitary matrices preserve innerproducts, { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } also forms an orthonormal basis.

By the assertion {P} U {Q}, given any linear combination v = a1 v1 + ... + an vn, we have QUv = Uv.

Hence { U v1, U v2, ..., U vn } forms a basis for the +1 eigenspace of Q.

Given a w such that Pw = -w we want to show that QUw = -Uw.
Since eigenvectors corresponding to distinct eigenvalues are orthogonal, the -1 eigenspace of Q is orthogonal to the +1 eigenspace of Q.
Therefore, the -1 eigenspace of Q must be spanned by { U w1, U w2, ..., U wn }.
Since { U w1, U w2, ..., U wn } is orthonormal, they form an orthonormal basis of the -1 eigenspace of Q.

Hence, given any linear combination w = a1 w1 + ... + an wn, we have QUw = - Uw.

For any basis v' in { v1, v2, ..., vn, w1, w2, ..., wn }, QUv' = UPv', 
*)




Lemma trace_zero_syntax_nonempty :
  ~ trace_zero_syntax [].
Proof. intro. dependent induction H;
  apply IHtrace_zero_syntax; (* Search (_ ++ _ = []); *)
  apply app_eq_nil in x;
    destruct x; auto.
Qed.

Lemma trace_zero_syntax_non_gI :
  ~ trace_zero_syntax [gI].
Proof. intro.
  dependent induction H.
  - apply app_eq_unit in x.
    destruct x.
    + destruct H0.
      subst.
      apply trace_zero_syntax_nonempty in H.
      contradiction.
    + destruct H0.
      apply IHtrace_zero_syntax.
      assumption.
  - apply app_eq_unit in x.
    destruct x.
    + destruct H0.
      apply IHtrace_zero_syntax.
      assumption.
    + destruct H0.
      subst.
      apply trace_zero_syntax_nonempty in H.
      contradiction.
Qed.

Lemma restricted_addition_semantic_non_nil : forall {n : nat},
    ~ (@restricted_addition_semantic n []).
Proof. intro. intro.
  dependent induction H.
  rewrite gScaleA_dist_app in x.
  apply app_eq_nil in x.
  destruct x.
  unfold gScaleA in *.
  apply map_eq_nil in H2, H3.
  subst.
  apply IHrestricted_addition_semantic1.
  apply eq_implies_JMeq.
  reflexivity.
Qed.

Lemma restricted_addition_syntactic_non_nil : forall {n : nat},
    ~ (@restricted_addition_syntactic n []).
Proof. intro. intro.
  dependent induction H.
  rewrite gScaleA_dist_app in x.
  apply app_eq_nil in x.
  destruct x.
  unfold gScaleA in *.
  apply map_eq_nil in H2, H3.
  subst.
  apply IHrestricted_addition_syntactic1.
  apply eq_implies_JMeq.
  reflexivity.
Qed.

(* Are these needed separately?
WF_AtoPred
WF_Sep
WF_Cap
*)

(** 
WF_Sep :
sum of length of each ln should equal n
    each TType n should be WF_TType **)

Inductive WF_Predicate {n} : Predicate n -> Prop :=
| WF_AtoPred : forall a : AType n, WF_AType a -> WF_Predicate (AtoPred a)
| WF_Cap : forall (la : list (AType n)), Forall WF_AType la -> WF_Predicate (Cap la)
| WF_Sep : forall (Ln_LLT_Perm : (list nat) * (list (list TTypes)) * (list nat)),
    fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm)) = n ->
    Forall2 (fun n LT => Forall (fun T => WF_TType (AssignT n T)) LT) (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm)) ->
    WF_Predicate (Sep Ln_LLT_Perm)
| WF_Cup : forall P1 P2 : Predicate n, WF_Predicate P1 -> WF_Predicate P2 -> WF_Predicate (Cup P1 P2).


(* we are treating I as not well-formed 
Lemma WF_I : WF_Predicate pI. Proof. repeat constructor; try lia; try easy. Qed. *)
Lemma not_WF_I : ~ WF_Predicate pI.
Proof. intro. 
  inversion H; subst; clear H.
  inversion H1; subst; clear H1.
  inversion H; subst; clear H.
  - inversion H1; subst.
    simpl in *.
    apply trace_zero_syntax_non_gI in H2.
    assumption. 
  - rewrite gScaleA_dist_app in H0.
    apply app_eq_unit in H0.
    destruct H0.
    + destruct H.
      apply map_eq_nil in H. subst.
      apply restricted_addition_syntactic_non_nil in H1.
      assumption.
    + destruct H.
      apply map_eq_nil in H0. subst.
      apply restricted_addition_syntactic_non_nil in H2.
      assumption.
Qed.

Lemma WF_X : WF_Predicate pX. 
Proof. do 2 constructor.
  repeat constructor; try lia; easy.
Qed.

Lemma WF_Z : WF_Predicate pZ. 
Proof. do 2 constructor.
  repeat constructor; try lia; easy.
Qed.

Lemma WF_Y : WF_Predicate pY. 
Proof. do 2 constructor.
  repeat constructor; try lia; easy.
Qed.


Lemma WF_TType_scale : forall {n} (a : TType n) (c : Coef),
    c = C1 \/ c = (- C1)%C -> WF_TType a -> WF_TType (gScaleT c a).
Proof. intros n a c H H0. inversion H0. constructor.
  - apply proper_length_TType_gScaleT. assumption.
  - destruct a. simpl in *.
    destruct H; destruct H2; simpl in H2; subst; autorewrite with C_db;
      [ left | right | right | left ]; reflexivity.
  - destruct a. simpl in *. assumption.
Qed.



Lemma WF_AType_scale : forall {n} (A : AType n) (c : Coef),
    c = C1 \/ c = (- C1)%C -> WF_AType A -> WF_AType (gScaleA c A).
Proof. intros n A c H H0. inversion H0; subst.
  constructor.
  induction H1; simpl in *.
  - constructor. apply WF_TType_scale; easy.
  - apply WF_A_syntactic in H1_, H1_0.
    remember H1_ as H1'. clear HeqH1'.
    remember H1_0 as H2'. clear HeqH2'.
    destruct H1', H2'.
    apply restricted_addition_syntactic_implies_proper_length_AType in H2, H3.
    apply IHrestricted_addition_syntactic1 in H1_.
    apply IHrestricted_addition_syntactic2 in H1_0.
    clear IHrestricted_addition_syntactic1. clear IHrestricted_addition_syntactic2.
    inversion H0; subst. clear H0.
    rewrite gScaleA_comm. rewrite gScaleA_dist_app.
    constructor; try easy.
    clear -H1.
    induction a; simpl in *.
    + apply Logic.I.
    + destruct H1. split.
      2: apply IHa; try assumption.
      clear -H.
      induction a0; simpl in *.
      * apply Logic.I.
      * destruct H. split.
        2: apply IHa0; try  assumption.
        destruct a, a0.
        simpl in *.
        assumption.
Qed.

(*
Lemma WF_Predicate_scale : forall {n} (A : Predicate n) (c : Coef), 
    c = C1 \/ c = (- C1)%C -> APredicate A -> 
    WF_Predicate A -> (WF_Predicate (scale c A)).  
Proof. intros n A c H H0 H1. 
  induction H0; simpl. constructor. inversion H1; subst.
  apply WF_AType_scale; try easy.
Qed.
*)

Lemma WF_AType_app : forall {n} (a b : AType n),
    anticommute_AType_syntactic a b ->
    WF_AType a -> WF_AType b -> WF_AType (gScaleA (C1 / √ 2) (a ++ b)).
Proof. intros n a b H H0 H1.
  destruct H0, H1.
  repeat constructor; try easy.
Qed.


Lemma gMulT_gScaleT_l : forall {n} (a b : TType n) (c : Coef),
    gMulT (gScaleT c a) b = gScaleT c (gMulT a b).
Proof. intros n a b c. destruct a, b. simpl.
  f_equal. rewrite ! Cmult_assoc.
  reflexivity.
Qed.

Lemma gMulA_gScaleA_l : forall {n} (A B : AType n) (c : Coef),
    (gMulA (gScaleA c A) B) = gScaleA c (gMulA A B).
Proof. intros n A B c. induction A.
  - simpl. reflexivity.
  - simpl. rewrite gScaleA_dist_app.
    rewrite IHA. f_equal.
    unfold gScaleA.
    rewrite map_map.
    f_equal.
    apply functional_extensionality.
    intros. apply gMulT_gScaleT_l.
Qed.

Lemma gMulT_gScaleT_r : forall {n} (a b : TType n) (c : Coef),
    gMulT a (gScaleT c b) = gScaleT c (gMulT a b).
Proof. intros n a b c. destruct a, b. simpl.
  f_equal. rewrite ! Cmult_assoc.
  do 2 f_equal. rewrite Cmult_comm. reflexivity.
Qed.

Lemma gMulA_gScaleA_r : forall {n} (A B : AType n) (c : Coef),
    (gMulA A (gScaleA c B)) = gScaleA c (gMulA A B).
Proof. intros n A B c. induction A.
  - simpl. reflexivity.
  - simpl. rewrite gScaleA_dist_app.
    rewrite IHA. f_equal.
    unfold gScaleA.
    rewrite ! map_map.
    f_equal.
    apply functional_extensionality.
    intros. apply gMulT_gScaleT_r.
Qed.

Lemma proper_length_TType_zipWith_gMul_base : forall (n : nat) (c c0 c1 : Coef) (l l0 : list Pauli),
    @proper_length_TType n (c, l) ->
    @proper_length_TType n (c0, l0) ->
    @proper_length_TType n (c1, zipWith gMul_base l l0).
Proof. intros n c c0 c1 l l0 H H0.
  destruct H, H0. simpl in *.
  constructor; try assumption.
  simpl in *.
  apply zipWith_len_pres; try assumption.
Qed.

Lemma trace_zero_syntax_zipWith_gMul_base_anticomm : forall (l l0 : list Pauli),
    length l = length l0 ->
    cBigMul (zipWith gMul_Coef l l0) = (- cBigMul (zipWith gMul_Coef l0 l))%C ->
    trace_zero_syntax (zipWith gMul_base l l0).
Proof. induction l.
  - intros.
    simpl in *.
    symmetry in H. rewrite length_zero_iff_nil in H.
    rewrite H. subst.
    unfold zipWith, gMul_base, cBigMul in *. simpl in *.
    inversion H0. lra.
  - intros.
    destruct l0.
    + simpl in *. inversion H.
    + simpl in *. inversion H.
      unfold zipWith in *. simpl in *.
      apply Pauli_anticomm_cons_comm_anticomm in H0; try assumption.
      destruct H0.
      unfold zipWith in *.
      assert (C1 = C1). { easy. }
      assert (Ci = (- - Ci)%C). { rewrite Copp_involutive. easy. }
      assert ((- Ci)%C = (- Ci)%C). {easy. }
      destruct a, p; simpl in *;
        try (apply H1 in H3; clear H4; clear H5; rename H3 into anticomm);
        try (apply H0 in H4; clear H3; clear H5; rename H4 into comm);
        try (apply H0 in H5; clear H3; clear H4; rename H5 into comm).
      all : unfold gMul_base at 1; unfold uncurry at 1; simpl in *.
      2,3,4,5,7,8,9,10,12,13,14,15 : 
      rewrite cons_conc in *; apply trace_zero_syntax_L; constructor.
      all : rewrite cons_conc in *; apply trace_zero_syntax_R; apply IHl; assumption.
      all : apply IHl; try assumption.
Qed.




Lemma big_kron_map_translate_P_twice (l : list Pauli) :
  (⨂ map translate_P l) × (⨂ map translate_P l) = I (2 ^ (length l)).
Proof. induction l.
  - simpl. lma'.
  - simpl. setoid_rewrite kron_mixed_product.
    rewrite IHl.
    assert (2 ^ length l + (2 ^ length l + 0) =  2 ^ S (length l))%nat. { simpl; easy. }
    assert (I 2 × I 2 = I 2). { lma'. }
    assert (σx × σx = I 2). { lma'. }
    assert (σy × σy = I 2). { lma'. }
    assert (σz × σz = I 2). { lma'. }
    destruct a; simpl;
      try rewrite H0;
      try rewrite H1;
      try rewrite H2;
      try rewrite H3;
      try rewrite H4;
      show_dimensions;
      rewrite map_length;
      rewrite kron_2_l;
      reflexivity.
Qed.

Lemma translate_gMulT_split : forall {n} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    translate (gMulT t1 t2) = (translate t1) × (translate t2).
Proof. intros n t1 t2 H0 H1.
  destruct H0, H1.
  destruct t1, t2. simpl in *.
  setoid_rewrite translate_gMulT.
  2: subst; auto.
  unfold translate. simpl.
  show_dimensions.
  rewrite map_length.
  rewrite H0.
  rewrite <- Mscale_assoc.
  rewrite <- Mscale_mult_dist_r.
  rewrite <- Mscale_mult_dist_l.
  easy.
Qed.

(** prove stronger lemma: 
even occurrences of anticommuting Paulis have coefficients +1 or -1
odd occurrences of anticommuting Paulis have coefficients +I or -i **)
Lemma cBigMul_zipWith_gMul_Coef_comm_anticomm_plus_minus_1_i : forall (l l0 : list Pauli),
    length l = length l0 ->
    (cBigMul (zipWith gMul_Coef l l0) = cBigMul (zipWith gMul_Coef l0 l)
     -> cBigMul (zipWith gMul_Coef l l0) = C1 \/ cBigMul (zipWith gMul_Coef l l0) = (-C1)%C)
      /\ (cBigMul (zipWith gMul_Coef l l0) = (- (cBigMul (zipWith gMul_Coef l0 l)))%C
     -> cBigMul (zipWith gMul_Coef l l0) = Ci \/ cBigMul (zipWith gMul_Coef l l0) = (-Ci)%C).
Proof. induction l; intros.
  - simpl in *. symmetry in H. Search (length ?a = 0%nat). rewrite length_zero_iff_nil in H.
    subst.
    unfold cBigMul, zipWith, gMul_Coef; simpl.
    split; intros.
    + auto.
    + inversion H. lra.
  - destruct l0.
    + simpl in H. inversion H.
    + inversion H.
      simpl in *.
      destruct (IHl l0); auto.
      split; intros.
       * apply Pauli_comm_cons_comm_anticomm in H3; auto.
         destruct H3.
         unfold zipWith, cBigMul in *; simpl.
         rewrite fold_left_Cmult.
         unfold uncurry in *; simpl.
         destruct (gMul_Coef_comm_anticomm a p).
         -- specialize (H0 (H3 H5)).
            apply gMul_Coef_comm_1 in H5.
            rewrite H5.
            rewrite Cmult_1_l.
            auto.
         -- specialize (H2 (H4 H5)).
            apply gMul_Coef_anticomm_plus_minus_i in H5.
            destruct H2, H5; rewrite H2, H5;
              [ right | left | left | right ]; lca.
       * apply Pauli_anticomm_cons_comm_anticomm in H3; auto.
         destruct H3.
         unfold zipWith, cBigMul in *; simpl.
         rewrite fold_left_Cmult.
         unfold uncurry in *; simpl.
         destruct (gMul_Coef_comm_anticomm a p).
         -- specialize (H2 (H4 H5)).
            apply gMul_Coef_comm_1 in H5.
            rewrite H5.
            rewrite Cmult_1_l.
            auto.
         -- specialize (H0 (H3 H5)).
            apply gMul_Coef_anticomm_plus_minus_i in H5.
            destruct H0, H5; rewrite H0, H5;
              [ left | right | right | left ]; lca.
Qed.

Lemma cBigMul_zipWith_gMul_Coef_comm_plus_minus_1 : forall (l l0 : list Pauli),
    length l = length l0 ->
    cBigMul (zipWith gMul_Coef l l0) = cBigMul (zipWith gMul_Coef l0 l)
    -> cBigMul (zipWith gMul_Coef l l0) = C1 \/ cBigMul (zipWith gMul_Coef l l0) = (-C1)%C.
(** The number of the anticommuting paulis must be even, so the number of Ci coefficients in the multiplied tensor must also be even. Hence, the multiplication of all coefficients must be either 1 or -1 **)
Proof. apply cBigMul_zipWith_gMul_Coef_comm_anticomm_plus_minus_1_i. Qed.

Lemma trace_zero_syntax_zipWith_gMul_base_comm : forall (n : nat) (l l0 : list Pauli),
  cBigMul (zipWith gMul_Coef l l0) = cBigMul (zipWith gMul_Coef l0 l)
  -> length l = n -> length l0 = n ->
  zipWith gMul_base l l0 <> repeat gI n ->
  trace_zero_syntax (zipWith gMul_base l l0).
Proof. intros. gen l0 n.  induction l.
  - intros.
    simpl in *.
    rewrite <- H0 in H1.
    rewrite length_zero_iff_nil in H1.
    subst.
    unfold zipWith, gMul_base, cBigMul in *. simpl in *.
    contradiction.
  - intros.
    destruct l0.
    + simpl in *. rewrite <- H1 in H0. inversion H0.
    + simpl in *. destruct n; inversion H0; inversion H1.
      unfold zipWith in *. simpl in *.
      
      unfold cBigMul in *. simpl in *.
      rewrite ! fold_left_Cmult in H.
      unfold uncurry in *.
      simpl in *.
      destruct (gMul_base a p) eqn:base.
      * assert ( ~ (uncurry gMul_base (a, p) = gI /\ map (uncurry gMul_base) (combine l l0) = repeat gI n)).
      { generalize H2. apply not_iff_compat.
        split. intros. destruct H3. unfold uncurry in H3. simpl in *.
        f_equal. auto. intros. inversion H3. split; auto. }
        assert (gMul_Coef a p = C1).
        { destruct a, p; unfold gMul_Coef; simpl; auto.
          all: unfold gMul_base in base; simpl in base; inversion base. }
        assert (gMul_Coef p a = C1).
        { destruct a, p; unfold gMul_Coef; simpl; auto.
          all: unfold gMul_base in base; simpl in base; inversion base. }

        rewrite H6, H7 in *. rewrite ! Cmult_1_l in H.
        unfold "<>" in H3.
        unfold uncurry in H3.
        simpl in H3.
        assert ( map (uncurry gMul_base) (combine l l0) <> repeat gI n ).
        { intro.
          assert (gMul_base a p = gI /\ map (uncurry gMul_base) (combine l l0) = repeat gI n).
          { auto. }
          destruct (H3 H9). }
        specialize (IHl l0 H n H4 H5 H8).
        Search ([?a] ++ ?b). rewrite cons_conc.
        apply trace_zero_syntax_R. assumption.
      * rewrite cons_conc. do 2 constructor.
      * rewrite cons_conc. do 2 constructor.
      * rewrite cons_conc. do 2 constructor.
Qed.

Lemma zipWith_gMul_base_eq : forall (n : nat) (l l0 : list Pauli),
    length l = length l0 ->
    (zipWith gMul_base l l0 = repeat gI (length l) <-> l = l0).
Proof. intros n l l0 H.
  split; intro.
  - gen l0. induction l; intros; simpl in *.
    + inversion H.
      symmetry in H2. rewrite length_zero_iff_nil in H2.
      subst. easy.
    + destruct l0.
      * inversion H.
      * simpl in *. inversion H.
        inversion H0.
        f_equal.
        -- unfold uncurry, gMul_base in H3.
           destruct a, p; try easy; inversion H3.
        -- rewrite H3 in H4.
           unfold zipWith in IHl.
           specialize (IHl l0 H2 H4).
           easy.
  - rewrite H0. rewrite zipWith_gMul_base_inv. easy.
Qed.


Lemma zipWith_gMul_base_neq : forall (n : nat) (l l0 : list Pauli),
    length l = length l0 ->
    (zipWith gMul_base l l0 <> repeat gI (length l) <-> l <> l0).
Proof. intros n l l0 H.
  apply zipWith_gMul_base_eq in H; auto.
  apply not_iff_compat in H. easy.
Qed.
  
(* simple multiplication does not preserve well-formedness
Lemma WF_AType_map_gMulT : forall {n} (a : TType n) (B : AType n),
    WF_TType n a -> WF_AType n B -> WF_AType n (map (fun x : TType n => gMulT a x) B).
Proof. intros n a B0 H H0.
  induction H0; simpl; constructor; try apply WF_TType_mul; easy.
Qed.

Lemma WF_AType_mul : forall {n} (A B : AType n),
    WF_AType n A -> WF_AType n B -> WF_AType n (gMulA A B).
Proof.  intros n A0 B0 H H0.
   induction H.
   - simpl. rewrite app_nil_r.
     apply WF_AType_map_gMulT; easy.
   - simpl. apply WF_AType_app; try easy.
     apply WF_AType_map_gMulT; easy.
Qed.

Lemma WF_Predicate_mul : forall {n} (A B : Predicate n),
    APredicate A -> APredicate B -> 
  WF_Predicate A -> WF_Predicate B ->
  WF_Predicate (A *' B). 
Proof. intros n A B H H0 H1 H2.
  induction H, H0. inversion H1; inversion H2; subst.
  constructor. apply WF_AType_mul; easy.
Qed.
 *)

(** Precondition: Commute -> gMulT a b <> (c, gI^n) <- use repeat function **)
Lemma WF_TType_mul_commute : forall {n} (a b : TType n),
    commute_TType a b -> (snd (gMulT a b) <> repeat gI n) ->
    WF_TType a -> WF_TType b -> WF_TType (gMulT a b).
Proof. intros n a b H H0 H1 H2. 
  unfold gMulT. destruct a, b.
  unfold commute_TType in H.
  do 2 destruct H1, H2; simpl in *.
  constructor; simpl.
  simpl; split; try assumption.
  apply zipWith_len_pres; assumption.
  apply cBigMul_zipWith_gMul_Coef_comm_plus_minus_1 in H; subst; auto.
  destruct H, H3, H5; simpl in *; rewrite H, H3, H5; autorewrite with C_db;
    [ left | right | right | left | right | left | left | right ]; reflexivity.
  apply trace_zero_syntax_zipWith_gMul_base_comm with (n := n);
    try assumption.
Qed.

(** Precondition : commute -> a <> b **)
Lemma WF_TType_mul_commute' : forall {n} (a b : TType n),
    commute_TType a b -> snd a <> snd b ->
    WF_TType a -> WF_TType b -> WF_TType (gMulT a b).
Proof. intros n a b H H0 H1 H2.
  destruct a, b. simpl in H0.
  remember H1. remember H2. clear Heqw Heqw0.
  destruct w, w0. destruct H3, H6. simpl in H9, H10.
  rewrite <- zipWith_gMul_base_neq in H0; auto.
  2: subst; auto.
  apply WF_TType_mul_commute; simpl; subst; auto.
Qed.



Lemma cBigMul_zipWith_gMul_Coef_anticomm_plus_minus_i : forall (l l0 : list Pauli),
    length l = length l0 ->
    (cBigMul (zipWith gMul_Coef l l0) = (- (cBigMul (zipWith gMul_Coef l0 l)))%C
     -> cBigMul (zipWith gMul_Coef l l0) = Ci \/ cBigMul (zipWith gMul_Coef l l0) = (-Ci)%C).
Proof. apply cBigMul_zipWith_gMul_Coef_comm_anticomm_plus_minus_1_i. Qed.


Lemma WF_TType_mul_anticommute : forall {n} (a b : TType n),
    anticommute_TType a b ->
    WF_TType a -> WF_TType b -> WF_TType (gScaleT Ci (gMulT a b)).
Proof. intros n a b H H0 H1.
  unfold anticommute_TType in H.
  destruct a, b.
  unfold gMulT.
  destruct H0, H1.
  inversion H0; inversion H1.
  simpl in *.
  constructor; simpl.
  - constructor; auto.
    simpl.
    rewrite zipWith_len_pres with (n := n); auto.
  - subst.
    apply cBigMul_zipWith_gMul_Coef_anticomm_plus_minus_i in H; auto.
    destruct H, H2, H4; simpl in *; rewrite H, H2, H4;
      [ right | left | left | right | left | right | right | left ]; lca.
  - subst.
    apply trace_zero_syntax_zipWith_gMul_base_anticomm; auto.
Qed.


Lemma gMulA_dist_app_l : forall {n} (a a1 a2 : AType n),
    gMulA (a1 ++ a2) a = (gMulA a1 a) ++ (gMulA a2 a).
Proof. intros n a a1 a2.
  induction a1; auto.
  simpl. rewrite IHa1.
  rewrite app_assoc.
  auto.
Qed.

(** counterexample : the form 1/√2 (A + B) is not closed under multiplication

YYYYYZ, XXYYZZ, 
XXXXXI, ZZZIII

1/√2 (a1 + a2)* 1/√2 (b1 + b2) = 1/2 (a1 b1 + a1 b2 + a2 b1 + a2 b2) =
1/√2 ( 1/√2 (a1 b1 + a1 b2) + 1/√2 (a2 b1 + a2 b2) )

a1 b1 a2 b2 = - a1 a2 b1 b2 = a2 a1 b1 b2 = - a2 a1 b2 b1 = a2 b2 a1 b1 (impossible)

a1 b1 a1 b2 = - a1 a1 b1 b2 = a1 a1 b2 b1 = - a1 b2 a1 b1 (possible)
a1 b1 a2 b1 = - a1 a2 b1 b1 = a2 a1 b1 b1 = - a2 b1 a1 b1 (possible)

(Is 1/√2 (a1 b1 + a1 b2) and 1/√2 (a2 b1 + a2 b2) anticommutative?)
a1 b1 a2 b1 + a1 b1 a2 b2 + a1 b2 a2 b1 + a1 b2 a2 b2
= - a2 b1 a1 b1 + a2 b2 a1 b1 + a2 b1 a1 b2 - a2 b2 a1 b2
= - a2 b1 a1 b1 + a2 b2 a1 b1 - a2 a1 b1 b2 - a2 b2 a1 b2
= - a2 b1 a1 b1 + a2 b2 a1 b1 - a2 b2 a1 b1 - a2 b2 a1 b2
= - a2 b1 a1 b1 - a2 b2 a1 b2

a2 b1 a1 b1 + a2 b2 a1 b1 + a2 b1 a1 b2 + a2 b2 a1 b2
= a2 b1 a1 b1 + a2 b2 a1 b1 - a2 a1 b1 b2 + a2 b2 a1 b2
= a2 b1 a1 b1 + a2 b2 a1 b1 - a2 b2 a1 b1 + a2 b2 a1 b2
= a2 b1 a1 b1 + a2 b2 a1 b2
(Yes, 1/√2 (a1 b1 + a1 b2) and 1/√2 (a2 b1 + a2 b2) are semantically anticommutative)

(Is 1/√2 (a1 b1 + a2 b1) and 1/√2 (a1 b2 + a2 b2) anticommutative?)
a1 b1 a1 b2 + a1 b1 a2 b2 + a2 b1 a1 b2 + a2 b1 a2 b2
= a1 b1 a1 b2 + a1 b1 a2 b2 + a2 b1 a1 b2 + a2 b1 a2 b2
= a1 b1 a1 b2 + a1 b1 a2 b2 - b1 a2 a1 b2 + a2 b1 a2 b2
= a1 b1 a1 b2 + a1 b1 a2 b2 + b1 a1 a2 b2 + a2 b1 a2 b2
= a1 b1 a1 b2 + a1 b1 a2 b2 - a1 b1 a2 b2 + a2 b1 a2 b2
= a1 b1 a1 b2 + a2 b1 a2 b2

a1 b2 a1 b1 + a2 b2 a1 b1 + a1 b2 a2 b1 + a2 b2 a2 b1
= - a1 b2 b1 a1 + a2 b2 a1 b1 - b2 a1 a2 b1 - a2 a2 b2 b1
= a1 b1 b2 a1 + a2 b2 a1 b1 + b2 a2 a1 b1 + a2 a2 b1 b2
= - a1 b1 a1 b2 + a2 b2 a1 b1 - a2 b2 a1 b1 - a2 b1 a2 b2
= - a1 b1 a1 b2 - a2 b1 a2 b2
(Yes, 1/√2 (a1 b1 + a1 b2) and 1/√2 (a2 b1 + a2 b2) are semantically anticommutative)


Inductive restricted_addition_syntactic (n : nat) : AType n -> Prop :=
    add_restrict_base_syntactic : forall t : TType n,
                                  WF_TType n t -> restricted_addition_syntactic [t]
  | add_restrict_inductive_syntactic : forall a1 a2 : AType n,
                                       restricted_addition_syntactic a1 ->
                                       restricted_addition_syntactic a2 ->
                                       anticommute_AType_syntactic a1 a2 ->
                                       restricted_addition_syntactic
                                         (gScaleA (C1 / √ 2) (a1 ++ a2)).
 **)

Lemma WF_AType_dist_app : forall {n} (a1 a2 : AType n),
    WF_AType a1 -> WF_AType a2 -> anticommute_AType_syntactic a1 a2 ->
    WF_AType (gScaleA (C1 / √ 2) (a1 ++ a2)).
Proof. intros n a1 a2 H H0 H1. 
  do 2 constructor; inversion H; inversion H0; auto.
Qed.

(* not needed?
(** prove for the simple tensored Paulis case of multiplication **)
Lemma WF_AType_mul_anticommutative_l : forall {n} (t : TType n) (A : AType n),
    anticommute_TType_AType t A ->
    WF_TType n t -> WF_AType n A -> WF_AType n (gScaleA (Ci)%C (map (fun (a : TType n) => gMulT t a) A)).
Proof. intros n t A H H0 H1.
  destruct H1.
  induction H1; simpl in *.
  - inversion H0. inversion H2.
    inversion H1. inversion H7.
    destruct t, t0. simpl in *.
    destruct H. clear H12. do 3 constructor. 
    + constructor; simpl; auto.
      rewrite zipWith_len_pres with (n:=n); auto.
    + simpl. rewrite <- H11 in H6.
      apply cBigMul_zipWith_gMul_Coef_anticomm_plus_minus_i in H; auto.
      destruct H, H3, H8; rewrite H, H3, H8;
        [ right | left | left | right | left | right | right | left ]; lca.
    + simpl. rewrite <- H11 in H6.
      apply trace_zero_syntax_zipWith_gMul_base_anticomm; auto.
  - assert (  (gScaleA Ci (map (fun a : TType n => gMulT t a) (gScaleA (C1 / √ 2) (a1 ++ a2)))) =
                (gScaleA (C1 / √ 2) ((gScaleA Ci (map (fun a : TType n => gMulT t a) a1)) ++
                  (gScaleA Ci (map (fun a : TType n => gMulT t a) a2)))) ).
    { unfold gScaleA. rewrite <- ! map_app.
      rewrite ! map_map. f_equal.
      apply functional_extensionality. intro.
      destruct t, x. simpl. f_equal. lca. }
    rewrite H2. clear H2.
    rewrite anticommute_TType_AType_gScaleA in H.
    rewrite anticommute_TType_AType_app_dist in H.
    destruct H.
    apply WF_AType_dist_app.
    + apply IHrestricted_addition_syntactic1; auto.
    + apply IHrestricted_addition_syntactic2; auto.
    + rewrite anticommute_AType_syntactic_gScaleA.
      apply anticommute_AType_syntactic_comm.
      rewrite anticommute_AType_syntactic_gScaleA.
      apply anticommute_AType_syntactic_comm.
      clear IHrestricted_addition_syntactic1 IHrestricted_addition_syntactic2.
      clear H1_ H1_0.
      induction a1; auto.
      simpl in *.
      destruct H, H1.
      specialize (IHa1 H3 H4).
      split; auto.
      clear IHa1.
      clear H3 H4.
      induction a2; auto.
      simpl in *.
      destruct H2, H1.
      specialize (IHa2 H3 H4).
      split; auto.
      clear IHa2.
      clear H3 H4.
      
      unfold gMulT, anticommute_TType in *.
      destruct t, a, a0.
      (* don't know how to proceed *)
      *)

(* does not work
Lemma WF_AType_mul_anticommutative : forall {n} (A B : AType n),
    anticommute_AType_syntactic A B ->
    WF_AType n A -> WF_AType n B -> WF_AType n (gScaleA (Ci)%C (gMulA A B)).
Proof. intros n A B H H0 H1.
  constructor. destruct H0, H1.

  induction H0.
  - simpl in *. rewrite app_nil_r.
    destruct H.
    induction H1.
    + simpl. constructor.
      destruct H. unfold anticommute_TType in H.
      destruct t, t0. simpl in *.
      constructor; simpl in *.
      3:{ destruct H0, H1. destruct H0, H1. simpl in *. rewrite <- H9 in H8.
          apply trace_zero_syntax_zipWith_gMul_base_anticomm; assumption. }
      1:{ apply proper_length_TType_zipWith_gMul_base with (c:=c) (c0:=c0);
          destruct H0; destruct H1; assumption. }
      destruct H0, H1. simpl in *.
      destruct H0, H1. simpl in *.
      apply cBigMul_zipWith_gMul_Coef_anticomm_plus_minus_i in H.
      2: subst; auto.
      destruct H, H4, H6; rewrite H, H4, H6;
      [ right | left | left | right | left | right | right | left ]; lca.
    + Search gScaleA.
      unfold gScaleA.
      rewrite ! map_map.
      assert ((fun x : TType n => gScaleT Ci (gMulT t (gScaleT (C1 / √ 2) x)))
              = (fun x : TType n => gScaleT (C1 / √ 2) (gMulT t (gScaleT Ci x)))).
      { apply functional_extensionality. intros.
        destruct x, t. simpl in *. f_equal. lca. }
      rewrite H3. rewrite <- map_map.
      assert ( (map (gScaleT (C1 / √ 2)) (map (fun x : TType n => gMulT t (gScaleT Ci x)) (a1 ++ a2))) = gScaleA (C1 / √ 2) (map (fun x : TType n => gMulT t (gScaleT Ci x)) (a1 ++ a2)) ).
      { unfold gScaleA. easy. }
      rewrite H4.
      rewrite map_app.
      constructor;
      clear H2;
      clear H3; clear H4;
      rewrite anticommute_TType_AType_gScaleA in H;
      rewrite anticommute_TType_AType_app_dist in H;
      destruct H.
      assert ( (map (fun x : TType n => gMulT t (gScaleT Ci x)) a1) =
                 (gScaleA Ci (map (fun x : TType n => gMulT t x) a1)) ).
      { unfold gScaleA.
        rewrite map_map. f_equal.
        apply functional_extensionality. intro.
        destruct x, t. simpl.
        f_equal. lca. }
      rewrite H3. 
      apply IHrestricted_addition_syntactic1. auto.
      assert ( (map (fun x : TType n => gMulT t (gScaleT Ci x)) a2) =
                 (gScaleA Ci (map (fun x : TType n => gMulT t x) a2)) ).
      { unfold gScaleA.
        rewrite map_map. f_equal.
        apply functional_extensionality. intro.
        destruct x, t. simpl.
        f_equal. lca. }
      rewrite H3.
      apply IHrestricted_addition_syntactic2. auto.
      assert ( (map (fun x : TType n => gMulT t (gScaleT Ci x)) a1) =
                 (gScaleA Ci (map (fun x : TType n => gMulT t x) a1)) ).
      { unfold gScaleA.
        rewrite map_map. f_equal.
        apply functional_extensionality. intro.
        destruct x, t. simpl.
        f_equal. lca. }
      rewrite H3.
      assert ( (map (fun x : TType n => gMulT t (gScaleT Ci x)) a2) =
                 (gScaleA Ci (map (fun x : TType n => gMulT t x) a2)) ).
      { unfold gScaleA.
        rewrite map_map. f_equal.
        apply functional_extensionality. intro.
        destruct x, t. simpl.
        f_equal. lca. }
      rewrite H4.
      clear H3. clear H4.
      rewrite anticommute_AType_syntactic_gScaleA.
      apply anticommute_AType_syntactic_comm.
      rewrite anticommute_AType_syntactic_gScaleA.
      apply anticommute_AType_syntactic_comm.
      specialize (IHrestricted_addition_syntactic1 H).
      specialize (IHrestricted_addition_syntactic2 H2).
      clear IHrestricted_addition_syntactic1.
      clear IHrestricted_addition_syntactic2.
      clear H1_. clear H1_0. 
      induction a1; auto.
      simpl in *. destruct H, H1.
      specialize (IHa1 H3 H4).
      split; auto.
      clear IHa1.
      induction a2; auto.
      apply anticommute_AType_syntactic_comm in H4.
      simpl in *. destruct H2, H1, H4.
      apply anticommute_AType_syntactic_comm in H7.
      specialize (IHa2 H5 H6 H7).
      split; auto.
      clear IHa2.
      clear -H0 H H2 H1. (** anticommute_TType (gMulT t a) (gMulT t a0) **)
      destruct t, a, a0.
      simpl in *.
      admit.
  - rewrite gScaleA_dist_app.
    rewrite gMulA_dist_app_l.
    rewrite gScaleA_dist_app.
    rewrite ! gMulA_gScaleA_l.
    setoid_rewrite gScaleA_comm at 1.
    setoid_rewrite gScaleA_comm at 2.
    rewrite <- gScaleA_dist_app.
    apply anticommute_AType_syntactic_comm in H.
    rewrite anticommute_AType_syntactic_gScaleA in H.
    apply anticommute_AType_syntactic_comm in H.
    rewrite anticommute_AType_syntactic_app_dist_l in H.
    destruct H.
    specialize (IHrestricted_addition_syntactic1 H).
    specialize (IHrestricted_addition_syntactic2 H2).
    constructor; auto.
    rewrite anticommute_AType_syntactic_gScaleA.
    apply anticommute_AType_syntactic_comm.
    rewrite anticommute_AType_syntactic_gScaleA.

    
(** second try **)
    clear - H H2 H0 H1.
    
    induction a2; auto.
    apply anticommute_AType_syntactic_comm in H0.
    simpl in *.
    destruct H2, H0.
    apply anticommute_AType_syntactic_comm in H4.
    specialize (IHa2 H3 H4).
    rewrite anticommute_AType_syntactic_app_dist_l.
    split; auto.
    apply anticommute_AType_syntactic_comm.
    clear IHa2.

    induction a1; auto.
    simpl in *.
    destruct H, H0, H4.
    specialize (IHa1 H5 H6 H7).
    rewrite anticommute_AType_syntactic_app_dist_l.
    split; auto.
    clear IHa1.
    clear - H H2 H0 H1.

    induction H1; simpl in *.
    + destruct H, H2. clear H3 H4.
      repeat split; auto.
      admit.
    + rewrite anticommute_TType_AType_gScaleA in H, H2.
      rewrite anticommute_TType_AType_app_dist in H, H2.
      destruct H, H2.
      specialize (IHrestricted_addition_syntactic1 H H2).
      specialize (IHrestricted_addition_syntactic2 H3 H4).
      assert ( (map (fun x : TType n => gMulT a1 x) (gScaleA (C1 / √ 2) (a0 ++ a2)))
               = (gScaleA (C1 / √ 2) (map (fun x : TType n => gMulT a1 x) (a0 ++ a2))) ).
      { unfold gScaleA. rewrite ! map_map.
        f_equal. apply functional_extensionality. intro.
        destruct a1, x. simpl. f_equal. lca. }
      rewrite H5. clear H5.
      assert ( (map (fun x : TType n => gMulT a x) (gScaleA (C1 / √ 2) (a0 ++ a2)))
               = (gScaleA (C1 / √ 2) (map (fun x : TType n => gMulT a x) (a0 ++ a2))) ).
      { unfold gScaleA. rewrite ! map_map.
        f_equal. apply functional_extensionality. intro.
        destruct a, x. simpl. f_equal. lca. }
      rewrite H5. clear H5.
      rewrite anticommute_AType_syntactic_gScaleA.
      apply anticommute_AType_syntactic_comm.
      rewrite anticommute_AType_syntactic_gScaleA.
      apply anticommute_AType_syntactic_comm.
      rewrite ! map_app.
      rewrite ! anticommute_AType_syntactic_app_dist_l.
      rewrite ! anticommute_AType_syntactic_app_dist_r.
      repeat split; auto.
      clear IHrestricted_addition_syntactic1 IHrestricted_addition_syntactic2.
      clear H1_ H1_0.

      * induction a0; auto.
        simpl in *. destruct H, H2, H1.
        specialize (IHa0 H5 H6 H7).
        split; auto.
        clear IHa0 H5 H6 H7.

        induction a2; auto.
        simpl in *. destruct H3, H4, H1.
        specialize (IHa2 H5 H6 H7).
        split; auto.
        clear IHa2 H5 H6 H7.


                            
    (* first try
    clear - H H2 H0.


    
    induction a2; auto.
    apply anticommute_AType_syntactic_comm in H0.
    simpl in *.
    destruct H2, H0.
    apply anticommute_AType_syntactic_comm in H3.
    specialize (IHa2 H2 H3).
    rewrite anticommute_AType_syntactic_app_dist_l.
    split; auto.
    apply anticommute_AType_syntactic_comm.
    clear IHa2.

    
    induction a1; auto.
    simpl in *.
    destruct H, H0, H3.
    specialize (IHa1 H4 H5 H6).
    rewrite anticommute_AType_syntactic_app_dist_l.
    split; auto.
    clear IHa1.
    clear - H H1 H0.
     

    induction a0; auto.
    simpl in *.
    destruct H, H1.
    specialize (IHa0 H2 H3).
    repeat split.
    3: apply anticommute_AType_syntactic_comm; simpl; split.
    4: apply anticommute_AType_syntactic_comm; auto.
    all: clear IHa0.
    clear H2 H3.

    
    2-3: induction a2; auto; simpl in *.
    2: destruct H2, H3; specialize (IHa2 H4 H5); split; auto; clear IHa2;
    clear - H H2 H1 H3 H0.
    3: destruct H2, H3; specialize (IHa2 H4 H5); split; auto; clear IHa2;
    clear - H H2 H1 H3 H0.
    2:{ destruct   }
         (* a1 a0 a a2 = - a1 a a0 a2 = a a1 a0 a2 = 
a0 a2 comm: a a1 a2 a0 = - a a2 a1 a0
a0 a2 anticomm : - a a1 a2 a0 = a a2 a1 a0
            a a2 a1 a0 *)
*)
*)

(* not needed?
(** prove for the simple tensored Paulis case of multiplication **)
(** commute_AType_syntactic, anticommute_AType_syntactic mutually define? **)
(** commute_AType_syntactic term-wise definition of commuttivity **)
(** permutation : vol3 software foundations, or monoid.v **)
Lemma WF_AType_mul_commutative : forall {n} (A B : AType n),
    commute_AType_syntactic A B -> A not a permutation of B ->
    WF_AType n A -> WF_AType n B -> WF_AType n (gMulA A B).
Proof. Admitted. *)



Lemma WF_TType_tensor : forall {n m} (a : TType n) (b : TType m), WF_TType a -> WF_TType b -> WF_TType (gTensorT a b).
Proof. intros n m a b H H0.
  destruct H, H0.
  constructor.
  - unfold proper_length_TType in *. destruct H, H0. split; try lia.
    unfold gTensorT. destruct a, b. simpl in *. rewrite app_length. subst. reflexivity.
  - destruct a, b. unfold gTensorT. simpl in *.
    destruct H1, H3; simpl in *; subst; autorewrite with C_db;
      [left | right | right | left]; reflexivity.
  - destruct a, b. unfold gTensorT. simpl in *.
    constructor. assumption.
Qed.

Lemma map_gTensorT_gScaleA : forall {n m} (c : Coef) (a : TType n) (A : AType m),
    map (fun x : TType m => gTensorT a x) (gScaleA c A) =
      gScaleA c (map (fun x : TType m => gTensorT a x) A).
Proof. intros n m c a A.
  induction A.
  - simpl. auto.
  - simpl. f_equal; auto.
    clear IHA.
    destruct a, a0. simpl.
    f_equal. lca.
Qed.



Lemma gTensorT_gScaleT_comm_l : forall {n m} (c : Coef) (a : TType n) (b : TType m), gTensorT (gScaleT c a) b = gScaleT c (gTensorT a b).
Proof. intros n m c a b.
  unfold gScaleT, gTensorT.
  destruct a, b.
  f_equal.
  lca.
Qed. 

Lemma gTensorA_gScaleA_comm_l : forall {n m} (c : Coef) (a : AType n) (b : AType m), gTensorA (gScaleA c a) b = gScaleA c (gTensorA a b).
Proof. intros n m c a b.
  induction a.
  - auto.
  - simpl.
    Search gScaleA.
    rewrite gScaleA_dist_app.
    rewrite IHa.
    f_equal.
    unfold gScaleA.
    rewrite map_map.
    f_equal.
    apply functional_extensionality.
    intros t.
    apply gTensorT_gScaleT_comm_l.
Qed.

Lemma gTensorT_gScaleT_comm_r : forall {n m} (c : Coef) (a : TType n) (b : TType m), gTensorT a (gScaleT c b) = gScaleT c (gTensorT a b).
Proof. intros n m c a b.
  unfold gScaleT, gTensorT.
  destruct a, b.
  f_equal.
  lca.
Qed. 

Lemma gTensorA_gScaleA_comm_r : forall {n m} (c : Coef) (a : AType n) (b : AType m), gTensorA a (gScaleA c b) = gScaleA c (gTensorA a b).
Proof. intros n m c a b.
  induction a.
  - auto.
  - simpl.
    Search gScaleA.
    rewrite gScaleA_dist_app.
    rewrite IHa.
    f_equal.
    unfold gScaleA.
    rewrite ! map_map.
    f_equal.
    apply functional_extensionality.
    intros t.
    apply gTensorT_gScaleT_comm_r.
Qed.

Lemma gTensorA_app_dist : forall {n m} (a1 a2 : AType n) (a0 : AType m), gTensorA (a1 ++ a2) a0 = (gTensorA a1 a0) ++ (gTensorA a2 a0).
Proof. intros n m a1 a2 a0.
  induction a1; auto.
  simpl.
  rewrite <- app_assoc.
  f_equal.
  auto.
Qed.


Lemma gTensorA_nil_r : forall {n m} (a : AType n), @gTensorA n m a [] = [].
Proof. intros n m a.
  induction a.
  - auto.
  - simpl.
    apply IHa.
Qed.

Lemma fold_left_Cmult_app : forall {l l0}, fold_left Cmult (l ++ l0) C1 = (fold_left Cmult l C1) * (fold_left Cmult l0 C1).
Proof. intros l l0.
  induction l.
  - simpl. lca.
  - simpl.
    rewrite ! fold_left_Cmult.
    rewrite IHl.
    lca.
Qed.

Lemma WF_AType_map_gTensorT : forall {n m} (a : TType n) (B : AType m),
    WF_TType a -> WF_AType B -> WF_AType (map (fun x : TType m => gTensorT a x) B).
Proof. intros n m a B0 H H0. 
  constructor.
  destruct H, H0. simpl in *.
  induction H0; simpl in *.
  - destruct a, t, H0. simpl in *.
    do 2 constructor; simpl in *.
    + constructor; destruct H, H0; simpl in *; try lia.
      rewrite app_length. subst. reflexivity.
    + destruct H1, H3; simpl in *; subst; autorewrite with C_db; [left | right | right | left]; reflexivity.
    + constructor. assumption.
  -  rewrite map_gTensorT_gScaleA.
     rewrite map_app.
     constructor; auto.
     clear IHrestricted_addition_syntactic1 IHrestricted_addition_syntactic2.
     clear -H0.
     induction a1.
     + simpl. auto.
     + simpl in *. destruct H0.
       split.
       2: apply IHa1; auto.
       clear IHa1.
       induction a2.
       * simpl. auto.
       * simpl in *. destruct H.
         apply anticommute_AType_syntactic_comm in H0.
         simpl in *.
         destruct H0.
         apply anticommute_AType_syntactic_comm in H2.
         split.
         2: apply IHa2; auto.
         clear IHa2.
         clear -H.
         destruct a, a0, a2.
         simpl in *.
         rewrite <- ! zipWith_app_product with (n:=length l); auto.
         unfold cBigMul in *.
         rewrite ! fold_left_Cmult_app.
         Search fold_left.
         rewrite H.
         lca.
Qed.

Lemma restricted_addition_syntactic_map_gTensorT : forall {n m} (a : TType n) (B : AType m),
    WF_TType a -> restricted_addition_syntactic B -> restricted_addition_syntactic (map (fun x : TType m => gTensorT a x) B).
Proof. intros n m a B0 H H0.
  destruct H. simpl in *.
  induction H0; simpl in *.
  - destruct a, t, H0. simpl in *.
    do 2 constructor; simpl in *.
    + constructor; destruct H, H0; simpl in *; try lia.
      rewrite app_length. subst. reflexivity.
    + destruct H1, H3; simpl in *; subst; autorewrite with C_db; [left | right | right | left]; reflexivity.
    + constructor. assumption.
  -  rewrite map_gTensorT_gScaleA.
     rewrite map_app.
     constructor; auto.
     
     clear -H0.
     induction a1.
     + simpl. auto.
     + simpl in *. destruct H0.
       split.
       2: apply IHa1; auto.
       clear IHa1.
       induction a2.
       * simpl. auto.
       * simpl in *. destruct H.
         apply anticommute_AType_syntactic_comm in H0.
         simpl in *.
         destruct H0.
         apply anticommute_AType_syntactic_comm in H2.
         split.
         2: apply IHa2; auto.
         clear IHa2.
         clear -H.
         destruct a, a0, a2.
         simpl in *.
         rewrite <- ! zipWith_app_product with (n:=length l); auto.
         unfold cBigMul in *.
         rewrite ! fold_left_Cmult_app.
         Search fold_left.
         rewrite H.
         lca.
Qed.


















(* counterexample

1/√2(a1+a2) ⊗ 1/√2(b1+b2)

suppose a1*a2=-a2*a1 and b1*b2=-b2*b1

(a1+a2)⊗(b1+b2)
= ((a1+a2)⊗b1)+((a1+a2)⊗b2)
= a1⊗b1+a2⊗b1+a1⊗b2+a2⊗b2

((a1+a2)⊗b1)*((a1+a2)⊗b2)
= ((a1+a2)^2⊗(b1*b2))

((a1+a2)⊗b2)*((a1+a2)⊗b1)
= ((a1+a2)^2⊗(b2*b1))


((a1+a2)⊗(b1+b2))*((a1+a2)⊗(b1+b2))
=((a1+a2)⊗(b1+b2))^2
=((a1+a2)^2)⊗((b1+b2)^2)


-----------------------
a1 = X
a2 = Z
a0 = 1/√2(X+Z)

1/√2(X+Z) : X anticommutes with Z
1/√2(X+Z) ⊗ 1/√2(X+Z)

1/2(XX+XZ+ZX+ZZ)
= 1/√2(1/√2(XX+XZ)+1/√2(ZX+ZZ))

1/2(XX+XZ+ZX+ZZ)*1/2(XX+XZ+ZX+ZZ)
=1/4(XX*XX+XX*XZ+XX*ZX+XX*ZZ+
     XZ*XX+XZ*XZ+XZ*ZX+XZ*ZZ+
     ZX*XX+ZX*XZ+ZX*ZX+ZX*ZZ+
     ZZ*XX+ZZ*XZ+ZZ*ZX+ZZ*ZZ)
=1/4(+II -iIY-iYI-YY
     +iIY+II +YY -iYI
     +iYI+YY +II -iIY
     -YY +iYI+iIY+II)
=1/4(4*II)
=II

a1 = X
a2 = Z
a0 = X+Z
a1⊗a0 = XX+XZ
a2⊗a0 = ZX+ZZ

a1⊗a0 * a2⊗a0 = (XX+XZ)*(ZX+ZZ)
= XX*ZX+XX*ZZ+XZ*ZX+XZ*ZZ
= -iYI -YY   +YY   -iYI

a2⊗a0 * a1⊗a0 = (ZX+ZZ)*(XX+XZ)
= ZX*XX+ZZ*XX+ZX*XZ+ZZ*XZ
= iYI  -YY   +YY   +iYI

 *)
(** ** not needed?? does not work
Lemma WF_AType_tensor : forall {n m} (A : AType n) (B : AType m),
    WF_AType n A -> WF_AType m B -> WF_AType (n+m) (gTensorA A B).
Proof. intros n m A0 B0 H H0.
  destruct H, H0.
  constructor.

  dependent induction H.
  - simpl. rewrite app_nil_r.
    apply restricted_addition_syntactic_map_gTensorT; auto.
  - rewrite gTensorA_gScaleA_comm.
    rewrite gTensorA_app_dist.
    apply add_restrict_inductive_syntactic.
    + apply IHrestricted_addition_syntactic1; auto.
    + apply IHrestricted_addition_syntactic2; auto.
    + 
    subst.
    Admitted. *)
(*
anticommute_AType_syntactic (gTensorA a1 a0) (gTensorA a2 a0)

syntactically not true:

a1 = X
a2 = Z
a0 = X+Z
a1⊗a0 = XX+XZ
a2⊗a0 = ZX+ZZ

XX commutes with ZZ

but semantically true:

a1⊗a0 * a2⊗a0 = (XX+XZ)*(ZX+ZZ)
= XX*ZX+XX*ZZ+XZ*ZX+XZ*ZZ
= -iYI -YY   +YY   -iYI

a2⊗a0 * a1⊗a0 = (ZX+ZZ)*(XX+XZ)
= ZX*XX+ZZ*XX+ZX*XZ+ZZ*XZ
= iYI  -YY   +YY   +iYI

----------------------------------------------------

NOT TRUE: 

a1 = X+Y
a2 = Z
a0 = X+Z
a1⊗a0 = XX+XZ+YX+YZ
a2⊗a0 = ZX+ZZ
Then XX and YX are commutative with ZZ,
and XZ and YZ are commmutative with ZX.
XX*ZX+XZ*ZX+YX*ZX+YZ*ZX
+XX*ZZ+XZ*ZZ+YX*ZZ+YZ*ZZ
= -iYI+YY+iXI-XY
-YY-iYI+XY+iXI

ZX*XX+ZX*XZ+ZX*YX+ZX*YZ
+ZZ*XX+ZZ*XZ+ZZ*YX+ZZ*YZ
= iYI+YY-iXI-XY
-YY+iYI+XY-iXI

semantically anticommutes

--------------------------
a1 = X+Y
a2 = Z
a0 = X+Z

1/√2(X+Y) : X anticommutes with Y
1/√2(1/√2(X+Y)+Z) : Z anticommutes with X and Y
1/√2(X+Z) : Z anticommutes with X

1/√2(1/√2(X+Y)+Z) ⊗ 1/√2(X+Z)
**)

    
(** ** not needed?
Lemma WF_Predicate_tensor : forall {n m} (A : Predicate n) (B : Predicate m),
  APredicate A -> APredicate B -> 
  WF_Predicate A -> WF_Predicate B ->
  WF_Predicate (A ⊗' B). 
Proof. intros n m A B H H0 H1 H2. 
  induction H, H0. inversion H1; inversion H2; subst.
  constructor. apply WF_AType_tensor; easy.
Qed.
*)


Lemma WF_AType_add : forall {n} (A B : AType n),
     anticommute_AType_syntactic A B ->
    WF_AType A -> WF_AType B -> WF_AType (gScaleA (C1 / √ 2) (gAddA A B)).
Proof. intros n A B H H0 H1.
  unfold gAddA.  apply WF_AType_app; easy.
Qed. 

(* Not used
Lemma WF_Predicate_add : forall {n} (A : Predicate n) (B : Predicate n),
    anticommute_APredicate_syntactic A B ->
    APredicate A -> APredicate B -> 
    WF_Predicate A -> WF_Predicate B ->
    WF_Predicate ((C1 / √ 2) ·' (A +' B)). 
Proof. intros n A B H H0 H1 H2 H3.
  induction H0, H1. inversion H; inversion H2; inversion H3; subst.
  constructor. apply WF_AType_add; try easy. Qed.
*)

Lemma WF_AType_neg : forall {n} (A : AType n),
    WF_AType A -> WF_AType (gScaleA (Copp C1) A).
Proof. intros n A H.  apply WF_AType_scale; try easy. right. reflexivity. Qed.

(* Not used
Lemma WF_Predicate_neg : forall {n} (A : Predicate n),
    APredicate A -> 
    WF_Predicate A ->  WF_Predicate (- A). 
Proof. intros n A H H0.
  induction H. inversion H0; subst.
  constructor. apply WF_AType_neg; easy.
Qed.
*)
(* scaling outside of +1 or -1 does not work 
Lemma WF_AType_i : forall {n} (A : AType n),
    WF_AType n A -> WF_AType n (gScaleA Ci A).
Proof. intros n A H.  apply WF_AType_scale; easy. Qed.

Lemma WF_Predicate_i : forall {n} (A : Predicate n),
    APredicate A -> 
    WF_Predicate A ->  WF_Predicate (i A). 
Proof. intros n A H H0.
  induction H. inversion H0; subst.
  constructor. apply WF_AType_i; easy.
Qed.
*)

#[export] Hint Resolve WF_I WF_X WF_Z WF_Y WF_AType_scale WF_AType_add WF_AType_neg : wfpt_db.
(** 
Hint Resolve WF_AType_implies_WF_AType_nil WF_I WF_X WF_Z WF_Y WF_AType_mul WF_Predicate_mul WF_AType_scale WF_Predicate_scale WF_AType_tensor WF_Predicate_tensor WF_AType_add WF_Predicate_add WF_AType_neg WF_Predicate_neg WF_AType_i WF_Predicate_i : wfpt_db. *)


Lemma fold_left_WF_Matrix_AType : forall {n} (a : TType n) (A : list (TType n)),  
    fold_left Mplus (map translate A) (Zero .+ translate a)%M
    =  (fold_left Mplus (map translate A) (Zero) .+  translate a)%M.
Proof. intros n a A. apply (fold_left_Mplus (translate a) Zero (map translate A)).
Qed.

Lemma WF_Matrix_AType : forall {n} (A : AType n), WF_AType A -> WF_Matrix (translateA A). 
Proof. intros n A H. destruct H.
  induction H.
  - destruct H.
    unfold translateA. simpl.
    rewrite Mplus_0_l.
    apply WF_translate; auto.
  - apply restricted_addition_syntactic_implies_proper_length_AType in H.
    apply restricted_addition_syntactic_implies_proper_length_AType in H0.
    rewrite translateA_gScaleA.
    2: apply proper_length_AType_App; auto.
    apply WF_scale.
    apply WF_Matrix_translateA.
    apply proper_length_AType_App; auto.
Qed.

#[export] Hint Resolve WF_Matrix_AType : wf_db wfpt_db.


(* Not used
(*************)
(* proper_length_TPredicate types *)
(*************)

(** ** probably not needed
Inductive WF_TPredicate {n} : Predicate n -> Prop :=
| WFT : forall T : Predicate n, TPredicate T -> WF_Predicate T -> WF_TPredicate T. *)


Lemma pl_tp_all : forall (c : Coef) (l : list Pauli),
    length l <> 0%nat ->
    @proper_length_TPredicate (length l) (G ([(c,l)])).
Proof. intros. do 2 constructor; auto. Qed.

#[export] Hint Resolve pl_tp_all : wfpt_db.

Lemma pl_tp_I : proper_length_TPredicate pI. Proof. do 2 constructor; auto. Qed.
Lemma pl_tp_X : proper_length_TPredicate pX. Proof. do 2 constructor; auto. Qed.
Lemma pl_tp_Z : proper_length_TPredicate pZ. Proof. do 2 constructor; auto. Qed.
Lemma pl_tp_Y : proper_length_TPredicate pY. Proof. do 2 constructor; auto. Qed.


Lemma pl_tp_mul : forall {n} (A B : Predicate n),
  proper_length_TPredicate A -> proper_length_TPredicate B -> 
  proper_length_TPredicate (A *' B). 
Proof. intros n A B H H0. 
  inversion H; inversion H0.
  inversion H1; inversion H3.
  simpl in *. constructor.
  destruct t, t0. constructor; auto.
  simpl in *.
  rewrite zipWith_len_pres with (n:=n); auto.
Qed.


Lemma pl_tp_tensor : forall {n m} (A : Predicate n) (B : Predicate m),
  proper_length_TPredicate A -> proper_length_TPredicate B ->
  proper_length_TPredicate (A ⊗' B). 
Proof. intros n m A B H H0. 
  inversion H; inversion H0.
  inversion H1. inversion H3.
  simpl in *. constructor.
  constructor; try lia.
  destruct t, t0. simpl in *.
  rewrite app_length.
  rewrite H6,H8. auto.
Qed.


Lemma pl_tp_scale : forall {n} (A : Predicate n) (c : Coef),
  proper_length_TPredicate A ->  proper_length_TPredicate (scale c A). 
Proof. intros n A c H.
  inversion H. inversion H0.
  do 2 constructor; auto.
  destruct t. simpl in *.
  auto.
Qed.

Lemma pl_tp_neg : forall {n} (A : Predicate n),
  proper_length_TPredicate A ->  proper_length_TPredicate (- A). 
Proof. intros n A H. 
  inversion H. inversion H0.
  do 2 constructor; auto.
  destruct t. simpl in *.
  auto.
Qed.
   
Lemma pl_tp_i : forall {n} (A : Predicate n),
  proper_length_TPredicate A ->  proper_length_TPredicate (+i A). 
Proof. intros n A H.
  inversion H. inversion H0.
  do 2 constructor; auto.
  destruct t. simpl in *.
  auto.
Qed.


#[export] Hint Resolve pl_tp_all pl_tp_I pl_tp_X pl_tp_Z pl_tp_Y pl_tp_scale pl_tp_mul pl_tp_tensor pl_tp_neg pl_tp_i : wfpt_db.

(*************)
(* proper_length_APredicate types *)
(*************)

(** ** probably not needed
Inductive WF_APredicate {n} : Predicate n -> Prop :=
| WFA : forall T : Predicate n, APredicate T -> WF_Predicate T -> proper_length_APredicate T. *)



Lemma pl_ap_I : proper_length_APredicate pI. Proof. do 3 constructor; auto. Qed.
Lemma pl_ap_X : proper_length_APredicate pX. Proof. do 3 constructor; auto. Qed.
Lemma pl_ap_Z : proper_length_APredicate pZ. Proof. do 3 constructor; auto. Qed.
Lemma pl_ap_Y : proper_length_APredicate pY. Proof. do 3 constructor; auto. Qed.
*)


(* Not used
Lemma pl_ap_mul : forall {n} (A B : Predicate n),
  proper_length_APredicate A -> proper_length_APredicate B -> 
  proper_length_APredicate (A *' B). 
Proof. intros n A B H H0. 
  inversion H; inversion H0.
  constructor.
  apply proper_length_AType_gMulA; auto.
Qed.
*)

(*
Lemma pl_ap_tensor : forall {n m} (A : Predicate n) (B : Predicate m),
  proper_length_APredicate A -> proper_length_APredicate B ->
  proper_length_APredicate (A ⊗' B). 
Proof. intros n m A B H H0. 
  inversion H; inversion H0.
  simpl in *. constructor.
  apply proper_length_AType_gTensorA; auto.
Qed.


Lemma pl_ap_scale : forall {n} (A : Predicate n) (c : Coef),
  proper_length_APredicate A ->  proper_length_APredicate (scale c A). 
Proof. intros n A c H.
  inversion H.
  constructor.
  apply proper_length_AType_gScaleA; auto.
Qed.

Lemma pl_ap_neg : forall {n} (A : Predicate n),
  proper_length_APredicate A ->  proper_length_APredicate (- A). 
Proof. intros n A H. 
       apply pl_ap_scale; easy. 
Qed.
   
Lemma pl_ap_i : forall {n} (A : Predicate n),
  proper_length_APredicate A ->  proper_length_APredicate (+i A). 
Proof. intros n A H.
       apply pl_ap_scale; easy. 
Qed.


Lemma pl_ap_G_sing : forall {n} (a : TType n) (A : AType n),
    proper_length_APredicate (G (a :: A)) -> proper_length_APredicate (G ([a])).
Proof. intros n a A H.
  inversion H; subst.
  inversion H1; subst.
  - destruct H2; do 3 constructor; auto.
  - destruct H3; do 3 constructor; auto.
Qed.

Lemma pl_ap_G_cons : forall {n} (a : TType n) (A : AType n),
    A <> [] -> proper_length_APredicate (G (a :: A)) -> proper_length_APredicate (G (A)).
Proof. intros n a A H H0. 
  inversion H0; subst.
  inversion H2; subst.
  - contradiction.
  - constructor; auto.
Qed.

Lemma pl_ap_G_cons' : forall {n} (a : TType n) (A : AType n),
    proper_length_AType n A -> proper_length_APredicate (G (a :: A)) -> proper_length_APredicate (G (A)).
Proof. intros n a A H H0. 
  inversion H0; subst.
  inversion H2; subst.
  - inversion H.
  - constructor; auto.
Qed.

#[export] Hint Resolve pl_ap_I pl_ap_X pl_ap_Z  pl_ap_Y pl_ap_scale pl_ap_mul pl_ap_tensor pl_ap_neg pl_ap_i pl_ap_G_sing pl_ap_G_cons pl_ap_G_cons' : wfpt_db.
*)


(******************)
(* unitary lemmas *)
(******************)


Lemma unitary_two_pauli : forall (p1 p2 : Pauli),
    p1 <> p2 -> p1 <> gI -> p2 <> gI -> WF_Unitary (C1 / √ 2 .* translate_P p1 .+ C1 / √ 2 .* translate_P p2)%M /\ WF_Unitary (- C1 / √ 2 .* translate_P p1 .+ C1 / √ 2 .* translate_P p2)%M /\ WF_Unitary (C1 / √ 2 .* translate_P p1 .+ - C1 / √ 2 .* translate_P p2)%M.
Proof. intros. split; [ idtac | split ]; unfold translate_P, WF_Unitary;
  induction p1, p2; simpl; split; try contradiction; auto with wf_db;
    lma'; auto 15 with wf_db;
    autounfold with U_db; simpl;
    C_field_simplify; try nonzero;
    autorewrite with Cexp_db C_db;
    eapply c_proj_eq; simpl;
    repeat (autorewrite with R_db; field_simplify_eq; simpl);
    try easy.
Qed.


Lemma zipWith_gMul_base_symmetric : forall (l l0 : list Pauli), length l = length l0 -> zipWith gMul_base l l0 = zipWith gMul_base l0 l.
Proof. intros l. unfold zipWith, gMul_base, uncurry. induction l.
  - intros. rewrite combine_nil. simpl. easy.
  - intros. destruct l0; try discriminate. simpl. f_equal. destruct a, p; simpl; try easy. apply IHl. inversion H. easy.
Qed.

Lemma commute_TType_gMulT_swap : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    fst t1 <> C0 -> fst t2 <> C0 ->
    commute_TType t1 t2 <-> gMulT t1 t2 = gMulT t2 t1.
Proof. intros n t1 t2 H H0 H1 H2. 
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  split; intros.
  - unfold commute_TType in H3.
    unfold gMulT.
    rewrite (Cmult_comm c1 c2).
    f_equal.
    f_equal; auto.
    rewrite zipWith_gMul_base_symmetric; auto.
    inversion H; subst; clear H.
    inversion H0; subst; clear H0.
    simpl in *.
    auto.
  - unfold commute_TType.
    unfold gMulT in H3.
    rewrite (Cmult_comm c1 c2) in H3.
    assert (forall {A B : Type} (a a' : A) (b b' : B), (a,b) = (a',b') -> a=a').
    { intros. inversion H4. auto. }
    apply H4  in H3. 
    apply Cmult_cancel_l with (a := c2 * c1) in H3; auto.
    simpl in *.
    apply Cmult_neq_0; auto.
Qed.

Lemma anticommute_TType_gMulT_antiswap : forall {n : nat} (t1 t2 : TType n),
    proper_length_TType t1 -> proper_length_TType t2 ->
    fst t1 <> C0 -> fst t2 <> C0 ->
    anticommute_TType t1 t2 <-> gMulT t1 t2 = gScaleT (Copp C1) (gMulT t2 t1).
Proof. intros n t1 t2 H H0 H1 H2.
  destruct t1 as [c1 l1].
  destruct t2 as [c2 l2].
  split; intros.
  - unfold anticommute_TType in H3.
    unfold gMulT.
    rewrite (Cmult_comm c1 c2).
    simpl.
    rewrite ! Cmult_assoc.
    replace (- C1 * c2 * c1) with (c2 * c1 * (- C1)) by lca.
    rewrite <- ! Cmult_assoc.
    f_equal.
    do 2 f_equal.
    2: { inversion H. inversion H0.
         simpl in *.
         rewrite zipWith_gMul_base_symmetric;
           subst; auto. }
    inversion H; subst; clear H.
    inversion H0; subst; clear H0.
    simpl in *.
    rewrite H3.
    lca.
  - unfold anticommute_TType.
    unfold gMulT in H3.
    rewrite (Cmult_comm c1 c2) in H3.
    assert (forall {A B : Type} (a a' : A) (b b' : B), (a,b) = (a',b') -> a=a').
    { intros. inversion H4. auto. }
    apply H4  in H3.
    rewrite ! Cmult_assoc in H3.
    replace (- C1 * c2 * c1) with (c2 * c1 * (- C1)) in H3 by lca.
    rewrite <- ! Cmult_assoc in H3.
    apply Cmult_cancel_l with (a := c2) in H3; auto.
    apply Cmult_cancel_l with (a := c1) in H3; auto.
    simpl in *.
    rewrite H3.
    lca.
Qed.


(* same as unitary_two_tensored_paulis except that (fst t2 = - C1/√2). *)
Lemma unitary_two_tensored_paulis' : forall {n} (t1 t2 : TType n), 
    proper_length_TType t1 -> proper_length_TType t2 ->
    (fst t1 = C1/√2) -> (fst t2 = - C1/√2) ->
    anticommute_TType t1 t2 ->
    WF_Unitary (@translateA n (t1 :: t2 :: nil)). 
Proof. intros. destruct t1, t2. simpl in *.
  destruct H, H0. simpl in *.
  rewrite H1, H2 in *. clear H1. clear H2.
  inversion H3; subst.
  unfold translateA.
  simpl. rewrite Mplus_0_l.
  unfold translate. simpl  in *.
  setoid_rewrite Cmult_comm at 2.
  setoid_rewrite <- Cmult_1_l at 5.
  setoid_rewrite <- Mscale_assoc at 2.
  replace ( C1 * / √ 2 ) with ( C1 / √ 2) by lca.
  setoid_rewrite <- Mscale_plus_distr_r with (x:=C1 / √ 2) (A:=⨂ map translate_P l) (B:=(-C1 .*(⨂ map translate_P l0))%M).
  rewrite ! map_length.
  apply unitary_hermitian_anticommute_unitary.
  rewrite <- map_length with (f:=translate_P).
  apply unit_list_Pauli.
  rewrite <- H5.
  rewrite <- map_length with (f:=translate_P).
  apply scale_unitary; try lca.
  apply unit_list_Pauli.
  apply list_Pauli_Hermitian.
  setoid_rewrite Mscale_adj with (x := (-C1)%C) (A := (⨂ map translate_P l0)).
  replace ((- C1) ^* )%C with (-C1)%C by lca.
  rewrite map_length.
  rewrite H5.
  apply Mscale_inj with (c:= (-C1)%C).
  apply list_Pauli_Hermitian.
  apply Mscale_cancel with (c:= (-C1)%C).
  intro. inversion H1. lra.
  setoid_rewrite <- Mscale_mult_dist_r at 1.
  unfold Matrix.scale at 1.
  setoid_rewrite Mscale_assoc at 1.
  replace (- C1 * - C1)%C with (C1) by lca.
  rewrite Mscale_1_l.
  setoid_rewrite <- Mscale_mult_dist_l.
  unfold Matrix.scale at 2.
  setoid_rewrite Mscale_assoc.
  replace (-C1 * - C1)%C with (C1) by lca.
  rewrite Mscale_1_l.
  replace (Copp (RtoC (IZR (Zpos xH)))) with (RtoC (IZR (Zneg xH))) by lca.
  apply Mscale_cancel with (c:=C1/C2).
  - intros G. apply C_inj_r with (c:=C2) in G. unfold Cdiv in G. rewrite <- Cmult_assoc in G. rewrite Cinv_l in G; try nonzero. rewrite Cmult_0_l in G. rewrite Cmult_1_l in G. contradict G. nonzero.
  - rewrite Mscale_assoc. rewrite Cmult_comm. rewrite <- Mscale_assoc.
    replace (C1 / C2) with ((C1/√2) * (C1/√2)) by C_field.
    rewrite Mscale_assoc. rewrite Cmult_assoc. symmetry. rewrite Cmult_comm. symmetry.
    assert ((C1 / √ 2 * (C1 / √ 2) .* ((⨂ map translate_P l) × (⨂ map translate_P l0)))%M
            = (translate (gMulT  (C1 / √ 2, l) (C1 / √ 2, l0)))%M).
    { rewrite <- translate_gMulT; easy. }
      rewrite <- map_length with (f:=translate_P).
    rewrite H1.
    assert ((C1 / √ 2 * (-1 * (C1 / √ 2)) .* ((⨂ map translate_P l0) × (⨂ map translate_P l)))%M
            = (translate (gMulT  (C1 / √ 2, l0) (-1 * (C1 / √ 2), l)))%M).
    { rewrite <- translate_gMulT; easy. }
    show_dimensions.
    rewrite map_length.
    rewrite <- H5.
    rewrite <- map_length with (f:=translate_P).
    rewrite H4.
    simpl.
    assert (C1 / √ 2 * (C1 / √ 2) * - cBigMul (zipWith gMul_Coef l0 l)
            = C1 / √ 2 * (-1 * (C1 / √ 2)) * cBigMul (zipWith gMul_Coef l0 l)).
    { rewrite <- ! Cmult_assoc. apply C_inj_l. symmetry. 
      rewrite Cmult_comm. rewrite <- ! Cmult_assoc. apply C_inj_l.
      lca. }
    rewrite <- H6.
    rewrite H2.
    rewrite zipWith_gMul_base_symmetric; easy.
Qed.

Fixpoint uni_Predicate {n} (P : Predicate n) :=
  match P with
  | AtoPred _ => WF_Unitary (translateP P)
  | Cap la => Forall WF_Unitary (map translateA la)
  | Sep Ln_LLT_Perm => Forall2 (fun n LT => Forall (fun T => coef_size_1 (AssignT n T)) LT) (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm))
  | Cup a b => (uni_Predicate a) /\ (uni_Predicate b)
  | Err => False
  end.

Lemma uni_vec_I : uni_Predicate pI.
Proof. simpl. unfold translateA, translate, translate_P. simpl.
       rewrite Mplus_0_l, Mscale_1_l, kron_1_r. unfold WF_Unitary.
       split. auto with wf_db. lma'.
Qed.
  
Lemma uni_vec_X : uni_Predicate pX.
Proof. simpl. unfold translateA, translate, translate_P. simpl.
       rewrite Mplus_0_l, Mscale_1_l, kron_1_r. unfold WF_Unitary.
       split. auto with wf_db. lma'.
Qed.

Lemma uni_vec_Y : uni_Predicate pY.
Proof.  simpl. unfold translateA, translate, translate_P. simpl.
       rewrite Mplus_0_l, Mscale_1_l, kron_1_r. unfold WF_Unitary.
       split. auto with wf_db. lma'.
Qed.

  Lemma uni_vec_Z : uni_Predicate pZ.
Proof.  simpl. unfold translateA, translate, translate_P. simpl.
       rewrite Mplus_0_l, Mscale_1_l, kron_1_r. unfold WF_Unitary.
       split. auto with wf_db. lma'.
Qed.


#[export] Hint Resolve unit_Pauli uni_vec_I uni_vec_X uni_vec_Y uni_vec_Z : wfpt_db.


(******************************************************)
(* Showing translations preserves relevent properties *)
(******************************************************)

(* we actually use this to prove translate_mult, so we prove it first *)
Lemma translate_kron : forall {n m} (g1 : TType n) (g2 : TType m),
    length (snd g1) = n -> length (snd g2) = m ->
    translate (gTensorT g1 g2) = (translate g1) ⊗ (translate g2).
Proof. intros n m g1 g2 H H0.  unfold translate.
         destruct g1; destruct g2.
         simpl in *.
         do 3 (rewrite map_length). 
         rewrite H, H0 in *.
         rewrite Mscale_kron_dist_r.
         rewrite Mscale_kron_dist_l.
         rewrite Mscale_assoc.
         bdestruct_all; simpl. 
         rewrite Cmult_comm.
         rewrite map_app. 
         assert (H3 : forall (l : list Pauli) (i0 : nat), WF_Matrix (nth i0 (map translate_P l) Zero)).
         { intros.  
           bdestruct (i0 <? length (map translate_P l1)).
           + apply (nth_In _ (@Zero 2 2)) in H1.
             apply in_map_iff in H1.
             destruct H1 as [x [H3 H4] ].
             rewrite <- H3; apply WF_Matrix_Pauli.
           + rewrite nth_overflow; try lia. 
             auto with wf_db. }
         rewrite big_kron_app; auto.
         do 2 (rewrite map_length).
         rewrite app_length.
         rewrite H, H0 in *.
         reflexivity.
Qed.


Lemma fold_left_translateA_kron : forall {n m} (a : TType n) (B : AType m),
 length (snd a) = n -> proper_length_AType B ->
    (fold_left Mplus (map (fun x : TType m => translate (gTensorT a x)) B) Zero
     =  translate a ⊗ fold_left Mplus (map translate B) Zero)%M.
Proof. intros n m a B H H0.  generalize dependent a. induction B.
  - intros a H.   simpl. lma.
  - intros a0 H.   simpl. rewrite 2 fold_left_Mplus. rewrite kron_plus_distr_l.
    inversion H0.
    + inversion H2. rewrite <- (translate_kron a0 a); try assumption. simpl.
      apply Zero_kron.
    + inversion H3. rewrite <- (translate_kron a0 a); try assumption.
      rewrite IHB; try assumption. reflexivity.
Qed.

Lemma translateA_kron : forall {n m} (a : AType n) (b : AType m),
    proper_length_AType a -> proper_length_AType b ->
    translateA (gTensorA a b) = (translateA a) ⊗ (translateA b).
Proof. intros n m a b H H0. induction H.
  - simpl. rewrite app_nil_r. unfold translateA. simpl. rewrite Mplus_0_l. rewrite <- fold_left_translateA_kron; inversion H; try assumption. rewrite map_map; reflexivity.
  - simpl. unfold translateA. simpl. rewrite fold_left_Mplus.
    unfold translateA in IHproper_length_AType. rewrite kron_plus_distr_r.  rewrite <- IHproper_length_AType.
    rewrite map_app. rewrite fold_left_Mplus_app_Zero.
    rewrite map_map. rewrite <- fold_left_translateA_kron; inversion H; try assumption. rewrite Mplus_comm. reflexivity.
Qed.
    

Lemma translate_reduce : forall (n : nat) (c : Coef) (p : Pauli) (l : list Pauli),
  length l = n -> 
  @translate (S n) (c, p :: l) = (translate_P p) ⊗ @translate n (c, l).
Proof. intros. 
       unfold translate. 
       simpl. 
       rewrite map_length.
       replace (2^(length l) + (2^(length l) + 0))%nat with (2 * 2^(length l))%nat by lia. 
       rewrite <- Mscale_kron_dist_r.
       rewrite H; easy. 
Qed.

Lemma translate_Mmult : forall {n} (g1 g2 : TType n),
    length (snd g1) = n -> length (snd g2) = n ->
    translate (gMulT g1 g2) = (translate g1) × (translate g2).
Proof. intros n g1 g2 H H0. induction n as [| n'].
       - destruct g1; destruct g2. 
         destruct l; destruct l0; try easy. 
         unfold translate. simpl. 
         distribute_scale.
         rewrite Mmult_1_r; auto with wf_db.
         unfold zipWith, cBigMul. simpl.
         destruct c; destruct c0; try easy.
         autorewrite with C_db.
         reflexivity.
       - destruct g1; destruct g2.
         destruct l; destruct l0; try easy. 
         simpl in H; simpl in H0.
         apply Nat.succ_inj in H.
         apply Nat.succ_inj in H0.
         rewrite gMulT_reduce; try easy.
         replace (S n') with (1 + n')%nat by lia.
         rewrite translate_kron; try easy.
         rewrite IHn'; try easy.
         rewrite (translate_reduce _ c), (translate_reduce _ c0); try easy.
         restore_dims.
         rewrite kron_mixed_product.
         assert (H' : @translate 1 (gMul_Coef p p0, [gMul_base p p0]) = 
                      translate_P p × translate_P p0).
         { destruct p; destruct p0; simpl. 
           all : unfold translate; simpl. 
           all : lma'. }
         rewrite H'; easy. 
         simpl. 
         bdestruct_all.
         simpl. 
         apply zipWith_len_pres; easy.
Qed.

Lemma fold_left_translateA_Mmult : forall {n} (a : TType n) (B : AType n),
    proper_length_TType a -> proper_length_AType B ->
    fold_left Mplus (map (fun x : TType n => translate (gMulT a x)) B) Zero =
      translate a × fold_left Mplus (map translate B) Zero.
Proof. intros n a B H H0.
  induction H0.
  - simpl. rewrite 2 Mplus_0_l. inversion H; inversion H0; rewrite translate_Mmult; easy.
  - simpl. rewrite 2 fold_left_Mplus. rewrite Mmult_plus_distr_l. rewrite <- translate_Mmult.
    rewrite IHproper_length_AType. reflexivity.
    + inversion H. assumption.
    + inversion H0. assumption.
Qed. 

Lemma translateA_Mmult : forall {n} (a b : AType n),
    proper_length_AType a -> proper_length_AType b ->
    translateA (gMulA a b) = (translateA a) × (translateA b).
Proof. intros n a b H H0.
  unfold translateA. induction H.
  - simpl. rewrite app_nil_r. rewrite map_map. rewrite Mplus_0_l.
    apply fold_left_translateA_Mmult; try assumption.
  - simpl. rewrite map_app. rewrite map_map. rewrite fold_left_Mplus_app_Zero.
    rewrite fold_left_Mplus. rewrite Mmult_plus_distr_r. rewrite <- IHproper_length_AType.
    rewrite fold_left_translateA_Mmult; try assumption. rewrite Mplus_comm. reflexivity.
Qed.

Lemma map_translate_gAddA : forall {n} (a b : AType n),
    proper_length_AType a -> proper_length_AType b ->
    map translate (gAddA a b) = ((map translate a) ++ (map translate b))%M.
Proof. intros n a b H H0.
       unfold gAddA. induction H.
       - simpl. reflexivity.
       - simpl. rewrite IHproper_length_AType. reflexivity.
Qed.

Lemma translateA_Add : forall {n} (a b : AType n),
    proper_length_AType a -> proper_length_AType b ->
    translateA (gAddA a b) = (translateA a .+ translateA b)%M.
Proof. intros n a b H H0.
       unfold translateA. induction H.
       - simpl. rewrite fold_left_Mplus. rewrite Mplus_0_l. rewrite Mplus_comm. reflexivity.
       - simpl. rewrite map_translate_gAddA; auto.
         rewrite ! fold_left_Mplus. rewrite fold_left_Mplus_app_Zero. rewrite ! Mplus_assoc. f_equal. rewrite Mplus_comm. reflexivity.
Qed. 

Lemma translate_scale : forall {n} (A : TType n) (c : Coef),
  translate (gScaleT c A) = (c .* (translate A))%M.
Proof. intros. 
       unfold translate. 
       destruct A. simpl. 
       rewrite <- Mscale_assoc.     
       reflexivity. 
Qed.

Lemma translateA_scale : forall {n} (A : AType n) (c : Coef),
    translateA (gScaleA c A) = (c .* (translateA A))%M.
Proof. intros n A c.
  unfold translateA. unfold gScaleA.
  rewrite map_map.
  induction A.
  - simpl. lma.
  - simpl. rewrite 2 fold_left_Mplus. rewrite Mscale_plus_distr_r.
    rewrite IHA. rewrite translate_scale. reflexivity.
Qed.


Declare Scope AType_scope.
Delimit Scope AType_scope with A.
Open Scope AType_scope.

Check EqdepFacts.eq_dep.
Inductive eq_AType {n1 n2} (A1 : AType n1) (A2 : AType n2) := 
| A_eq : n1 = n2 -> EqdepFacts.eq_dep nat (fun n => Square (2 ^ n)%nat) n1 (translateA A1) n2 (translateA A2) -> eq_AType A1 A2.
Infix "≡" := eq_AType (at level 70, no associativity): AType_scope.


(* will now show this is an equivalence relation *)
Lemma eq_AType_refl : forall {n} (A : AType n), A ≡ A.
Proof. intros. constructor; auto. Qed.

Lemma eq_AType_sym : forall {n1 n2} (A : AType n1) (B : AType n2), A ≡ B -> B ≡ A.
Proof. intros. inversion H; subst; constructor; auto. Qed.

Lemma eq_AType_trans : forall {n1 n2 n3} (A : AType n1) (B : AType n2) (C : AType n3),
    A ≡ B -> B ≡ C -> A ≡ C.
Proof.
  intros.
  inversion H; inversion H0; subst; constructor; auto.
  apply eq_dep_eq in H2, H4.
  apply JMeq_eq_dep; auto. 
  apply eq_implies_JMeq.
  rewrite H2; auto.
  Qed.

Add Parametric Relation n : (AType n) eq_AType
  reflexivity proved by eq_AType_refl
  symmetry proved by eq_AType_sym
  transitivity proved by eq_AType_trans
    as eq_AType_rel.


Lemma permutation_preserves_eq_AType :
  forall {n} (A B : AType n),
    Permutation A B -> A ≡ B.
Proof. intros. constructor; auto.
  apply JMeq_eq_dep; auto. apply eq_implies_JMeq.
  induction H; simpl; auto;
  unfold translateA in *; simpl in *; 
    try rewrite ! fold_left_Mplus;
    try rewrite IHPermutation1; auto. 
  - rewrite IHPermutation; easy.
  - rewrite ! Mplus_assoc. f_equal. rewrite Mplus_comm. auto. 
Qed.

Lemma eq_AType_rel_app_translateA : forall {n} (a b c : AType n),
    a ++ b ≡ c <-> ((translateA a) .+ (translateA b))%M = translateA c.
Proof. intros. unfold translateA in *. 
       split; intros. 
      - rewrite <- fold_left_Mplus_app_Zero, <- map_app.
        inversion H; subst. apply eq_dep_eq in H1. auto.
      - rewrite <- fold_left_Mplus_app_Zero, <- map_app in H.
        constructor; auto. apply eq_eq_dep; auto.
Qed.

Lemma eq_AType_gScaleA_app_comm : forall {n} (a b : AType n) c, gScaleA c (a ++ b) ≡ gScaleA c (b ++ a).
Proof. intros. constructor; auto. 
  apply eq_eq_dep.
  induction a; simpl; try rewrite app_nil_r; try easy.
  unfold translateA in *; simpl.
  rewrite fold_left_Mplus. 
  rewrite IHa. clear IHa.
  induction b; simpl; rewrite fold_left_Mplus; try easy.
  rewrite fold_left_Mplus.
  rewrite <- IHb. clear IHb.
  rewrite ! Mplus_assoc.
  assert (translate (gScaleT c a1) .+ translate (gScaleT c a) = translate (gScaleT c a) .+ translate (gScaleT c a1))%M.
  { rewrite Mplus_comm. easy. }
  rewrite H.
  easy.
Qed.

Lemma eq_AType_gScaleA_gAddA_comm : forall {n} (a b : AType n) c, gScaleA c (gAddA a b) ≡ gScaleA c (gAddA b a).
Proof. intros n a b.
       unfold gAddA.
       apply eq_AType_gScaleA_app_comm.
Qed.

Lemma eq_Atype_gMulA_gMulA' : forall {n} (a b : AType n), gMulA a b ≡ gMulA' a b.
Proof.
  intros n a b.
  unfold gMulA, gMulA'.
  induction a.
  - induction b.
    + reflexivity.
    + simpl. easy.
  - rewrite eq_AType_rel_app_translateA.
    inversion IHa; subst; clear IHa.
    apply eq_dep_eq in H0.
    rewrite H0. clear H0.
    induction b.
    + compute. autorewrite with R_db. reflexivity.
    + simpl.
      unfold translateA in *. simpl in *. rewrite ! map_app in *. rewrite ! map_map in *.
      rewrite ! fold_left_Mplus. rewrite Mplus_assoc.
      assert ((translate (gMulT a a1)
                 .+ fold_left Mplus
                 (map (fun x : TType n => translate (gMulT x a1)) a0 ++
                    map translate (gMulA' a0 b)) Zero)
              =
                (fold_left Mplus
                  (map (fun x : TType n => translate (gMulT x a1)) a0 ++
                     map translate (gMulA' a0 b)) Zero) .+  translate (gMulT a a1) )%M.
      { rewrite Mplus_comm. easy. }
      setoid_rewrite H0.
      rewrite ! fold_left_Mplus_app_Zero.
      rewrite <- ! Mplus_assoc.
      assert (fold_left Mplus (map (fun x : TType n => translate (gMulT a x)) b) Zero
                .+ fold_left Mplus (map (fun x : TType n => translate (gMulT x a1)) a0) Zero
              =
                fold_left Mplus (map (fun x : TType n => translate (gMulT x a1)) a0) Zero
                  .+ fold_left Mplus (map (fun x : TType n => translate (gMulT a x)) b) Zero)%M.
      { rewrite Mplus_comm. easy. }
      rewrite H1. unfold gMulA'.
      unfold translateA in IHb.
      f_equal. rewrite Mplus_assoc. rewrite IHb.
      reflexivity.
Qed.

Lemma eq_AType_gTensorA_gTensorA' : forall {n m} (a : AType n) (b : AType m),
    gTensorA a b ≡ gTensorA' a b.
Proof. intros n m a b. 
  induction a.
  - induction b.
    + reflexivity.
    + simpl. easy. 
  - simpl.
    rewrite eq_AType_rel_app_translateA. 
    inversion IHa; subst; clear IHa.
    apply eq_dep_eq in H0.
    rewrite H0. clear H0.
    induction b.
    + compute. autorewrite with R_db. reflexivity.
    + simpl.
      unfold translateA in *. simpl. rewrite ! map_app in *. rewrite ! map_map in *.
      rewrite ! fold_left_Mplus. rewrite Mplus_assoc.
      assert ((translate (gTensorT a a1)
                 .+ fold_left Mplus
            (map (fun x : TType n => translate (gTensorT x a1)) a0 ++
                map translate (gTensorA' a0 b)) Zero)
             =
               (fold_left Mplus
            (map (fun x : TType n => translate (gTensorT x a1)) a0 ++
               map translate (gTensorA' a0 b)) Zero)
                 .+ translate (gTensorT a a1))%M.
      { rewrite Mplus_comm. easy. }
      setoid_rewrite H0.
      rewrite ! fold_left_Mplus_app_Zero.
      setoid_rewrite Mplus_assoc at 2.
      setoid_rewrite <- IHb.
      assert (fold_left Mplus (map (fun x : TType n => translate (gTensorT x a1)) a0) Zero
                .+ fold_left Mplus (map (fun x : TType n => translate (gTensorT a x)) b) Zero
              =
                fold_left Mplus (map (fun x : TType n => translate (gTensorT a x)) b) Zero
                  .+ fold_left Mplus (map (fun x : TType n => translate (gTensorT x a1)) a0) Zero)%M.
      { rewrite Mplus_comm. easy. }
      rewrite <- ! Mplus_assoc.
      symmetry.
      setoid_rewrite H1.
      f_equal.
Qed.



(* Not used
(** G : equivalently, Cap&Cup: pointwise **)
Inductive eq_Predicate {n1 n2} : Predicate n1 -> Predicate n2 -> Prop :=
| G_eq : forall (a : AType n1) (b : AType n2), n1 = n2 -> EqdepFacts.eq_dep nat (fun n => Square (2 ^ n)%nat) n1 (translateA a) n2 (translateA b) -> eq_Predicate (G a) (G b)
| Cap_eq : forall (T1 T1' : Predicate n1) (T2 T2' : Predicate n2), n1 = n2 -> EqdepFacts.eq_dep nat Predicate n1 T1 n2 T2 -> EqdepFacts.eq_dep nat Predicate n1 T1' n2 T2' -> eq_Predicate (Cap T1 T1') (Cap T2 T2')
| Arr_eq : forall (T1 T1' : Predicate n1) (T2 T2' : Predicate n2), n1 = n2 -> EqdepFacts.eq_dep nat Predicate n1 T1 n2 T2 -> EqdepFacts.eq_dep nat Predicate n1 T1' n2 T2' -> eq_Predicate (Cup T1 T1') (Cup T2 T2')
| Sep_eq : forall (l1 l2 : list nat) (T1 : Predicate (length l1)) (T2 : Predicate (length l2)), n1 = n2 -> l1 = l2 -> EqdepFacts.eq_dep (list nat) (fun L => Predicate (length L)) l1 T1 l2 T2 -> eq_Predicate (Sep n1 l1 T1) (Sep n2 l2 T2)
| Err_eq : eq_Predicate Err Err.



(* Declare Scope Predicate_scope.
Delimit Scope Predicate_scope with P. *)
Open Scope Predicate_scope.
Infix "≡" := eq_Predicate (at level 70, no associativity): Predicate_scope.

(* will now show this is an equivalence relation *)
Lemma eq_Predicate_refl : forall {n} (A : Predicate n), A ≡ A.
Proof. intros n A. destruct A; try constructor; try easy.

Qed.

Lemma eq_Predicate_sym : forall {n1 n2} (A : Predicate n1) (B : Predicate n2), A ≡ B -> B ≡ A.
Proof. intros.
inversion H; try easy; try constructor; auto. 
Qed.

Lemma eq_Predicate_trans : forall {n1 n2 n3} (A : Predicate n1) (B : Predicate n2) (C : Predicate n3),
    A ≡ B -> B ≡ C -> A ≡ C.
Proof.
  intros.
  inversion H; inversion H0; subst; try discriminate; try easy; try constructor; auto;
  repeat match goal with
  | H' : context[EqdepFacts.eq_dep] |- _ => try apply eq_dep_eq in H'
  | |- context[EqdepFacts.eq_dep] => apply JMeq_eq_dep
  | |- context[JMeq] => apply eq_implies_JMeq
  end; subst; auto; try (inversion H9; subst; auto).
  inversion H7; subst. rewrite H2; auto.
  Qed.


Add Parametric Relation n : (Predicate n) eq_Predicate
  reflexivity proved by eq_Predicate_refl
  symmetry proved by eq_Predicate_sym
  transitivity proved by eq_Predicate_trans
    as eq_Predicate_rel.



Lemma eq_AType_implies_eq_Predicate : forall{n1 n2} (A : AType n1) (B : AType n2),
    (A ≡ B)%A -> (G A ≡ G B)%P.
Proof. intros.
  inversion H; subst; clear H.
  apply eq_dep_eq in H1.
  constructor; auto.
  apply eq_eq_dep; auto.
Qed.

Add Parametric Morphism (n : nat) : G
  with signature (@eq_AType n n) ==> (@eq_Predicate n n) as AType_Predicate_mor.
Proof.
  intros.
  apply eq_AType_implies_eq_Predicate; easy.
Qed.


Lemma eq_Predicate_scale_add_comm : forall {n} (A A' : Predicate n) c, c ·' (A +' A') ≡ c ·' (A' +' A).
Proof. intros n A A' c.
  destruct A, A'; simpl; try easy.
  constructor; auto.
  apply eq_eq_dep.
  pose (eq_AType_gScaleA_gAddA_comm a a0 c) as E.
  inversion E; subst; clear E.
  apply eq_dep_eq in H0; auto.
Qed.
*)




(** 
Definition a1' : AType 2 := (Ci, gZ :: gI :: nil) :: nil.
Definition a2' : AType 2 := (Ci, gI :: gX :: nil) ::  (Ci, gY :: gZ :: nil) :: nil.
Definition a3' : AType 3 :=  (C1+Ci, gI :: gX :: gZ :: nil) :: (Ci, gY :: gZ :: gY :: nil) :: (Ci, gY :: gX :: gZ :: nil) :: nil.
Definition a4' : AType 3 := (C1, gY :: gY :: gX :: nil) :: nil.
Example test :  gMulA' (gTensorA' a1' a3') (gTensorA' a2' a4') = gTensorA (gMulA a1' a2') (gMulA a3' a4').
Proof. compute. replace R0 with 0 by lra. autorewrite with R_db. reflexivity. Qed.
***)



       
(*** Admitted ***)
(*
Lemma gMulA_gTensorA_dist : forall {n m : nat} (a1 a2 : AType n) (a3 a4 : AType m),
  WF_AType n a1 -> WF_AType n a2 -> WF_AType m a3 -> WF_AType m a4 -> 
  (gMulA (gTensorA a1 a3) (gTensorA a2 a4) ≡ gTensorA (gMulA a1 a2) (gMulA a3 a4))%A.
Proof. intros. unfold "≡"%A.


  (* rewrite gMulA_is_gMulA'. rewrite 2 gTensorA_is_gTensorA'. *)

  
  (* induction a1; simpl; try easy.
  
  - simpl. induction a4.
    + simpl. reflexivity.
    + induction a3.
      * simpl in *. rewrite <- gMulA_is_gMulA' in *. simpl. reflexivity.
      * rewrite <- gTensorA_is_gTensorA'. rewrite <- gMulA_is_gMulA'
      *)
  


  
  induction H. (*
  - simpl. rewrite ! app_nil_r. induction H2; simpl;  repeat (rewrite ! gMulA_is_gMulA'; rewrite ! gTensorA_is_gTensorA'; simpl); try rewrite ! app_nil_r. 
    admit.
  - simpl. *)

    induction H0; induction H1; induction H2; simpl in *; try easy. 
-
  
  16 : { clear IHWF_AType2. clear IHWF_AType1. clear IHWF_AType0.
         f_equal. apply (@gMulT_gTensorT_dist n m _ _ _ _); try easy; try constructor; try easy. rewrite ! map_app, ! map_map, <- ! app_assoc in *. f_equal. clear IHWF_AType.
         induction H6. simpl. f_equal. apply (@gMulT_gTensorT_dist n m _ _ _ _); try easy; try constructor; try easy.
         simpl. rewrite IHWF_AType. f_equal. apply (@gMulT_gTensorT_dist n m _ _ _ _); try easy; try constructor; try easy.


         f_equal.
         unfold gMulA.

         rewrite IHWF_AType. 
         f_equal.  f_equal. 



         (map (fun x : TType (n + m) => gMulT (gTensorT a a1) x) (gTensorA b0 (a2 :: b2))
              
   ++ gMulA (map (fun x : TType n => gTensorT a x) b1 ++ gTensorA b (a1 :: b1))
       (gTensorT a0 a2
          :: map (fun x : TType n => gTensorT a0 x) b2 ++ gTensorA b0 (a2 :: b2))) =
                                                                                
           (map (fun x : TType n => gTensorT (gMulT a a0) x) (gMulA b1 (a2 :: b2))
                
   ++ gTensorA (map (fun x : TType n => gMulT a x) b0 ++ gMulA b (a0 :: b0))
       (gMulT a1 a2 :: map (fun x : TType m => gMulT a1 x) b2 ++ gMulA b1 (a2 :: b2)))
*)



(***************************************************************************)
(* proving some preliminary lemmas on the TType level before we prove their 
                    counterparts on the Predicate level *)
(***************************************************************************)


Lemma gMulT_assoc_map : forall {n} (a a0 : TType n) (b : AType n),
    proper_length_AType b -> proper_length_TType a -> proper_length_TType a0 ->
    map (fun x : TType n => gMulT (gMulT a a0) x) b = map (fun x : TType n => gMulT a (gMulT a0 x)) b.
Proof. intros n a a0 b H H0 H1.
  induction H.
  - simpl. rewrite gMulT_assoc; try easy.
  - simpl. rewrite gMulT_assoc; try easy. rewrite IHproper_length_AType; easy.
Qed.


Lemma gMulA_map_app : forall {n} (b b0 b1 b2 : AType n) (a : TType n),
    proper_length_AType b -> proper_length_AType b0 ->
    proper_length_AType b1 -> proper_length_AType b2 ->
    proper_length_TType a ->
    gMulA (map (fun x : TType n => gMulT a x) b0 ++ gMulA b b1) b2
    = (map (fun x : TType n => gMulT a x) (gMulA b0 b2) ++ gMulA (gMulA b b1) b2).
Proof. intros n b b0 b1 b2 a H H0 H1 H2 H3. 
  induction H0.
  - simpl. rewrite app_nil_r. rewrite map_map.
    rewrite gMulT_assoc_map; try easy.
  - simpl. rewrite map_app. rewrite map_map. rewrite IHproper_length_AType. rewrite app_assoc.
    rewrite gMulT_assoc_map; try easy.
Qed. 

Lemma gMulA_assoc : forall (n : nat) (a1 a2 a3 : AType n),
  proper_length_AType a1 -> proper_length_AType a2 -> proper_length_AType a3 ->
  gMulA (gMulA a1 a2) a3 = gMulA a1 (gMulA a2 a3).
Proof. intros n a1 a2 a3 H H0 H1.
  induction H; induction H0; induction H1; simpl in *; rewrite gMulT_assoc; try rewrite IHproper_length_AType; try easy. 
  + rewrite map_app. rewrite map_map. rewrite 2 app_nil_r.
    rewrite gMulT_assoc_map; try easy.
  + rewrite app_nil_r in *. rewrite map_map.
    rewrite gMulT_assoc_map; try easy.
  + rewrite <- IHproper_length_AType.
    rewrite gMulA_map_app; try easy; try constructor; try easy.
  + rewrite <- IHproper_length_AType. rewrite gMulA_map_app; try easy; try constructor; try easy. 
    rewrite map_app. rewrite map_map. rewrite app_assoc. rewrite gMulT_assoc_map; try easy.
Qed.


(* Multiplication laws *)
(* Not used
Lemma mul_assoc : forall {n} (A B C : Predicate n), 
    proper_length_APredicate A -> proper_length_APredicate B ->
    proper_length_APredicate C -> 
    A *' (B *' C) = A *' B *' C. 
Proof. intros. 
       destruct A; destruct B; destruct C; try easy.
       inversion H; inversion H0; inversion H1.
       unfold mul. f_equal.
       rewrite gMulA_assoc; easy. 
Qed.


Lemma mul_I_l : forall (A : Predicate 1), proper_length_APredicate A -> pI *' A = A.
Proof. intros A H.
  inversion H. 
  destruct A; try easy.
  inversion H0; inversion H1; subst.
  - clear H. clear H0. clear H1.
    simpl. f_equal. destruct t. 
    inversion H2. f_equal. simpl in *.
    destruct l. inversion H0.
    inversion H0. rewrite length_zero_iff_nil in H3.
    subst. f_equal. lca. 
  - clear H. clear H0. clear H1.
    simpl. f_equal. rewrite app_nil_r.
    destruct t.
    destruct H2. simpl in *.
    destruct l.
    + inversion H0.
    + inversion H0.
      rewrite length_zero_iff_nil in H2. subst.
      f_equal.
      * f_equal. lca.
      * simpl.
        induction H3.
        -- simpl. destruct t. f_equal.
           destruct H1. simpl in *.
           destruct l.
           ++ inversion H2.
           ++ inversion H2.
              rewrite length_zero_iff_nil in H4. subst.
              f_equal. lca.
        -- simpl. f_equal; auto.
           destruct t. destruct H1.
           simpl in *. destruct l.
           ++ inversion H2.
           ++ inversion H2. rewrite length_zero_iff_nil in H5. subst.
              f_equal. lca.
Qed.

Lemma mul_I_r : forall (A : Predicate 1), proper_length_APredicate A -> A *' pI = A.
Proof. intros A H.
  inversion H. 
  destruct A; try easy.
  inversion H0; inversion H1; subst.
  - clear H. clear H0. clear H1.
    simpl. f_equal. destruct t. 
    inversion H2. f_equal. simpl in *.
    destruct l. inversion H0.
    inversion H0. rewrite length_zero_iff_nil in H3.
    subst. destruct p; f_equal; lca. 
  - clear H. clear H0. clear H1.
    simpl. do 2 f_equal.
    + destruct t. simpl.
      destruct H2. simpl in *.
      destruct l.
      * inversion H0.
      * inversion H0.
        rewrite length_zero_iff_nil in H2. subst.
        destruct p; f_equal; lca.
    + induction H3; simpl in *.
      * destruct t0. destruct H.
        simpl in *. destruct l.
        -- inversion H0.
        -- inversion H0.
           rewrite length_zero_iff_nil in H3. subst.
           f_equal. destruct p; f_equal; lca.
      * f_equal; auto.
        destruct t0. destruct H.
        simpl in *. destruct l.
        -- inversion H0.
        -- inversion H0.
           rewrite length_zero_iff_nil in H4. subst.
           destruct p; f_equal; lca.
Qed.
*)

Open Scope Predicate_scope.

Lemma Xsqr : pX *' pX = pI.
Proof. simpl. unfold zipWith, cBigMul, gMul_Coef, uncurry. simpl. unfold I.
  do 3 f_equal. repeat f_equal. lca. Qed.       

Lemma Zsqr : pZ *' pZ = pI.
Proof. simpl. unfold zipWith, cBigMul, gMul_Coef, uncurry. simpl. unfold I.
  do 3 f_equal. repeat f_equal. lca. Qed.

Lemma ZmulX : pZ *' pX = - (pX *' pZ).
Proof. simpl. do 3 f_equal.
  unfold zipWith, cBigMul, gMul_Coef, uncurry.  simpl. lca. Qed.



Lemma switch_neg : forall n (A : Predicate n) (c : Coef), - (c ·' A) = c ·' (- A).
Proof. intros n A c.
  induction A; simpl; try inversion H0; try rewrite IHA1, IHA2; try easy.
  - rewrite ! gScaleA_merge.
    rewrite Cmult_comm.
    auto.
  - f_equal. rewrite ! map_map.
    f_equal. apply functional_extensionality. intros.
    rewrite ! gScaleA_merge.
    rewrite Cmult_comm.
    auto.
  - do 2 destruct p. simpl.
    rewrite ! map_map. do 4 f_equal.
    apply functional_extensionality; intros. 
    rewrite ! map_map. f_equal.
    apply functional_extensionality; intros. 
    rewrite ! gScaleTTypes_merge.
    f_equal. lca.
Qed.

(* Not used
Lemma neg_inv_A : forall (n : nat) (A : Predicate n), APredicate A -> - - A = A.
Proof. intros n A H.
  destruct H.
  unfold "-"%P.
  f_equal.
  unfold gScaleA.
  rewrite map_map.
  unfold gScaleT.
  induction a; auto.
  simpl.
  rewrite IHa. f_equal.
  destruct a.
  f_equal.
  lca.
Qed.
*)

Lemma gMulT_gScaleT_map : forall {n} (a : TType n) (b : AType n),
    proper_length_TType a -> proper_length_AType b ->
    (map (fun x : TType n => gMulT (gScaleT (- C1)%C a) x) b)
    = (map (fun x : TType n => gScaleT (- C1)%C (gMulT a x)) b).
Proof. intros n a b H H0. induction H0.
  - simpl. f_equal. destruct a, t. simpl. f_equal. lca.
  - simpl. rewrite IHproper_length_AType. f_equal. destruct a, t. simpl. f_equal. lca.
Qed.

(* Not used
Lemma neg_dist_l : forall (n : nat) (A B : Predicate n), 
  APredicate A -> APredicate B -> 
  -A *' B = - (A *' B).
Proof. intros. 
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gMulA_gScaleA_l.
Qed.

Lemma neg_dist_r : forall (n : nat) (A B : Predicate n), 
  proper_length_APredicate A -> proper_length_APredicate B -> 
  A *' (-B) = - (A *' B).
Proof. intros. 
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gMulA_gScaleA_r.
Qed.
*)

Lemma neg_dist_add : forall (n : nat) (A B : Predicate n), - (A +' B) = -A +' -B.
Proof. intros n A B.
  induction A; induction B; simpl; try easy.
  unfold gScaleA, gAddA.
  rewrite ! map_app.
  auto.
Qed. 

Lemma i_sqr : forall (n : nat) (A : Predicate n), +i (+i A) = -A.
Proof. intros. 
  induction A; simpl; auto; try rewrite IHA1, IHA2; try easy.
  - rewrite gScaleA_merge.
    do 2 f_equal.
    lca.
  - f_equal. rewrite ! map_map.
    f_equal. apply functional_extensionality. intros.
    rewrite gScaleA_merge.
    do 2 f_equal.
    lca.
  - do 2 destruct p. simpl.
    rewrite ! map_map. do 4 f_equal.
    apply functional_extensionality; intros. 
    rewrite ! map_map. f_equal.
    apply functional_extensionality; intros. 
    rewrite ! gScaleTTypes_merge.
    f_equal. lca.
Qed.

(* Not used
Lemma i_dist_l : forall (n : nat) (A B : Predicate n), 
  proper_length_APredicate A -> proper_length_APredicate B -> 
  +i A *' B = +i (A *' B).
Proof. intros. 
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gMulA_gScaleA_l.
Qed.

Lemma i_dist_r : forall (n : nat) (A B : Predicate n), 
  proper_length_APredicate A -> proper_length_APredicate B -> 
  A *' +i B = +i (A *' B).
Proof. intros. 
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gMulA_gScaleA_r.
Qed.
*)

Lemma i_neg_comm : forall (n : nat) (A : Predicate n), +i (-A) = -i A.
Proof. intros.
  induction A; simpl; auto; try rewrite IHA1, IHA2; try easy.
  - rewrite gScaleA_merge.
    do 2 f_equal.
    lca.
  - f_equal. rewrite ! map_map.
    f_equal. apply functional_extensionality. intros.
    rewrite gScaleA_merge.
    do 2 f_equal.
    lca.
  - do 2 destruct p. simpl.
    rewrite ! map_map. do 4 f_equal.
    apply functional_extensionality; intros. 
    rewrite ! map_map. f_equal.
    apply functional_extensionality; intros. 
    rewrite ! gScaleTTypes_merge.
    f_equal. lca.
Qed.

#[export] Hint Resolve switch_neg neg_dist_add i_sqr i_neg_comm : typing_db.
#[export] Hint Rewrite switch_neg neg_dist_add i_sqr i_neg_comm : typing_db.



(** ** Tensor Laws *)


Lemma gTensorT_assoc : forall {n : nat} (t1 t2 t3 : TType n),
  proper_length_TType t1 -> proper_length_TType t2 -> proper_length_TType t3 ->
  gTensorT (gTensorT t1 t2) t3 = gTensorT t1 (gTensorT t2 t3).
Proof. intros n t1 t2 t3 H H0 H1.
  unfold gTensorT. destruct t1, t2, t3. f_equal. lca. rewrite app_assoc. easy.
Qed.


Lemma gTensorA_assoc_map : forall {n} (a : TType n) (b b0 b1 b2 : AType n),
    proper_length_TType a -> proper_length_AType b  -> proper_length_AType b0  -> proper_length_AType b1  -> proper_length_AType b2 ->
    gTensorA (map (fun x : TType n => gTensorT a x) b0 ++ gTensorA b b1) b2 =
      (map (fun x : TType n => gTensorT a x) (gTensorA b0 b2) ++ gTensorA (gTensorA b b1) b2).
Proof. intros n a b b0 b1 b2 H H0 H1 H2 H3.
  induction H1; simpl.
  - rewrite app_nil_r. f_equal. rewrite map_map. induction H3; simpl; try rewrite IHproper_length_AType; f_equal; destruct a, t, t0; simpl; f_equal; try lca; rewrite app_assoc; easy.
  - rewrite map_app, map_map. rewrite IHproper_length_AType, <- app_assoc. f_equal.
    clear IHproper_length_AType. induction H3; simpl; try rewrite IHproper_length_AType; f_equal; destruct a, t, t0; simpl; f_equal; try lca; rewrite app_assoc; easy.
Qed.


Lemma gTensorA_assoc : forall (n : nat) (a1 a2 a3 : AType n),
  proper_length_AType a1 -> proper_length_AType a2 -> proper_length_AType a3 ->
  gTensorA (gTensorA a1 a2) a3 = gTensorA a1 (gTensorA a2 a3).
Proof. intros n a1 a2 a3 H H0 H1. 
  induction H; induction H0; induction H1; simpl in *; f_equal; try apply (gTensorT_assoc t t0 t1); try rewrite IHproper_length_AType; try easy; repeat rewrite app_nil_r in *; try rewrite map_app; try rewrite map_map.
  1,2: f_equal; clear IHproper_length_AType; clear IHproper_length_AType0; induction H3; simpl; try rewrite IHproper_length_AType; f_equal; destruct t, t0, t2; simpl; f_equal; try lca; repeat rewrite app_assoc; easy.
  + rewrite <- IHproper_length_AType. rewrite gTensorA_assoc_map; try easy; constructor; easy.
  + clear IHproper_length_AType1. clear IHproper_length_AType0.
    rewrite <- IHproper_length_AType. rewrite <- app_assoc. f_equal.
    * clear IHproper_length_AType; induction H4; simpl; try rewrite IHproper_length_AType; f_equal; destruct t, t0, t2; simpl; f_equal; try lca; rewrite app_assoc; easy.
    * rewrite gTensorA_assoc_map; try easy; constructor; easy.
Qed.

(* Not used
Lemma neg_tensor_dist_l : forall {n m} (A : Predicate n) (B : Predicate m), 
  proper_length_APredicate A -> proper_length_APredicate B -> 
  -A ⊗' B = - (A ⊗' B).
Proof. intros.
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gTensorA_gScaleA_comm_l.
Qed.

Lemma neg_tensor_dist_r : forall {n m} (A : Predicate n) (B : Predicate m), 
  proper_length_APredicate A -> proper_length_APredicate B -> 
  A ⊗' (-B) = - (A ⊗' B).
Proof. intros. 
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gTensorA_gScaleA_comm_r.
Qed.

Lemma i_tensor_dist_l : forall {n m} (A : Predicate n) (B : Predicate m), 
  proper_length_APredicate A -> proper_length_APredicate B -> 
  +i A ⊗' B = +i (A ⊗' B).
Proof. intros.
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gTensorA_gScaleA_comm_l.
Qed.

Lemma i_tensor_dist_r : forall {n m} (A : Predicate n) (B : Predicate m), 
  proper_length_APredicate A -> proper_length_APredicate B -> 
  A ⊗' +i B = +i (A ⊗' B).
Proof. intros. 
  inversion H; inversion H0; subst.
  simpl. f_equal. apply gTensorA_gScaleA_comm_r.
Qed. 
*)
(*** Not Derivable ***)
(*
(** **Multiplication & Tensor Laws *)

(* Appropriate restriction is that size A = size C and size B = size D,
   but axiomatization doesn't allow for that calculation. *)
(* This should be generalizable to the other, assuming we're multiplying
   valid types. *)
Lemma mul_tensor_dist : forall {n m} (A C : Predicate n) (B D : Predicate m),
  proper_length_APredicate A -> proper_length_APredicate B -> proper_length_APredicate C -> proper_length_APredicate D ->
  (A ⊗' B) *' (C ⊗' D) = (A *' C) ⊗' (B *' D).
Proof. intros.
       destruct A; destruct B; destruct C; destruct D; try easy.
       inversion H; inversion H0; inversion H1; inversion H2; subst.
       simpl. f_equal. Admitted.
Qed.



Lemma decompose_tensor : forall (A B : Predicate 1),
  proper_length_APredicate A -> proper_length_APredicate B ->
  A .⊗ B = (A .⊗ I) .* (I .⊗ B).
Proof.
  intros A B H H0.  
  rewrite mul_tensor_dist; auto with wfpt_db.
  rewrite mul_I_r, mul_I_l; easy.
Qed.


Lemma decompose_tensor_mult_l : forall (A B : Predicate 1),
  proper_length_APredicate A -> proper_length_APredicate B ->
  (A .* B) .⊗ I = (A .⊗ I) .* (B .⊗ I).
Proof.
  intros. 
  rewrite mul_tensor_dist; auto with wfpt_db.
Qed.


Lemma decompose_tensor_mult_r : forall (A B : Predicate 1),
  proper_length_APredicate A -> proper_length_APredicate B ->
  I .⊗ (A .* B) = (I .⊗ A) .* (I .⊗ B).
Proof.
  intros. 
  rewrite mul_tensor_dist; auto with wfpt_db.
Qed.
 
 *)

(*********************)
(* defining programs *)
(*********************)


Inductive prog :=
| H (n : nat)
| S (n : nat)
| T (n : nat)
| CNOT (n1 n2 : nat)
| seq (p1 p2 : prog).

(* denote successor as s instead of S since it overlaps with the S gate *)
Notation s := Datatypes.S.

(*** I & Paulis can be derived ***)

Infix ";;" := seq (at level 51, right associativity).

Fixpoint translate_prog (prg_len : nat) (p : prog) : Square (2^prg_len) :=
  match p with 
  | H n => (prog_simpl_app prg_len hadamard n)
  | S n => (prog_simpl_app prg_len Sgate n)
  | T n => (prog_simpl_app prg_len Tgate n)
  | CNOT n1 n2 => (prog_ctrl_app prg_len σx n1 n2)
  | seq p1 p2 => (translate_prog prg_len p2) × (translate_prog prg_len p1)
  end.

Lemma unit_prog : forall (prg_len : nat) (p : prog), 
  WF_Unitary (translate_prog prg_len p).
Proof. intros. induction p as [ | | | | ];
       try (apply unit_prog_simpl_app; auto with unit_db);
       try (apply unit_prog_ctrl_app; auto with unit_db);
       simpl. apply Mmult_unitary; easy.
Qed.


Lemma WF_Matrix_translate_prog : forall (n : nat) (p : prog),
    WF_Matrix (translate_prog n p).
Proof.
  intros n p.
  induction p; simpl.
  all : unfold prog_simpl_app; unfold prog_ctrl_app;
    try bdestruct_all; simpl; auto 15 with wf_db.
Qed.

#[export] Hint Resolve unit_prog : unit_db.
#[export] Hint Resolve WF_Matrix_translate_prog : wf_db.



Definition simpl_prog_H (p : nat -> prog) : Prop := 
  (forall (n : nat), p n = H n).

Definition simpl_prog_S (p : nat -> prog) : Prop := 
  (forall (n : nat), p n = S n).

Definition simpl_prog_T (p : nat -> prog) : Prop := 
  (forall (n : nat), p n = T n).
        
Definition simpl_prog (p : nat -> prog) : Prop := 
  simpl_prog_H p \/ simpl_prog_S p \/ simpl_prog_T p.

Definition simpl_prog' (p : prog) : Prop := 
  match p with
  | H _ => True
  | S _ => True
  | T _ => True
  | _ => False
  end.

Definition ctrl_prog (p : nat -> nat -> prog) : Prop := 
  (forall (n m : nat), p n m = CNOT n m).

Definition ctrl_prog' (p : prog) : Prop :=
  match p with 
  | CNOT _ _ => True 
  | _ => False
  end.



(** ** matrix maniplulation for semantics ** **)

Definition Ceqb (c1 c2 : C) : bool :=
  if Ceq_dec c1 c2 then true else false.

Example test : Ceqb C1 C1 = true.
Proof. unfold Ceqb. destruct (Ceq_dec C1 C1).
  easy. contradiction.
Qed.

Lemma Ceqb_eq : forall c1 c2, c1 = c2 <-> Ceqb c1 c2 = true.
Proof. intros.
  unfold Ceqb.
  destruct (Ceq_dec c1 c2); auto with *.
Qed.

Infix "=?" := Ceqb.

Lemma fold_left_Cplus : forall (c : C) (l : list C),
    fold_left Cplus l (0 + c) = c + (fold_left Cplus l 0).
Proof. intros c l. gen c.
  induction l.
  - intros. simpl. lca.
  - intros. simpl.
    rewrite <- Cplus_assoc.
    rewrite ! IHl.
    rewrite Cplus_assoc.
    easy.
Qed.

Lemma fold_left_Cplus_app : forall (l1 l2 : list C),
    fold_left Cplus (l1 ++ l2) 0 = (fold_left Cplus l1 0) + (fold_left Cplus l2 0).
Proof. intros. induction l1.
  - simpl. rewrite Cplus_0_l. easy.
  - simpl. rewrite ! fold_left_Cplus.
    rewrite IHl1. rewrite Cplus_assoc.
    easy.
Qed.

Lemma list_seq_decompose : forall (n1 n2 m : nat),
    List.seq m (n1 + n2)%nat = List.seq m n1 ++ List.seq (n1 + m) n2.
Proof. intros. gen m n2. induction n1; try easy.
  intros. simpl. f_equal. rewrite IHn1. rewrite <- plus_n_Sm. easy.
Qed.

Lemma seq_matrix_filter_orth_app_permutation : forall n a (A : Square n),
    Permutation (List.seq 0 n)
      ((filter (fun x : nat => A x x =? a) (List.seq 0 n)) ++
         (filter (fun x : nat => negb (A x x =? a)) (List.seq 0 n))).
Proof. intros. apply filter_orth_app_permutation. Qed.

Lemma Clist_disjoint2_is_orth : forall l a b,
  (forall c : C, In c l -> (c=a \/ c=b)) -> (a <> b) ->
  (filter (fun x:C => Ceqb x b) l = filter (fun x:C => (negb (Ceqb x a))) l).
Proof. intros.
  induction l; try easy.
  assert (forall c : C, In c l -> c = a \/ c = b).
  { intros.
    assert (In c (a0 :: l)).
    { simpl. right. easy. }
    specialize (H0 c H3).
    easy. }
  specialize (IHl H2).
  assert (In a0 (a0 :: l)).
  { simpl. left. easy. }
  specialize (H0 a0 H3).
  simpl.
  destruct H0; rewrite H0.
  - unfold Ceqb.
    destruct (Ceq_dec a b);
      destruct (Ceq_dec a a);
      try contradiction.
    simpl. easy.
  - unfold Ceqb.
    destruct (Ceq_dec b b);
      destruct (Ceq_dec b a);
      try contradiction.
    symmetry in e0.
    contradiction.
    simpl.
    f_equal.
    easy.
Qed.

Lemma filter_Cdisjoint2_length : forall (a b : C) (l : list C),
    (forall c : C, In c l -> (c=a \/ c=b)) -> (a <> b) ->
    (length l = length (filter (fun x:C => Ceqb x a) l) + length (filter (fun x:C => Ceqb x b) l))%nat.
Proof. intros.
  rewrite (Clist_disjoint2_is_orth l a b); try easy.
  apply filter_orth_length.
Qed.

Lemma seq_matrix_filter_disjoint2_is_orth : forall n a b (A: Square n),
  (forall x:nat, In x (List.seq 0 n) -> (A x x = a \/ A x x = b)) -> (a <> b) ->
  (filter (fun x:nat => Ceqb (A x x) b) (List.seq 0 n) = filter (fun x:nat => (negb (Ceqb (A x x) a))) (List.seq 0 n)).
Proof. intros.
  apply filter_ext_in.
  intros.
  specialize (H0 a0 H2).
  destruct H0.
  - unfold Ceqb.
    rewrite H0.
    destruct (Ceq_dec a b);
      destruct (Ceq_dec a a);
      try contradiction.
    easy.
  - unfold Ceqb.
    rewrite H0.
    destruct (Ceq_dec b b);
      destruct (Ceq_dec b a);
      try contradiction.
    symmetry in e0.
    contradiction.
    easy.
Qed.

Lemma map_filter_Ceqb_comm : forall n a (f : nat -> C),
    (map f (filter (fun x : nat => f x =? a) (List.seq 0 n))) =
      (filter (fun c : C => c =? a) (map f (List.seq 0 n))).
Proof. induction n; intros; try easy.
  rewrite seq_S.
  simpl. rewrite filter_app, ! map_app, filter_app.
  simpl. 
  f_equal.
  - apply IHn.
  - unfold Ceqb.
    destruct (Ceq_dec (f n) a); easy.
Qed.

Lemma map_filter_matrix_Ceqb_comm : forall n a (A : Square n),
  (map (fun x : nat => A x x) (filter (fun x : nat => A x x =? a) (List.seq 0 n))) =
    (filter (fun c : C => c =? a) (map (fun x : nat => A x x) (List.seq 0 n))).
Proof. intros. apply map_filter_Ceqb_comm. Qed.


Lemma plusminus1list_sum_is_length_diff : forall n l,
    (forall x, In x l -> x = C1 \/ x = Copp C1) -> fold_left Cplus l C0 = n ->
    RtoC (INR (length (filter (fun c : C => Ceqb c C1) l))) = n + RtoC (INR (length (filter (fun c : C => Ceqb c (Copp C1)) l))).
Proof. intros. gen n. induction l.
  - intros. simpl in *. rewrite <- H1. lca.
  - intros.
    assert (forall x : C, In x l -> x = C1 \/ x = (- C1)%C).
    { intros.
      assert (In x (a :: l)).
      { simpl. right. easy. }
      specialize (H0 x H3).
      easy. }
    specialize (IHl H2).
    assert (In a (a :: l)).
    { simpl. left. easy. }
    specialize (H0 a H3).
    destruct H0; rewrite H0 in *.
    + rewrite cons_conc in H1.
      rewrite fold_left_Cplus_app in H1.
      simpl in H1. rewrite Cplus_0_l in H1.
      simpl. unfold Ceqb.
      destruct (Ceq_dec C1 C1);
        destruct (Ceq_dec C1 (Copp C1));
        try easy.
      * inversion e0. lra.
      * assert ((length (C1 :: filter (fun c : C => if Ceq_dec c C1 then true else false) l)) =
                  s (length (filter (fun c : C => if Ceq_dec c C1 then true else false) l))).
        { simpl. easy. }
        rewrite H4.
        rewrite S_INR.
        apply Cplus_inj_l with (c := Copp C1) in H1.
        rewrite Cplus_assoc in H1.
        rewrite Cplus_opp_l in H1.
        rewrite Cplus_0_l in H1.
        specialize (IHl ((Copp C1) + n) H1).
        unfold Ceqb in IHl.
        assert (RtoC (INR (length (filter (fun c : C => if Ceq_dec c C1 then true else false) l)) + 1)%R = C1 + RtoC (INR (length (filter (fun c : C => if Ceq_dec c C1 then true else false) l)))).
        { lca. }
        rewrite H5.
        rewrite IHl.
        rewrite ! Cplus_assoc.
        rewrite Cplus_opp_r.
        rewrite Cplus_0_l.
        easy.
    + rewrite cons_conc in H1.
      rewrite fold_left_Cplus_app in H1.
      simpl in H1. rewrite Cplus_0_l in H1.
      simpl. unfold Ceqb.
      destruct (Ceq_dec (Copp C1) C1);
        destruct (Ceq_dec (Copp C1) (Copp C1));
        try easy.
      * inversion e. lra.
      * assert ((length ((Copp C1) :: filter (fun c : C => if Ceq_dec c (Copp C1) then true else false) l)) = s (length (filter (fun c : C => if Ceq_dec c (- C1) then true else false) l))).
        { simpl. easy. }
        rewrite H4.
        rewrite S_INR.
        apply Cplus_inj_l with (c := C1) in H1.
        rewrite Cplus_assoc in H1.
        rewrite Cplus_opp_r in H1.
        rewrite Cplus_0_l in H1.
        specialize (IHl (C1 + n) H1).
        unfold Ceqb in IHl.
        assert (RtoC (INR (length (filter (fun c : C => if Ceq_dec c (- C1) then true else false) l)) + 1)%R = C1 + RtoC (INR (length (filter (fun c : C => if Ceq_dec c (- C1) then true else false) l)))).
        { lca. }
        rewrite H5.
        rewrite IHl.
        rewrite ! Cplus_assoc.
        setoid_rewrite Cplus_comm at 2.
        easy.
Qed.


Lemma Unitary_Hermitian_trace_zero_index_split : forall {n} (A : Square n),
    WF_Unitary A -> A † = A -> trace A = 0 ->
    (exists l1 l2 U D, Permutation (l1 ++ l2) (List.seq 0 n) /\
                    length l1 = length l2 /\ 
                    WF_Diagonal D /\ WF_Unitary U /\
                    A = U × D × U† /\ trace D = 0 /\
                    (forall x, In x l1 -> Eigenpair A (U × (e_i x), C1)) /\
                    (forall x, In x l2 -> Eigenpair A (U × (e_i x), Copp C1))).
Proof. intros n A WFUA HA TRA.
  specialize (Unitary_Hermitian_trace_zero_eigenvalues_plus_minus_1 A WFUA HA TRA); intros [U [D [WDDD [WFUU [SPECA [TRD0 EigenA_plus_minus_1]]]]]].

  assert (EigenA :  forall x : nat, (x < n)%nat -> Eigenpair A (U × e_i x, D x x)).
  { intros x H0.
    specialize (EigenA_plus_minus_1 x H0).
    destruct EigenA_plus_minus_1.
    assumption. }
  assert (plus_minus_1 :  forall x : nat, (x < n)%nat -> (D x x = C1 \/ D x x = (- C1)%C)).
  { intros x H0.
    specialize (EigenA_plus_minus_1 x H0).
    destruct EigenA_plus_minus_1.
    assumption. }
  
  assert (EigenA_in_seq : forall x:nat, In x (List.seq 0 n) -> Eigenpair A (U × e_i x, D x x)).
  { intros x H0.
    assert (x < n)%nat.
    { rewrite in_seq in H0. lia. }
    specialize (EigenA x H1).
    easy. }
  assert (plus_minus_1_in_seq : forall x:nat, In x (List.seq 0 n) -> D x x = C1 \/ D x x = (Copp C1)).
  { intros x H0.
    assert (x < n)%nat.
    { rewrite in_seq in H0. lia. }
    specialize (plus_minus_1 x H1).
    easy. }
  
  pose (plus1list_idx := filter (fun x:nat => Ceqb (D x x) C1) (List.seq 0 n)).
  pose (minus1list_idx := filter (fun x:nat => Ceqb (D x x) (Copp C1)) (List.seq 0 n)).
  pose (minus1list_idx_orth := filter (fun x:nat => negb (Ceqb (D x x) C1)) (List.seq 0 n)).

  pose (orth := seq_matrix_filter_disjoint2_is_orth n C1 (Copp C1) D).
  assert (plus_minus_1_different : C1 <> Copp C1).
  { intro. inversion H0. lra. }
  specialize (orth plus_minus_1_in_seq plus_minus_1_different).
  assert (minus1list_idx_orth_equal : minus1list_idx=minus1list_idx_orth).
  { apply orth. }

  pose (listD := map (fun x:nat => D x x) (List.seq 0 n)).
  pose (list_sum := fold_left Cplus listD C0).
  assert (trace_is_sum : list_sum = trace D).
  { clear -list_sum. 
    induction n.
    - simpl in *. easy.
    - unfold trace in *. simpl. rewrite <- IHn.
      unfold list_sum, listD.
      rewrite Cplus_comm.
      rewrite <- fold_left_Cplus.
      assert (H0: List.seq 0 (s n) = List.seq 0 n ++ [n]).
      { clear -n. pose list_seq_decompose.
        specialize (e n (s 0) 0%nat).
        simpl in e. rewrite <- plus_n_Sm in e. simpl in *.
        rewrite <- plus_n_O in e. easy. }
      rewrite H0. rewrite map_app. rewrite fold_left_Cplus_app.
      simpl. rewrite Cplus_0_l at 1. rewrite Cplus_comm.
      rewrite <- fold_left_Cplus. easy. }

  pose (plus1list := filter (fun c : C => Ceqb c C1) listD).
  pose (minus1list := filter (fun c : C => (Ceqb c (Copp C1))) listD).

  assert (plus_minus_1_in_listD : (forall x : C, In x listD -> x = C1 \/ x = (- C1)%C)).
  { intros.
    unfold listD in H0.
    rewrite in_map_iff in H0.
    do 2 destruct H0.
    rewrite <- H0.
    specialize (plus_minus_1_in_seq x0 H1).
    easy. }
    
  exists plus1list_idx, minus1list_idx, U, D.
  rewrite minus1list_idx_orth_equal.
  repeat (split; try easy).
  - apply Permutation_sym.
    apply seq_matrix_filter_orth_app_permutation.
  - rewrite <- minus1list_idx_orth_equal.
    rewrite <- ! map_length with (f := fun x:nat => D x x).
    assert (map_plus1list_idx: (map (fun x : nat => D x x) plus1list_idx) = plus1list).
    { apply map_filter_matrix_Ceqb_comm. }
    assert (map_minus1list_idx: (map (fun x : nat => D x x) minus1list_idx) = minus1list).
    { apply map_filter_matrix_Ceqb_comm. }
    rewrite map_plus1list_idx, map_minus1list_idx.
    rewrite TRD0 in trace_is_sum.
    pose (plusminus1list_sum_is_length_diff 0 listD plus_minus_1_in_listD trace_is_sum).
    rewrite Cplus_0_l in e.
    pose (INR_eq (length (filter (fun c : C => c =? C1) listD)) (length (filter (fun c : C => c =? - C1) listD))).
    inversion e.
    apply e0 in H1.
    easy.
  - intros.
    unfold plus1list_idx in H0.
    rewrite filter_In in H0.
    destruct H0.
    specialize (EigenA_in_seq x H0).
    unfold Ceqb in H1.
    destruct (Ceq_dec (D x x) C1); try discriminate.
    rewrite <- e.
    easy.
  - intros.
    rewrite <- minus1list_idx_orth_equal in H0.
    unfold minus1list_idx in H0.
    rewrite filter_In in H0.
    destruct H0.
    specialize (EigenA_in_seq x H0).
    unfold Ceqb in H1.
    destruct (Ceq_dec (D x x) (Copp C1)); try discriminate.
    rewrite <- e.
    easy.
Qed.




(** matrix_by_basis also exists **)
Lemma e_i_get_vec {n m : nat} (i : nat) (A : Matrix n m):
  WF_Matrix A -> A × e_i i = get_vec i A.
Proof. intros. unfold get_vec. unfold Mmult, e_i.
  apply functional_extensionality. intros.
  apply functional_extensionality. intros.
  bdestruct_all. 
  - assert ((fun y : nat => A x y * (if (y =? i)%nat && (y <? m) && true then C1 else 0)) =
              (fun y : nat => A x y * (if (y =? i)%nat && (y <? m) then C1 else 0))).
    { apply functional_extensionality. intros. rewrite andb_true_r. easy. }
    rewrite H2. clear H2.
    bdestruct (i <? m)%nat.
    + apply big_sum_unique.
      exists i.
      split; try easy.
      split.
      * bdestruct_all; try easy. simpl. lca.
      * intros. bdestruct_all; try easy.
        simpl. lca.
    + unfold WF_Matrix in H0.
      specialize (H0 x i).
      assert ((x >= n)%nat \/ (i >= m)%nat).
      { right. easy. }
      specialize (H0 H3).
      rewrite H0.
      assert ((fun y : nat => A x y * (if (y =? i)%nat && (y <? m) then C1 else 0)) =
                (fun y : nat => A x y * (if false then C1 else 0))).
      { apply functional_extensionality. intros. f_equal.
        bdestruct_all; easy. }
      rewrite H4.
      rewrite big_sum_0; try easy.
      intros. lca.
  - assert ((fun y : nat => A x y * (if (y =? i)%nat && (y <? m) && false then C1 else 0)) =
              (fun y : nat => A x y * (if false then C1 else 0))).
    { apply functional_extensionality. intros. f_equal.
      bdestruct_all; easy. }
    rewrite H2.
    rewrite big_sum_0; try easy.
    intros. lca.
Qed.


Lemma combine_map_list_app (X Y Z: Type) (f : X -> Y) (g : X -> Z) (l1 l2 : list X) :
  (combine
     (map (fun x => f x) (l1 ++ l2))
     (map (fun x => g x) (l1 ++ l2))) =
    (combine
     (map (fun x => f x) (l1))
     (map (fun x => g x) (l1))) ++
      (combine
         (map (fun x => f x) (l2))
         (map (fun x => g x) (l2))).
Proof. intros. induction l1; try easy.
  simpl. rewrite IHl1. easy.
Qed.

(** try Set Printing All: the type of fold_left takes two types A and B but the type of col_append is Matrix n m -> Vector n -> Matrix n (s m), the type A gets fixed as Matrix n m which is not what we want. We want the type A to incrementally increase as we append the column vectors to the matrix.**) (*
Definition list_vector_to_matrix_indirect {n} (l : list (Vector n)) : Matrix n (length l) := fold_left col_append l (@Zero n 0).
Check list_vector_to_matrix. *)

Definition list_vector_to_matrix {n} (l : list (Vector n)) : Matrix n (length l) := (fun r c : nat => (nth c l (@Zero n 1)) r 0%nat).
Check list_vector_to_matrix.

Lemma list_vector_to_matrix_col_wedge : forall {n} (x : Vector n) (l : list (Vector n)),
    list_vector_to_matrix (x :: l) = col_wedge (list_vector_to_matrix l) x 0.
Proof. intros n x l.
  unfold list_vector_to_matrix.
  simpl.
  unfold col_wedge. simpl.
  do 2 (apply functional_extensionality; intros).
  bdestruct_all.
  - rewrite H0.
    easy.
  - destruct x1.
    + contradiction.
    + assert (s x1 - 1 = x1)%nat.
      { lia. }
      rewrite H1.
      easy.
Qed.

Lemma WF_list_vector_to_matrix : forall {n} (l : list (Vector n)), Forall WF_Matrix l -> WF_Matrix (list_vector_to_matrix l).
Proof. intros n l H0.
  induction H0.
  - unfold WF_Matrix, list_vector_to_matrix.
    intros. simpl in *. destruct y; easy.
  - unfold WF_Matrix, list_vector_to_matrix.
    intros. simpl in *. destruct y.
    + destruct H2.
      * unfold WF_Matrix in H0.
        specialize (H0 x0 0%nat).
        assert ((x0 >= n)%nat \/ (0 >= 1)%nat).
        { left. easy. }
        specialize (H0 H3).
        easy.
      * lia.
    + destruct H2.
      * unfold list_vector_to_matrix in *.
        unfold WF_Matrix in IHForall.
        specialize (IHForall x0 y).
        assert ((x0 >= n)%nat \/ (y >= length l)%nat).
        { left. easy. }
        specialize (IHForall H3).
        easy.
      * assert (y >= length l)%nat.
        { lia. }
        rewrite nth_overflow; easy.
Qed.

Definition matrix_column_choose {n m} (indices_list : list nat) (M : Matrix n m) : Matrix n (length indices_list) := list_vector_to_matrix (map (fun i : nat => get_vec i M) indices_list).

Definition vector_row_choose {n} (indices_list : list nat) (v : Vector n) : Vector (length indices_list) := (fun r c : nat => v (nth r indices_list n) c).

Compute ((matrix_column_choose [] (I 3)) × (matrix_column_choose [] (I 3)) ⊤).
Compute ((I 0) 0%nat 0%nat).



Lemma matrix_column_choose_pop : forall {n m o} (indices_list : list nat) (M1 : Matrix m n) (M2 : Matrix n o), WF_Matrix M2 -> matrix_column_choose indices_list (M1 × M2) = M1 × (matrix_column_choose indices_list M2).
Proof. intros. unfold matrix_column_choose.
  unfold list_vector_to_matrix.
  unfold Mmult.
  do 2 (apply functional_extensionality; intros).
  assert (Zero = @get_col m o (fun x1 z : nat => Σ (fun y : nat => M1 x1 y * M2 y z) n) o).
  { unfold WF_Matrix in H0.
    unfold get_vec.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all. 2: easy.
    rewrite big_sum_0. 1: easy.
    intros.
    specialize (H0 x3 o).
    assert ((x3 >= n)%nat \/ (o >= o)%nat). 1: right; lia.
    specialize (H0 H2).
    rewrite H0.
    lca. }
  rewrite H1.
  rewrite map_nth with (d := o).
  unfold get_vec.
  bdestruct_all.
  f_equal.
  apply functional_extensionality; intros.
  f_equal.
  assert (@Zero n o = (fun i0 x2 y : nat => if (y =? 0)%nat then M2 x2 i0 else 0) o).
  { do 2 (apply functional_extensionality; intros).
    bdestruct_all. 2: easy.
    unfold WF_Matrix in H0.
    specialize (H0 x2 o).
    assert ((x2 >= n)%nat \/ (o >= o)%nat). 1: right; lia.
    specialize (H0 H4).
    rewrite H0.
    easy. }
  setoid_rewrite H3.
  rewrite map_nth with (d := o).
  bdestruct_all.
  easy.
Qed.

Lemma   WF_Matrix_matrix_column_choose_indices_list_I_n: forall (n : nat) (indices_list : list nat),
    WF_Matrix (matrix_column_choose indices_list (I n)).
Proof. intros.
  unfold WF_Matrix.
  intros.
  unfold matrix_column_choose.
  unfold list_vector_to_matrix.
  assert (Zero = get_col (I n) n).
  { unfold get_col.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all; try easy.
    unfold I.
    bdestruct_all; try easy. }
  rewrite H1.
  rewrite map_nth with (d := n).
  unfold get_col.
  bdestruct_all.
  destruct H0; unfold I; bdestruct_all; simpl; try easy.
  rewrite nth_overflow in H4; lia.
Qed.

Lemma WF_Matrix_matrix_column_choose_indices_list : forall {n m : nat} (indices_list : list nat) (M : Matrix n m), WF_Matrix M -> WF_Matrix (matrix_column_choose indices_list M).
Proof. intros.
  unfold WF_Matrix.
  intros.
  unfold matrix_column_choose.
  unfold list_vector_to_matrix.
  assert (Zero = get_col M m).
  { unfold get_col.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all; try easy.
    unfold WF_Matrix in H0.
    assert ((x0 >= n)%nat \/ (m >= m)%nat). { right. lia. }
    specialize (H0 x0 m H3).
    rewrite H0.
    trivial. }
  rewrite H2.
  rewrite map_nth with (d := m).
  unfold get_col.
  bdestruct_all.
  destruct H1.
  - unfold WF_Matrix in H0.
    assert ((x >= n)%nat \/ ((nth y indices_list m) >= m)%nat). { left. assumption. }
    specialize (H0 x (nth y indices_list m) H4).
    assumption.
  - rewrite nth_overflow.
    2 : lia.
    unfold WF_Matrix in H0.
    assert ((x >= n)%nat \/ (m >= m)%nat). { right. lia. }
    specialize (H0 x m H4).
    assumption.
Qed.

Lemma  WF_Matrix_vector_row_choose_indices_list : forall {n : nat} (indices_list : list nat) (v : Vector n), WF_Matrix v -> WF_Matrix (vector_row_choose indices_list v).
Proof. intros.
  unfold WF_Matrix.
  intros.
  unfold vector_row_choose.
  destruct H1.
  - rewrite nth_overflow.
    2 : lia.
    unfold WF_Matrix in H0.
    assert ((n >= n)%nat \/ (y >= 1)%nat). { left. lia. }
    specialize (H0 n y H2).
    apply H0.
  - unfold WF_Matrix in H0.
    assert (((nth x indices_list n) >= n)%nat \/ (y >= 1)%nat). { right. assumption. }
    specialize (H0 (nth x indices_list n) y H2).
    apply H0.
Qed.

#[export] Hint Resolve WF_Matrix_matrix_column_choose_indices_list_I_n WF_Matrix_matrix_column_choose_indices_list WF_Matrix_vector_row_choose_indices_list : wf_db.

  
Lemma matrix_column_choose_inverse_r' : forall (n : nat) (indices_list : list nat),
    Permutation (List.seq 0 n) indices_list ->
    (matrix_column_choose indices_list (I n)) × (matrix_column_choose indices_list (I n)) ⊤ = I n.
Proof. intros.
  remember H0 as Perm. clear HeqPerm.
  unfold matrix_column_choose.
  unfold transpose. unfold Mmult.
  do 2 (apply functional_extensionality; intros).
  unfold list_vector_to_matrix.

  assert (WF_Diagonal (I n)). 1: apply diag_I.
  unfold WF_Diagonal in H1. destruct H1.
  unfold WF_Matrix in H1.
  
  assert (Zero = get_vec n (I n)).
  { unfold WF_Matrix in H1.
    unfold get_col.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all; try easy.
    rewrite H1; try easy; try lia. }
  rewrite H3.

  assert ((fun y : nat =>
     nth y (map (fun i0 : nat => get_vec i0 (I n)) indices_list) 
       (get_vec n (I n)) x 0%nat *
     nth y (map (fun i0 : nat => get_vec i0 (I n)) indices_list) 
       (get_vec n (I n)) x0 0%nat) =
            (fun y : nat =>
     get_vec (nth y indices_list n) (I n) x 0%nat *
  get_vec (nth y indices_list n) (I n) x0 0%nat)).
  { apply functional_extensionality; intros.
    rewrite map_nth with (d := n). easy. }
  rewrite H4.
  
  unfold get_vec.
  bdestruct_all.

  unfold I in H1, H2.
  unfold WF_Matrix in H0.
  unfold I.
  bdestruct_all.
  - simpl.
    rewrite H8.
    replace
      (fun y : nat =>
         (if (x0 =? nth y indices_list n)%nat && true then C1 else 0) *
           (if (x0 =? nth y indices_list n)%nat && true then C1 else 0))
      with
      (fun y : nat =>
         (if (x0 =? nth y indices_list n)%nat then C1 else 0) *
           (if (x0 =? nth y indices_list n)%nat then C1 else 0))
      by (apply functional_extensionality; intros; rewrite andb_true_r; easy).
    rewrite Permutation_nth in H0; try easy.
    destruct H0. destruct H9 as [f H9]. destruct H9. destruct H10.
    specialize (FinFun.bInjective_bSurjective H9). intros.
    rewrite H12 in H10.
    specialize (FinFun.bSurjective_bBijective H9 H10). intros.
    destruct H13 as [g H13].
    destruct H13.
    
    assert (FinFun.bInjective (length (List.seq 0 n)) g).
    { unfold FinFun.bInjective.
      intros.
      remember H14. clear Heqa.
      specialize (H14 x1 H15).
      specialize (a y H16).
      destruct H14.
      destruct a.
      apply f_equal with (f := f) in H17.
      rewrite H18, H20 in H17.
      easy. }
    specialize (FinFun.bInjective_bSurjective H13). intros.
    rewrite H16 in H15.
    
    apply big_sum_unique.

    exists (g x0). rewrite ! H0.
    remember H10 as bSurjective_f. clear HeqbSurjective_f.
    unfold FinFun.bSurjective in H10.
    specialize (seq_length n 0). intros.
    rewrite <- H17 in H6, H7.
    specialize (H10 x0 H7).
    destruct H10.
    destruct H10.
    apply f_equal with (f := g) in H18.
    remember H14. clear Heqa.
    specialize (a x1 H10).
    destruct a.
    rewrite H19 in H18.
    rewrite <- H18.
    split; try easy.
    split.
    + specialize (H11 x1 H10).
      rewrite H11.
      apply f_equal with (f := f) in H18.
      specialize (H14 x0 H7).
      destruct H14.
      rewrite H21 in H18.
      rewrite H18.
      rewrite seq_nth.
      bdestruct_all.
      lca.
      rewrite H17 in H7.
      easy.
    + intros.
      remember H14. clear Heqa.
      specialize (a x0 H7).
      destruct a.
      apply f_equal with (f := f) in H18.
      rewrite H24 in H18.
      rewrite <- H18.
      rewrite H11; try easy.
      rewrite seq_nth.
      2: { unfold FinFun.bSurjective in H15.
           specialize (H15 x' H21).
           destruct H15.
           destruct H15.
           specialize (H14 x2 H15).
           destruct H14.
           apply f_equal with (f := f) in H25.
           rewrite H26 in H25.
           rewrite <- H17.
           rewrite <- H25.
           easy. }
      bdestruct_all; try lca.
      rewrite Nat.add_0_l in H25.
      rewrite <- H12 in bSurjective_f.
      rename bSurjective_f into bInjective_f.
      unfold FinFun.bInjective in bInjective_f.
      specialize (bInjective_f x1 x' H10 H21).
      apply bInjective_f in H25.
      contradiction.
  - simpl.
    replace C0 with (big_sum (fun _ : nat => C0) (length indices_list)) at 1 by (rewrite big_sum_0; easy).
    apply big_sum_eq_bounded.
    intros.
    bdestruct_all; simpl; lca.
  - simpl.
    replace C0 with (big_sum (fun _ : nat => C0) (length indices_list)) at 1 by (rewrite big_sum_0; easy).
    apply big_sum_eq_bounded.
    intros.
    bdestruct_all; simpl; lca.
  - simpl.
    replace C0 with (big_sum (fun _ : nat => C0) (length indices_list)) at 1 by (rewrite big_sum_0; easy).
    apply big_sum_eq_bounded.
    intros.
    bdestruct_all; simpl; lca.
  - simpl.
    replace C0 with (big_sum (fun _ : nat => C0) (length indices_list)) at 1 by (rewrite big_sum_0; easy).
    apply big_sum_eq_bounded.
    intros.
    bdestruct_all; simpl; lca.
  - simpl.
    replace C0 with (big_sum (fun _ : nat => C0) (length indices_list)) at 1 by (rewrite big_sum_0; easy).
    apply big_sum_eq_bounded.
    intros.
    bdestruct_all; simpl; lca.
Qed.

Lemma matrix_column_choose_inverse_l' : forall (n : nat) (indices_list : list nat),
    Permutation (List.seq 0 n) indices_list ->
    (matrix_column_choose indices_list (I n)) ⊤ × (matrix_column_choose indices_list (I n)) = I (length indices_list).
Proof. intros.
  remember H0 as Perm. clear HeqPerm.
  apply Permutation_length in H0.
  rewrite seq_length in H0. rewrite <- ! H0.
  apply Minv_flip.
  assert (@WF_Matrix n n (matrix_column_choose indices_list (I n)) =
            @WF_Matrix n (length indices_list) (matrix_column_choose indices_list (I n))).
  { rewrite <- H0. easy. }
  rewrite H1. apply WF_Matrix_matrix_column_choose_indices_list_I_n.
  apply WF_transpose.
  assert (@WF_Matrix n n (matrix_column_choose indices_list (I n)) =
            @WF_Matrix n (length indices_list) (matrix_column_choose indices_list (I n))).
  { rewrite <- H0. easy. }
  rewrite H1. apply WF_Matrix_matrix_column_choose_indices_list_I_n.
  assert (@eq (Matrix n n)
            (@Mmult n (@length nat indices_list) n
               (@matrix_column_choose n n indices_list (I n))
               (@transpose n (@length nat indices_list)
                  (@matrix_column_choose n n indices_list (I n)))) 
            (I n) =
            @eq (Matrix n n)
              (@Mmult n n n (@matrix_column_choose n n indices_list (I n))
                 (@transpose n n (@matrix_column_choose n n indices_list (I n)))) 
              (I n)).
  { rewrite <- H0. easy. }
  rewrite <- H1.
  apply matrix_column_choose_inverse_r'.
  easy.
Qed.

Lemma matrix_column_choose_I_n_adjoint_transpose : forall (n : nat) (indices_list : list nat),
    (matrix_column_choose indices_list (I n)) † =  (matrix_column_choose indices_list (I n)) ⊤.
Proof. intros. unfold matrix_column_choose.
  unfold list_vector_to_matrix.
  unfold transpose, adjoint.
  do 2 (apply functional_extensionality; intros).
  assert (Zero = get_vec n (I n)).
  { unfold get_vec.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all; try easy.
    unfold I.
    bdestruct_all; try easy. }
    rewrite H0.
  rewrite map_nth with (d := n).
  unfold get_vec.
  bdestruct_all.
  unfold I.
  bdestruct_all; simpl; lca.
Qed.

Lemma matrix_column_choose_inverse_r : forall (n : nat) (indices_list : list nat),
    Permutation (List.seq 0 n) indices_list ->
    (matrix_column_choose indices_list (I n)) × (matrix_column_choose indices_list (I n)) † = I n.
Proof. intros.
  rewrite matrix_column_choose_I_n_adjoint_transpose.
  apply matrix_column_choose_inverse_r'.
  easy.
Qed.

Lemma matrix_column_choose_inverse_l : forall (n : nat) (indices_list : list nat),
    Permutation (List.seq 0 n) indices_list ->
    (matrix_column_choose indices_list (I n)) † × (matrix_column_choose indices_list (I n)) = I (length indices_list).
Proof. intros.
  rewrite matrix_column_choose_I_n_adjoint_transpose.
  apply matrix_column_choose_inverse_l'.
  easy.
Qed.

(** 
     0    1   0       0  1  0  0
     1    0   0       1  0  0  0
     0    0   1       0  0  1  0
     0    0   0
*)


Lemma matrix_column_choose_app_smash : forall {n m} (list1 list2 : list nat) (M : Matrix n m), WF_Matrix M -> matrix_column_choose (list1 ++ list2) M = smash (matrix_column_choose list1 M) (matrix_column_choose list2 M).
Proof. intros. unfold matrix_column_choose. unfold smash.
  unfold list_vector_to_matrix.
  do 2 (apply functional_extensionality; intros).
  (*** You can get rid of this by splitting cases on x0 <? length indices_list, and using nth_indep & nth_overflow ***)
  assert (Zero = get_vec m M).
  { unfold WF_Matrix in H0.
    unfold get_vec.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all. 2: easy.
    specialize (H0 x1 m).
    assert ((x1 >= n)%nat \/ (m >= m)%nat). 1: right; lia.
    specialize (H0 H2).
    rewrite H0.
    easy. }
  rewrite ! H1.
  rewrite ! map_nth with (d := m).
  bdestruct_all.
  - f_equal. apply app_nth1; easy.
  - f_equal. apply app_nth2; easy.
Qed.


Lemma big_sum_permutation : forall (A : Type) (m : nat) (d : A) (l1 l2 : list A) (f : A -> C),
    Permutation l1 l2 -> (m >= length l1)%nat ->
    Σ (fun y : nat => f (nth y l1 d)) m = Σ (fun y : nat => f (nth y l2 d)) m.
Proof. intros.
  gen m.
  induction H0.
  - simpl. easy.
  - intros. simpl in *.
    destruct m; try easy.
    rewrite <- ! big_sum_extend_l.
    rewrite IHPermutation.
    easy. lia.
  - intros. 
    destruct m; try easy.
    destruct m.
    simpl in *.
    lia.
    rewrite <- ! big_sum_extend_l.
    simpl.
    lca.
  - intros.
    rewrite IHPermutation1; try easy.
    rewrite IHPermutation2; try easy.
    apply Permutation_length in H0_.
    rewrite H0_ in H1.
    easy.
Qed.  


Lemma matrix_column_choose_vector_row_choose_original : forall {n m} (indices_list : list nat) (M : Matrix n m) (v : Vector m),
    WF_Matrix M ->
    Permutation (List.seq 0 m) indices_list ->
    (matrix_column_choose indices_list M)
      × (vector_row_choose indices_list v) = M × v. (** = Σ_i M_i v_i **)
Proof. intros.
  unfold matrix_column_choose.
  unfold list_vector_to_matrix.
  unfold vector_row_choose.
  unfold Mmult.
  do 2 (apply functional_extensionality; intros).

  remember H1 as H2. clear HeqH2.
  apply Permutation_length in H2.
  rewrite seq_length in H2.
  symmetry in H2.
  rewrite H2.
  (*** You can get rid of this by splitting cases on y <? length indices_list, and using nth_indep & nth_overflow ***)
  assert (Zero = get_vec m M).
  { unfold WF_Matrix in H0.
    unfold get_vec.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all. 2: easy.
    specialize (H0 x1 m).
    assert ((x1 >= n)%nat \/ (m >= m)%nat). 1: right; lia.
    specialize (H0 H4).
    rewrite H0.
    easy. }
  rewrite H3.

  assert ((fun y : nat =>
             nth y (map (fun i0 : nat => get_vec i0 M) indices_list) (get_vec m M) x 0%nat *
               v (nth y indices_list m) x0) =
            (fun y : nat =>
                get_vec (nth y indices_list m) M x 0%nat * v (nth y indices_list m) x0)).
  { apply functional_extensionality; intros.
    rewrite map_nth with (d := m). easy. }
  rewrite H4.
  unfold get_vec.
  bdestruct_all.

  rewrite big_sum_permutation with (A := nat) (d := m) (l1 := indices_list) (f := (fun y : nat => M x y * v y x0)) (l2 := List.seq 0 m).

  - apply big_sum_eq_bounded.
    intros.
    rewrite seq_nth; easy.
  - apply Permutation_sym in H1. easy.
  - lia.
Qed.


Lemma matrix_column_choose_pop_square : forall {n} (indices_list : list nat) (M1 M2 : Square n), WF_Matrix M2 -> matrix_column_choose indices_list (M1 × M2) = M1 × (matrix_column_choose indices_list M2).
Proof. intros. rewrite <- matrix_column_choose_pop; auto with wf_db.
Qed.

Lemma matrix_column_choose_pop_square_id : forall {n} (indices_list : list nat) (M : Square n), WF_Matrix M -> matrix_column_choose indices_list M = M × (matrix_column_choose indices_list (I n)).
Proof. intros. rewrite <- matrix_column_choose_pop; auto with wf_db.
  rewrite Mmult_1_r; auto with wf_db.
Qed.

Lemma vector_row_choose_matrix_column_choose : forall (n : nat) (v : Vector n) (indices_list : list nat),
    WF_Matrix v ->
    (vector_row_choose indices_list v) = (matrix_column_choose indices_list (I n)) ⊤ × v.
Proof. intros. unfold vector_row_choose.
  unfold matrix_column_choose.
  unfold list_vector_to_matrix.
  unfold transpose, Mmult.
  do 2 (apply functional_extensionality; intros).

  assert (Zero = get_vec n (I n)).
  { unfold get_vec.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all. 2: easy.
    unfold I.
    bdestruct_all; simpl; easy. }

  assert ((fun y : nat =>
     nth x (map (fun i0 : nat => get_vec i0 (I n)) indices_list) Zero y 0%nat *
     v y x0) = (fun y : nat => get_vec (nth x indices_list n) (I n) y 0%nat * v y x0)).
  { rewrite H1.
    rewrite map_nth with (d := n).
    easy. }
  rewrite H2.

  unfold get_vec.
  bdestruct_all.
  bdestruct ((nth x indices_list n) <? n).
  - rewrite big_sum_unique with (k := v (nth x indices_list n) x0); try easy.
    exists (nth x indices_list n). split; try easy.
    split.
    + unfold I. bdestruct_all. simpl. lca.
    + intros. unfold I. bdestruct_all. simpl. lca.
  - unfold WF_Matrix in H0.
    rewrite H0. 2: left; assumption.
    rewrite big_sum_0; try easy.
    intros.
    unfold I.
    bdestruct_all; simpl; lca.
Qed.


Definition is_in_nat_list (n : nat) (listN : list nat) : bool :=
  existsb (fun m : nat => Nat.eqb n m) listN.

Definition selective_diagonal (n : nat) (indices_list : list nat): Square n :=
  fun x y => if (x =? y)%nat && (x <? n) && (is_in_nat_list x indices_list) then C1 else 0.

Lemma WF_selective_diagonal : forall (n : nat) (indices_list : list nat),
    WF_Matrix (selective_diagonal n indices_list).
Proof. unfold WF_Matrix. intros.
  unfold selective_diagonal.
  destruct H0.
  bdestruct_all; simpl; trivial.
  destruct ((x =? y)%nat) eqn:E; trivial.
  rewrite Nat.eqb_eq in E.
  subst.
  bdestruct_all.
  trivial.
Qed.

#[export] Hint Resolve WF_selective_diagonal : wf_db.

Lemma selective_diagonal_permutation_identity : forall (n : nat) (indices_list : list nat),
    Permutation (List.seq 0 n) indices_list ->
    I n = selective_diagonal n indices_list.
Proof. intros. unfold I. unfold selective_diagonal.
  do 2 (apply functional_extensionality; intros).
  bdestruct_all; simpl; trivial.
  assert (0 <= x < 0 + n)%nat.
  { lia. }
  rewrite <- in_seq in H3.
  apply Permutation_in with (l := (List.seq 0 n)) (l' := indices_list) in H3; trivial.
  unfold is_in_nat_list.
  assert (exists y : nat, In y indices_list /\ ((fun m : nat => (x =? m)%nat) y = true)).
  { exists x. split; bdestruct_all; trivial. }
  rewrite <- existsb_exists with (f := (fun m : nat => (x =? m)%nat)) (l := indices_list) in H4.
  rewrite H4.
  reflexivity.
Qed.

Lemma matrix_column_choose_selective_diagonal : forall (n : nat) (indices_list : list nat),
    NoDup indices_list ->
    (matrix_column_choose indices_list (I n)) × (matrix_column_choose indices_list (I n)) ⊤ = selective_diagonal n indices_list.
Proof. intros n indices_list H'.  unfold matrix_column_choose. unfold list_vector_to_matrix.
  unfold selective_diagonal.
  unfold transpose, Mmult.
  do 2 (apply functional_extensionality; intros).
  assert (Zero = get_vec n (I n)).
  { unfold get_vec, I.
    do 2 (apply functional_extensionality; intros).
    bdestruct_all; simpl; lca. }
  rewrite ! H0.
  assert ((fun y : nat =>
             nth y (map (fun i0 : nat => get_vec i0 (I n)) indices_list) 
               (get_vec n (I n)) x 0%nat *
               nth y (map (fun i0 : nat => get_vec i0 (I n)) indices_list) 
                 (get_vec n (I n)) x0 0%nat) =
            (fun y : nat =>
               get_vec (nth y indices_list n) (I n) x 0%nat *
                 get_vec (nth y indices_list n) (I n) x0 0%nat)).
  { apply functional_extensionality; intros.
    rewrite map_nth with (d := n). easy. }
  rewrite H1.
  unfold get_vec.
  bdestruct (0 =? 0)%nat.
  2: contradiction.
  unfold I.
  bdestruct_all; simpl.
  - assert ((fun y : nat =>
               (if (x =? nth y indices_list n)%nat && true then C1 else 0) *
                 (if (x0 =? nth y indices_list n)%nat && true then C1 else 0)) =
              (fun y : nat =>
                 (if (x =? nth y indices_list n)%nat then C1 else 0))).
    { rewrite H5.
      apply functional_extensionality; intros.
      bdestruct_all; simpl; lca. }
    rewrite H6.
    unfold is_in_nat_list.
    clear - H'.
    destruct (existsb (fun m : nat => (x =? m)%nat) indices_list) eqn:E.
    + apply big_sum_unique.
      apply existsb_exists in E.
      destruct E. destruct H0.
      apply Nat.eqb_eq in H1.
      apply In_nth with (x := x0) (l := indices_list) (d := n) in H0; trivial.
      destruct H0. destruct H0.
      exists x1. split; trivial.
      split.
      * rewrite H1. bdestruct_all; easy.
      * intros.
        bdestruct_all; trivial.
        rewrite H1 in H5. symmetry in H5.
        rewrite NoDup_nth in H'.
        rewrite <- H5 in H2.
        specialize (H' x1 x' H0 H3 H2).
        contradiction.
    + assert (C0 =  Σ (fun _ : nat => 0) (length indices_list)).
      { rewrite big_sum_0; easy. }
      rewrite H0.
      apply big_sum_eq_bounded.
      intros.
      rewrite existsb_nth; trivial.
      setoid_rewrite H0 at 2.
      reflexivity.
  - assert ((fun y : nat =>
               (if (x =? nth y indices_list n)%nat && true then C1 else 0) *
                 (if (x0 =? nth y indices_list n)%nat && true then C1 else 0)) =
              (fun y : nat => 0)).
    { apply functional_extensionality; intros.
      bdestruct_all; simpl; lca. }
    rewrite H6.
    rewrite big_sum_0; easy.
  - assert ((fun y : nat =>
               (if (x =? nth y indices_list n)%nat && true then C1 else 0) *
                 (if (x0 =? nth y indices_list n)%nat && false then C1 else 0)) =
              (fun y : nat => 0)).
    { apply functional_extensionality; intros.
      bdestruct_all; simpl; lca. }
    rewrite H6.
    rewrite big_sum_0; easy.
  - assert ((fun y : nat =>
               (if (x =? nth y indices_list n)%nat && false then C1 else 0) *
                 (if (x0 =? nth y indices_list n)%nat && true then C1 else 0)) =
              (fun y : nat => 0)).
    { apply functional_extensionality; intros.
      bdestruct_all; simpl; lca. }
    rewrite H6.
    rewrite big_sum_0; easy.
  - assert ((fun y : nat =>
               (if (x =? nth y indices_list n)%nat && false then C1 else 0) *
                 (if (x0 =? nth y indices_list n)%nat && false then C1 else 0)) =
              (fun y : nat => 0)).
    { apply functional_extensionality; intros.
      bdestruct_all; simpl; lca. }
    rewrite H6.
    rewrite big_sum_0; easy.
  - assert ((fun y : nat =>
     (if (x =? nth y indices_list n)%nat && false then C1 else 0) *
     (if (x0 =? nth y indices_list n)%nat && false then C1 else 0)) =
              (fun y : nat => 0)).
    { apply functional_extensionality; intros.
      bdestruct_all; simpl; lca. }
    rewrite H6.
    rewrite big_sum_0; easy.
Qed.

Lemma NoDup_app_comm : forall (A : Type) (list1 list2 : list A),
    NoDup (list1 ++ list2) -> NoDup (list2 ++ list1).
Proof. intros. apply NoDup_incl_NoDup with (l := list1 ++ list2) (l' := list2 ++ list1); trivial.
  - rewrite ! app_length. lia.
  - apply incl_app.
    + apply incl_appr.
      apply incl_refl.
    + apply incl_appl.
      apply incl_refl.
Qed.

Lemma NoDup_app_in_neg_r : forall (A : Type) (a : A) (list1 list2 : list A),
    NoDup (list1 ++ list2) -> In a list1 -> ~ In a list2.
Proof. intros.
  gen a list1. induction list2.
  - intros. intro. inversion H2.
  - intros.
    apply NoDup_remove in H0.
    intro.
    simpl in *.
    destruct H0.
    destruct H2.
    + rewrite <- H2 in H1.
      assert (In a (list1 ++ list2)).
      { rewrite in_app_iff. left. easy. }
      apply H3 in H4.
      contradiction.
    + contradict H2.
      apply IHlist2 with (list1 := list1); trivial.
Qed.

Lemma NoDup_app_in_neg_l : forall (A : Type) (a : A) (list1 list2 : list A),
    NoDup (list1 ++ list2) -> In a list2 -> ~ In a list1.
Proof. intros. apply NoDup_app_comm in H0.
  apply NoDup_app_in_neg_r with (list1 := list2); trivial.
Qed.

Lemma selective_diagonal_app_split : forall (n : nat) (list1 list2 : list nat),
    NoDup (list1 ++ list2) ->
    selective_diagonal n (list1 ++ list2) = selective_diagonal n list1 .+ selective_diagonal n list2.
Proof. intros. unfold selective_diagonal.
  unfold Mplus.
  do 2 (apply functional_extensionality; intros).
  bdestruct_all; simpl; try lca.
  unfold is_in_nat_list.
  destruct (existsb (fun m : nat => (x =? m)%nat) (list1 ++ list2)) eqn:E.
  - rewrite existsb_app in E.
    rewrite orb_true_iff in E.
    destruct E.
    + rewrite H3.
      rewrite existsb_exists in H3.
      destruct H3. destruct H3.
      apply NoDup_app_in_neg_r with (a := x1) in H0; trivial.
      rewrite Nat.eqb_eq in H4.
      rewrite H4.
      destruct (existsb (fun m : nat => (x1 =? m)%nat) list2) eqn:E; try lca.
      rewrite existsb_exists in E.
      destruct E. destruct H5.
      rewrite Nat.eqb_eq in H6.
      rewrite H6 in H0.
      contradiction.
    + rewrite H3.
      rewrite existsb_exists in H3.
      destruct H3. destruct H3.
      apply NoDup_app_in_neg_l with (a := x1) in H0; trivial.
      rewrite Nat.eqb_eq in H4.
      rewrite H4.
      destruct (existsb (fun m : nat => (x1 =? m)%nat) list1) eqn:E; try lca.
      rewrite existsb_exists in E.
      destruct E. destruct H5.
      rewrite Nat.eqb_eq in H6.
      rewrite H6 in H0.
      contradiction.
  - rewrite existsb_app in E.
    rewrite orb_false_iff in E.
    destruct E.
    rewrite H3, H4.
    lca.
Qed.

Lemma matrix_column_choose_I_n_app_split : forall (n : nat) (list1 list2 : list nat),
    NoDup (list1 ++ list2) ->
    (matrix_column_choose (list1 ++ list2) (I n)) × (matrix_column_choose (list1 ++ list2) (I n)) ⊤ = (matrix_column_choose (list1) (I n)) × (matrix_column_choose (list1) (I n)) ⊤ .+ (matrix_column_choose (list2) (I n)) × (matrix_column_choose (list2) (I n)) ⊤.
Proof. intros.
  remember H0. clear Heqn0.
  remember H0. clear Heqn1.
  apply NoDup_app_remove_l in n0.
  apply NoDup_app_remove_r in n1.
  rewrite ! matrix_column_choose_selective_diagonal; trivial.
  rewrite selective_diagonal_app_split; trivial.
Qed.

Lemma matrix_column_choose_vector_row_choose_app_split : forall {n} (list1 list2 : list nat) (M : Square n) (v : Vector n),
    WF_Matrix M -> WF_Matrix v -> NoDup (list1 ++ list2) ->
    Permutation (list1 ++ list2) (List.seq 0 n) ->
    (matrix_column_choose (list1 ++ list2) M)
      × (vector_row_choose (list1 ++ list2) v) =
      ((matrix_column_choose list1 M)
         × (vector_row_choose list1 v)) .+
        ((matrix_column_choose list2 M)
           × (vector_row_choose list2 v)).
Proof. intros.
  rewrite matrix_column_choose_pop_square_id.
  rewrite vector_row_choose_matrix_column_choose.
  assert (M × matrix_column_choose (list1 ++ list2) (I n)
            × ((matrix_column_choose (list1 ++ list2) (I n)) ⊤ × v) =
            M × (matrix_column_choose (list1 ++ list2) (I n)
                   × (matrix_column_choose (list1 ++ list2) (I n)) ⊤) × v).
  { rewrite ! Mmult_assoc. easy. }
  rewrite H4.
  rewrite matrix_column_choose_I_n_app_split.
  rewrite Mmult_plus_distr_l.
  rewrite <- ! Mmult_assoc.
  rewrite <- ! matrix_column_choose_pop_square_id.
  rewrite Mmult_plus_distr_r.
  rewrite ! Mmult_assoc.
  rewrite <- ! vector_row_choose_matrix_column_choose.
  easy.
  all: assumption.
Qed.


Lemma matrix_column_choose_vector_row_choose_selective_diagonal :
  forall {n} (indices_list : list nat) (M : Square n) (v : Vector n),
    NoDup indices_list -> WF_Matrix M -> WF_Matrix v ->
    matrix_column_choose indices_list M × vector_row_choose indices_list v
    = M × selective_diagonal n indices_list × v.
Proof. intros.
  rewrite matrix_column_choose_pop_square_id.
  rewrite vector_row_choose_matrix_column_choose.
  replace (M × matrix_column_choose indices_list (I n)
             × ((matrix_column_choose indices_list (I n)) ⊤ × v))
    with (M × (matrix_column_choose indices_list (I n)
                 × (matrix_column_choose indices_list (I n)) ⊤) × v)
    by (rewrite <- ! Mmult_assoc; reflexivity).
  rewrite matrix_column_choose_selective_diagonal.
  all: trivial.
Qed.

(*
    In x plus1idxA ->
       Eigenpair (translateA b) (translate_prog n g × UA × e_i x, C1)
                 
         ( forall x,  In x indices_list -> Eigenpair (M1) (M2 × e_i x, c) )
       -> M1 M2 e_i x = c M2 e_i x
       -> M1 M2 selective_diagonal n indices_list = c M2 selective_diagonal n indices_list
 *)
Lemma Permutation_incl : forall (A : Type) (l l' : list A), Permutation l l' -> incl l l'.
Proof. intros. unfold incl. intros. apply Permutation_in with (l := l); trivial. Qed.

Lemma selective_diagonal_idempotent : forall (n : nat) (indices_list : list nat), selective_diagonal n indices_list × selective_diagonal n indices_list = selective_diagonal n indices_list.
Proof. intros. unfold selective_diagonal. unfold Mmult.
  do 2 (apply functional_extensionality; intros).
  bdestruct_all; simpl.
  - subst. destruct (is_in_nat_list x0 indices_list) eqn:E.
    + apply big_sum_unique.
      exists x0. repeat split; trivial.
      * bdestruct_all; simpl. rewrite E. lca.
      * intros. bdestruct_all; simpl; lca.
    + apply @big_sum_0 with (H := C_is_monoid).
      intros. bdestruct_all; simpl; lca.
  - apply @big_sum_0 with (H := C_is_monoid).
    intros. bdestruct_all; simpl; lca.
  - apply @big_sum_0 with (H := C_is_monoid).
    intros. bdestruct_all; simpl; lca.
  - apply @big_sum_0 with (H := C_is_monoid).
    intros. bdestruct_all; simpl; lca.
Qed.

Lemma selective_diagonal_orth : forall (n : nat) (list1 list2 : list nat),
    NoDup (list1 ++ list2) ->
    selective_diagonal n list1 × selective_diagonal n list2 = @Zero n n.
Proof. intros.
  unfold selective_diagonal. unfold Mmult.
  do 2 (apply functional_extensionality; intros).
  
  replace (@Zero n n x x0) with C0 by lca.
  apply @big_sum_0_bounded with (H := C_is_monoid).
  intros.
  bdestruct_all; simpl; try lca.
  subst.
  destruct (is_in_nat_list x0 list1) eqn:E1; try lca.
  destruct (is_in_nat_list x0 list2) eqn:E2; try lca.
  unfold is_in_nat_list in *.
  rewrite existsb_exists in *.
  destruct E1, E2.
  destruct H4, H5.
  rewrite Nat.eqb_eq in *.
  subst.
  pose (NoDup_app_in_neg_l nat x1 list1 list2 H0 H5).
  contradiction.
Qed.


Lemma selective_diagonal_adjoint_transpose : forall (n : nat) (indices_list : list nat),
    (selective_diagonal n indices_list) † = (selective_diagonal n indices_list) ⊤.
Proof. intros.
  unfold adjoint, transpose.
  do 2 (apply functional_extensionality; intros).
  unfold selective_diagonal.
  bdestruct_all; simpl; try lca.
  destruct (is_in_nat_list x0 indices_list) eqn:E; lca.
Qed.
  
Lemma selective_diagonal_symmetric : forall (n : nat) (indices_list : list nat),
    (selective_diagonal n indices_list) ⊤ = selective_diagonal n indices_list.
Proof. intros.
  unfold adjoint, transpose.
  do 2 (apply functional_extensionality; intros).
  unfold selective_diagonal.
  bdestruct_all; simpl; try lca.
  subst.
  destruct (is_in_nat_list x indices_list) eqn:E; lca.
Qed.

Lemma selective_diagonal_hermitian : forall (n : nat) (indices_list : list nat),
    (selective_diagonal n indices_list) † = selective_diagonal n indices_list.
Proof. intros.
  rewrite selective_diagonal_adjoint_transpose.
  apply selective_diagonal_symmetric.
Qed.

Lemma selective_diagonal_e_i_identity : forall (n i : nat) (indices_list : list nat),
    In i indices_list -> selective_diagonal n indices_list × e_i i = e_i i.
Proof. intros.
  unfold selective_diagonal.
  unfold e_i.
  unfold Mmult.
  do 2 (apply functional_extensionality; intros).
  assert ((fun y : nat =>
             (if (x =? y)%nat && (x =? i)%nat && (x <? n) && (x0 =? 0)%nat &&
                   is_in_nat_list x indices_list then C1 else 0))
         =
           (fun y : nat =>
              (if (x =? y)%nat && (x <? n) && is_in_nat_list x indices_list then C1 else 0) *
                (if (y =? i)%nat && (y <? n) && (x0 =? 0)%nat then C1 else 0))).
  { apply functional_extensionality; intros. 
    bdestruct_all; simpl; try lca; subst. }
  rewrite <- H1.
  bdestruct_all; simpl.
  2-8: apply @big_sum_0 with (H := C_is_monoid); intros; bdestruct_all; simpl; lca.
  subst.
  apply @big_sum_unique with (H := C_is_monoid).
  exists i.
  split; trivial.
  split; bdestruct_all.
  - simpl. destruct (is_in_nat_list i indices_list) eqn:E; try lca.
    unfold is_in_nat_list in E.
    assert (exists x : nat, In x indices_list /\ (fun m : nat => (i =? m)%nat) x = true).
    { exists i. split; trivial. rewrite Nat.eqb_eq. trivial. }
    rewrite <- existsb_exists in H4.
    rewrite H4 in E.
    discriminate.
  - intros. bdestruct_all. simpl. trivial.
Qed.

Lemma selective_diagonal_e_i_zero : forall (n i : nat) (indices_list : list nat),
    ~ In i indices_list -> selective_diagonal n indices_list × e_i i = Zero.
Proof. intros.
  unfold selective_diagonal.
  unfold e_i.
  unfold Mmult.
  do 2 (apply functional_extensionality; intros).
  assert ((fun y : nat =>
             (if (x =? y)%nat && (x =? i)%nat && (x <? n) && (x0 =? 0)%nat &&
                   is_in_nat_list x indices_list then C1 else 0))
         =
           (fun y : nat =>
              (if (x =? y)%nat && (x <? n) && is_in_nat_list x indices_list then C1 else 0) *
                (if (y =? i)%nat && (y <? n) && (x0 =? 0)%nat then C1 else 0))).
  { apply functional_extensionality; intros. 
    bdestruct_all; simpl; try lca; subst. }
  rewrite <- H1.
  bdestruct_all; simpl.
  2-8: apply @big_sum_0 with (H := C_is_monoid); intros; bdestruct_all; simpl; lca.
  subst.
  apply @big_sum_unique with (H := C_is_monoid).
  exists i.
  split; trivial.
  split; bdestruct_all.
  - simpl. destruct (is_in_nat_list i indices_list) eqn:E; try lca.
    unfold is_in_nat_list in E.
    rewrite existsb_exists in E.
    destruct E.
    destruct H4.
    rewrite Nat.eqb_eq in H5.
    subst.
    contradiction.
  - intros. bdestruct_all. simpl. trivial.
Qed.



(*
matrix_column_choose_pop_square_id
vector_row_choose_matrix_column_choose
  matrix_column_choose_selective_diagonal
  
v = M × selective_diagonal n indices_list × ((M) † × v)

      (forall x : nat, In x indices_list ->
                M1 × M2 × M3 × e_i x = c .* M2 × M3 × e_i x)
      ->  
        (forall v : Vector (2 ^ n), v = matrix_column_choose indices_list M3
                                     × vector_row_choose indices_list ((M3) † × v) ->
                               M1 × M2 × v = c .* M2 × v)
          
(forall v : Vector (2 ^ n), v = matrix_column_choose indices_list M3
                             × vector_row_choose indices_list ((M3) † × v)
                             = M3 × selective_diagonal n indices_list × (M3) † × v
                       ->
                               M1 × M2 × v = c .* M2 × v)
*)
Lemma eigenpair_to_selective_diagonal : forall {n} (indices_list : list nat) (c : C) (M1 M2 M3 : Square n),
    WF_Matrix M2 -> WF_Matrix M3 -> 
    (forall x : nat, In x indices_list -> Eigenpair M1 (M2 × M3 × e_i x, c)) ->  
    (M1 × M2 × M3 × selective_diagonal n indices_list × (M3) †
     = c .* M2 × M3 × selective_diagonal n indices_list × (M3) †).
Proof. intros. 
  unfold Eigenpair in H2. simpl in H2.
  setoid_rewrite e_i_get_vec in H2; auto with wf_db.

  do 2 (apply functional_extensionality; intros).
  unfold Matrix.scale, Mmult in *. unfold get_vec in *.
  unfold selective_diagonal in *.
  f_equal.
  apply functional_extensionality; intros.
  
  do 2 f_equal.
  apply functional_extensionality; intros.

  destruct (is_in_nat_list x2 indices_list) eqn:E.
  - unfold is_in_nat_list in E.
    rewrite existsb_exists in E.
    destruct E as [x4 [H3 H4]].
    rewrite Nat.eqb_eq in H4.
    subst.
    specialize (H2 x4 H3).
    apply f_equal_inv with (x := x) in H2.
    apply f_equal_inv with (x := 0%nat) in H2.
    simpl in H2.

    f_equal.

    assert ((fun y : nat => (c * M2 x y) * M3 y x4) = (fun y : nat => c * (M2 x y * M3 y x4))).
    { apply functional_extensionality; intros. lca. }
    rewrite H4.
    
    rewrite @big_sum_mult_l with (R := C) (H := C_is_monoid) (H0 := C_is_group) (H1 := C_is_comm_group) (H2 := C_is_ring) in H2.
    rewrite <- @big_sum_mult_l with (R := C) (H := C_is_monoid) (H0 := C_is_group) (H1 := C_is_comm_group) (H2 := C_is_ring).
    rewrite @big_sum_mult_l with (R := C) (H := C_is_monoid) (H0 := C_is_group) (H1 := C_is_comm_group) (H2 := C_is_ring).
    rewrite <- H2.
    
    pose (Mmult_assoc M1 M2 M3) as e.
    unfold Mmult in e.
    apply f_equal_inv with (x := x) in e.
    apply f_equal_inv with (x := x4) in e.
    apply e.
  - bdestruct_all; simpl; lca.
Qed.
  
  
Lemma eigenpair_to_selective_diagonal' : forall {n} (indices_list : list nat) (c : C) (M1 M2 : Square n),
    WF_Matrix M2 -> 
    ((forall i : nat, In i indices_list -> Eigenpair M1 (M2 × e_i i, c)) ->
    M1 × M2 × (selective_diagonal n indices_list) = c .* M2 × selective_diagonal n indices_list).
Proof. intros. pose (eigenpair_to_selective_diagonal indices_list c M1 M2 (I n)).
  rewrite ! Mmult_assoc in e.
  rewrite ! Mmult_1_l in e.
  rewrite ! id_adjoint_eq in e.
  rewrite ! Mmult_1_r in e.
  rewrite Mmult_assoc.
  apply e.
  all: auto with wf_db.
Qed.

Lemma eigenpair_to_selective_diagonal'' : forall {n} (indices_list : list nat) (c : C) (M1 M3 : Square n),
    WF_Matrix M3 -> 
    (forall x : nat, In x indices_list -> Eigenpair M1 (M3 × e_i x, c)) ->  
    (M1 × M3 × selective_diagonal n indices_list × (M3) †
     = c .* M3 × selective_diagonal n indices_list × (M3) †).
Proof. intros.  pose (eigenpair_to_selective_diagonal indices_list c M1 (I n) M3).
  rewrite ! Mscale_mult_dist_l in e.
  rewrite ! Mmult_1_l in e.
  rewrite ! Mmult_assoc in e.
  rewrite ! Mmult_1_l in e.
  rewrite <- ! Mmult_assoc in e.
  rewrite e.
  distribute_scale.
  all: auto with wf_db.
Qed.

(** Extra Lemmas which may or may not be needed *)
(*** matrix_row_choose ***)
           (** Permutation (List.seq 0 n) list
                -> linearly_independent M
                -> linearly_independent (matrix_column_choose list M) **)


















































(** eigenvalue is real : https://books.physics.oregonstate.edu/LinAlg/eigenhermitian.html **)
Lemma Hermitian_eigenvalue_is_real : forall {n} (M : Square n) (v : Vector n) (c : C),
    WF_Matrix M -> WF_Matrix v -> v <> Zero -> M † = M -> M × v = c .* v -> c ^* = c.
Proof. intros n M v c H0 H1 H2 H3 H4. 
  assert (v† × M × v = c .* (v† × v))
    by (rewrite Mmult_assoc, H4; distribute_scale; reflexivity).
  replace (v† × M) with (c ^* .* v†) in H5
    by (rewrite <- H3, <- Mmult_adjoint, H4; distribute_adjoint; reflexivity).
  rewrite Mscale_mult_dist_l in H5.
  destruct (Ceq_dec c C0).
  - subst; lca.
  - assert ((v) † × v <> Zero).
    { intro.
      apply f_equal_inv with (x := 0%nat) in H6.
      apply f_equal_inv with (x := 0%nat) in H6.
      replace (Zero 0%nat 0%nat) with C0 in H6 by (simpl; reflexivity).
      assert ((((v) † × v) 0%nat 0%nat) = (inner_product v v))
        by (unfold inner_product; reflexivity).
      rewrite H7 in H6.
      rewrite inner_product_zero_iff_zero in H6; auto with wf_db. }
    assert (forall a b v, (a .* v = b .* v -> (a - b) .* v = @Zero 1 1%nat)).
    { intros a b v0 H7.
      rewrite Cminus_unfold.
      rewrite Mscale_plus_distr_l.
      rewrite H7.
      rewrite <- Mscale_plus_distr_l.
      replace (b + - b) with C0 by lca.
      rewrite Mscale_0_l.
      reflexivity. }
    apply H7 in H5.
    destruct (Ceq_dec (c ^* - c) C0).
    + apply Cplus_inj_r with (c := c) in e.
      autorewrite with C_db in e.
      setoid_rewrite <- e at 2.
      lca.
    + replace (@Zero 1 1) with ((c ^* - c) .* (@Zero 1 1)) in H5 by lma'.
      apply (Mscale_cancel ((v) † × v) Zero (c ^* - c) n1) in H5.
      contradiction.
Qed.

(** eigenvalue is unimodular : https://books.physics.oregonstate.edu/LinAlg/eigenunitary.html **)
Lemma Unitary_eigenvalue_is_unimodular : forall {n} (M : Square n) (v : Vector n) (c : C),
    WF_Unitary M -> WF_Matrix v -> v <> Zero -> M × v = c .* v -> c^* * c = C1.
Proof. intros n M v c H0 H1 H2 H3.
  assert ((v) † × v <> Zero).
  { intro.
    apply f_equal_inv with (x := 0%nat) in H4.
    apply f_equal_inv with (x := 0%nat) in H4.
    replace (Zero 0%nat 0%nat) with C0 in H4 by (simpl; reflexivity).
    assert ((((v) † × v) 0%nat 0%nat) = (inner_product v v))
      by (unfold inner_product; reflexivity).
    rewrite H5 in H4.
    rewrite inner_product_zero_iff_zero in H4; auto with wf_db. }
  assert (v† × v = (c^* * c) .* (v†× v)).
  { destruct H0.
    replace (v† × v) with (v† × I n × v) at 1 by (rewrite Mmult_1_r; auto with wf_db).
    rewrite <- H5 at 1.
    replace ((v) † × ((M) † × M) × v) with (((v) † × (M) †) × (M × v))
      by (rewrite ! Mmult_assoc; reflexivity).
    rewrite <- Mmult_adjoint.
    rewrite ! H3.
    distribute_adjoint.
    distribute_scale.
    reflexivity. }
  assert (forall a v, (v = a .* v -> (a - C1) .* v = @Zero 1 1%nat)).
  { intros a v0 H6. 
    rewrite Cminus_unfold.
    rewrite Mscale_plus_distr_l.
    rewrite <- H6.
    setoid_rewrite <- Mscale_1_l at 2.
    rewrite <- Mscale_plus_distr_l.
    replace (C1 + - C1) with C0 by lca.
    rewrite Mscale_0_l.
    reflexivity. }
  apply H6 in H5.
  destruct (Ceq_dec (c ^* * c - C1) C0).
  + apply Cplus_inj_r with (c := C1) in e.
    autorewrite with C_db in e.
    setoid_rewrite <- e.
    lca.
  + replace (@Zero 1 1) with ((c ^* * c - C1) .* (@Zero 1 1)) in H5 by lma'.
    apply (Mscale_cancel ((v) † × v) Zero (c ^* * c - C1) n0) in H5.
    contradiction.
Qed.

Lemma Unitary_Hermitian_eigenvalue_plusminus1: forall {n} (M : Square n) (v : Vector n) (c : C),
    WF_Unitary M -> WF_Matrix v -> v <> Zero -> M † = M -> M × v = c .* v -> (c = C1) \/ (c = Copp C1).
Proof. intros n M v c H0 H1 H2 H3 H4.
  remember H0 as H0'. clear HeqH0'. destruct H0'.
  pose (Hermitian_eigenvalue_is_real M v c H5 H1 H2 H3 H4).
  pose (Unitary_eigenvalue_is_unimodular M v c H0 H1 H2 H4).
  destruct c.
  inversion e.
  assert (r0 = 0)%R by lra.
  subst.
  inversion e0.
  autorewrite with R_db in H9, H10.
  assert (r = 1 \/ r = - 1)%R by nra.
  autorewrite with R_db.
  destruct H7; subst.
  - left. lca.
  - right. lca.
Qed.


  

(** https://books.physics.oregonstate.edu/LinAlg/eigenhermitian.html **)
Lemma Hermitian_different_eigenvalue_orthogonal_eigenvector :
  forall {n} (v1 v2 : Vector n) (M : Square n) (c1 c2 : C),
    WF_Matrix M -> WF_Matrix v1 -> WF_Matrix v2 ->
    M † = M -> c1 <> c2 -> M × v1 = c1 .* v1 -> M × v2 = c2 .* v2 ->
    inner_product v1 v2 = 0.
Proof. intros n v1 v2 M c1 c2 H0 H1 H2 H3 H4 H5 H6. 
  assert (v1† × M × v2 = c2 .* (v1† × v2))
    by (rewrite Mmult_assoc, H6; distribute_scale; reflexivity).
  assert (v1† × M × v2 = c1^* .* (v1† × v2))
    by (rewrite <- H3, <- Mmult_adjoint, H5; distribute_adjoint; distribute_scale; reflexivity).
  destruct (Mat_eq_dec n 1%nat v1 Zero H1 (WF_Zero n 1%nat)).
  - subst.
    unfold inner_product.
    assert ((@Zero n 1%nat)† × v2 = @Zero 1%nat 1%nat)
      by (rewrite zero_adjoint_eq, Mmult_0_l; reflexivity).
    rewrite H9.
    reflexivity.
  - destruct (Mat_eq_dec n 1%nat v2 Zero H2 (WF_Zero n 1%nat)).
    + subst.
      unfold inner_product.
      assert (v1† × (@Zero n 1%nat) = @Zero 1%nat 1%nat)
        by (rewrite Mmult_0_r; reflexivity).
      rewrite H9.
      reflexivity.
    + rewrite (Hermitian_eigenvalue_is_real M v1 c1 H0 H1 n0 H3 H5) in H8.
      assert (forall (n m : nat) (c1 c2 : C) (M : Matrix n m),
                 WF_Matrix M -> c1 .* M = c2 .* M ->  (c1 - c2) .* M = Zero).
      { intros n2 m c0 c3 M0 H9 H10.
        rewrite Cminus_unfold, Mscale_plus_distr_l, H10.
        lma'. }
      assert (c1 .* ((v1) † × v2) = c2 .* ((v1) † × v2)) by (rewrite <- H7, <- H8; reflexivity).
      assert (WF_Matrix ((v1) † × v2)) by auto with wf_db.
      apply (H9 1%nat 1%nat c1 c2 ((v1) † × v2) H11) in H10.
      assert (@Zero 1%nat 1%nat = (c1 - c2) .* (@Zero 1%nat 1%nat))
        by (rewrite Mscale_0_r; reflexivity).
      rewrite H12 in H10.
      assert (c1 - c2 <> 0).
      { intro. apply Cminus_eq_0 in H13. contradiction. }
      apply Mscale_cancel with (c := c1 - c2) in H10; auto.
      unfold inner_product.
      rewrite H10.
      reflexivity.
Qed.

(** https://www.math.purdue.edu/~eremenko/dvi/spectral.pdf **)
Lemma Unitary_different_eigenvalue_orthogonal_eigenvector :
  forall {n} (v1 v2 : Vector n) (M : Square n) (c1 c2 : C),
    WF_Unitary M -> WF_Matrix v1 -> WF_Matrix v2 ->
    v1 <> Zero -> v2 <> Zero ->
    c1 <> c2 -> M × v1 = c1 .* v1 -> M × v2 = c2 .* v2 ->
    inner_product v1 v2 = 0.
Proof. intros n v1 v2 M c1 c2 H0 H1 H2 H3 H4 H5 H6 H7. 
  assert (v1† × v2 = c1^* * c2 .* (v1† × v2)).
  { unfold WF_Unitary in H0.
    destruct H0 as [WFM UM].
    setoid_rewrite <- Mmult_1_l at 4; auto.
    rewrite <- UM.
    replace ((v1) † × ((M) † × M × v2)) with ((v1† × M†) × (M × v2))
      by (rewrite ! Mmult_assoc; reflexivity).
    rewrite <- Mmult_adjoint.
    rewrite H6, H7.
    distribute_adjoint.
    distribute_scale.
    reflexivity. }
  assert (c1 <> 0).
  { destruct (Classical_Prop.classic (c1 = 0)); auto.
    rewrite H9, Mscale_0_l in H6.
    unfold WF_Unitary in H0.
    destruct H0 as [WFM UM].
    apply @Mmult_inj_l with (i := n) (m := M†) in H6.
    rewrite <- Mmult_assoc, UM, Mmult_1_l, Mmult_0_r in H6; auto. }
  assert (c2 <> 0).
  { destruct (Classical_Prop.classic (c2 = 0)); auto.
    rewrite H10, Mscale_0_l in H7.
    unfold WF_Unitary in H0.
    destruct H0 as [WFM UM].
    apply @Mmult_inj_l with (i := n) (m := M†) in H7.
    rewrite <- Mmult_assoc, UM, Mmult_1_l, Mmult_0_r in H7; auto. }
  assert (c1^* = /c1).
  { pose (Unitary_eigenvalue_is_unimodular M v1 c1 H0 H1 H3 H6).
    setoid_rewrite <- Cmult_1_l at 3.
    rewrite <- e.
    rewrite <- Cmult_assoc, Cinv_r, Cmult_1_r; auto. }
  rewrite H11 in H8.
  assert (/ c1 * c2 <> C1).
  { destruct (Classical_Prop.classic (/ c1 * c2 = C1)); auto.
    apply Cmult_l with (c := c1) in H12.
    rewrite Cmult_assoc, Cinv_r, Cmult_1_l, Cmult_1_r in H12; auto. }
  assert (forall (i j : nat) (A B : Matrix i j), WF_Matrix A -> A = B -> A .+ (- C1)%C .* B = Zero).
  { intros i0 j A B H13 H14. rewrite <- H14. lma'. }
  assert (WF_Matrix ((v1) † × v2)); auto with wf_db.
  pose (H13 1%nat 1%nat ((v1) † × v2) (/ c1 * c2 .* ((v1) † × v2)) H14 H8).
  rewrite Mscale_assoc in e.
  setoid_rewrite <- Mscale_1_l in e at 2.
  rewrite <- Mscale_plus_distr_l in e.
  replace (@Zero 1%nat 1%nat) with ((C1 + - C1 * (/ c1 * c2)) .* (@Zero 1%nat 1%nat)) in e
      by lma'.
  assert ((C1 + - C1 * (/ c1 * c2)) <> C0).
  { destruct (Classical_Prop.classic (C1 + - C1 * (/ c1 * c2) = 0)); auto.
    rewrite <- Copp_mult_distr_l, <- Cminus_unfold, Cmult_1_l in H15.
    apply Cminus_eq_0 in H15. auto. }
  apply Mscale_cancel in e; auto.
  unfold inner_product.
  rewrite e.
  reflexivity.
Qed.


(*
For both P and Q, the only eigenvalues are +1 and -1, and the dimension of +1-eigenstates equals that of the -1-eigenstates.

Let { v1, v2, ..., vn, w1, w2, ..., wn } be the eigenvectors of P where the vi's are the +1 eigenvectors and the wi's are the -1 eigenvectors.
Since there is a spectral decomposition for P, we can take { v1, v2, ..., vn, w1, w2, ..., wn } as an orthonormal basis that spans the whole space.

Consider { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn }.
Since unitary matrices preserve innerproducts, { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } also forms an orthonormal basis.
(Let X=[v1 v2 ... vn w1 w2 ... wn]. Then UX is unitary.)

By the assertion {P} U {Q}, given any linear combination v = a1 v1 + ... + an vn, we have QUv = Uv.
Hence { U v1, U v2, ..., U vn } forms a basis for the +1 eigenspace of Q.
(?????)

Given a w such that Pw = -w we want to show that QUw = -Uw.
Since eigenvectors corresponding to distinct eigenvalues are orthogonal, the -1 eigenspace of Q is orthogonal to the +1 eigenspace of Q.
Since { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } forms an orthonormal basis, the -1 eigenspace of Q must be spanned by { U w1, U w2, ..., U wn }.

(1. { U v1, U v2, ..., U vn } forms a basis for the +1 eigenspace of Q.
 2. eigenvectors corresponding to distinct eigenvalues are orthogonal
 --> the -1 eigenspace of Q is orthogonal to the +1 eigenspace of Q.
 3. { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } forms an orthonormal basis
       (there are only 2 eigenspaces: +1, -1)
       (there are only 2n dimensions.)
 4. Therefore, the -1 eigenspace of Q must be spanned by { U w1, U w2, ..., U wn }. )


(( Let u be a -1 eigenvector of Q. Then Q u = - u  and 
   u = a1 U v1 + ... + an U vn + b1 U w1 + ... + bn U wn  and
   Qu = - u = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).


(( ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ??????????????????????????
   ?????????????????????????? ))


(* WRONG *)
( Let u be a -1 eigenvector of Q. Then Q u = - u  and 
  u = a1 U v1 + ... + an U vn + b1 U w1 + ... + bn U wn  and
  Qu = - u = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).

  Then 0 = u - u = (b1 U w1 + ... + bn U wn) + Q (b1 U w1 + ... + bn U wn)  so
  Q (b1 U w1 + ... + bn U wn) = - (b1 U w1 + ... + bn U wn).
  Then u = - (a1 U v1 + ... + an U vn) + (b1 U w1 + ... + bn U wn)  and so
  2 u = 2 (b1 U w1 + ... + bn U wn)  which gives
  u = b1 U w1 + ... + bn U wn. )


Since { U w1, U w2, ..., U wn } is orthonormal, they form an orthonormal basis of the -1 eigenspace of Q.

Hence, given any linear combination w = a1 w1 + ... + an wn, we have QUw = - Uw.
 *)

(*
The salient point is that the “additive types” P and Q have the property that their +1 and -1 eigenspaces are precisely dimension n (where the underlying Hilbert space has dimension 2n). Then since U is invertible, the assertion {P} U {Q} implies that U maps the +1-eigenspace of P precisely onto the +1-eigenspace of Q. Now as U is unitary it preserves orthogonality, and so maps the -1-eigenspace of P precisely onto the -1-eigenspace of Q (as the -1-eigenspace is the orthogonal complement of the +1-eigenspace of each operator).
*)

(** *** here for reference
Lemma Unitary_Hermitian_trace_zero_eigenvalues_plus_minus_1 : 
forall {n} (A : Square n),
  WF_Unitary A -> A † = A -> trace A = 0 ->
  (exists U D, WF_Diagonal D /\ WF_Unitary U /\ A = U × D × U† /\ trace D = C0 /\
  (forall x, (x < n)%nat -> Eigenpair A (U × (e_i x), D x x) /\ (D x x = C1 \/ D x x = (Copp C1)))).

A = U × D × U† = ∑ U_i D_ii U_i† 

Lemma Unitary_Hermitian_trace_zero_index_split : forall {n} (A : Square n),
    WF_Unitary A -> A † = A -> trace A = 0 ->
    (exists l1 l2 U D, Permutation (l1 ++ l2) (List.seq 0 n) /\
                    length l1 = length l2 /\ 
                    WF_Diagonal D /\ WF_Unitary U /\
                    A = U × D × U† /\ trace D = 0 /\
                    (forall x, In x l1 -> Eigenpair A (U × (e_i x), C1)) /\
                    (forall x, In x l2 -> Eigenpair A (U × (e_i x), Copp C1))).
 *)














































(** subspace of the form { v | P v } **)
Definition subspace {n : nat} (P : Vector n -> Prop) : Prop :=
  (forall (v : Vector n), P v -> WF_Matrix v) /\
    P Zero /\
    (forall (v w : Vector n), P v -> P w -> P (v .+ w)) /\
    (forall (v : Vector n) (c : C), P v -> P (c .* v)).

Lemma WF_subspace : forall {n : nat} {P : Vector n -> Prop} {v : Vector n},
    subspace P -> P v -> WF_Matrix v.
Proof. intros n P v H0 H1. destruct H0 as [WFP [PZero [Psum Pscale]]].
  auto.
Qed.

#[export] Hint Resolve WF_subspace : wf_db.


Lemma matrix_column_choose_original : forall {n m : nat} (A : Matrix n m),
    WF_Matrix A -> matrix_column_choose (List.seq 0 m) A = A.
Proof. intros n m A H0. 
  unfold matrix_column_choose, list_vector_to_matrix.
  unfold WF_Matrix in H0.
  prep_matrix_equality.
  assert (@Zero n 1 = (get_vec m A)).
  { unfold get_vec.
    prep_matrix_equality.
    bdestruct_all; trivial.
    rewrite H0; trivial.
    lia. }
  bdestruct (x <? n)%nat.
  - bdestruct (y <? m)%nat.
    + rewrite H1.
      rewrite map_nth with (d := m).
      rewrite seq_nth; trivial.
    + rewrite nth_overflow.
      * rewrite H0; trivial.
        lia.
      * rewrite map_length.
        rewrite seq_length.
        assumption.
  - bdestruct (y <? m)%nat.
    + rewrite H1.
      rewrite map_nth with (d := m).
      rewrite seq_nth; trivial.
    + rewrite nth_overflow.
      * rewrite H0; trivial.
        lia.
      * rewrite map_length.
        rewrite seq_length.
        assumption.
Qed.

Lemma subspace_closed_under_linear_combinations : forall {n m : nat} {P : Vector n -> Prop} (M : Matrix n m) (a : Vector m), WF_Matrix a -> subspace P -> (forall (i : nat), (i < m)%nat -> P (get_vec i M)) -> P (M × a).
Proof. intros n m P M a H0 H1 H2. 
  induction m.
  - unfold Mmult. simpl.
    unfold subspace in H1.
    destruct H1 as [WFP [PZero [Psum Pscale]]].
    assumption.
  - assert (M × a = (matrix_column_choose (List.seq 0 m) M) × (vector_row_choose (List.seq 0 m) a) .+ (a m 0%nat) .* (get_vec m M)).
      { unfold Mmult.
        unfold Matrix.scale.
        unfold matrix_column_choose, list_vector_to_matrix.
        unfold vector_row_choose.
        unfold get_vec.
        unfold Mplus.
        simpl.
        do 2 (apply functional_extensionality; intros).
        unfold WF_Matrix in *.
        bdestruct (x0 <? 1)%nat.
        - bdestruct_all.
          subst.
          f_equal.
          2 : apply Cmult_comm.
          rewrite seq_length.
          apply big_sum_eq_bounded.
          intros.
          rewrite seq_nth.
          2 : assumption.
          simpl.
          f_equal.
          rewrite nth_indep with (d' := (fun i0 x1 y : nat => if (y =? 0)%nat then M x1 i0 else 0) (s m)).
          2 : rewrite map_length;
          rewrite seq_length;
          assumption.
          rewrite map_nth with (d := s m).
          bdestruct_all.
          rewrite seq_nth; trivial.
        - remember H0 as H0'. clear HeqH0'.
          remember H0 as H0''. clear HeqH0''.
          assert ((m >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H0 m x0 H4).
          rewrite H0. rewrite Cmult_0_r, Cplus_0_r.
          bdestruct_all.
          rewrite Cmult_0_r, Cplus_0_r.
          f_equal.
          2 : symmetry; apply seq_length.
          apply functional_extensionality; intros.
          assert ((x1 >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H0' x1 x0 H6).
          rewrite H0'.
          rewrite Cmult_0_r.
          assert ((nth x1 (List.seq 0 m) (s m) >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H0'' (nth x1 (List.seq 0 m) (s m)) x0 H7).
          rewrite H0''.
          rewrite Cmult_0_r.
          reflexivity. }
      rewrite H3.
      remember H1 as H1'.
      clear HeqH1'.
      unfold subspace in H1.
      destruct H1 as [WFP [PZero [Psum Pscale]]].
      apply Psum.
    + rewrite ! seq_length.
      apply IHm. 
      * pose (WF_Matrix_vector_row_choose_indices_list (List.seq 0 m) a).
        rewrite ! seq_length in w; auto.
      * intros i0 H1.
        assert (get_vec i0 (matrix_column_choose (List.seq 0 m) M) = get_vec i0 M).
           { unfold matrix_column_choose, list_vector_to_matrix.
             unfold get_vec.
             do 2 (apply functional_extensionality; intros).
             bdestruct_all; trivial.
             subst.
             rewrite nth_indep with (d' := (fun i1 x0 y : nat => if (y =? 0)%nat then M x0 i1 else 0) (s m)).
             2 : rewrite map_length;
             rewrite seq_length;
             assumption.
             rewrite map_nth with (d := s m).
             bdestruct_all.
             rewrite seq_nth; trivial. }
           setoid_rewrite H4.
           auto.
    + apply Pscale.
      auto.
Qed.

(* old version of the lemma

Lemma subspace_closed_under_linear_combinations' : forall (n m : nat) (M : Matrix n m) (a : Vector m) (P : Vector n -> Prop), WF_Matrix M -> WF_Matrix a -> subspace P -> (forall (i : nat), P (get_vec i M)) -> P (M × a).
Proof. intros n m M a P H0 H1 H2 H3.
  induction m.
  - unfold Mmult. simpl.
    unfold subspace in H2.
    destruct H2.
    specialize (H3 0%nat).
    unfold get_vec in H3.
    assert (@Zero n 0 = fun x y : nat => if (y =? 0)%nat then M x 0%nat else 0).
    { do 2 (apply functional_extensionality; intros).
      bdestruct_all; trivial.
      unfold WF_Matrix in H0.
      assert ((x >= n)%nat \/ (0 >= 0)%nat). { right. lia. }
      specialize (H0 x 0%nat H6).
      rewrite H0.
      trivial. }
    rewrite <- H5 in H3.
    apply H3.
  - assert (M × a = (matrix_column_choose (List.seq 0 m) M) × (vector_row_choose (List.seq 0 m) a) .+ (a m 0%nat) .* (get_vec m M)).
      { unfold Mmult.
        unfold Matrix.scale.
        unfold matrix_column_choose, list_vector_to_matrix.
        unfold vector_row_choose.
        unfold get_vec.
        unfold Mplus.
        simpl.
        do 2 (apply functional_extensionality; intros).
        unfold WF_Matrix in H1.
        bdestruct (x0 <? 1)%nat.
        - bdestruct_all.
          subst.
          f_equal.
          2 : apply Cmult_comm.
          rewrite seq_length.
          apply big_sum_eq_bounded.
          intros.
          rewrite seq_nth.
          2 : assumption.
          simpl.
          f_equal.
          assert (@Zero n 1 = (fun i0 x1 y : nat => if (y =? 0)%nat then M x1 i0 else 0) (s m)).
          { do 2 (apply functional_extensionality; intros).
            bdestruct_all; trivial.
            unfold WF_Matrix in H0.
            assert ((x1 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
            specialize (H0 x1 (s m) H7).
            rewrite H0.
            trivial. }
          rewrite H6.
          rewrite map_nth with (d := s m).
          bdestruct_all.
          rewrite seq_nth; trivial.
        - remember H1 as H1'. clear HeqH1'.
          remember H1 as H1''. clear HeqH1''.
          assert ((m >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1 m x0 H5).
          rewrite H1. rewrite Cmult_0_r, Cplus_0_r.
          bdestruct_all.
          rewrite Cmult_0_r, Cplus_0_r.
          f_equal.
          2 : symmetry; apply seq_length.
          apply functional_extensionality; intros.
          assert ((x1 >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1' x1 x0 H7).
          rewrite H1'.
          rewrite Cmult_0_r.
          assert ((nth x1 (List.seq 0 m) (s m) >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1'' (nth x1 (List.seq 0 m) (s m)) x0 H8).
          rewrite H1''.
          rewrite Cmult_0_r.
          reflexivity. }
      rewrite H4.
      remember H2 as H2'.
      clear HeqH2'.
      unfold subspace in H2.
      destruct H2.
      specialize (H5
                    (matrix_column_choose (List.seq 0 m) M × vector_row_choose (List.seq 0 m) a)
                    (get_vec m M)
                    (C1)
                    (a m 0%nat)).
      rewrite Mscale_1_l in H5.
      apply H5.
      2 : specialize (H3 m); assumption.
      specialize (IHm
                    (matrix_column_choose (List.seq 0 m) M)
                    (vector_row_choose (List.seq 0 m) a)).
      rewrite seq_length.
      apply IHm.
      * pose (WF_Matrix_matrix_column_choose_indices_list (List.seq 0 m) M).
        rewrite seq_length in w.
        apply w; trivial.
      * pose (WF_Matrix_vector_row_choose_indices_list (List.seq 0 m) a).
        rewrite seq_length in w.
        apply w; trivial.
      * intros.
        specialize (H3 i0).
        bdestruct (i0 <? m).
        -- assert (get_vec i0 (matrix_column_choose (List.seq 0 m) M) = get_vec i0 M).
           { unfold matrix_column_choose, list_vector_to_matrix.
             unfold get_vec.
             do 2 (apply functional_extensionality; intros).
             bdestruct_all; trivial.
             subst.
             assert (@Zero n 1 = (fun i1 x0 y : nat => if (y =? 0)%nat then M x0 i1 else 0) (s m)).
             { do 2 (apply functional_extensionality; intros).
               bdestruct_all; trivial.
               unfold WF_Matrix in H0.
               assert ((x0 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
               specialize (H0 x0 (s m) H8).
               rewrite H0.
               trivial. }
             rewrite H7.
             rewrite map_nth with (d := s m).
             bdestruct_all.
             rewrite seq_nth; trivial. }
           rewrite seq_length in H7.
           rewrite H7.
           apply H3.
        -- assert (WF_Matrix (matrix_column_choose (List.seq 0 m) M)).
           { pose (WF_Matrix_matrix_column_choose_indices_list (List.seq 0 m) M).
             apply w; trivial. }
           unfold WF_Matrix in H7.
           rewrite seq_length in H7.
           assert (Zero = get_vec i0 (matrix_column_choose (List.seq 0 m) M)).
           { do 2 (apply functional_extensionality; intros).
             unfold matrix_column_choose, list_vector_to_matrix.
             unfold get_vec.
             bdestruct_all; trivial.
             subst.
             assert (@Zero n 1 = (fun i1 x0 y : nat => if (y =? 0)%nat then M x0 i1 else 0) (s m)).
             { do 2 (apply functional_extensionality; intros).
               bdestruct_all; trivial.
               unfold WF_Matrix in H0.
               assert ((x0 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
               specialize (H0 x0 (s m) H9).
               rewrite H0.
               reflexivity. }
             rewrite H8 at 1.
             rewrite map_nth with (d := s m).
             bdestruct_all.
             unfold WF_Matrix in H0.
             assert ((x >= n)%nat \/ ((nth i0 (List.seq 0 m) (s m)) >= s m)%nat).
             { right. rewrite nth_overflow. lia. rewrite seq_length. lia. }
             specialize (H0 x (nth i0 (List.seq 0 m) (s m)) H10).
             rewrite H0.
             trivial. }
           rewrite seq_length in H8.
           rewrite <- H8.
           unfold subspace in H2'.
           destruct H2'.
           specialize (H10 (get_vec i0 M) (get_vec i0 M) C0 C0 H3 H3).
           rewrite ! Mscale_0_l, Mplus_0_r in H10.
           assumption.
Qed.
 *)




(** old version 

(** subspace of the form { v | P v } **)

Inductive subspace {n : nat} (P : Vector n -> Prop) : Prop :=
| subspace_def :
    (forall (v w : Vector n) (a b : C), P v -> P w -> P ((a .* v) .+ (b .* w)))
    -> subspace P.


Lemma subspace_closed_under_linear_combinations : forall (n m : nat) (M : Matrix n m) (a : Vector m) (P : Vector n -> Prop), WF_Matrix M -> WF_Matrix a -> subspace P -> (forall (i : nat), P (get_vec i M)) -> P (M × a).
Proof. intros n m M a P H0 H1 H2 H3.
  induction m.
  - unfold Mmult. simpl.
    inversion H2.
    specialize (H3 0%nat).
    unfold get_vec in H3.
    assert (@Zero n 0 = fun x y : nat => if (y =? 0)%nat then M x 0%nat else 0).
    { do 2 (apply functional_extensionality; intros).
      bdestruct_all; trivial.
      unfold WF_Matrix in H0.
      assert ((x >= n)%nat \/ (0 >= 0)%nat). { right. lia. }
      specialize (H0 x 0%nat H6).
      rewrite H0.
      trivial. }
    rewrite <- H5 in H3.
    apply H3.
  - assert (M × a = (matrix_column_choose (List.seq 0 m) M) × (vector_row_choose (List.seq 0 m) a) .+ (a m 0%nat) .* (get_vec m M)).
      { unfold Mmult.
        unfold Matrix.scale.
        unfold matrix_column_choose, list_vector_to_matrix.
        unfold vector_row_choose.
        unfold get_vec.
        unfold Mplus.
        simpl.
        do 2 (apply functional_extensionality; intros).
        unfold WF_Matrix in H1.
        bdestruct (x0 <? 1)%nat.
        - bdestruct_all.
          subst.
          f_equal.
          2 : apply Cmult_comm.
          rewrite seq_length.
          apply big_sum_eq_bounded.
          intros.
          rewrite seq_nth.
          2 : assumption.
          simpl.
          f_equal.
          assert (@Zero n 1 = (fun i0 x1 y : nat => if (y =? 0)%nat then M x1 i0 else 0) (s m)).
          { do 2 (apply functional_extensionality; intros).
            bdestruct_all; trivial.
            unfold WF_Matrix in H0.
            assert ((x1 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
            specialize (H0 x1 (s m) H7).
            rewrite H0.
            trivial. }
          rewrite H6.
          rewrite map_nth with (d := s m).
          bdestruct_all.
          rewrite seq_nth; trivial.
        - remember H1 as H1'. clear HeqH1'.
          remember H1 as H1''. clear HeqH1''.
          assert ((m >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1 m x0 H5).
          rewrite H1. rewrite Cmult_0_r, Cplus_0_r.
          bdestruct_all.
          rewrite Cmult_0_r, Cplus_0_r.
          f_equal.
          2 : symmetry; apply seq_length.
          apply functional_extensionality; intros.
          assert ((x1 >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1' x1 x0 H7).
          rewrite H1'.
          rewrite Cmult_0_r.
          assert ((nth x1 (List.seq 0 m) (s m) >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1'' (nth x1 (List.seq 0 m) (s m)) x0 H8).
          rewrite H1''.
          rewrite Cmult_0_r.
          reflexivity. }
      rewrite H4.
      inversion H2.
      specialize (H5
                    (matrix_column_choose (List.seq 0 m) M × vector_row_choose (List.seq 0 m) a)
                    (get_vec m M)
                    (C1)
                    (a m 0%nat)).
      rewrite Mscale_1_l in H5.
      apply H5.
      2 : specialize (H3 m); assumption.
      specialize (IHm
                    (matrix_column_choose (List.seq 0 m) M)
                    (vector_row_choose (List.seq 0 m) a)).
      rewrite seq_length.
      apply IHm.
      * pose (WF_Matrix_matrix_column_choose_indices_list (List.seq 0 m) M).
        rewrite seq_length in w.
        apply w; trivial.
      * pose (WF_Matrix_vector_row_choose_indices_list (List.seq 0 m) a).
        rewrite seq_length in w.
        apply w; trivial.
      * intros.
        specialize (H3 i0).
        bdestruct (i0 <? m).
        -- assert (get_vec i0 (matrix_column_choose (List.seq 0 m) M) = get_vec i0 M).
           { unfold matrix_column_choose, list_vector_to_matrix.
             unfold get_vec.
             do 2 (apply functional_extensionality; intros).
             bdestruct_all; trivial.
             subst.
             assert (@Zero n 1 = (fun i1 x0 y : nat => if (y =? 0)%nat then M x0 i1 else 0) (s m)).
             { do 2 (apply functional_extensionality; intros).
               bdestruct_all; trivial.
               unfold WF_Matrix in H0.
               assert ((x0 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
               specialize (H0 x0 (s m) H8).
               rewrite H0.
               trivial. }
             rewrite H7.
             rewrite map_nth with (d := s m).
             bdestruct_all.
             rewrite seq_nth; trivial. }
           rewrite seq_length in H7.
           rewrite H7.
           apply H3.
        -- assert (WF_Matrix (matrix_column_choose (List.seq 0 m) M)).
           { pose (WF_Matrix_matrix_column_choose_indices_list (List.seq 0 m) M).
             apply w; trivial. }
           unfold WF_Matrix in H7.
           rewrite seq_length in H7.
           assert (Zero = get_vec i0 (matrix_column_choose (List.seq 0 m) M)).
           { do 2 (apply functional_extensionality; intros).
             unfold matrix_column_choose, list_vector_to_matrix.
             unfold get_vec.
             bdestruct_all; trivial.
             subst.
             assert (@Zero n 1 = (fun i1 x0 y : nat => if (y =? 0)%nat then M x0 i1 else 0) (s m)).
             { do 2 (apply functional_extensionality; intros).
               bdestruct_all; trivial.
               unfold WF_Matrix in H0.
               assert ((x0 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
               specialize (H0 x0 (s m) H9).
               rewrite H0.
               reflexivity. }
             rewrite H8 at 1.
             rewrite map_nth with (d := s m).
             bdestruct_all.
             unfold WF_Matrix in H0.
             assert ((x >= n)%nat \/ ((nth i0 (List.seq 0 m) (s m)) >= s m)%nat).
             { right. rewrite nth_overflow. lia. rewrite seq_length. lia. }
             specialize (H0 x (nth i0 (List.seq 0 m) (s m)) H10).
             rewrite H0.
             trivial. }
           rewrite seq_length in H8.
           rewrite <- H8.
           inversion H2.
           specialize (H9 (get_vec i0 M) (get_vec i0 M) C0 C0 H3 H3).
           rewrite ! Mscale_0_l, Mplus_0_r in H9.
           assumption.
Qed.
**)




(** old version 

(** subspace of the form { v | P v } **)

Inductive subspace' (n : nat) (P : Vector n -> Prop) : Vector n -> Prop :=
| subspace'_def : forall (u : Vector n),
    (forall (v w : Vector n) (a b : C), P v -> P w -> P ((a .* v) .+ (b .* w)))
    -> P (@Zero n 1)
    -> P u
    -> subspace' n P u.


Lemma subspace'_closed_under_linear_combinations : forall (n m : nat) (M : Matrix n m) (a : Vector m) (P : Vector n -> Prop), WF_Matrix M -> WF_Matrix a -> (forall (i : nat), subspace' n P (get_vec i M)) -> subspace' n P (M × a).
Proof. intros n m M a P H0 H1 H2. 
  constructor.
  - intros.
    specialize (H2 0%nat).
    inversion H2.
    specialize (H5 v w a0 b H3 H4).
    assumption.
  - intros.
    specialize (H2 0%nat).
    inversion H2.
    assumption.
  - induction m.
    + simpl.
      specialize (H2 0%nat).
      inversion H2.
      apply H4.
    + assert (M × a = (matrix_column_choose (List.seq 0 m) M) × (vector_row_choose (List.seq 0 m) a) .+ (a m 0%nat) .* (get_vec m M)).
      { unfold Mmult.
        unfold Matrix.scale.
        unfold matrix_column_choose, list_vector_to_matrix.
        unfold vector_row_choose.
        unfold get_vec.
        unfold Mplus.
        simpl.
        do 2 (apply functional_extensionality; intros).
        unfold WF_Matrix in H1.
        bdestruct (x0 <? 1)%nat.
        - bdestruct_all.
          rewrite H4.
          f_equal.
          2 : apply Cmult_comm.
          rewrite seq_length.
          apply big_sum_eq_bounded.
          intros.
          rewrite seq_nth.
          2 : assumption.
          simpl.
          f_equal.
          assert (@Zero n 1 = (fun i0 x2 y : nat => if (y =? 0)%nat then M x2 i0 else 0) (s m)).
          { do 2 (apply functional_extensionality; intros).
            bdestruct_all; trivial.
            unfold WF_Matrix in H0.
            assert ((x2 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
            specialize (H0 x2 (s m) H7).
            rewrite H0.
            trivial. }
          rewrite H6.
          rewrite map_nth with (d := s m).
          bdestruct_all.
          rewrite seq_nth; trivial.
        - remember H1 as H1'. clear HeqH1'.
          remember H1 as H1''. clear HeqH1''.
          assert ((m >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1 m x0 H4).
          rewrite H1. rewrite Cmult_0_r, Cplus_0_r.
          bdestruct_all.
          rewrite Cmult_0_r, Cplus_0_r.
          f_equal.
          2 : symmetry; apply seq_length.
          apply functional_extensionality; intros.
          assert ((x1 >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1' x1 x0 H6).
          rewrite H1'.
          rewrite Cmult_0_r.
          assert ((nth x1 (List.seq 0 m) (s m) >= s m)%nat \/ (x0 >= 1)%nat). { right. assumption. }
          specialize (H1'' (nth x1 (List.seq 0 m) (s m)) x0 H7).
          rewrite H1''.
          rewrite Cmult_0_r.
          reflexivity. }
      rewrite H3.
      remember H2 as H2'. clear HeqH2'.
      specialize (H2' 0%nat).
      inversion H2'.
      clear H5 H6 H7.
      specialize (H4
                    (matrix_column_choose (List.seq 0 m) M × vector_row_choose (List.seq 0 m) a)
                    (get_vec m M)
                    (C1)
                    (a m 0%nat)).
      rewrite Mscale_1_l in H4.
      apply H4.
      2 : { specialize (H2 m).
            inversion H2.
            assumption. }
      specialize (IHm
                    (matrix_column_choose (List.seq 0 m) M)
                    (vector_row_choose (List.seq 0 m) a)).
      rewrite seq_length.
      apply IHm.
      * pose (WF_Matrix_matrix_column_choose_indices_list (List.seq 0 m) M).
        rewrite seq_length in w.
        apply w; trivial.
      * pose (WF_Matrix_vector_row_choose_indices_list (List.seq 0 m) a).
        rewrite seq_length in w.
        apply w; trivial.
      * intros.
        specialize (H2 i0).
        inversion H2; subst.
        constructor; trivial.
        bdestruct (i0 <? m).
        -- assert (get_vec i0 (matrix_column_choose (List.seq 0 m) M) = get_vec i0 M).
           { unfold matrix_column_choose, list_vector_to_matrix.
             unfold get_vec.
             do 2 (apply functional_extensionality; intros).
             bdestruct_all; trivial.
             subst.
             assert (@Zero n 1 = (fun i1 x0 y : nat => if (y =? 0)%nat then M x0 i1 else 0) (s m)).
             { do 2 (apply functional_extensionality; intros).
               bdestruct_all; trivial.
               unfold WF_Matrix in H0.
               assert ((x0 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
               specialize (H0 x0 (s m) H10).
               rewrite H0.
               trivial. }
             rewrite H9.
             rewrite map_nth with (d := s m).
             bdestruct_all.
             rewrite seq_nth; trivial. }
           rewrite seq_length in H9.
           rewrite H9.
           apply H7.
        -- assert (WF_Matrix (matrix_column_choose (List.seq 0 m) M)).
           { pose (WF_Matrix_matrix_column_choose_indices_list (List.seq 0 m) M).
             apply w; trivial. }
           unfold WF_Matrix in H9.
           rewrite seq_length in H9.
           assert (Zero = get_vec i0 (matrix_column_choose (List.seq 0 m) M)).
           { do 2 (apply functional_extensionality; intros).
             unfold matrix_column_choose, list_vector_to_matrix.
             unfold get_vec.
             bdestruct_all; trivial.
             subst.
             assert (@Zero n 1 = (fun i1 x0 y : nat => if (y =? 0)%nat then M x0 i1 else 0) (s m)).
             { do 2 (apply functional_extensionality; intros).
               bdestruct_all; trivial.
               unfold WF_Matrix in H0.
               assert ((x0 >= n)%nat \/ (s m >= s m)%nat). { right. lia. }
               specialize (H0 x0 (s m) H11).
               rewrite H0.
               reflexivity. }
             rewrite H10 at 1.
             rewrite map_nth with (d := s m).
             bdestruct_all.
             unfold WF_Matrix in H0.
             assert ((x >= n)%nat \/ ((nth i0 (List.seq 0 m) (s m)) >= s m)%nat).
             { right. rewrite nth_overflow. lia. rewrite seq_length. lia. }
             specialize (H0 x (nth i0 (List.seq 0 m) (s m)) H12).
             rewrite H0.
             trivial. }
           rewrite seq_length in H10.
           rewrite <- H10.
           assumption.
Qed.
**)




Definition span {n m : nat} (M : Matrix n m) (u : Vector n) : Prop := (exists (a : Vector m), WF_Matrix a /\ u = M × a).

(** old definition by inductive type
Inductive span {n m : nat} (M : Matrix n m) : Vector n -> Prop :=
| span_def : forall (u : Vector n), (exists (a : Vector m), u = M × a) -> span M u.
**)

Lemma span_is_subspace : forall (n m : nat) (M : Matrix n m),
    WF_Matrix M -> subspace (span M).
Proof. intros n m M H0. 
  repeat constructor.
  - intros v H1.
    unfold span in H1.
    destruct H1 as [a [WFa vMa]].
    rewrite vMa.
    auto with wf_db.
  - exists Zero.
    split; auto with wf_db.
    rewrite Mmult_0_r.
    reflexivity.
  - intros v w H1 H2.
    unfold span in *.
    destruct H1 as [a [WFa vMa]].
    destruct H2 as [b [WFb wMb]].
    exists (a .+ b).
    split; auto with wf_db.
    subst.
    rewrite Mmult_plus_distr_l.
    reflexivity.
  - intros v c H1. 
    unfold span in *.
    destruct H1 as [a [WFa vMa]].
    exists (c .* a).
    split; auto with wf_db.
    subst.
    distribute_scale.
    reflexivity.
Qed.


(* Lemma 19 Suppose V is a vector space, u1,u2,...,un are vectors in V, and v ∈ sp{u1,u2,...,un}. Then
sp{u1,u2,...,un,v} = sp{u1,u2,...,un}. *)
Lemma equal_span_col_append : forall {n m : nat} (M : Matrix n m) (v u : Vector n),
    span M u -> span (col_append M v) u.
Proof. intros n m M v u H0.
  unfold span in *.
  destruct H0 as [a [H0 H1]].
  exists (fun (r c : nat) => if r <? m then a r c else C0).
  split.
  - unfold WF_Matrix.
    intros x y H2. 
    unfold WF_Matrix in H0.
    rewrite H0.
    bdestruct_all; reflexivity.
    lia.
  - rewrite H1.
    unfold col_append, col_wedge.
    unfold Mmult.
    prep_matrix_equality.
    simpl.
    bdestruct_all.
    rewrite Cmult_0_r, Cplus_0_r.
    apply big_sum_eq_bounded.
    intros.
    bdestruct_all.
    reflexivity.
Qed.

(* Lemma 19 Suppose V is a vector space, u1,u2,...,un are vectors in V, and v ∈ sp{u1,u2,...,un}. Then
sp{u1,u2,...,un,v} = sp{u1,u2,...,un}. *)
Lemma equal_span_col_append_inv : forall {n m : nat} (M : Matrix n m) (v : Vector n), span M v -> (forall (u : Vector n), span (col_append M v) u -> span M u).
Proof. intros n m M v H0 u H1.
  unfold span in *.
  do 2 destruct H0.
  do 2 destruct H1.
  rewrite H2 in H3.
  rewrite H3.
  unfold Mmult in H3.
  (** Σ_{i = 0}^{i = m-1} M_i x0_i + x0_m * Σ_{i = 0}^{i = m-1} M_i x_i 
           = Σ_{i = 0}^{i = m-1} M_i (x0_i + x0_m * x_i) **)
  (** (fun (r c : nat) => (big_sum (fun (i : nat) => M r i  * ((x0 i c) + (x0 m c) * (x i c))) m)). **)
  exists (fun (r c : nat) => if (r <? m) then ((x0 r c) + (x0 m c) * (x r 0%nat)) else C0).
  split.
  - unfold WF_Matrix.
    intros x1 y H4.
    destruct H4; bdestruct_all; trivial.
    remember H1 as H1'. clear HeqH1'.
    unfold WF_Matrix in H1, H1'.
    assert ((x1 >= s m)%nat \/ (y >= 1)%nat). { right. lia. }
    specialize (H1 x1 y H6).
    rewrite H1.
    assert ((m >= s m)%nat \/ (y >= 1)%nat). { right. lia. }
    specialize (H1' m y H7).
    rewrite H1'.
    lca.
  - unfold col_append, col_wedge.
    unfold Mmult.
    do 2 (apply functional_extensionality; intros).
    simpl.
    bdestruct_all. clear H5.
    assert ( Σ (fun y : nat => M x1 y * (if y <? m then x0 y x2 + x0 m x2 * x y 0%nat else 0)) m
             =  Σ (fun y : nat => M x1 y * (x0 y x2 + x0 m x2 * x y 0%nat)) m).
    { apply big_sum_eq_bounded.
      intros x3 H5.
      bdestruct_all.
      reflexivity. }
    rewrite H5.
    replace (fun y : nat => M x1 y * (x0 y x2 + x0 m x2 * x y 0%nat))
      with (fun y : nat => M x1 y * x0 y x2 + (M x1 y * x y 0%nat)* x0 m x2)
      by (apply functional_extensionality; intros; lca).
    assert (Σ (fun y : nat => M x1 y * x0 y x2 + M x1 y * x y 0%nat * x0 m x2) m
            = Σ (fun y : nat => M x1 y * x0 y x2) m + Σ (fun y : nat => M x1 y * x y 0%nat) m  * x0 m x2).
    { setoid_rewrite big_sum_plus.
      simpl.
      f_equal.
      rewrite @big_sum_mult_r with (R := C) (H := C_is_monoid) (H0 := C_is_group) (H1 := C_is_comm_group) (H2 := C_is_ring).
      simpl.
      reflexivity. }
    rewrite H6.
    f_equal.
    apply big_sum_eq_bounded.
    intros.
    bdestruct_all.
    reflexivity.
Qed.

(* Lemma 19 Suppose V is a vector space, u1,u2,...,un are vectors in V, and v ∈ sp{u1,u2,...,un}. Then
sp{u1,u2,...,un,v} = sp{u1,u2,...,un}. *)
(*** May not be needed *)
Lemma equal_span_reduce_col_inv : forall {n m : nat} (M : Matrix n (s m)) (i : nat),
    (i < s m)%nat -> (forall (u : Vector n), span (reduce_col M i) u -> span M u).
Proof. intros n m M i H u H0.
  unfold span in *.
  destruct H0 as [a [H0 H0']].
  exists (fun r c => if (r <? i)%nat then (a r c) else if (r =? i)%nat then C0 else (a (r-1)%nat c)).
  split.
  - unfold WF_Matrix in *.
    intros.
    rewrite ! H0;
      bdestruct_all; trivial;
      lia.
  - rewrite H0'.
    unfold reduce_col.
    prep_matrix_equality.
    unfold Mmult.

    replace m with (i + (m - i))%nat at 1 by lia.
    rewrite @big_sum_sum with (H := C_is_monoid) (m := i) (n := (m - i)%nat).
    replace (s m) with (i + ((s m) - i))%nat at 1 by lia.
    rewrite @big_sum_sum with (H := C_is_monoid) (m := i) (n := ((s m) - i)%nat).
    f_equal.
    + apply big_sum_eq_bounded.
      intros.
      bdestruct_all.
      reflexivity.
    + replace ((s m) - i)%nat with (s (m - i))%nat by lia.
      rewrite <- big_sum_extend_l.
      bdestruct_all.
      rewrite Cmult_0_r, Cplus_0_l.
      apply big_sum_eq_bounded.
      intros.
      bdestruct_all.
      replace (1 + (i + x0))%nat with (i + s x0)%nat by lia.
      replace (i + s x0 - 1)%nat with (i + x0)%nat by lia.
      reflexivity.
Qed.
    
  
(* Lemma 19 Suppose V is a vector space, u1,u2,...,un are vectors in V, and v ∈ sp{u1,u2,...,un}. Then
sp{u1,u2,...,un,v} = sp{u1,u2,...,un}. *)

Lemma equal_span_reduce_col : forall {n m : nat} (M : Matrix n (s m)) (i : nat),
    (i < s m)%nat -> span (reduce_col M i) (get_vec i M) ->
    (forall (u : Vector n), span M u -> span (reduce_col M i) u).
Proof. intros n m M i H H0 u H1.
  unfold span in *.
  destruct H0 as [a [H0 H0']].
  destruct H1 as [b [H1 H1']].
  (* get_vec i M = reduce_col M i × a
     =>  M_i = (Σ_{k=0}^{k=i-1} M_k a_k) + (Σ_{k=i+1}^{k=m} M_k a_{k-1})
     
        u = M × b = Σ_{k=0}^{k=m} M_k b_k
        = (Σ_{k=0}^{k=i-1} M_k b_k) + M_i b_i + (Σ_{k=i+1}^{k=m} M_k b_k)
        = (Σ_{k=0}^{k=i-1} M_k b_k) 
        + ((Σ_{k=0}^{k=i-1} M_k a_k) + (Σ_{k=i+1}^{k=m} M_k a_{k-1})) b_i 
        + (Σ_{k=i+1}^{k=m} M_k b_k)
        = (Σ_{k=0}^{k=i-1} M_k (b_i a_k + b_k)) + (Σ_{k=i+1}^{k=m} M_k (b_i a_{k-1} + b_k))
        
        u = reduce_col M i × c = (Σ_{k=0}^{k=i-1} M_k c_k) + (Σ_{k=i+1}^{k=m} M_k c_{k-1})
        c = ((b i 0%nat) .* a) .+ (reduce_row i b) *)
  exists (((b i 0%nat) .* a) .+ (reduce_row b i)).
  split.
  - auto with wf_db.
  - rewrite H1'.
    rewrite Mmult_plus_distr_l.
    distribute_scale.
    rewrite <- H0'.
    unfold get_vec, reduce_row, reduce_col.
    unfold Mmult, Matrix.scale, Mplus.
    prep_matrix_equality.
    bdestruct_all.
    + subst.
      replace (s m) with (i + (s (m - i)))%nat by lia.
      rewrite @big_sum_sum with (H := C_is_monoid) (m := i) (n := (s (m - i))%nat).
      rewrite <- big_sum_extend_l.
      simpl.
      setoid_rewrite Cplus_comm at 1.
      rewrite <- ! Cplus_assoc.
      f_equal.
      * replace (i + 0)%nat with i by lia.
        lca.
      * rewrite Cplus_comm at 1.
        replace m with (i + (m - i))%nat at 2 by lia.
        rewrite @big_sum_sum with (H := C_is_monoid) (m := i) (n := (m - i)%nat).
        simpl.
        f_equal.
        -- apply big_sum_eq_bounded.
           intros.
           bdestruct_all.
           lca.
        -- apply big_sum_eq_bounded.
           intros.
           bdestruct_all.
           replace (i + s x0)%nat with (s (i + x0)) by lia.
           reflexivity.
    + assert ((fun y0 : nat => M x y0 * b y0 y)
              =
                (fun _ : nat => C0)).
      { apply functional_extensionality; intros.
        unfold WF_Matrix in H1.
        rewrite H1; try lca; lia. }
      rewrite H3.
      simpl.
      rewrite Cmult_0_r, Cplus_0_l, Cplus_0_r.
      apply big_sum_eq_bounded.
      intros.
      unfold WF_Matrix in H1.
      rewrite ! H1.
      bdestruct_all; lca.
      all : lia.
Qed.      

  

Lemma last_in_list : forall {A : Type} (d : A) (l : list A),
    l <> [] -> In (last l d) l.
Proof. intros A d l H0.
  apply app_removelast_last with (d := d) in H0.
  rewrite <- nth_middle with (a := (last l d)) (d := d) (l := removelast l) (l' := []).
  rewrite <- H0.
  apply nth_In.
  rewrite H0.
  rewrite removelast_last.
  rewrite app_length.
  simpl.
  lia.
Qed.

(*** Admitted. : Not used ***)
(* 
Lemma big_sum_permutation_function : forall (m : nat) (f g : nat -> C) (l : list nat),
    Permutation l (List.seq 0 m) -> map f l = map g (List.seq 0 m) -> Σ f m = Σ g m.
Proof. intros m f g l H0 H1.
  gen H1.
  dependent induction H0.
  - intros.
    simpl in *.
    destruct m.
    + reflexivity.
    + discriminate.
  - intros.
    
  (*
  gen l.
  induction m.
  - reflexivity.
  - intros l H0 H1.
    inversion H1.
    destruct (list_eq_dec Nat.eq_dec l []) as [H2 | H2].
    + subst.
      apply Permutation_length in H0.
      simpl in *.
      discriminate.
    + remember H2 as H2'. clear HeqH2'.
      apply app_removelast_last with (d := 0%nat) in H2'.
      rewrite <- Nat.add_1_r in H1.
      rewrite (seq_app m 1%nat 0%nat) in H1.
      simpl in H1.
      rewrite map_last in H1.
      rewrite H2' in H1.
      rewrite map_last in H1.
      rewrite app_inj_tail_iff in H1.
      destruct H1.
      apply last_in_list with (d := 0%nat) in H2.
      apply Permutation_in with (l' := (List.seq 0 (s m))) in H2; try assumption.
      rewrite in_seq in H2.
      assert (Add (last l 0%nat) (removelast l) l).
      { setoid_rewrite <- app_nil_r at 2.
        rewrite H2' at 3.
        apply Add_app. }
      assert ((List.seq 0 (s m)) = (firstn (last l 0%nat) (List.seq 0 (s m)) ++ [nth (last l 0%nat) (List.seq 0 (s m)) 0%nat] ++ skipn (s (last l 0%nat)) (List.seq 0 (s m)))).
      { apply nth_inc.
        rewrite seq_length.
        lia. }
      assert (Add (last l 0%nat) (firstn (last l 0%nat) (List.seq 0 (s m)) ++ skipn (s (last l 0%nat)) (List.seq 0 (s m))) (List.seq 0 (s m))).
      { rewrite seq_nth in H6; try lia.
        replace (0 + last l 0)%nat with (last l 0)%nat in H6 by lia.
        rewrite H6 at 3.
        apply Add_app. }
      apply Permutation_Add_inv with (a := (last l 0%nat)) (l1 := l) (l1' := removelast l) in H7; try assumption.
*)

(* Permutation_nth
FinFun.bInjective_bSurjective

      specialize (IHm (removelast l) H7 H1).


      
      assert (Add m (List.seq 0 m) (List.seq 0 (s m))).
      { rewrite <- Nat.add_1_r.
        rewrite (seq_app m 1%nat 0%nat).
        simpl.
        setoid_rewrite <- app_nil_r at 1.
        apply Add_app. }
seq_nth
  nth_inc

    (last l 0%nat) < (s m)

    seq_nth :
forall [len : nat] (start : nat) [n : nat] (d : nat),
  (n < len)%nat -> nth n (List.seq start len) d = (start + n)%nat
                            nth (last l 0%nat) (List.seq 0%nat (s m)) d = (0 + (last l 0%nat))%nat
n := (last l 0%nat)
ls := (List.seq 0%nat (s m))

    nth_inc :
forall {X : Type} (n : nat) (ls : list X) (x : X),
  (n < length ls)%nat -> ls = firstn n ls ++ [nth n ls x] ++ skipn (s n) ls

                                  
      
Search firstn.
      in_seq
        
        nth_in_or_default
          
          list_seq_decompose
      Permutation
      apply Permutation_Add_inv with  *)
  Admitted.

(*** Admitted. : Not used ***)
Lemma big_sum_permutation_function' : forall (m : nat) (f g : nat -> C),
    (exists l, Permutation l (List.seq 0 m) /\ map f l = map g (List.seq 0 m))
    -> Σ f m = Σ g m.
Proof. intros m f g H0.
  destruct H0 as [l [H0 H1]].
  gen l.
  apply big_sum_permutation_function.
Qed.
*)


(*** Admitted. : Not used ***)
(*
Lemma map_ext_nth : forall {A : Type} (d : A) (l1 l2 : list A) (f g : A -> C),
    map f l1 = map g l2 <->
      (length l1 = length l2 /\ (forall n : nat, (n < length l1)%nat -> f (nth n l1 d) = g (nth n l2 d))).
Proof. intros A d l1 l2 f g.
  split.
  - intros H0.
    assert (length l1 = length l2).
    { rewrite <- map_length with (f := f) (l := l1).
      rewrite <- map_length with (f := g) (l := l2).
      rewrite H0.
      reflexivity. }
    split; try assumption.
    intros n H2.
    rewrite <- map_nth with (f := f) (n := n) (d := d) (l := l1).
    rewrite <- map_nth with (f := g) (n := n) (d := d) (l := l2).
    rewrite H0.
    rewrite nth_indep with (d := f d) (d' := g d);
      try reflexivity.
    rewrite map_length.
    rewrite <- H1.
    assumption.
  - intros H0.
    destruct H0 as [H0 H1].
    gen l1.
    induction l2.
    + intros l1 H0 H1.
      simpl in H0.
      rewrite length_zero_iff_nil in H0.
      subst.
      reflexivity.
    + intros l1 H0 H1.
      simpl in H0.
      Admitted.
*)

Definition col_insert_front {n m : nat} (M : Matrix n m) (v : Vector n) : Matrix n (s m) :=
  fun r c => if (c =? 0)%nat then v r 0%nat else M r (c - 1)%nat.

Lemma WF_Matrix_col_insert_front : forall {n m : nat} (M : Matrix n m) (v : Vector n),
    WF_Matrix M -> WF_Matrix v -> WF_Matrix (col_insert_front M v).
Proof. intros n m M v H0 H1.
  unfold col_insert_front.
  unfold WF_Matrix in *.
  intros.
  bdestruct_all.
  - rewrite H1; trivial.
    lia.
  - rewrite H0; trivial.
    lia.
Qed.

 #[export] Hint Resolve WF_Matrix_col_insert_front : wf_db.
 

(* # ~12 *)
    (** Theorem 24 Let V be a vector space over a field F, and let u1,u2,...,un be vectors in V , where n ≥ 2. Then {u1, u2, . . . , un} is linearly dependent if and only if at least one of u1, u2, . . . , un can be written as a linear combination of the remaining n − 1 vectors. **)

(* proves the "only if" part of theorem 24

Lemma lin_dep_gen_elem : forall {m n} (T : Matrix n (S m)),
  WF_Matrix T -> linearly_dependent T -> 
  (exists i, i < (S m) /\ 
             (exists v : Vector m, WF_Matrix v /\ 
                 @Mmult n m 1 (reduce_col T i) v = (-C1) .* (get_vec i T))). 
 *)

Lemma span_linearly_dependent_col_insert_front : forall {m n} (M : Matrix n m) (v : Vector n),
    WF_Matrix M -> span M v -> linearly_dependent (col_insert_front M v).
Proof. intros m n M v H0 H1.
  unfold linearly_dependent.
  unfold span in H1.
  destruct H1 as [a [H1 H2]].
  exists (fun r c => if (r =? 0)%nat
             then if (c =? 0)%nat
                  then (- C1)%C
                  else C0
             else a (r - 1)%nat c).
  split.
  - unfold WF_Matrix.
    intros.
    bdestruct_all; trivial.
    unfold WF_Matrix in H1.
    rewrite H1; trivial; lia.
  - split.
    + intro.
      apply f_equal_inv with (x := 0%nat) in H3.
      apply f_equal_inv with (x := 0%nat) in H3.
      simpl in H3.
      inversion H3.
      lra.
    + unfold col_insert_front.
      unfold Mmult.
      prep_matrix_equality.
      rewrite <- big_sum_extend_l.
      bdestruct_all.
      * subst.
        simpl.
        unfold Mmult.
        assert (@Zero n 1 x 0%nat
                = Σ (fun y : nat => M x y * a y 0%nat) m * - C1 + Σ (fun y : nat => M x y * a y 0%nat) m).
        { lca. }
        rewrite H2.
        apply Cplus_inj_l.
        apply big_sum_eq_bounded.
        intros.
        replace (x0 - 0)%nat with x0 by lia.
        reflexivity.
      * rewrite Cmult_0_r, Cplus_0_l.
        replace (@Zero n 1 x y) with C0 by lca.
        simpl.
        rewrite big_sum_0_bounded; trivial.
        intros.
        unfold WF_Matrix in H1.
        rewrite H1; try lca; lia.
Qed.

Lemma span_linearly_dependent_col_append : forall {m n} (M : Matrix n m) (v : Vector n),
    WF_Matrix M -> span M v -> linearly_dependent (col_append M v).
Proof. intros m n M v H0 H1.
  unfold linearly_dependent.
  unfold span in H1.
  destruct H1 as [a [H1 H2]].
  exists (fun r c => if (r =? m)%nat
             then if (c =? 0)%nat
                  then (- C1)%C
                  else C0
             else a r c).
  split.
  - unfold WF_Matrix.
    intros.
    bdestruct_all; trivial.
    unfold WF_Matrix in H1.
    rewrite H1; trivial; lia.
  - split.
    + intro.
      apply f_equal_inv with (x := m) in H3.
      apply f_equal_inv with (x := 0%nat) in H3.
      simpl in H3.
      replace (m =? m)%nat with true in H3 by (rewrite Nat.eqb_refl; reflexivity).
      inversion H3.
      lra.
    + unfold col_append, col_wedge.
      unfold Mmult.
      prep_matrix_equality.
      rewrite <- big_sum_extend_r.
      bdestruct_all.
      * subst.
        simpl.
        unfold Mmult.
        assert (@Zero n 1 x 0%nat
                = Σ (fun y : nat => M x y * a y 0%nat) m + Σ (fun y : nat => M x y * a y 0%nat) m * - C1 ).
        { lca. }
        rewrite H2.
        apply Cplus_inj_r.
        apply big_sum_eq_bounded.
        intros.
        bdestruct_all.
        reflexivity.
      * rewrite Cmult_0_r, Cplus_0_r.
        replace (@Zero n 1 x y) with C0 by lca.
        rewrite big_sum_0_bounded; trivial.
        intros.
        bdestruct_all.
        unfold WF_Matrix in H1.
        rewrite H1; try lca; lia.
Qed.

        

Lemma linearly_dependent_linear_combination : forall {n m : nat} (M : Matrix n m), (m > 1)%nat -> WF_Matrix M -> linearly_dependent M -> (exists (i : nat) (a : Vector (m-1)), (i < m)%nat /\ WF_Matrix a /\ get_vec i M = (matrix_column_choose ((List.seq 0 i) ++ (List.seq (i+1) (m - i - 1)%nat)) M) × a).
Proof. intros n m M H0 H1 H2.
  unfold linearly_dependent in H2.
  destruct H2 as [u [H2 [H3 H4]]].
  apply nonzero_vec_nonzero_elem in H3; trivial.
  destruct H3 as [i H3].
  exists i.
  bdestruct (i <? m).
  - exists (fun r c : nat => if r <? i then (- (/ (u i 0%nat)) * (u r c))%C else (- (/ (u i 0%nat)) * (u (r+1)%nat c))%C).
    split.
    + assumption.
    + split.
      * unfold WF_Matrix in *.
        intros.
        destruct H6; bdestruct_all.
        -- assert ((x+1 >= m)%nat \/ (y >= 1)%nat). { left. lia. }
           specialize (H2 (x+1)%nat y H8).
           rewrite H2.
           lca.
        -- assert ((x >= m)%nat \/ (y >= 1)%nat). { right. lia. }
           specialize (H2 x y H8).
           rewrite H2.
           lca.
        -- assert ((x+1 >= m)%nat \/ (y >= 1)%nat). { right. lia. }
           specialize (H2 (x+1)%nat y H8).
           rewrite H2.
           lca.
      * unfold Mmult in *.
        unfold matrix_column_choose, list_vector_to_matrix.
        unfold get_vec.
        do 2 (apply functional_extensionality; intros).
        apply f_equal_inv with (x := x) in H4.
        apply f_equal_inv with (x := x0) in H4.
        replace (Zero x x0) with C0 in H4 by reflexivity.
        bdestruct_all.
        -- assert (@Zero n 1%nat = (fun i0 x1 y0 : nat => if (y0 =? 0)%nat then M x1 i0 else 0) m).
           { do 2 (apply functional_extensionality; intros).
             replace (Zero x1 x2) with C0 by reflexivity.
             bdestruct_all; trivial.
             unfold WF_Matrix in H1.
             assert ((x1 >= n)%nat \/ (m >= m)%nat). { right. lia. }
             specialize (H1 x1 m H8).
             rewrite H1.
             reflexivity. }
           rewrite H7.
           assert ((fun y : nat =>
                      nth y
                        (map (fun i0 x1 y0 : nat => if (y0 =? 0)%nat then M x1 i0 else 0)
                           (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)))
                        (fun x1 y0 : nat => if (y0 =? 0)%nat then M x1 m else 0) x 0%nat *
                        (if y <? i then - / u i 0%nat * u y x0 else - / u i 0%nat * u (y + 1)%nat x0))
                   =
                     (fun y : nat =>
                        (- / u i 0%nat)%C * ((M x (nth y (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)) m)) *
                                             (if y <? i then u y x0 else u (y + 1)%nat x0)))).
           { apply functional_extensionality; intros.
             rewrite map_nth with (d := m).
             bdestruct_all; lca. }
           setoid_rewrite H8.
           rewrite <- @big_sum_scale_l with (H7 := C_is_module_space).
           simpl.
           apply Cmult_cancel_l with (a := (- u i 0%nat)%C).
           ++ intro.
              rewrite Copp_opp in H9.
              replace (- C0)%C with C0%C in H9 by lca.
              contradiction.
           ++ rewrite Cmult_assoc.
              replace (- u i 0%nat * - / u i 0%nat)%C with C1.
              ** rewrite Cmult_1_l.
                 rewrite Cmult_comm.
                 rewrite <- Copp_mult_distr_r.
                 apply Cplus_inv_r with (c := (M x i * u i 0%nat)%C).
                 replace (- (M x i * u i 0%nat) + M x i * u i 0%nat)%C with C0 by lca.
                 rewrite <- H4 at 1.
                 Search big_sum.
                 
                 assert (Σ
                           (fun x1 : nat =>
                              M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)) m) *
                                (if x1 <? i then u x1 x0 else u (x1 + 1)%nat x0))
                           (length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1))) +
                           M x i * u i 0%nat
                         =
                           Σ
                             (fun x1 : nat =>
                                M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) *
                                  (if (x1 =? m-1)%nat then u i 0%nat else
                                     (if x1 <? i then u x1 x0 else u (x1 + 1)%nat x0)))
                             (length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]))).
                 { rewrite app_assoc.
                   setoid_rewrite app_length at 2.
                   simpl.
                   Search ((?x + 1)%nat = Datatypes.S ?x).
                   setoid_rewrite Nat.add_1_r at 6.
                   rewrite <- @big_sum_extend_r with (H := C_is_monoid).
                   simpl.
                   assert ((length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1))) = (m-1)%nat).
                   { rewrite app_length.
                     rewrite ! seq_length.
                     lia. }
                   rewrite ! H9.
                   bdestruct_all.
                   rewrite <- H9 at 3.
                   rewrite nth_middle with (a := i) (l' := []).
                   f_equal.
                   apply big_sum_eq_bounded.
                   intros x1 H12.
                   bdestruct_all.
                   - setoid_rewrite app_nth1 at 2.
                     + reflexivity.
                     + rewrite app_length.
                       rewrite ! seq_length.
                       lia.
                   - setoid_rewrite app_nth1 at 2.
                     + reflexivity.
                     + rewrite app_length.
                       rewrite ! seq_length.
                       lia. }
                 rewrite H9.
                 rewrite ! app_length.
                 rewrite ! seq_length.
                 simpl.
                 replace (i + (m - i - 1 + 1))%nat with m by lia.
                 assert (Σ (fun y : nat => M x y * u y x0) m
                         =
                           Σ (fun y : nat => M x (nth y (List.seq 0 m) m) *
                                          u (nth y (List.seq 0 m) m) x0) m).
                 { apply big_sum_eq_bounded.
                   intros x1 H10. 
                   rewrite seq_nth.
                   lca.
                   assumption. }
                 rewrite H10.
                 assert ((fun x1 : nat =>
                            M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) *
                              (if (x1 =? m - 1)%nat
                               then u i 0%nat
                               else if x1 <? i then u x1 x0 else u (x1 + 1)%nat x0))
                         =
                           (fun x1 : nat =>
                              M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) *
                                u (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) x0)).
                 { apply functional_extensionality; intros.
                   subst.
                   f_equal.
                   bdestruct_all.
                   - rewrite <- nth_firstn with (n := i); try lia.
                     rewrite firstn_app.
                     rewrite seq_length.
                     replace (i - i)%nat with 0%nat by lia.
                     simpl.
                     rewrite app_nil_r.
                     replace i with (length (List.seq 0 i)) at 1
                       by (rewrite seq_length; reflexivity).
                     rewrite firstn_all.
                     rewrite seq_nth; try lia.
                     lca.
                   - subst.
                     rewrite app_assoc.
                     replace (m - 1)%nat with (length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)))
                       by (rewrite app_length; rewrite ! seq_length; lia).
                     rewrite nth_middle.
                     reflexivity.
                   - bdestruct (x1 <? (m-1)%nat).
                     + rewrite <- nth_firstn with (n := (m-1)%nat); try assumption.
                       rewrite <- firstn_removelast.
                       * rewrite app_assoc.
                         rewrite removelast_last.
                         rewrite nth_firstn; try assumption.
                         rewrite app_nth2.
                         -- rewrite seq_length.
                            rewrite seq_nth; try lia.
                            replace (i + 1 + (x1 - i))%nat with (x1 + 1)%nat by lia.
                            reflexivity.
                         -- rewrite seq_length; assumption.
                       * rewrite ! app_length; rewrite ! seq_length; simpl; lia.
                     + remember H2 as H2'. clear HeqH2'.
                       unfold WF_Matrix in H2, H2'.
                       rewrite nth_overflow.
                       * assert ((x1 + 1 >= m)%nat \/ (0 >= 1)%nat). { left; lia. }
                         assert ((m >= m)%nat \/ (0 >= 1)%nat). { left; lia. }
                         specialize (H2 (x1+1)%nat 0%nat H13).
                         specialize (H2' m 0%nat H14).
                         rewrite H2, H2'.
                         reflexivity.
                       * rewrite ! app_length; rewrite ! seq_length; simpl; lia. }
                 rewrite H11.
                 apply big_sum_permutation with (f := fun z => M x z * u z x0).
                 2: rewrite seq_length; lia.
                 replace (List.seq 0 m) with (List.seq 0 i ++ List.seq i (m - i))
                   by (rewrite <- seq_app; f_equal; lia).
                 apply Permutation_app.
                 1: apply Permutation_refl.
                 replace (m - i)%nat with ((m - i - 1) + 1)%nat at 1 by lia.
                 rewrite Nat.add_1_r at 1.
                 simpl.
                 rewrite cons_conc.
                 rewrite <- Nat.add_1_r.
                 apply Permutation_app_comm.
              ** rewrite <- Copp_mult_distr_l, <- Copp_mult_distr_r.
                 rewrite Copp_involutive.
                 rewrite Cinv_r; trivial.
        -- unfold WF_Matrix in H2.
           assert ((fun y : nat =>
                      nth y
                        (map (fun i0 x1 y0 : nat => if (y0 =? 0)%nat then M x1 i0 else 0)
                           (List.seq 0 i ++ List.seq (i + 1) (m - i - 1))) (@Zero n 1%nat) x 0%nat *
                        (if y <? i then - / u i 0%nat * u y x0 else - / u i 0%nat * u (y + 1)%nat x0)) =
                     (fun _ : nat => C0)).
           { apply functional_extensionality; intros.
             assert (@Zero n 1%nat = (fun i0 x2 y0 : nat => if (y0 =? 0)%nat then M x2 i0 else 0) m).
             { do 2 (apply functional_extensionality; intros).
               replace (Zero x2 x3) with C0 by reflexivity.
               bdestruct_all; trivial.
               unfold WF_Matrix in H1.
               assert ((x2 >= n)%nat \/ (m >= m)%nat). { right. lia. }
               specialize (H1 x2 m H8).
               rewrite H1.
               reflexivity. }
             rewrite H7.
             rewrite map_nth with (d := m).
             bdestruct_all.
             - assert ((x1 >= m)%nat \/ (x0 >= 1)%nat). { right. lia. }
               specialize (H2 x1 x0 H10).
               rewrite H2.
               lca.
             - assert ((x1+1 >= m)%nat \/ (x0 >= 1)%nat). { right. lia. }
               specialize (H2 (x1+1)%nat x0 H10).
               rewrite H2.
               lca. }
           setoid_rewrite H7.
           rewrite big_sum_0; trivial. 
  - assert ((i >= m)%nat \/ (0 >= 1)%nat). { left. lia. }
    unfold WF_Matrix in H2.
    specialize (H2 i 0%nat H6).
    contradiction.
Qed.

(*** Admitted. : Not Used.
     Use lin_dep_gen_elem *)
(** lin_dep_gen_elem :
forall {m n : nat} (T : Matrix n (s m)),
WF_Matrix T ->
linearly_dependent T ->
exists i : nat,
  (i < s m)%nat /\
  (exists v : Vector m, WF_Matrix v /\ reduce_col T i × v = - C1 .* get_vec i T) *)
(* 
Lemma linearly_dependent_linear_combination' : forall {n m : nat} (M : Matrix n m), (m > 1)%nat -> WF_Matrix M -> (linearly_dependent M <-> (exists (i : nat) (a : Vector (m-1)), (i < m)%nat /\ WF_Matrix a /\ get_vec i M = (matrix_column_choose ((List.seq 0 i) ++ (List.seq (i+1) (m-i-1))) M) × a)).
Proof. intros n m M H0 H1.
  split.
  - intros H2.
    unfold linearly_dependent in H2.
    destruct H2 as [u [H2 [H3 H4]]].
    apply nonzero_vec_nonzero_elem in H3; trivial.
    destruct H3 as [i H3].
    exists i.
    bdestruct (i <? m).
    + exists (fun r c : nat => if r <? i then (- (/ (u i 0%nat)) * (u r c))%C else (- (/ (u i 0%nat)) * (u (r+1)%nat c))%C).
      split.
      * assumption.
      * split.
        -- unfold WF_Matrix in *.
           intros.
           destruct H6; bdestruct_all.
           ++ assert ((x+1 >= m)%nat \/ (y >= 1)%nat). { left. lia. }
              specialize (H2 (x+1)%nat y H8).
              rewrite H2.
              lca.
           ++ assert ((x >= m)%nat \/ (y >= 1)%nat). { right. lia. }
              specialize (H2 x y H8).
              rewrite H2.
              lca.
           ++ assert ((x+1 >= m)%nat \/ (y >= 1)%nat). { right. lia. }
              specialize (H2 (x+1)%nat y H8).
              rewrite H2.
              lca.
        -- unfold Mmult in *.
           unfold matrix_column_choose, list_vector_to_matrix.
           unfold get_vec.
           do 2 (apply functional_extensionality; intros).
           apply f_equal_inv with (x := x) in H4.
           apply f_equal_inv with (x := x0) in H4.
           replace (Zero x x0) with C0 in H4 by reflexivity.
           bdestruct_all.
           ++ assert (@Zero n 1%nat = (fun i0 x1 y0 : nat => if (y0 =? 0)%nat then M x1 i0 else 0) m).
              { do 2 (apply functional_extensionality; intros).
                replace (Zero x1 x2) with C0 by reflexivity.
                bdestruct_all; trivial.
                unfold WF_Matrix in H1.
                assert ((x1 >= n)%nat \/ (m >= m)%nat). { right. lia. }
                specialize (H1 x1 m H8).
                rewrite H1.
                reflexivity. }
              rewrite H7.
              assert ((fun y : nat =>
                         nth y
                           (map (fun i0 x1 y0 : nat => if (y0 =? 0)%nat then M x1 i0 else 0)
                              (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)))
                           (fun x1 y0 : nat => if (y0 =? 0)%nat then M x1 m else 0) x 0%nat *
                           (if y <? i then - / u i 0%nat * u y x0 else - / u i 0%nat * u (y + 1)%nat x0))
                      =
                        (fun y : nat =>
                           (- / u i 0%nat)%C * ((M x (nth y (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)) m)) *
                             (if y <? i then u y x0 else u (y + 1)%nat x0)))).
              { apply functional_extensionality; intros.
                rewrite map_nth with (d := m).
                bdestruct_all; lca. }
              setoid_rewrite H8.
              rewrite <- @big_sum_scale_l with (H7 := C_is_module_space).
              simpl.
              apply Cmult_cancel_l with (a := (- u i 0%nat)%C).
              ** intro.
                 rewrite Copp_opp in H9.
                 replace (- C0)%C with C0%C in H9 by lca.
                 contradiction.
              ** rewrite Cmult_assoc.
                 replace (- u i 0%nat * - / u i 0%nat)%C with C1.
                 --- rewrite Cmult_1_l.
                     rewrite Cmult_comm.
                     rewrite <- Copp_mult_distr_r.
                     apply Cplus_inv_r with (c := (M x i * u i 0%nat)%C).
                     replace (- (M x i * u i 0%nat) + M x i * u i 0%nat)%C with C0 by lca.
                     rewrite <- H4 at 1.
                     Search big_sum.

                     assert (Σ
                               (fun x1 : nat =>
                                  M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)) m) *
                                    (if x1 <? i then u x1 x0 else u (x1 + 1)%nat x0))
                               (length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1))) +
                              M x i * u i 0%nat
                             =
                               Σ
                                 (fun x1 : nat =>
                                    M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) *
                                      (if (x1 =? m-1)%nat then u i 0%nat else
                                         (if x1 <? i then u x1 x0 else u (x1 + 1)%nat x0)))
                                 (length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]))).
                     { rewrite app_assoc.
                       setoid_rewrite app_length at 2.
                       simpl.
                       Search ((?x + 1)%nat = Datatypes.S ?x).
                       setoid_rewrite Nat.add_1_r at 6.
                       rewrite <- @big_sum_extend_r with (H := C_is_monoid).
                       simpl.
                       assert ((length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1))) = (m-1)%nat).
                       { rewrite app_length.
                         rewrite ! seq_length.
                         lia. }
                       rewrite ! H9.
                       bdestruct_all.
                       rewrite <- H9 at 3.
                       rewrite nth_middle with (a := i) (l' := []).
                       f_equal.
                       apply big_sum_eq_bounded.
                       intros x1 H12.
                       bdestruct_all.
                       - setoid_rewrite app_nth1 at 2.
                         + reflexivity.
                         + rewrite app_length.
                           rewrite ! seq_length.
                           lia.
                       - setoid_rewrite app_nth1 at 2.
                         + reflexivity.
                         + rewrite app_length.
                           rewrite ! seq_length.
                           lia. }
                     rewrite H9.
                     rewrite ! app_length.
                     rewrite ! seq_length.
                     simpl.
                     replace (i + (m - i - 1 + 1))%nat with m by lia.
                     assert (Σ (fun y : nat => M x y * u y x0) m
                             =
                               Σ (fun y : nat => M x (nth y (List.seq 0 m) m) *
                                              u (nth y (List.seq 0 m) m) x0) m).
                     { apply big_sum_eq_bounded.
                       intros x1 H10. 
                       rewrite seq_nth.
                       lca.
                       assumption. }
                     rewrite H10.
                     assert ((fun x1 : nat =>
                                 M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) *
                                   (if (x1 =? m - 1)%nat
                                    then u i 0%nat
                                    else if x1 <? i then u x1 x0 else u (x1 + 1)%nat x0))
                              =
                                (fun x1 : nat =>
                                   M x (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) *
                                     u (nth x1 (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]) m) x0)).
                     { apply functional_extensionality; intros.
                       subst.
                       f_equal.
                       bdestruct_all.
                       - rewrite <- nth_firstn with (n := i); try lia.
                         rewrite firstn_app.
                         rewrite seq_length.
                         replace (i - i)%nat with 0%nat by lia.
                         simpl.
                         rewrite app_nil_r.
                         replace i with (length (List.seq 0 i)) at 1
                           by (rewrite seq_length; reflexivity).
                         rewrite firstn_all.
                         rewrite seq_nth; try lia.
                         lca.
                       - subst.
                         rewrite app_assoc.
                         replace (m - 1)%nat with (length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)))
                           by (rewrite app_length; rewrite ! seq_length; lia).
                         rewrite nth_middle.
                         reflexivity.
                       - bdestruct (x1 <? (m-1)%nat).
                         + rewrite <- nth_firstn with (n := (m-1)%nat); try assumption.
                           rewrite <- firstn_removelast.
                           * rewrite app_assoc.
                             rewrite removelast_last.
                             rewrite nth_firstn; try assumption.
                             rewrite app_nth2.
                             -- rewrite seq_length.
                                rewrite seq_nth; try lia.
                                replace (i + 1 + (x1 - i))%nat with (x1 + 1)%nat by lia.
                                reflexivity.
                             -- rewrite seq_length; assumption.
                           * rewrite ! app_length; rewrite ! seq_length; simpl; lia.
                         + remember H2 as H2'. clear HeqH2'.
                           unfold WF_Matrix in H2, H2'.
                           rewrite nth_overflow.
                           * assert ((x1 + 1 >= m)%nat \/ (0 >= 1)%nat). { left; lia. }
                             assert ((m >= m)%nat \/ (0 >= 1)%nat). { left; lia. }
                             specialize (H2 (x1+1)%nat 0%nat H13).
                             specialize (H2' m 0%nat H14).
                             rewrite H2, H2'.
                             reflexivity.
                           * rewrite ! app_length; rewrite ! seq_length; simpl; lia. }
                     rewrite H11.
                     apply big_sum_permutation with (f := fun z => M x z * u z x0).
                     2: rewrite seq_length; lia.
                     replace (List.seq 0 m) with (List.seq 0 i ++ List.seq i (m - i))
                       by (rewrite <- seq_app; f_equal; lia).
                     apply Permutation_app.
                     1: apply Permutation_refl.
                     replace (m - i)%nat with ((m - i - 1) + 1)%nat at 1 by lia.
                     rewrite Nat.add_1_r at 1.
                     simpl.
                     rewrite cons_conc.
                     rewrite <- Nat.add_1_r.
                     apply Permutation_app_comm.
                     (** unused old code


                       apply big_sum_permutation_function'. (*** Admitted *)
                     assert (List.seq 0 m = List.seq 0 i ++ [i] ++ List.seq (i + 1) (m - i - 1)).
                     { replace m with (i + (m-i))%nat at 1 by lia.
                       rewrite seq_app.
                       simpl.
                       replace (m - i)%nat with (1 + (m - i - 1))%nat at 1 by lia.
                       rewrite seq_app.
                       simpl.
                       reflexivity. }
                     assert (List.seq 0 m = List.seq 0 i ++ List.seq i (m - i - 1) ++ [m - 1])%nat.
                     { replace m with (i + (m-i))%nat at 1 by lia.
                       rewrite seq_app.
                       simpl.
                       replace (m - i)%nat with ((m - i - 1) + 1)%nat at 1 by lia.
                       rewrite seq_app.
                       simpl.
                       replace (i + (m - i - 1))%nat with (m - 1)%nat by lia.
                       reflexivity. }
                     exists (List.seq 0 i ++ List.seq (i + 1) (m - i - 1) ++ [i]).
                     split.
                     +++ rewrite H11.
                         apply Permutation_app.
                         *** apply Permutation_refl.
                         *** apply Permutation_app_comm.
                     +++ setoid_rewrite H12 at 3.
                         rewrite ! map_app.
                         f_equal.
                         *** rewrite map_ext_in_iff.
                             intros a H13.
                             f_equal.
                             ---- f_equal.
                                  rewrite in_seq in H13.
                                  rewrite seq_nth; try lia.
                                  rewrite <- nth_firstn with (n := i); try lia.
                                  rewrite firstn_app.
                                  rewrite seq_length.
                                  replace (i - i)%nat with 0%nat by lia.
                                  simpl.
                                  rewrite app_nil_r.
                                  replace i with (length (List.seq 0 i)) at 1
                                    by (rewrite seq_length; reflexivity).
                                  rewrite firstn_all.
                                  rewrite seq_nth; lia.
                             ---- rewrite in_seq in H13.
                                  bdestruct_all; try lia.
                                  f_equal.
                                  rewrite seq_nth; try lia.
                         *** f_equal.
                             ---- rewrite map_ext_nth.
                                  assert (length (List.seq (i + 1) (m - i - 1)) = length (List.seq i (m - i - 1))).
                                  { rewrite ! seq_length.
                                    reflexivity. }
                                  split; try assumption.
                                  intros n0 H14.
                                  rewrite seq_length in H14.
                                  f_equal.
                                  ++++ f_equal.
                                       rewrite ! seq_nth; try lia.
                                       **** rewrite <- nth_firstn with (n := (i + n0 + 1)%nat).
                                         ----- rewrite <- Nat.add_assoc with (n := i) (m := n0) (p := 1%nat).
                                         replace i with (length (List.seq 0 i)) at 3
                                           by (rewrite seq_length; reflexivity).
                                         rewrite firstn_app_2.
                                         rewrite app_nth2 with (n := (i + n0)%nat);
                                           try (rewrite seq_length; lia).
                                         rewrite seq_length.
                                         replace (i + n0 - i)%nat with n0 by lia.
                                         rewrite nth_firstn; try lia.
                                         rewrite <- nth_firstn with (n := (m - i - 1)%nat); try lia.
                                         rewrite firstn_app.
                                         rewrite seq_length.
                                         replace (m - i - 1 - (m - i - 1))%nat with 0%nat by lia.
                                         simpl.
                                         rewrite app_nil_r.
                                         rewrite nth_firstn; try assumption.
                                         rewrite seq_nth; try assumption.
                                         reflexivity.
                                         ----- lia.
                                       **** rewrite seq_nth; lia.
                                  ++++ bdestruct_all;
                                         rewrite seq_nth in H15;
                                         rewrite seq_nth in H16;
                                         try lia.
                                       f_equal.
                                       rewrite ! seq_nth; try lia.
                                       rewrite seq_nth; lia.
                             ---- simpl.
                                  f_equal.
                                  bdestruct_all.
                                  f_equal.
                                  +++++ f_equal.
                                  rewrite seq_nth; try lia.
                                  assert (length (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)) + 0 = m - 1)%nat.
                                  { rewrite app_length.
                                    rewrite ! seq_length.
                                    lia. }
                                  rewrite <- H15.
                                  rewrite app_assoc.
                                  rewrite app_nth2_plus.
                                  reflexivity.
                                  +++++ f_equal; try assumption.
                                  rewrite seq_nth; lia. *)
                 --- rewrite <- Copp_mult_distr_l, <- Copp_mult_distr_r.
                     rewrite Copp_involutive.
                     rewrite Cinv_r; trivial.
           ++ unfold WF_Matrix in H2.
              assert ((fun y : nat =>
                         nth y
                           (map (fun i0 x1 y0 : nat => if (y0 =? 0)%nat then M x1 i0 else 0)
                              (List.seq 0 i ++ List.seq (i + 1) (m - i - 1))) (@Zero n 1%nat) x 0%nat *
                           (if y <? i then - / u i 0%nat * u y x0 else - / u i 0%nat * u (y + 1)%nat x0)) =
                        (fun _ : nat => C0)).
              { apply functional_extensionality; intros.
                assert (@Zero n 1%nat = (fun i0 x2 y0 : nat => if (y0 =? 0)%nat then M x2 i0 else 0) m).
                { do 2 (apply functional_extensionality; intros).
                  replace (Zero x2 x3) with C0 by reflexivity.
                  bdestruct_all; trivial.
                  unfold WF_Matrix in H1.
                  assert ((x2 >= n)%nat \/ (m >= m)%nat). { right. lia. }
                  specialize (H1 x2 m H8).
                  rewrite H1.
                  reflexivity. }
                rewrite H7.
                rewrite map_nth with (d := m).
                bdestruct_all.
                - assert ((x1 >= m)%nat \/ (x0 >= 1)%nat). { right. lia. }
                  specialize (H2 x1 x0 H10).
                  rewrite H2.
                  lca.
                - assert ((x1+1 >= m)%nat \/ (x0 >= 1)%nat). { right. lia. }
                  specialize (H2 (x1+1)%nat x0 H10).
                  rewrite H2.
                  lca. }
              setoid_rewrite H7.
              rewrite big_sum_0; trivial. 
    + assert ((i >= m)%nat \/ (0 >= 1)%nat). { left. lia. }
      unfold WF_Matrix in H2.
      specialize (H2 i 0%nat H6).
      contradiction.
  - intros H2.
    destruct H2 as [i [u [H2 [H3 H4]]]].
    unfold linearly_dependent.
    exists (fun r c : nat => if r <? i then u r c else (if (r =? i)%nat then (if (c =? 0)%nat then (- C1)%C else C0) else u (r-1)%nat c)).
    split.
    + unfold WF_Matrix.
      intros x y H5.
      unfold WF_Matrix in H3.
      destruct H5; bdestruct_all; trivial.
      * assert ((x-1 >= m - 1)%nat \/ (y >= 1)%nat). { left. lia. }
        specialize (H3 (x-1)%nat y H8).
        assumption.
      * assert ((x >= m - 1)%nat \/ (y >= 1)%nat). { right. lia. }
        specialize (H3 x y H7).
        assumption.
      * assert ((x-1 >= m - 1)%nat \/ (y >= 1)%nat). {right. lia. }
        specialize (H3 (x-1)%nat y H8).
        assumption.
    + split.
      * intro.
        apply f_equal_inv with (x := i) in H5.
        apply f_equal_inv with (x := 0%nat) in H5.
        contradict H5.
        bdestruct_all.
        replace (Zero i 0%nat) with C0 by reflexivity.
        nonzero.
      * unfold Mmult in *.
        do 2 (apply functional_extensionality; intros).
        unfold matrix_column_choose, list_vector_to_matrix in H4.
        unfold get_vec in H4.
        apply f_equal_inv with (x := x) in H4.
        apply f_equal_inv with (x := x0) in H4.
        replace (@Zero n 1%nat x x0) with C0 by lca.
        assert (@Zero n 1%nat = (fun i x y0 : nat => if (y0 =? 0)%nat then M x i else 0) m).
        { do 2 (apply functional_extensionality; intros).
          replace (@Zero n 1%nat x1 x2) with C0 by lca.
          bdestruct_all; trivial.
          unfold WF_Matrix in H1.
          assert ((x1 >= n)%nat \/ (m >= m)%nat). { right. lia. }
          specialize (H1 x1 m H6).
          rewrite H1.
          reflexivity. }
        rewrite H5 in H4.
        assert ((fun y : nat =>
                   nth y
                     (map (fun i x y0 : nat => if (y0 =? 0)%nat then M x i else 0)
                        (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)))
                     (fun x y0 : nat => if (y0 =? 0)%nat then M x m else 0) x 0%nat * 
                     u y x0)
                =
                  (fun y : nat =>
                    M x (nth y (List.seq 0 i ++ List.seq (i + 1) (m - i - 1)) m) * u y x0)).
        { apply functional_extensionality; intros.
          rewrite map_nth with (d := m).
          bdestruct_all.
          reflexivity. }
        setoid_rewrite H6 in H4.
        clear H5 H6.
        bdestruct_all; try lca.
        -- subst.
           
           

           
           admit.


        (**   

           
           Lemma vsum_reorder : forall {d} n (v : nat -> Vector d) f,
  permutation n f ->
  big_sum v n = big_sum (fun i => v (f i)) n.



           (*** Admitted *)
          Lemma big_sum_split :
           big_sum f m = big_sum f i + f i + (big_sum f m - big_sum f (i + 1))
                                               f = fun y => ...
            i+1 <= y < m
                        
           **)
           
        -- assert ((fun y : nat =>
                      M x y *
                        (if y <? i then u y x0 else if (y =? i)%nat then 0 else u (y - 1)%nat x0))
                   = (fun _ : nat => C0)).
           { apply functional_extensionality; intros.
             bdestruct_all; try lca.
             - unfold WF_Matrix in H3.
               assert ((x1 >= m - 1)%nat \/ (x0 >= 1)%nat). { right. lia. }
               specialize (H3 x1 x0 H7).
               rewrite H3.
               lca.
             - unfold WF_Matrix in H3.
               assert ((x1-1 >= m - 1)%nat \/ (x0 >= 1)%nat). { right. lia. }
               specialize (H3 (x1-1)%nat x0 H8).
               rewrite H3.
               lca. }
           rewrite H6.
           apply @big_sum_0 with (H := C_is_monoid).
           trivial.
Admitted.
*)

(* # ~11 *)
(** Theorem 26 Let V be a vector space over a field F, and let u1,u2,...,un be vectors in V . Then {u1, u2, . . . , un} is linearly independent if and only if each vector in sp{u1,u2,...,un} can be written uniquely as a linear combination of u1,u2,...,un. **)

Lemma linearly_independent_iff_unique_linear_combination_of_span : forall {n m : nat} (M : Matrix n m), linearly_independent M <-> (forall v : Vector n, span M v -> (exists a : Vector m, WF_Matrix a /\ v = M × a /\ (forall b : Vector m, WF_Matrix b -> v = M × b -> b = a))).
Proof. intros n m M.
  split.
  - intros H0 v H1.
    unfold span in *.
    do 2 destruct H1.
    exists x.
    split; trivial.
    split; trivial.
    intros b H3 H4.
    apply Mscale_inj with (c := (- C1)%C) in H2.
    apply (Mplus_double_side H4) in H2.
    replace (v .+ - C1 .* v) with (@Zero n 1) in H2 by lma.
    unfold linearly_independent in *.
    symmetry in H2.
    rewrite <- Mscale_mult_dist_r in H2.
    rewrite <- Mmult_plus_distr_l in H2.
    specialize (H0 (b .+ - C1 .* x)).
    apply H0 in H2; auto with wf_db.
    apply Mplus_inj_r with (m := x) in H2.
    rewrite Mplus_assoc in H2.
    replace (- C1 .* x .+ x) with (@Zero m 1) in H2 by lma.
    rewrite Mplus_0_l, Mplus_0_r in H2.
    assumption.
  - intros.
    unfold linearly_independent.
    intros a H1 H2.
    assert (span M Zero).
    { unfold span.
      exists Zero.
      split; auto with wf_db.
      rewrite Mmult_0_r.
      reflexivity. }
    specialize (H0 Zero H3).
    do 2 destruct H0.
    destruct H4.
    symmetry in H2.
    remember H5 as H5'. clear HeqH5'.
    specialize (H5' Zero).
    assert (WF_Matrix (@Zero m 1%nat)). { auto with wf_db. }
    assert (@Zero n 1%nat = M × (@Zero m 1%nat)). { rewrite Mmult_0_r. reflexivity. }
    specialize (H5' H6 H7).
    specialize (H5 a H1 H2).
    subst.
    reflexivity.
Qed.

(** Definition 27 Let V be a vector space over a field F, and let u1,u2,...,un be vectors in V. We say that {u1,u2,...,un} is a basis for V if and only if {u1,u2,...,un} spans V and is linearly independent. **)

Definition basis {n m : nat} (P : Vector n -> Prop) (M : Matrix n m) : Prop := subspace P /\ (forall i : nat, (i < m)%nat -> P (get_vec i M)) /\ (forall v : Vector n, P v -> span M v) /\ linearly_independent M.

(** Theorem 28 Let V be a vector space over a field F, and suppose u1,u2,...,un are vectors in V. Then {u1,u2,...,un} is a basis for V if and only if each v ∈ V can be written uniquely as a linear combination of u1, u2, . . . , un. **)

Lemma basis_iff_unique_linear_combination : forall {n m : nat} (P : Vector n -> Prop) (M : Matrix n m), basis P M <-> subspace P /\ (forall i : nat, (i < m)%nat -> P (get_vec i M)) /\ (forall v : Vector n, P v -> (exists a : Vector m, WF_Matrix a /\ v = M × a /\ (forall b : Vector m, WF_Matrix b -> v = M × b -> b = a))).
Proof. intros n m P M.
  split.
  - intros H0. 
    unfold basis in H0.
    destruct H0.
    destruct H1.
    destruct H2.
    do 2 (split; trivial).
    intros v H4.
    specialize (H2 v H4).
    rewrite linearly_independent_iff_unique_linear_combination_of_span in H3.
    specialize (H3 v H2).
    assumption.
  - intros H0.
    destruct H0.
    destruct H1.
    unfold basis.
    do 2 (split; trivial).
    split.
    + intros v H3.
      unfold span.
      specialize (H2 v H3).
      destruct H2.
      exists x.
      destruct H2.
      destruct H4.
      split; trivial.
    + rewrite linearly_independent_iff_unique_linear_combination_of_span.
      intros v H3.
      unfold span in H3.
      destruct H3.
      destruct H3.
      assert (P (M × x)).
      { apply subspace_closed_under_linear_combinations; trivial. }
      rewrite <- H4 in H5.
      specialize (H2 v H5).
      assumption.
Qed.




    
  

(*** Not used ***)
Lemma sumbool_decidable : forall (A : Prop), {A} + {~ A} -> A \/ ~ A.
Proof. intros.
  destruct H0.
  - left. assumption.
  - right. assumption.
Qed.

(*** Admitted. : Not used ***)
(* 
Lemma linearly_dependent_least_column : forall {n m : nat} (M : Matrix n m), WF_Matrix M -> (forall i : nat, (i < m)%nat -> get_vec i M <> Zero) -> linearly_dependent M -> (exists k : nat, (k < m)%nat /\ (linearly_dependent (matrix_column_choose (List.seq 0 k) M)) /\ (forall k' : nat, ((k' < m)%nat /\ (linearly_dependent (matrix_column_choose (List.seq 0 k') M))) -> (k <= k')%nat)).
Proof. intros.
  pose (dec_inh_nat_subset_has_unique_least_element (fun k : nat => (k < m)%nat /\ (linearly_dependent (matrix_column_choose (List.seq 0 k) M)))).
  assert ((forall n0 : nat,
      (fun k : nat =>
       (k < m)%nat /\ linearly_dependent (matrix_column_choose (List.seq 0 k) M))
        n0 \/
      ~
      (fun k : nat =>
       (k < m)%nat /\ linearly_dependent (matrix_column_choose (List.seq 0 k) M))
      n0)).
  { intros.
    assert (((n0 < m)%nat /\ linearly_dependent (matrix_column_choose (List.seq 0 n0) M) \/
              ~ ((n0 < m)%nat /\ linearly_dependent (matrix_column_choose (List.seq 0 n0) M)))
             <-> ((n0 < m)%nat /\ linearly_dependent (matrix_column_choose (List.seq 0 n0) M) \/
                  ((n0 >= m)%nat \/ linearly_independent (matrix_column_choose (List.seq 0 n0) M)))).
    { split.
      - intros. destruct H3.
        + destruct H3.
          left. split; assumption.
        + (*** Classical Logic Used ***)
          apply Classical_Prop.not_and_or in H3.
          destruct H3.
          * right. left. lia.
          * apply not_lindep_implies_linindep in H3.
            right. right; assumption.
      - intros. destruct H3.
        + destruct H3.
          left. split; assumption.
        + destruct H3.
          * right.
            (*** Classical Logic Used ***)
            apply Classical_Prop.or_not_and.
            left. intro. lia.
          * right.
            (*** Classical Logic Used ***)
            apply Classical_Prop.or_not_and.
            right.
            pose (lindep_implies_not_linindep (matrix_column_choose (List.seq 0 n0) M)).
            pose (not_lindep_implies_linindep (matrix_column_choose (List.seq 0 n0) M)).
            intro.
            specialize (n1 H4).
            contradiction. }
    rewrite H3.
    assert (WF_Matrix (matrix_column_choose (List.seq 0 n0) M)).
    { apply WF_Matrix_matrix_column_choose_indices_list.
      assumption. }
    (*
    destruct (lin_dep_indep_dec (matrix_column_choose (List.seq 0 n0) M)).
     *)

    Admitted.
*)
    
  

(** another way to say the first n columns **)
Definition submatrix_column {n m} (k : nat) (M : Matrix n m) : Matrix n k :=
  (fun r c : nat => if (c <? k)%nat then M r c else C0).

Lemma subsubmatrix_column_outer : forall {n m} (i j : nat) (M : Matrix n m),
    (i >= j)%nat -> submatrix_column i (submatrix_column j M) = (submatrix_column j M).
Proof. intros.
  unfold submatrix_column.
  apply functional_extensionality; intros r.
  apply functional_extensionality; intros c.
  bdestruct_all; trivial.
Qed.

Lemma subsubmatrix_column_inner : forall {n m} (i j : nat) (M : Matrix n m),
    (i < j)%nat -> submatrix_column i (submatrix_column j M) = (submatrix_column i M).
Proof. intros.
  unfold submatrix_column.
  apply functional_extensionality; intros r.
  apply functional_extensionality; intros c.
  bdestruct_all; trivial.
Qed.

Lemma submatrix_column_matrix_column_choose : forall {n m} (k : nat) (M : Matrix n m), WF_Matrix M -> submatrix_column k M = matrix_column_choose (List.seq 0 k) M.
Proof. intros.
  unfold submatrix_column.
  unfold matrix_column_choose, list_vector_to_matrix.
  apply functional_extensionality; intros r.
  apply functional_extensionality; intros c.
  (*** You can get rid of this by splitting cases on c <? k, and using nth_indep & nth_overflow ***)
  assert (Zero = (fun i0 : nat => get_vec i0 M) m).
  { unfold get_vec.
    apply functional_extensionality; intros x.
    apply functional_extensionality; intros y.
    bdestruct_all; trivial.
    unfold WF_Matrix in H0.
    assert ((x >= n)%nat \/ (m >= m)%nat). { right. lia. }
    specialize (H0 x m H2).
    rewrite H0.
    trivial. }
  rewrite H1.
  rewrite map_nth with (d := m).
  unfold get_vec.
  bdestruct_all.
  - rewrite seq_nth; auto.
  - rewrite nth_overflow.
    + unfold WF_Matrix in H0.
      rewrite H0; auto.
    + rewrite seq_length; trivial.
Qed.

Lemma WF_Matrix_submatrix_column : forall {n m} (k : nat) (M : Matrix n m),
    WF_Matrix M -> WF_Matrix (submatrix_column k M).
Proof. intros.
  unfold WF_Matrix in *.
  unfold submatrix_column.
  intros.
  bdestruct_all; trivial.
  rewrite H0; trivial.
  destruct H1; lia.
Qed.

#[export] Hint Resolve WF_Matrix_submatrix_column : wf_db.




 (** Lemma 33 Let V be a vector space over a field F, and let v1,v2,...,vn be nonzero vectors in V . If {v1, v2, . . . , vn} is linearly dependent, then there exists an integer k, with 2 ≤ k ≤ n, such that vk is a linear combination of v1,v2,...,vk−1. **)

(* Proof Let k be the smallest positive integer such that {v1, v2, . . . , vk} is linearly dependent. By assumption k ≤ n, and k ≥ 2 because the singleton set {v1} is linearly dependent only if v1 is the zero vector, which is not the case. By Theorem 24, one of the vectors v1,v2,...,vk is a linear combination of the others. If it is vk, then the proof is complete, so suppose vt, 1 ≤ t < k, is a linear combination of v1, ..., vt−1, vt+1, ..., vk:

vt = α1 v1 + ... + αt−1 vt−1 + αt+1 vt+1 + ... + αk vk. (2.12)

We must have αk ̸= 0, since otherwise {v1, v2, . . . , vk−1} would be linearly dependent by Theorem 26, contradicting that {v1, v2, . . . , vl} is linearly inde- pendent for l < k. But, with αk ̸= 0, we can solve (2.12) for vk:

vk = −α−1α1v1−...−α−1αt−1vt−1+α−1vt−α−1αt+1vt+1−...−α−1αk−1vk−1.
Therefore vk is a linear combination of v1,v2,...,vk−1. *)


Lemma linearly_dependent_bounded_linear_combination : forall {n m : nat} (M : Matrix n m), WF_Matrix M -> (forall i : nat, (i < m)%nat -> get_vec i M <> Zero) -> linearly_dependent M -> (exists k : nat, (0 < k < m)%nat /\ (exists a : Vector k, WF_Matrix a /\ get_vec k M = (submatrix_column k M) × a)).
Proof. intros n m M H H0 H1.
  induction m.
  - exists 0%nat.
    intros.
    Search Zero.
    unfold linearly_dependent in H1.
    destruct H1 as [a [H1 [H2 H3]]].
    contradict H2.
    unfold WF_Matrix in H1.
    prep_matrix_equality.
    apply H1.
    lia.
  - remember (submatrix_column m M) as M'.
    (*** Classical Logic Used ***)
    destruct (Classical_Prop.classic (linearly_dependent M')).
    + destruct (IHm M') as [k H'].
      * subst.
        apply WF_Matrix_submatrix_column.
        assumption.
      * intros.
        rewrite HeqM'.
        intro.
        apply (H0 i).
        -- lia.
        -- unfold get_vec.
           unfold get_vec in H4.
           rewrite <- H4.
           unfold submatrix_column.
           bdestruct_all.
           reflexivity.
      * assumption.
      * exists k.
        intros.
        destruct H'.
        split; try lia.
        assert (submatrix_column k M' = submatrix_column k M).
        { rewrite HeqM'.
          rewrite subsubmatrix_column_inner; trivial.
          lia. }
        assert (get_vec k M' = get_vec k M).
        { rewrite HeqM'.
          unfold get_vec.
          unfold submatrix_column.
          bdestruct_all.
          reflexivity. }
        rewrite <- H6.
        rewrite <- H5.
        assumption.
    + assert (linearly_independent M').
      { unfold linearly_independent.
        unfold linearly_dependent in H2.
        intros.
        (*** Classical Logic Used ***)
        apply Classical_Pred_Type.not_ex_all_not with (U := Vector m) (n := a) in H2.
        apply Classical_Prop.not_and_or in H2.
        destruct H2; try contradiction.
        apply Classical_Prop.not_and_or in H2.
        destruct H2; try contradiction.
        unfold "<>" in H2.
        rewrite Decidable.not_not_iff in H2; trivial.
        unfold Decidable.decidable.
        apply (Classical_Prop.classic (a = Zero)). }
      subst.
      exists m.
      bdestruct (m =? 0)%nat.
      * subst.
        remember H1 as H1'. clear HeqH1'.
        apply lindep_implies_not_linindep in H1'.
        assert (M <> Zero).
        { intro.
          assert (0 < 1)%nat. { lia. }
          specialize (H0 0%nat H5).
          contradict H0.
          rewrite H4.
          unfold get_vec.
          prep_matrix_equality.
          bdestruct_all; trivial. }
        pose (lin_indep_vec M H H4).
        contradiction.
      * split; try lia.
        unfold linearly_dependent in H1.
        destruct H1 as [a [H5 [H6 H7]]].
        assert (a m 0%nat <> C0).
        { intro.
          assert (WF_Matrix (reduce_row a m)).
          { unfold WF_Matrix.
            unfold WF_Matrix in H5.
            intros.
            unfold reduce_row.
            bdestruct_all.
            - apply H5. right. lia.
            - apply H5. left. lia. }
          assert (reduce_row a m <> Zero).
          { unfold reduce_row.
            intro.
            destruct (nonzero_vec_nonzero_elem a H5 H6) as [x H10].
            apply f_equal_inv with (x := x) in H9.
            apply f_equal_inv with (x := 0%nat) in H9.
            replace (Zero x 0%nat) with C0 in H9 by trivial.
            bdestruct (x <? m)%nat.
            - contradiction.
            - bdestruct (x =? m)%nat.
              + subst. contradiction.
              + contradict H10.
                unfold WF_Matrix in H5.
                apply H5.
                left.
                lia. }
          assert ((submatrix_column m M) × (reduce_row a m) = Zero).
          { unfold reduce_row, submatrix_column.
            unfold Mmult.
            prep_matrix_equality.
            replace (@Zero n 1%nat x y) with C0 by trivial.
            assert ((fun y0 : nat =>
                       (if y0 <? m then M x y0 else 0) *
                         (if y0 <? m then a y0 y else a (1 + y0)%nat y))
                    =
                      (fun y0 : nat =>
                         (if y0 <? m then M x y0 * a y0 y else 0))).
            { apply functional_extensionality; intros.
              bdestruct_all; lca. }
            rewrite H10.
            assert (Σ (fun y0 : nat => if y0 <? m then M x y0 * a y0 y else 0) m
                    =
                      Σ (fun y0 : nat => M x y0 * a y0 y) m).
            { apply big_sum_eq_bounded.
              intros.
              bdestruct_all.
              reflexivity. }
            rewrite H11.
            unfold Mmult in H7.
            apply f_equal_inv with (x := x) in H7.
            apply f_equal_inv with (x := y) in H7.
            replace (@Zero n 1%nat x y) with C0 in H7 by lca.
            rewrite <- H7.
            simpl.
            bdestruct (y =? 0)%nat.
            - subst.
              rewrite H1.
              rewrite Cmult_0_r.
              rewrite Cplus_0_r.
              reflexivity.
            - unfold WF_Matrix in H5.
              rewrite H5.
              + rewrite Cmult_0_r.
                rewrite Cplus_0_r.
                reflexivity.
              + right. lia. }
          unfold linearly_independent in H3.
          specialize (H3 (reduce_row a m) H8 H10).
          contradiction. }
        exists ((- (/ (a m 0%nat)))%C .* (reduce_row a m)).
        split; auto with wf_db. 
        distribute_scale.
        apply Mscale_div with (c := (- (a m 0%nat))%C).
        -- intro.
           rewrite Copp_opp in H8.
           replace (- 0)%C with C0 in H8 by lca.
           contradiction.
        -- distribute_scale.
           replace (- a m 0%nat * - / a m 0%nat)%C with (a m 0%nat * / a m 0%nat)%C by lca.
           rewrite Cinv_r; trivial.
           rewrite Mscale_1_l.
           apply Mplus_inv_r with (m := a m 0%nat .* get_vec m M); auto with wf_db.
           replace (- a m 0%nat .* get_vec m M .+ a m 0%nat .* get_vec m M) with (@Zero n 1)
             by lma.
           rewrite <- H7.
           unfold submatrix_column, reduce_row, get_vec.
           unfold Mmult, Matrix.scale, Mplus.
           prep_matrix_equality.
           simpl.
           assert ((fun y0 : nat =>
                      (if y0 <? m then M x y0 else 0) * (if y0 <? m then a y0 y else a (s y0) y))
                   =
                     (fun y0 : nat =>
                        (if y0 <? m then M x y0 *a y0 y else C0))).
           { apply functional_extensionality; intros.
             bdestruct_all; lca. }
           rewrite H8.
           bdestruct_all.
           ++ subst.
              f_equal; try lca.
              apply big_sum_eq_bounded.
              intros.
              bdestruct_all.
              reflexivity.
           ++ unfold WF_Matrix in H5.
              rewrite H5 at 1.
              ** f_equal; try lca.
                 apply big_sum_eq_bounded.
                 intros.
                 bdestruct_all.
                 reflexivity.
              ** right. lia.
Qed.

Lemma linearly_dependent_submatrix_column : forall {n m : nat} (k : nat) (M : Matrix n m),
    (k < m)%nat -> linearly_dependent (submatrix_column k M) -> linearly_dependent M.
Proof. intros n m k M H0 H1.
  unfold submatrix_column in H1.
  unfold linearly_dependent in *.
  destruct H1 as [a [H1 [H2 H3]]].
  exists (fun r c => if (r <? k) then a r c else C0).
  split.
  - unfold WF_Matrix.
    intros.
    bdestruct_all; trivial.
    unfold WF_Matrix in H1.
    rewrite H1; trivial.
    lia.
  - split.
    + pose (nonzero_vec_nonzero_elem a H1 H2) as H4.
      destruct H4 as [x H4].
      intro.
      apply f_equal_inv with (x := x) in H5.
      apply f_equal_inv with (x := 0%nat) in H5.
      bdestruct (x <? k)%nat.
      * contradiction.
      * unfold WF_Matrix in H1.
        rewrite H1 in H4.
        -- contradiction.
        -- lia.
    + rewrite <- H3.
      unfold Mmult.
      prep_matrix_equality.
      replace m with (k + (m - k))%nat by lia.
      rewrite @big_sum_sum with (H := C_is_monoid) (m := k) (n := (m - k)%nat).
      simpl.
      rewrite <- Cplus_0_r with (x := Σ (fun y0 : nat => (if y0 <? k then M x y0 else 0) * a y0 y) k).
      f_equal.
      * apply big_sum_eq_bounded.
        intros.
        bdestruct_all.
        reflexivity.
      * rewrite big_sum_0_bounded; trivial.
        intros.
        bdestruct_all.
        lca.
Qed.

 (*** Classical Logic used ***)
Lemma some_zero_vector_linearly_dependent : forall {n m : nat} (M : Matrix n m),
    ~ (forall i : nat, (i < m)%nat -> get_vec i M <> Zero) -> linearly_dependent M.
Proof. intros n m M H0.
  apply Classical_Pred_Type.not_all_ex_not in H0.
  destruct H0 as [k H0 ].
  apply Classical_Prop.imply_to_and in H0.
  destruct H0.
  unfold "~", "<>" in H1.
  rewrite Decidable.not_not_iff in H1.
  2 : { unfold Decidable.decidable.
        apply (Classical_Prop.classic (get_vec k M = Zero)). }
  unfold linearly_dependent.
  exists (e_i k).
  split; auto with wf_db.
  split.
  - intro.
    unfold e_i in H2.
    apply f_equal_inv with (x := k) in H2.
    apply f_equal_inv with (x := 0%nat) in H2.
    assert ((k =? k)%nat && (k <? m) && (0 =? 0)%nat = true).
    { bdestruct_all. trivial. }
    rewrite H3 in H2.
    replace (Zero k 0%nat) with C0 in H2; trivial.
    inversion H2.
    lra.
  - rewrite <- H1.
    rewrite matrix_by_basis; trivial.
Qed.

Lemma submatrix_column_overflow : forall {n m : nat} (k : nat) (M : Matrix n m),
    WF_Matrix M -> (k >= m)%nat -> submatrix_column k M = M.
Proof. intros n m k M H0 H1.
  unfold submatrix_column.
  prep_matrix_equality.
  bdestruct_all; trivial.
  unfold WF_Matrix in H0.
  rewrite H0; trivial; lia.
Qed.

Lemma get_vec_submatrix_column : forall {n m : nat} (i k : nat) (M : Matrix n m),
    (i < k)%nat -> get_vec i (submatrix_column k M) = get_vec i M.
Proof. intros n m i0 k M H0.
  unfold submatrix_column.
  unfold get_vec.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Lemma get_vec_col_insert_front_front : forall {n m : nat} (i : nat) (M : Matrix n m) (v : Vector n),
    WF_Matrix v -> (i = 0%nat) -> get_vec i (col_insert_front M v) = v.
Proof. intros n m i0 M v H0 H1.
  unfold get_vec, col_insert_front.
  prep_matrix_equality.
  bdestruct_all.
  - subst.
    reflexivity.
  - unfold WF_Matrix in H0.
    rewrite H0; trivial.
    lia.
Qed.

Lemma get_vec_col_insert_front_back : forall {n m : nat} (i : nat) (M : Matrix n m) (v : Vector n),
    (i <> 0%nat) -> get_vec i (col_insert_front M v) = get_vec (i - 1)%nat M.
Proof. intros n m i0 M v H0.
  unfold get_vec, col_insert_front.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.


Lemma get_vec_col_append_front : forall {n m : nat} (i : nat) (M : Matrix n m) (v : Vector n),
    (i < m)%nat -> get_vec i (col_append M v) = get_vec i M.
Proof. intros n m i0 M v H0.
  unfold get_vec, col_append, col_wedge.
  prep_matrix_equality.
  bdestruct_all; auto.
Qed.

Lemma get_vec_col_append_back : forall {n m : nat} (i : nat) (M : Matrix n m) (v : Vector n),
    WF_Matrix v -> (i = m) -> get_vec i (col_append M v) = v.
Proof. intros n m i0 M v H0 H1.
  unfold get_vec, col_append, col_wedge.
  prep_matrix_equality.
  bdestruct_all.
  - subst.
    reflexivity.
  - unfold WF_Matrix in H0.
    rewrite H0; trivial.
    lia.
Qed.

Lemma submatrix_column_col_append : forall {n m : nat} (k : nat) (M : Matrix n m) (v : Vector n),
    (k <= m)%nat -> submatrix_column k (col_append M v) = submatrix_column k M.
Proof. intros n m k M v H0.
  unfold submatrix_column.
  unfold col_append, col_wedge.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Lemma submatrix_column_1_get_vec : forall {n m : nat} (M : Matrix n m),
    submatrix_column 1%nat M = get_vec 0%nat M.
Proof. intros n m M.
  unfold submatrix_column, get_vec.
  prep_matrix_equality.
  bdestruct_all; auto.
Qed.

Lemma span_submatrix_column_span_reduce_col :
  forall {n m : nat} (k i : nat) (M : Matrix n (s m)) (v : Vector n),
    (k <= m)%nat -> (i >= k)%nat -> span (submatrix_column k M) v -> span (reduce_col M i) v.
Proof. intros n m k i0 M v H0 H1 H2.
  unfold span in *.
  destruct H2 as [a [H2 H3]].
  exists (fun r c => if (r <? k)%nat then a r c else C0).
  split.
  - unfold WF_Matrix.
    intros.
    bdestruct_all; trivial.
    unfold WF_Matrix in H2.
    rewrite H2; trivial.
    lia.
  - rewrite H3.
    unfold submatrix_column, reduce_col.
    unfold Mmult.
    prep_matrix_equality.
    replace m with (k + (m - k))%nat by lia.
    rewrite @big_sum_sum with (H := C_is_monoid).
    rewrite <- Cplus_0_r with (x := Σ (fun y0 : nat => (if y0 <? k then M x y0 else 0) * a y0 y) k).
    simpl.
    f_equal.
    + apply big_sum_eq_bounded.
      intros.
      bdestruct_all.
      reflexivity.
    + rewrite big_sum_0_bounded; trivial.
      intros.
      bdestruct_all; lca.
Qed. 
    

Lemma span_col_insert_front :
  forall {n m : nat} (P : Vector n -> Prop) (M : Matrix n m) (v : Vector n),
    basis P M -> span M v ->
    (forall u : Vector n, span M u <-> span (col_insert_front M v) u).
Proof. intros n m P M v H0 H1 u.
  split.
  - intros H2.
    unfold span in *.
    unfold basis in *.
    destruct H0 as [H0 [H0' [H0'' H0''']]].
    destruct H1 as [a [H1 H1']].
    destruct H2 as [b [H2 H2']].
    exists (fun r c => if (r =? 0)%nat then C0 else b (r - 1)%nat c).
    split.
    + unfold WF_Matrix.
      intros x y H3.
      bdestruct_all; trivial.
      unfold WF_Matrix in H2.
      rewrite H2; trivial.
      lia.
    + rewrite H2'.
      unfold col_insert_front, Mmult.
      prep_matrix_equality.
      rewrite <- big_sum_extend_l.
      bdestruct_all.
      rewrite Cmult_0_r, Cplus_0_l.
      apply big_sum_eq_bounded.
      intros x0 H4.
      bdestruct_all.
      replace (s x0 - 1)%nat with x0 by lia.
      reflexivity.
  - intros H2. 
    unfold span in *.
    unfold basis in *.
    destruct H0 as [H0 [H0' [H0'' H0''']]].
    destruct H1 as [a [H1 H1']].
    destruct H2 as [b [H2 H2']].
    exists (fun r c => (b 0%nat c) * (a r 0%nat) + (b (r + 1)%nat c)).
    split.
    + unfold WF_Matrix in *.
      intros x y H3.
      destruct H3.
      * rewrite H1; try lia.
        setoid_rewrite H2 at 2; try lia.
        lca.
      * setoid_rewrite H2; try lia.
        lca.
    + rewrite H2'.
      unfold col_insert_front, Mmult.
      prep_matrix_equality.
      rewrite <- big_sum_extend_l.
      bdestruct_all.
      rewrite H1'.
      unfold Mmult.
      simpl.
      rewrite @big_sum_mult_r with (H2 := C_is_ring).
      rewrite <- @big_sum_plus with (H0 := C_is_group).
      2 : apply C_is_comm_group.
      apply big_sum_eq_bounded.
      intros x0 H4.
      simpl.
      replace (x0 - 0)%nat with x0 by lia.
      replace (x0 + 1)%nat with (s x0) by lia.
      lca.
Qed.


 Lemma span_col_append :
  forall {n m : nat} (P : Vector n -> Prop) (M : Matrix n m) (v : Vector n),
    basis P M -> span M v ->
    (forall u : Vector n, span M u <-> span (col_append M v) u).
 Proof. intros n m P M v H0 H1 u.
   split.
   - intros H2.
     unfold span in *.
     unfold basis in *.
     destruct H0 as [H0 [H0' [H0'' H0''']]].
     destruct H1 as [a [H1 H1']].
     destruct H2 as [b [H2 H2']].
     exists (fun r c => if (r <? m)%nat then b r c else C0).
     split.
     + unfold WF_Matrix.
       intros x y H3.
       bdestruct_all; trivial.
       unfold WF_Matrix in H2.
       rewrite H2; trivial.
       lia.
     + rewrite H2'.
       unfold col_append, col_wedge, Mmult.
       prep_matrix_equality.
       simpl.
       bdestruct_all.
       rewrite Cmult_0_r, Cplus_0_r.
       apply big_sum_eq_bounded.
       intros x0 H5.
       bdestruct_all.
       reflexivity.
   - intros H2.
     unfold span in *.
     unfold basis in *.
     destruct H0 as [H0 [H0' [H0'' H0''']]].
     destruct H1 as [a [H1 H1']].
     destruct H2 as [b [H2 H2']].
     exists (fun r c => if (r <? m) then (b m c) * (a r 0%nat) + (b r c) else C0).
     split.
     + unfold WF_Matrix.
       intros x y H3.
       bdestruct_all; trivial.
       unfold WF_Matrix in *.
       rewrite ! H2; try lia.
       lca.
     + rewrite H2'.
       unfold col_append, col_wedge, Mmult.
       prep_matrix_equality.
       simpl.
       bdestruct_all. clear H4.
       rewrite H1'.
       unfold Mmult.
       rewrite @big_sum_mult_r with (H2 := C_is_ring).
       rewrite <- @big_sum_plus with (H0 := C_is_group).
       2 : apply C_is_comm_group.
       apply big_sum_eq_bounded.
       intros x0 H4.
       bdestruct_all.
       lca.
 Qed.

 Lemma get_vec_reduce_col_back : forall {n m : nat} (i col : nat) (A : Matrix n (s m)),
     (i >= col)%nat -> get_vec i (reduce_col A col) = get_vec (1 + i)%nat A.
 Proof. intros n m i0 col A H0.
   unfold get_vec, reduce_col.
   prep_matrix_equality.
   bdestruct_all; reflexivity.
 Qed.

 Lemma get_vec_overflow : forall {n m : nat} (k : nat) (A : Matrix n m),
    (k >= m)%nat -> WF_Matrix A -> get_vec k A = Zero.
Proof. intros n m k A H0 H1.
  prep_matrix_equality.
  unfold get_vec.
  bdestruct_all; trivial.
  unfold WF_Matrix in H1.
  rewrite H1; trivial; lia.
Qed.



Lemma submatrix_column_zero : forall {n m : nat} (A : Matrix n m),
    submatrix_column 0 A = @Zero n 0.
Proof. intros n m A.
  unfold submatrix_column.
  prep_matrix_equality.
  bdestruct_all.
  reflexivity.
Qed.

Lemma get_vec_smash_left : forall {n m o : nat} (i : nat) (A : Matrix n m) (B : Matrix n o),
    (i < m)%nat -> get_vec i (smash A B) = get_vec i A.
Proof. intros n m o i0 A B H0.
  unfold smash, get_vec.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Lemma get_vec_smash_right : forall {n m o : nat} (i : nat) (A : Matrix n m) (B : Matrix n o),
    (i >= m)%nat -> get_vec i (smash A B) = get_vec (i - m) B.
Proof. intros n m o i0 A B H0.
  unfold smash, get_vec.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Lemma get_vec_matrix_column_choose : forall {n m : nat} (i d : nat) (indices_list : list nat) (A : Matrix n m),
    (i < length indices_list)%nat -> WF_Matrix A ->
    get_vec i (matrix_column_choose indices_list A) = get_vec (nth i indices_list d) A.
Proof. intros n m i0 d indices_list A H0 H1. 
  unfold get_vec, matrix_column_choose, list_vector_to_matrix.
  prep_matrix_equality.
  bdestruct_all; trivial.
  assert (@Zero n 1 = get_vec m A).
  { unfold get_vec.
    prep_matrix_equality.
    bdestruct_all; trivial.
    unfold WF_Matrix in H1.
    rewrite H1; trivial.
    lia. }
  rewrite H3.
  rewrite map_nth with (d := m).
  unfold get_vec.
  bdestruct_all.
  rewrite nth_indep with (d := d) (d' := m); trivial.
Qed.

Lemma submatrix_column_smash_left : forall {n m o : nat} (k : nat) (A : Matrix n m) (B : Matrix n o),
    (k <= m)%nat -> submatrix_column k (smash A B) = submatrix_column k A.
Proof. intros n m o k A B H0.
  unfold smash, submatrix_column.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Lemma submatrix_column_smash_right : forall {n m o : nat} (k : nat) (A : Matrix n m) (B : Matrix n o),
    (k > m)%nat -> submatrix_column k (smash A B) = smash A (submatrix_column (k - m) B).
Proof. intros n m o k A B H0.
  unfold smash, submatrix_column.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Lemma submatrix_column_original : forall {n m : nat} (k : nat) (A : Matrix n m),
    WF_Matrix A -> (k >= m)%nat -> submatrix_column k A = A.
Proof. intros n m k A H0 H1.
  unfold submatrix_column.
  prep_matrix_equality.
  bdestruct_all; trivial.
  unfold WF_Matrix in H0.
  rewrite H0; trivial; lia.
Qed.
  
Lemma get_vec_submatrix_column_linearly_dependent : forall {n m : nat} (k : nat) (a : Vector k) (A : Matrix n m),
    (k < m)%nat -> get_vec k A = (submatrix_column k A) × a -> linearly_dependent A.
Proof. intros n m k a A H0 H1.
  unfold linearly_dependent.
  exists (fun r c => if (r <? k)%nat then (if (c =? 0)%nat then a r c else C0)
             else if (r =? k)%nat then (if (c =? 0)%nat then (Copp C1) else C0)
                  else C0).
  repeat split.
  - unfold WF_Matrix.
    intros x y H2.
    bdestruct_all; trivial.
  - intro.
    apply f_equal_inv with (x := k) in H2.
    apply f_equal_inv with (x := 0%nat) in H2.
    simpl in H2.
    rewrite Nat.ltb_irrefl in H2.
    rewrite Nat.eqb_refl in H2.
    inversion H2.
    lra.
  - unfold Mmult.
    prep_matrix_equality.
    replace (@Zero n 1 x y) with C0 by easy.
    replace m with (k + (1 + (m - k - 1)))%nat by lia.
    rewrite big_sum_sum with (m := k).
    rewrite big_sum_sum with (m := 1%nat).
    simpl.
    rewrite Cplus_0_l.
    bdestruct_all.
    + assert (forall x y z : C, x + z = y -> x + (y * (Copp C1) + z) = 0).
      { intros x0 y0 z H5.
        rewrite <- H5.
        lca. }
      apply H5.
      replace (k + 0)%nat with k by lia.
      unfold get_vec in H1.
      apply f_equal_inv with (x := x) in H1.
      apply f_equal_inv with (x := 0%nat) in H1.
      simpl in H1.
      rewrite H1.
      unfold submatrix_column, Mmult.
      rewrite <- Cplus_0_r.
      f_equal.
      * apply big_sum_eq_bounded.
        intros x0 H6.
        bdestruct_all.
        subst.
        reflexivity.
      * rewrite big_sum_0_bounded; trivial.
        intros x0 H6.
        bdestruct_all.
        lca.
    + rewrite Cmult_0_r, Cplus_0_l.
      rewrite <- Cplus_0_r.
      f_equal.
      * rewrite big_sum_0_bounded; trivial.
        intros x0 H5.
        bdestruct_all.
        lca.
      * rewrite big_sum_0_bounded; trivial.
        intros x0 H5.
        bdestruct_all.
        lca.
Qed.
    
Lemma reduce_col_smash_left : forall {n m o : nat} (k : nat) (A : Matrix n (s m)) (B : Matrix n o),
    (k <= m)%nat -> reduce_col (smash A B) k = smash (reduce_col A k) B.
Proof. intros n m o k A B H0.
  unfold smash, reduce_col.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Lemma reduce_col_smash_right : forall {n m o : nat} (k : nat) (A : Matrix n m) (B : Matrix n (s o)),
    (k >= m)%nat -> reduce_col (smash A B) k = smash A (reduce_col B (k - m)).
Proof. intros n m o k A B H0.
  unfold smash, reduce_col.
  prep_matrix_equality.
  bdestruct_all; trivial.
  replace (1 + (y - m))%nat with (1 + y - m)%nat by lia.
  reflexivity.
Qed.

Lemma reduce_col_submatrix_column_last : forall {n m : nat} (j : nat) (A : Matrix n m),
    reduce_col (submatrix_column (s j) A) j = submatrix_column j A.
Proof. intros n m j A.
  unfold submatrix_column, reduce_col.
  prep_matrix_equality.
  bdestruct_all; trivial.
Qed.

Definition delete_nth {A : Type} (l : list A) (n : nat) := firstn n l ++ skipn (n + 1) l.
Compute (delete_nth [0; 1; 2; 3]%nat 0). (* = [1; 2; 3]%nat *)
Compute (delete_nth [0; 1; 2; 3]%nat 1). (* = [0; 2; 3]%nat *)

Lemma reduce_col_matrix_column_choose_delete : forall {n m : nat} (k : nat) (indices_list : list nat) (A : Matrix n m),
    WF_Matrix A -> (length indices_list > k)%nat->
    reduce_col (matrix_column_choose indices_list A) k = matrix_column_choose (delete_nth indices_list k) A.
Proof. intros n m k indices_list A H0 H1. 
  unfold reduce_col, delete_nth, matrix_column_choose, list_vector_to_matrix.
  prep_matrix_equality.
  assert (@Zero n 1 = get_vec m A).
  { unfold get_vec.
    prep_matrix_equality.
    bdestruct_all; trivial.
    unfold WF_Matrix in H0.
    rewrite H0; trivial; lia. }
  bdestruct_all.
  - rewrite <- firstn_skipn with (n := k) (l := indices_list) at 1.
    rewrite ! H2.
    rewrite ! map_nth with (d := m).
    unfold get_vec.
    bdestruct_all.
    f_equal.
    rewrite ! app_nth1; trivial; rewrite firstn_length; lia.
  - rewrite H2.
    rewrite ! map_nth with (d := m).
    unfold get_vec.
    bdestruct_all.
    f_equal.
    rewrite app_nth2.
    + rewrite firstn_length.
      replace (Init.Nat.min k (length indices_list)) with k by lia.
      rewrite <- firstn_skipn with (n := (k + 1)%nat) at 1.
      rewrite app_nth2.
      * rewrite firstn_length.
        replace (Init.Nat.min (k + 1) (length indices_list)) with (k + 1)%nat by lia.
        f_equal.
        lia.
      * rewrite firstn_length.
        lia.
    + rewrite firstn_length.
      lia.
Qed.

Lemma length_delete_nth : forall {A : Type} (l : list A) (k : nat),
    (k < length l)%nat -> length (delete_nth l k) = ((length l) - 1)%nat.
Proof. intros A l k H0. 
  unfold delete_nth.
  rewrite app_length.
  rewrite firstn_length.
  rewrite skipn_length.
  lia.
Qed.

Lemma incl_firstn_next : forall {A : Type} (l : list A) (k : nat),
    incl (firstn k l) (firstn (s k) l).
Proof. unfold incl.
  intros A l k a H0.
  gen l.
  induction k.
  - intros.
    simpl in H0.
    contradiction.
  - intros.
    destruct l.
    + inversion H0.
    + simpl in H0.
      destruct H0.
      * simpl.
        auto.
      * right.
        auto.
Qed.

Lemma incl_skipn_previous : forall {A : Type} (l : list A) (k : nat),
    incl (skipn (s k) l) (skipn k l).
Proof. unfold incl.
  intros A l k a H0.
    gen l.
  induction k.
  - intros.
    simpl.
    destruct l.
    + inversion H0.
    + simpl in H0.
      simpl.
      auto.
  - intros. 
    destruct l.
    + inversion H0.
    + simpl.
      apply IHk.
      simpl in H0.
      apply H0.
Qed.

Lemma incl_delete_nth_original : forall {A : Type} (l : list A) (k : nat),
    incl (delete_nth l k) l.
Proof. intros A l k.
  unfold incl, delete_nth.
  intros a H0.
  rewrite in_app_iff in H0.
  destruct H0.
  - induction l.
    + rewrite firstn_nil in H0.
      assumption.
    + destruct k.
      * simpl in *.
        contradiction.
      * rewrite firstn_cons in H0.
        simpl in H0.
        simpl.
        destruct H0.
        -- left; assumption.
        -- right.
           apply IHl.
           apply incl_firstn_next; trivial.
  - induction k.
    + replace l with (skipn 0%nat l) by easy.
      apply incl_skipn_previous.
      assumption.
    + apply IHk.
      apply incl_skipn_previous.
      assumption.
Qed.

Lemma incl_delete_nth : forall {A : Type} (l l' : list A) (k : nat),
    incl l l' -> incl (delete_nth l k) l'.
Proof. intros A l l' k H0.
  apply (incl_tran (incl_delete_nth_original l k)) in H0.
  assumption.
Qed.

Lemma matrix_column_choose_empty : forall {n m : nat} (A : Matrix n m),
    matrix_column_choose [] A = Zero.
Proof. intros n m A.
  unfold matrix_column_choose, list_vector_to_matrix.
  prep_matrix_equality.
  simpl.
  destruct y; auto.
Qed.


 (** separate lemma of invariant for Theorem 34 *)
Lemma invariant_span : forall {n m o : nat} (P : Vector n -> Prop) (M : Matrix n m) (A : Matrix n o),
    WF_Matrix M -> WF_Matrix A -> basis P M ->
    (forall i : nat, (i < o)%nat -> P (get_vec i A)) -> (o > m)%nat ->
    (forall i : nat, (i < m)%nat -> get_vec i M <> Zero) ->
    (forall i : nat, (i < o)%nat -> get_vec i A <> Zero) ->
    forall j , (j <= m)%nat ->
          (linearly_dependent (submatrix_column j A) \/
             (exists indices_list : list nat,
                 length indices_list = (m - j)%nat /\
                   incl indices_list (List.seq 0 m) /\
                   (forall v : Vector n,
                       span M v <->
                         (span
                            (smash
                               (submatrix_column j A)
                               (matrix_column_choose indices_list M))
                            v)))).
Proof. intros n m o P M A H0 H1 H2 H3 H4 nonzero_col_M nonzero_col_A  j H5.
  induction j.
  - right.
    exists (List.seq 0 m).
    split.
    + rewrite seq_length. lia.
    + split.
      * unfold incl.
        intros a H6.
        assumption.
      * intros v.
        -- assert (H7 : submatrix_column 0 A = @Zero n 0).
           { apply submatrix_column_zero. }
           rewrite H7.
           assert (H8 : matrix_column_choose (List.seq 0 m) M = M).
           { apply matrix_column_choose_original.
             assumption. }
           rewrite H8.
           assert (H9 : smash (@Zero n 0) M = M).
           { prep_matrix_equality.
             unfold smash.
             bdestruct_all.
             replace (y - 0)%nat with y by lia.
             reflexivity. }
           rewrite seq_length.
           rewrite H9.
           split; auto.
  - assert (H6 : (j <= m)%nat). { lia. }
    specialize (IHj H6).
    destruct IHj as [H7 | H7].
    + left.
      assert (H8 : submatrix_column j A = submatrix_column j (submatrix_column (s j) A)).
      { rewrite subsubmatrix_column_inner; auto. }
      rewrite H8 in H7.
      apply linearly_dependent_submatrix_column in H7; auto.
    + destruct H7 as [indices_list [length_indices_list [incl_indices_list eq_span]]].
      assert (H7 : WF_Matrix (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M))).
      { auto with wf_db. }
      assert (H8 : forall i : nat, (i < s m)%nat ->
                       get_vec i (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) <> @Zero n (s m)).
      { intros i0 H8.
        bdestruct (i0 <? s j).
        - rewrite get_vec_smash_left; try lia.
          rewrite get_vec_submatrix_column; try lia.
          apply nonzero_col_A; lia.
        - rewrite get_vec_smash_right; try lia.
          rewrite get_vec_matrix_column_choose with (d := 0%nat); trivial; try lia.
          apply nonzero_col_M.
          assert (H10 : In (nth (i0 - s j) indices_list 0%nat) indices_list). { apply nth_In; lia. }
          apply incl_indices_list in H10.
          rewrite in_seq in H10.
          lia. }
      assert (H9 : linearly_dependent
                (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M))).
      { unfold linearly_dependent.
        assert (H9 : span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) (get_vec j A)).
        { rewrite <- eq_span.
          unfold basis in H2.
          destruct H2 as [subspaceP [MinP [MspansP lin_indep_m]]].
          apply MspansP.
          apply H3.
          lia. }
        unfold span in H9.
        destruct H9 as [a [WFa H9]].
        exists (fun r c => if (r <? j)%nat then a r c else
                     if (r =? j)%nat then
                       if (c =? 0)%nat then (Copp C1) else C0
                     else a (r - 1)%nat c).
        repeat split.
        - unfold WF_Matrix.
          intros x y H10.
          unfold WF_Matrix in WFa.
          bdestruct_all; trivial.
          + rewrite WFa; trivial; lia.
          + rewrite WFa; trivial; lia.
        - intro H10.
          apply f_equal_inv with (x := j) in H10.
          apply f_equal_inv with (x := 0%nat) in H10.
          simpl in H10.
          rewrite Nat.ltb_irrefl in H10.
          rewrite Nat.eqb_refl in H10.
          inversion H10; lra.
        - unfold smash, submatrix_column, matrix_column_choose, list_vector_to_matrix, Mmult.
          prep_matrix_equality.
          replace (@ Zero n 1 x y) with C0 by easy.
          rewrite length_indices_list.
          replace (s j + (m - j))%nat with ((j) + ((1) + (m - j)))%nat by lia.

          rewrite big_sum_sum with (m := j) (n := (1 + (m - j))%nat).
          rewrite big_sum_sum with (m := 1%nat) (n := (m - j)%nat).
          assert (H10 : forall x y z : C, x + (y + z) = (x + z) + y). { intros. lca. }
          rewrite H10.
          simpl.
          rewrite Cplus_0_l.
          bdestruct_all; trivial.
          
          + subst.
            clear H10. clear H11. clear H12.  clear H14.
            assert (H10 : forall x y z : C, x + y = z -> (x + y) + z * (Copp C1) = 0).
            { intros.
              rewrite H10.
              lca. }
            apply H10.
            replace (j + 0)%nat with j by lia.
            apply f_equal_inv with (x := x) in H9.
            apply f_equal_inv with (x := 0%nat) in H9.
            unfold get_vec in H9.
            simpl in H9.
            rewrite H9.
            unfold smash, submatrix_column, matrix_column_choose, list_vector_to_matrix, Mmult.
            rewrite length_indices_list.
            rewrite big_sum_sum with (m := j) (n := (m - j)%nat).
            simpl.
            f_equal.
            * apply big_sum_eq_bounded.
              intros x0 H11.
              bdestruct_all.
              reflexivity.
            * apply big_sum_eq_bounded.
              intros x0 H11.
              bdestruct_all.
              replace (j + s x0 - s j)%nat with x0 by lia.
              replace (j + x0 - j)%nat with x0 by lia.
              replace (j + s x0 - 1)%nat with (j + x0)%nat by lia.
              reflexivity.
          + unfold WF_Matrix in WFa.
            rewrite Cmult_0_r, Cplus_0_r.
            rewrite <- Cplus_0_r.
            f_equal.
            * rewrite big_sum_0_bounded; trivial.
              intros x0 H15.
              bdestruct_all.
              rewrite WFa; trivial.
              -- lca.
              -- lia.
            * rewrite big_sum_0_bounded; trivial.
              intros x0 H15.
              bdestruct_all.
              rewrite WFa; trivial.
              -- lca.
              -- lia. }
      
      assert (H10 : (s m = s j + length indices_list)%nat).
      { rewrite length_indices_list. rewrite <- Nat.add_1_r. lia. }
      rewrite H10 in H8.
      pose (linearly_dependent_bounded_linear_combination
              (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M))
              H7 H8 H9) as H11.
      destruct H11 as [k [H11 [a [WFa H12]]]].
(* split k into two cases: 
1. when k corresponds to (submatrix_column (s j) A)
2. when k corresponds to (matrix_column_choose indices_list M)
bdestruct (k <? s j). *)
      bdestruct (k <? s j).
      * (* For case 1: k < s j *)
        (* We can get "get_vec k (submatrix_column (s j) A)
           = (submatrix_column k (submatrix_column (s j) A)) × a" *)
        rewrite get_vec_smash_left in H12; try lia.
        rewrite submatrix_column_smash_left in H12; try lia.
        (* Prove that  (submatrix_column (s j) A) is linearly_dependent by proving a separate lemma "get_vec k A = (submatrix_column k A) × a -> linearly_dependent A" then substitute A with (submatrix_column (s j) A) to get "linearly_dependent (submatrix_column (s j) A)" *)
        apply get_vec_submatrix_column_linearly_dependent with (k := k) (a := a) (A := (submatrix_column (s j) A)) in H12; auto.
      * (* For case 2: k >= s j *)
        (* We prove the assertion "span (submatrix_column k (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M))) (get_vec k (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)))" *)
        assert (H14 : span (submatrix_column k (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M))) (get_vec k (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)))).
        { unfold span.
          exists a.
          auto. }
        (* Then, by using "span_submatrix_column_span_reduce_col" we prove the assertion "span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) k) (get_vec k (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)))" *)
        apply span_submatrix_column_span_reduce_col with (i := k) in H14; auto.
        2: { rewrite length_indices_list.
             assert (k <= j + (m - j))%nat; trivial; lia. }
        (* Then, by using "equal_span_reduce_col" and "equal_span_reduce_col_inv" we can prove the assertion "∀ u, span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u <-> span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) k) u" *)
        assert (H15 : forall u, span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u <-> span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) k) u).
        { intros u.
          split.
          - intros H15.
            apply equal_span_reduce_col; trivial.
            rewrite length_indices_list.
            assert (k < s (j + (m - j)))%nat; trivial; lia.
          - intros H15.
            apply equal_span_reduce_col_inv with (i := k); trivial.
            rewrite length_indices_list.
            assert (k < s (j + (m - j)))%nat; trivial; lia. }
        (* We can directly prove the assertion "∀ u, span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) u -> span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u" *)
        assert (H16 : forall u, span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) u -> span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u).
        { intros u H16.
          unfold span.
          unfold span in H16.
          rewrite length_indices_list in *.
          replace (j + (m - j))%nat with m in H16 by lia.
          replace (s j + (m - j))%nat with (s m) by lia.
          destruct H16 as [b [WFb H16]].
          exists (fun r c => if (r <? j)%nat then b r c else if (r =? j)%nat then C0 else b (r - 1)%nat c).
          split.
          - unfold WF_Matrix.
            intros x y H17.
            bdestruct_all; trivial.
            assert (y >= 1)%nat; auto; try lia.
            destruct H17; auto.
            assert (x - 1 >= m)%nat; auto; lia.
          - rewrite H16.
            unfold smash, Mmult, submatrix_column.
            prep_matrix_equality.
            replace m with (j + (m - j))%nat at 1 by lia.
            rewrite big_sum_sum with (m := j) (n := (m - j)%nat) at 1.
            replace (s m) with (j + ((s m) - j))%nat at 1 by lia.
            rewrite big_sum_sum with (m := j) (n := ((s m) - j)%nat) at 1.
            f_equal.
            + apply big_sum_eq_bounded.
              intros x0 H17.
              bdestruct_all; trivial.
            + replace (s m - j)%nat with (1 + (m - j))%nat at 1 by lia.
              rewrite big_sum_sum with (m := 1%nat) (n := (m - j)%nat) at 1.
              simpl.
              rewrite ! Cplus_0_l.
              rewrite <- Cplus_0_l at 1.
              f_equal.
              * bdestruct_all.
                lca.
              * apply big_sum_eq_bounded.
                intros x0 H17.
                bdestruct_all.
                replace (j + x0 - j)%nat with x0 by lia.
                replace (j + s x0 - s j)%nat with x0 by lia.
                replace (j + s x0 - 1)%nat with (j + x0)%nat by lia.
                reflexivity. }
        (* Using "forall i : nat, (i < o)%nat -> P (get_vec i A)" and "basis P M" and "∀ v, span M v <-> span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) v" and by proving the assertion "get_vec j (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) = get_vec j A" we can prove the assertion "span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) (get_vec j (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)))" *)
        assert (H17 : span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) (get_vec j (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)))).
        { rewrite get_vec_smash_left; try lia.
          rewrite get_vec_submatrix_column; try lia.
          rewrite <- eq_span.
          unfold basis in H2.
          destruct H2 as [subspaceP [MinP [MspansP lin_indep_M]]].
          apply MspansP.
          apply H3.
          lia. }
        (* By proving a separate general lemma "k <= size of A -> reduce_col (smash A B) k = smash (reduce_col A k) B" and by proving a separate lemma "reduce_col (submatrix_column (s j) A) j = submatrix_column j A", we can prove the assertion "smash (submatrix_column j A) (matrix_column_choose indices_list M) = reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) j" *)
        assert (H18 : smash (submatrix_column j A) (matrix_column_choose indices_list M) = reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) j).
        { rewrite reduce_col_smash_left, reduce_col_submatrix_column_last; trivial. }
        (* By combining the above assertions, we can get the assertion "span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) j) (get_vec j (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)))" *)
        rewrite H18 in H17.
        (* By using the lemma "equal_span_reduce_col", we can get the assertion "∀ u, span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u -> span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) j) u" *)
        assert (H19 : forall u, span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u -> span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) j) u).
        { intros u H19.
          apply equal_span_reduce_col; trivial.
          rewrite length_indices_list.
          assert (j < 1 + (j + (m - j)))%nat; trivial; lia. }
        (* By combining the above assertions, we can get the assertion "∀ u, span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u -> span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) u" *)
        rewrite <- H18 in H19.
        (* Thus, we get the assertion "∀ u, span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) u <-> span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u" *)
        assert (H20 : forall u, span (smash (submatrix_column j A) (matrix_column_choose indices_list M)) u <-> span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u).
        { intros u.
          split; auto. }
        (* We can now obtain the assertion "∀ u, span M u <-> span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u" *)
        assert (H21 : forall u, span M u <-> span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) u).
        { intros u.
          split.
          - intros H21.
            rewrite <- H20, <- eq_span; trivial.
          - intros H21.
            rewrite eq_span, H20; trivial. }
        (* By using the above assertions, we can obtain the assertion "∀ u, span M u <-> span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) k) u" *)
        assert (H22 : forall u, span M u <-> span (reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) k) u).
        { intros u.
          split.
          - intros H22.
            rewrite <- H15, <- H21; trivial.
          - intros H22.
            rewrite H21, H15; trivial. }
        (* We need to show that "reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) k = smash (submatrix_column (s j) A) (reduce_col (matrix_column_choose indices_list M) (k - # around (s j)))". We can do this by proving a separate general lemma "k > size of A -> reduce_col (smash A B) k = smash A (reduce_col B (k - size of A))" *)
        assert (H23 : reduce_col (smash (submatrix_column (s j) A) (matrix_column_choose indices_list M)) k = @smash n (s j) (m - j - 1)%nat (submatrix_column (s j) A) (reduce_col (matrix_column_choose indices_list M) (k - (s j)))).
        { rewrite ! length_indices_list.
          replace (Init.Nat.sub m j) with (Datatypes.S (Init.Nat.sub (Init.Nat.sub m j) (Datatypes.S O))) by lia.
          replace ((fix add (n0 m0 : nat) {struct n0} : nat :=
           match n0 return nat with
           | O => m0
           | Datatypes.S p => Datatypes.S (add p m0)
           end) j (Datatypes.S (Init.Nat.sub (Init.Nat.sub m j) (Datatypes.S O))))
            with
            (Init.Nat.add (Datatypes.S j) (Init.Nat.sub (Init.Nat.sub m j) (Datatypes.S O)))
            by (rewrite Nat.add_succ_comm; trivial).
          rewrite reduce_col_smash_right; easy. }
        (* We show that "reduce_col (matrix_column_choose indices_list M) (k - # around (s j)) = matrix_column_choose indices_list0 M". We can do this by proving a separate general lemma "reduce_col (matrix_column_choose indices_list M) k = matrix_column_choose (delete the kth element of indices_list) M". We delete the kth element in "indices_list" to create indices_list0. Define : firstn n l ++ skipn (n + 1) l  <- ??? try to compute on a concrete sequence *)
        setoid_rewrite reduce_col_matrix_column_choose_delete with (k := (k - s j)%nat) in H23; trivial; try lia.
        (* Using the above, we obtain the assertion "∀ u, span M u <-> span (smash (submatrix_column (s j) A) (matrix_column_choose indices_list0 M)) u" *)
        rewrite H23 in H22.
        (* Additionally, we need to show "length indices_list0 = (m - s j)%nat" and "incl indices_list0 (List.seq 0 m)". You might need to prove separate additional lemmas about lists to prove these. *)
        right.
        exists (delete_nth indices_list (k - s j)%nat).
        split.
        -- rewrite length_delete_nth, length_indices_list; lia.
        -- split.
           ++ apply incl_delete_nth; trivial.
           ++ intros v.
              split.
              ** intros H24.
                 rewrite length_delete_nth; try lia.
                 assert (H25 : (Init.Nat.add (Datatypes.S j)
                            (Init.Nat.sub (@length nat indices_list) (Datatypes.S O)))
                         =
                           ((fix add (n m : nat) {struct n} : nat :=
                               match n return nat with
                               | O => m
                               | Datatypes.S p => Datatypes.S (add p m)
                               end) j (@length nat indices_list))).
                 { rewrite length_indices_list, Nat.add_succ_comm.
                   replace (Init.Nat.add j (Datatypes.S (Init.Nat.sub (Init.Nat.sub m j) (Datatypes.S O)))) with m by lia.
                   replace ((fix add (n0 m0 : nat) {struct n0} : nat :=
                               match n0 return nat with
                               | O => m0
                               | Datatypes.S p => Datatypes.S (add p m0)
                               end) j (Init.Nat.sub m j))
                     with
                     (Init.Nat.add j (Init.Nat.sub m j))
                     by trivial.
                   lia. }
                 rewrite H25.
                 rewrite <- H22.
                 assumption.
              ** intros H24.
                 rewrite H22.
                 rewrite length_delete_nth, length_indices_list in H24; try lia.
                 rewrite length_indices_list.
                 assert (H25 : (Init.Nat.add (Datatypes.S j)
                                  (Init.Nat.sub (Init.Nat.sub m j) (Datatypes.S O)))
                               =
                                 ((fix add (n m : nat) {struct n} : nat :=
                                     match n return nat with
                                     | O => m
                                     | Datatypes.S p => Datatypes.S (add p m)
                                     end) j (Init.Nat.sub m j))).
                 { rewrite Nat.add_succ_comm.
                   replace (Init.Nat.add j (Datatypes.S (Init.Nat.sub (Init.Nat.sub m j) (Datatypes.S O)))) with m by lia.
                   replace ((fix add (n0 m0 : nat) {struct n0} : nat :=
                               match n0 return nat with
                               | O => m0
                               | Datatypes.S p => Datatypes.S (add p m0)
                               end) j (Init.Nat.sub m j))
                     with
                     (Init.Nat.add j (Init.Nat.sub m j))
                     by trivial.
                   lia. }
                 rewrite H25 in H24.
                 assumption.
Qed.

Lemma invariant_span_final_step : forall {n m o : nat} (P : Vector n -> Prop) (M : Matrix n m) (A : Matrix n o),
    WF_Matrix M -> WF_Matrix A -> basis P M ->
    (forall i : nat, (i < o)%nat -> P (get_vec i A)) -> (o > m)%nat ->
    (forall v : Vector n, span M v <-> span (submatrix_column m A) v) -> linearly_dependent A.
Proof. intros n m o P M A H0 H1 H2 H3 H4 H5.
  (** Show that the m+1 th column (get_vec m A) of A is a linear combination of (submatrix_column m A): (span (submatrix_column m A) (get_vec m A)) **)
  unfold basis in H2.
  destruct H2 as [subspaceP [MinP [MspansP lin_indep_M]]].
  specialize (H3 m H4).
  specialize (MspansP (get_vec m A) H3).
  rewrite H5 in MspansP.
  unfold span in MspansP.
  destruct MspansP as [a [WFa H6]].
  (** Use the lemma "get_vec_submatrix_column_linearly_dependent" to show (linearly_dependent A) **)
  apply (get_vec_submatrix_column_linearly_dependent m a A H4 H6).
Qed.


(** Theorem 34 Let V be a finite-dimensional vector space over a field F, and let {u1,u2,...,um} be a basis for V. If v1,v2,...,vn are any n vectors in V, with n > m, then {v1, v2, . . . , vn} is linearly dependent. **)
(*** Classical Logic used ***)
Lemma dimension_overflow : forall {n m o : nat} (P : Vector n -> Prop) (M : Matrix n m) (A : Matrix n o),
    WF_Matrix M -> WF_Matrix A ->
    basis P M -> (forall i : nat, (i < o)%nat -> P (get_vec i A)) -> (o > m)%nat -> linearly_dependent A.
Proof. intros n m o P M A WFM WFA basisM AinP overflow.
  destruct (Classical_Prop.classic (forall i : nat, (i < m)%nat -> get_vec i M <> Zero)) as [M_nonzero_cols | M_some_zero_cols].
  2 : { apply some_zero_vector_linearly_dependent in M_some_zero_cols.
        unfold basis in basisM.
        destruct basisM as [subspaceP [MinP [MspansP lin_indep_M]]].
        apply lindep_implies_not_linindep in M_some_zero_cols.
        contradiction. }  
  destruct (Classical_Prop.classic (forall i : nat, (i < o)%nat -> get_vec i A <> Zero)) as [A_nonzero_cols | A_some_zero_cols].
  2 : { apply some_zero_vector_linearly_dependent in A_some_zero_cols.
        assumption. }
  remember basisM as basisM'. clear HeqbasisM'.
  unfold basis in basisM'.
  destruct basisM' as [subspaceP [MinP [MspansP lin_indep_M]]].
  assert (m_leq_m : (m <= m)%nat); auto.
  destruct (invariant_span P M A WFM WFA basisM AinP overflow M_nonzero_cols A_nonzero_cols m m_leq_m) as [lin_dep_A_m | [indices_list [length_indices_list [incl_indices_list_seq eq_span]]]].
  - apply linearly_dependent_submatrix_column in lin_dep_A_m; assumption.
  - replace (m - m)%nat with 0%nat in length_indices_list by lia.
    rewrite length_zero_iff_nil in length_indices_list.
    rewrite length_indices_list in eq_span.
    rewrite matrix_column_choose_empty in eq_span.
    rewrite smash_zero in eq_span; auto with wf_db.
    simpl in eq_span.
    rewrite Nat.add_0_r in eq_span.
    apply (invariant_span_final_step P M A WFM WFA basisM AinP overflow eq_span).
Qed.


(* Corollary 35 Let V be a vector space over a field F, and let {u1,u2,...,un}
and {v1,v2,...,vm} be two bases for V. Then m=n.
Proof Since {u1,u2,...,un} is a basis for V and {v1,v2,...,vm} is linearly independent, Theorem 34 implies that m ≤ n. But the same reasoning implies that n ≤ m, and so m = n must hold. *)
Lemma basis_equal_number : forall {n m o : nat} (P : Vector n -> Prop) (A : Matrix n m) (B : Matrix n o),
    WF_Matrix A -> WF_Matrix B -> basis P A -> basis P B -> m = o.
Proof. intros n m o P A B WFA WFB basisA basisB.
  remember basisA as basisA'. clear HeqbasisA'.
  remember basisB as basisB'. clear HeqbasisB'.
  unfold basis in basisA', basisB'.
  destruct basisA' as [subspaceP [AinP [AspansP lin_indep_A]]].
  destruct basisB' as [subspaceP' [BinP [BspansP lin_indep_B]]].
  bdestruct (o <=? m)%nat.
  - bdestruct (m <=? o)%nat.
    + lia.
    + pose (dimension_overflow P B A WFB WFA basisB AinP H1) as lin_dep_B.
      apply lindep_implies_not_linindep in lin_dep_B.
      contradiction.
  - pose (dimension_overflow P A B WFA WFB basisA BinP H0) as lin_dep_B.
    apply lindep_implies_not_linindep in lin_dep_B.
    contradiction.
Qed.

(* Definition 36 Let V be a finite-dimensional vector space. If V is the trivial vector space, then we say that the dimension of V is zero; otherwise, the dimension of V is the number of vectors in a basis for V . *)

Definition dimension {n : nat} (P : Vector n -> Prop) (d : nat) := exists (A : Matrix n d), WF_Matrix A /\ basis P A.
Check dimension.

(* Inductive dimension {n : nat} (P : Vector n -> Prop) (d : nat) :=
| dim : forall (A : Matrix n d), basis P A -> dimension P d.

Definition dimension {n : nat} (P : Vector n -> Prop) := { d : nat & {A : Matrix n d | basis P A } }. *)

Lemma subspace_dimension : forall {n : nat} {P Q : Vector n -> Prop} {d1 d2 : nat},
    subspace P -> subspace Q -> (forall v, Q v -> P v) -> dimension Q d1  -> dimension P d2 ->
    (d1 <= d2)%nat.
Proof. intros n P Q d1 d2 H0 H1 H2 H3 H4.
  bdestruct (d1 <=? d2)%nat; auto.
  unfold dimension in *.
  destruct H3 as [A1 [WFA1 bA1]].
  destruct H4 as [A2 [WFA2 bA2]].
  unfold basis in bA1.
    destruct bA1 as [sQ [A1inQ [A1spQ indA1]]].
  assert (forall i, (i < d1)%nat -> P (get_vec i A1)).
  { intros i0 H3.
    apply H2.
    apply A1inQ; auto. }
  pose (dimension_overflow P A2 A1 WFA2 WFA1 bA2 H3 H5) as H6.
  apply lindep_implies_not_linindep in H6.
  contradiction.
Qed.

Lemma unique_dimension : forall {n d1 d2 : nat} (P : Vector n -> Prop),
    dimension P d1 -> dimension P d2 -> d1 = d2.
Proof. intros n d1 d2 P H0 H1.
  unfold dimension in *.
  destruct H0 as [A [WFA basisA]].
  destruct H1 as [B [WFB basisB]].
  apply (basis_equal_number P A B WFA WFB basisA basisB).
Qed.

Lemma list_vector_to_matrix_nil : forall n : nat, @list_vector_to_matrix n nil = Zero.
Proof. intros n.
  unfold list_vector_to_matrix.
  prep_matrix_equality.
  destruct y; auto.
Qed.


(** Probably not needed

(*** Admitted. ***)
Lemma get_vec_list_vector_to_matrix_nth : forall {i n : nat} {l : list (Vector n)} ,
    Forall WF_Matrix l -> get_vec i (list_vector_to_matrix l) = nth i l (@Zero n 1).
Proof. intros i0 n l H0.
  unfold get_vec, list_vector_to_matrix.
  prep_matrix_equality.
  bdestruct_all; auto.
  admit.
Admitted.

(*** Admitted. ***)
Lemma f_to_vec_vec : forall {n : nat} {a : Vector n},
    WF_Matrix a -> f_to_vec n (fun r => a r 0%nat) =  a.
Proof. Admitted.

(*** Admitted. ***)
Lemma list_vector_to_matrix_times_vector_big_sum : forall {n : nat} {l : list (Vector n)} {a : Vector (length l)},
    Forall WF_Matrix l -> WF_Matrix a ->
    (list_vector_to_matrix l) × a = big_sum (fun i : nat =>  (a i 0%nat) .* (nth i l (@Zero n 1))) (length l).
Proof. (* use Msum_to_Mmult *) Admitted.
 *)

Lemma map_const_repeat : forall {A B : Type} {a : A} {l : list B},
    map (fun x => a) l = repeat a (length l).
Proof. intros A B a l.
  induction l; auto.
  simpl. rewrite IHl.
  reflexivity.
Qed.

Lemma zero_all_zero : forall {n : nat} {a : Vector n},
    WF_Matrix a -> ((forall i, (i < n)%nat -> a i 0%nat = C0) <-> a = Zero).
Proof. intros n a H0.
  split; intros.
  - prep_matrix_equality.
    bdestruct (y <? 1)%nat.
    + replace y with 0%nat by lia.
      bdestruct (x <? n)%nat.
      * rewrite H1; auto.
      * rewrite H0; auto; lia.
    + rewrite H0; auto; lia.
  - rewrite H1; auto.
Qed.

Lemma repeat_nth : forall {A : Type} {a : A} {l : list A},
    l = repeat a (length l) <-> (forall i, nth i l a = a).
Proof. intros A a l.
  split; intros.
  - rewrite H0, nth_repeat; reflexivity.
  - apply nth_ext with (d := a) (d' := a).
    + rewrite repeat_length; auto.
    + intros n H1.
      rewrite H0.
      rewrite nth_repeat.
      reflexivity.
Qed.

Lemma permutation_repeat_nth : forall {A : Type} {a : A} {l : list A},
    Permutation l (repeat a (length l)) <-> (forall i, nth i l a = a).
Proof. intros A a l.
  split; intros.
  - rewrite Permutation_nth in H0.
    destruct H0 as [H0 [f [H1 [H2 H3]]]].
    remember H2 as H4. clear HeqH4.
    rewrite FinFun.bInjective_bSurjective in H4; auto.
    destruct (FinFun.bSurjective_bBijective H1 H4) as [g [H5 H6]].
    bdestruct (i <? length l)%nat.
    + destruct (H6 i H7) as [H8 H9].
      unfold FinFun.bFun in H5.
      specialize (H5 i H7).
      specialize (H3 (g i) H5).
      rewrite H9 in H3.
      rewrite <- H3.
      rewrite nth_repeat.
      reflexivity.
    + rewrite nth_overflow; auto; lia.
  - rewrite <- repeat_nth in H0.
    rewrite <- H0.
    apply Permutation_refl.
Qed.

Lemma permutation_list_vector_to_matrix_times_vector : forall {n : nat} {l1 l2 : list (Vector n)},
    Permutation l1 l2 ->
    forall a : Vector (length l1), WF_Matrix a ->
            exists b : Vector (length l2), WF_Matrix b /\
                    (list_vector_to_matrix l1) × a = (list_vector_to_matrix l2) × b /\
                    Permutation (map (fun i => a i 0%nat) (List.seq 0 (length l1))) (map (fun i => b i 0%nat) (List.seq 0 (length l2))).
Proof. intros n l1 l2 H0 a H1.
  induction H0.
  - exists Zero.
    repeat (split; auto with wf_db).
  - assert (@WF_Matrix (length l) 1%nat (fun r c => a (r + 1)%nat c)).
    { unfold WF_Matrix.
      intros x0 y H2.
      apply Permutation_length in H0.
      simpl in *.
      rewrite H1; auto; destruct H2; lia. }
    destruct (IHPermutation (fun r c => a (r + 1)%nat c) H2) as [b [WFb [eqn perm]]].
    exists (fun r c => if (r =? 0)%nat then a 0%nat c else b (r - 1)%nat c).
    repeat (split; auto with wf_db).
    + unfold WF_Matrix.
      intros x0 y H3. 
      apply Permutation_length in H0.
      simpl in *.
      bdestruct_all.
      * subst.
        rewrite H1; auto; lia.
      * rewrite WFb; auto; lia.
    + unfold list_vector_to_matrix, Mmult.
      prep_matrix_equality.
      replace (length (x :: l)) with (s (length l)) by easy.
      replace (length (x :: l')) with (s (length l')) by easy.
      rewrite ! big_sum_shift.
      f_equal.
      apply Permutation_length in H0.
      rewrite H0 in *.
      unfold list_vector_to_matrix, Mmult in eqn.
      apply f_equal_inv with (x := x0) in eqn.
      apply f_equal_inv with (x := y) in eqn.

      assert ((fun x1 : nat => nth (s x1) (x :: l) Zero x0 0%nat * a (s x1) y)
              = (fun x1 : nat => nth x1 l Zero x0 0%nat * a (x1 + 1)%nat y))
        by (apply functional_extensionality; intros; rewrite Nat.add_1_r; auto).
      rewrite H3, eqn.
      apply big_sum_eq_bounded.
      intros x1 H4.
      simpl.
      replace (x1 - 0)%nat with x1 by lia.
      reflexivity.
    + simpl.
      apply Permutation_cons; auto.
      assert ((map (fun i0 : nat => a i0 0%nat) (List.seq 1 (length l)))
              = (map (fun i : nat => a (i + 1)%nat 0%nat) (List.seq 0 (length l)))).
      { apply nth_ext with (d := C0) (d' := C0).
        - rewrite ! map_length, ! seq_length; reflexivity.
        - intros n0 H3.
          rewrite nth_indep with (d' := a 0%nat 0%nat); auto.
          rewrite map_nth with (f := (fun i0 : nat => a i0 0%nat)) (d := 0%nat).
          rewrite nth_indep with (d' := a (0 + 1)%nat 0%nat); auto.
          rewrite map_nth with (f := (fun i0 : nat => a (i0 + 1)%nat 0%nat)) (d := 0%nat).
          f_equal.
          rewrite ! seq_nth.
          lia.
          all : try rewrite map_length, seq_length;
          rewrite map_length, seq_length in H3;
            auto. }
      rewrite H3.
      assert ((map
                 (fun i0 : nat => if (i0 =? 0)%nat then a 0%nat 0%nat else b (i0 - 1)%nat 0%nat)
                 (List.seq 1 (length l')))
              = (map (fun i : nat => b i 0%nat) (List.seq 0 (length l')))).
      { apply nth_ext with (d := C0) (d' := C0).
        - rewrite ! map_length, ! seq_length; reflexivity.
        - intros n0 H4.
          rewrite map_length, seq_length in H4.
          rewrite nth_indep with (d' := (fun i0 : nat => if (i0 =? 0)%nat 
                                                   then a 0%nat 0%nat else b (i0 - 1)%nat 0%nat) 0%nat);
            auto.
          rewrite map_nth with (f := (fun i0 : nat => if (i0 =? 0)%nat
                                                then a 0%nat 0%nat else b (i0 - 1)%nat 0%nat)) (d := 0%nat).
          rewrite nth_indep with (d' := (fun i0 : nat => b i0 0%nat) 0%nat); auto.
          rewrite map_nth with (f := (fun i0 : nat => b i0 0%nat)) (d := 0%nat).
          bdestruct_all.
          + rewrite seq_nth in H5; auto; lia.
          + do 2 f_equal.
            rewrite ! seq_nth; auto; lia.
          + rewrite map_length, seq_length; easy.
          + rewrite map_length, seq_length; easy. }
      rewrite H4.
      auto.
  - exists (fun r c => if (r =? 0)%nat then a 1%nat c else
                 if (r =? 1)%nat then a 0%nat c else a r c).
    repeat (split; intros; auto).
    + unfold WF_Matrix.
      intros x0 y0 H0.
      bdestruct_all; subst; simpl in *; auto; rewrite H1; auto; lia.
    + unfold list_vector_to_matrix, Mmult.
      prep_matrix_equality.
      replace (length (y :: x :: l)) with (s (s (length l))) by easy.
      replace (length (x :: y :: l)) with (s (s (length l))) by easy.
      rewrite ! big_sum_shift.
      simpl.
      rewrite ! Cplus_assoc.
      setoid_rewrite Cplus_comm at 2.
      auto.
    + simpl.
      assert (map
                (fun i0 : nat =>
                   if (i0 =? 0)%nat
                   then a 1%nat 0%nat
                   else if (i0 =? 1)%nat then a 0%nat 0%nat else a i0 0%nat)
                (List.seq 2 (length l))
              = map (fun i0 : nat => a i0 0%nat) (List.seq 2 (length l))).
      { apply nth_ext with (d := C0) (d' := C0).
        - rewrite ! map_length; reflexivity.
        - intros n0 H0.
          rewrite ! map_length, seq_length in H0.
          rewrite nth_indep with (d' := (fun i0 : nat =>
                                                 if (i0 =? 0)%nat
                                                 then a 1%nat 0%nat
                                                 else if (i0 =? 1)%nat then a 0%nat 0%nat else a i0 0%nat) 0%nat).
          rewrite map_nth with (f := (fun i0 : nat =>
                                       if (i0 =? 0)%nat
                                       then a 1%nat 0%nat
                                       else if (i0 =? 1)%nat then a 0%nat 0%nat else a i0 0%nat)).
          rewrite nth_indep with (d' := (fun i0 : nat => a i0 0%nat) 0%nat).
          rewrite map_nth with (f := (fun i0 : nat => a i0 0%nat)).
          bdestruct_all; auto.
          + rewrite seq_nth in H2; auto; lia.
          + rewrite seq_nth in H3; auto; lia.
          + rewrite map_length, seq_length; auto.
          + rewrite map_length, seq_length; auto. }
      rewrite H0.
      apply perm_swap.
  - destruct (IHPermutation1 a H1) as [b [H2 [H3 H4]]].
    destruct (IHPermutation2 b H2) as [c [H5 [H6 H7]]].
    exists c.
    repeat (split; auto).
    + rewrite H3, H6; auto.
    + apply (perm_trans H4 H7).
Qed.

Lemma permutation_preserves_linearly_indep : forall {n : nat} {l1 l2 : list (Vector n)},
    Permutation l1 l2 -> linearly_independent (list_vector_to_matrix l1) ->
    linearly_independent (list_vector_to_matrix l2).
Proof. intros n l1 l2 H0 H1.
  unfold linearly_independent in *.
  intros a H2 H3.
  apply Permutation_sym in H0.
  destruct (permutation_list_vector_to_matrix_times_vector H0 a H2) as [b [H4 [H5 H6]]].
  rewrite H3 in H5.
  symmetry in H5.
  specialize (H1 b H4 H5).
  rewrite H1 in H6.
  unfold Zero in H6.
  rewrite map_const_repeat in H6.
  rewrite seq_length in H6.
  rewrite <- (Permutation_length H0) in H6.
  assert (forall i, nth i (map (fun i : nat => a i 0%nat) (List.seq 0 (length l2))) C0 = C0)
    by (rewrite <- permutation_repeat_nth, map_length, seq_length; auto).
  assert (forall i, (i < length l2)%nat -> a i 0%nat = C0).
  { intros i0 H8.
    assert (a (length l2) 0%nat = C0) by (rewrite H2; auto).
    setoid_rewrite <- H9 in H7 at 1.
    setoid_rewrite map_nth with (d := length l2) in H7.
    specialize (H7 i0).
    rewrite seq_nth in H7; auto. }
  rewrite zero_all_zero in H8; auto.
Qed.
    
Lemma permutation_preserves_span : forall {n : nat} {l1 l2 : list (Vector n)} {P : Vector n -> Prop},
  subspace P -> Permutation l1 l2 ->
  (forall v : Vector n, P v -> span (list_vector_to_matrix l1) v) ->
  (forall v : Vector n, P v -> span (list_vector_to_matrix l2) v).
Proof. intros n l1 l2 P H0 H1 H2 v H3.
  unfold span in *.
  specialize (H2 v H3).
  destruct H2 as [a [WFa H4]].
  destruct (permutation_list_vector_to_matrix_times_vector H1 a WFa) as [b [WFb [H5 Perm]]].
  exists b.
  split; auto.
  rewrite <- H5; apply H4.
Qed.

Lemma permutation_preserves_subspace_containment : forall {n : nat} {l1 l2 : list (Vector n)} {P : Vector n -> Prop},
        subspace P -> Permutation l1 l2 ->
        (forall i : nat, (i < (length l1))%nat -> P (get_vec i (list_vector_to_matrix l1))) ->
        (forall i : nat, (i < (length l2))%nat -> P (get_vec i (list_vector_to_matrix l2))).
Proof. intros n l1 l2 P H0 H1 H2 i0 H3.
  unfold get_vec, list_vector_to_matrix in *.
  remember H1 as H4. clear HeqH4.
  rewrite Permutation_nth in H4.
  destruct H4 as [H4 [f [H5 [H6 H7]]]].
  remember H6 as H8. clear HeqH8.
  rewrite (FinFun.bInjective_bSurjective H5) in H8.
  destruct (FinFun.bSurjective_bBijective H5 H8) as [g [H9 H10]].
  rewrite H4 in *.
  rewrite H7; auto.
Qed.

Lemma permutation_preserves_map_get_vec_matrix : forall {n m : nat} {indices_list1 indices_list2 : list nat} (M : Matrix n m),
    Permutation indices_list1 indices_list2 ->
    Permutation (map (fun i : nat => get_vec i M) indices_list1) (map (fun i : nat => get_vec i M) indices_list2).
Proof. intros n m indices_list1 indices_list2 M H0.
  remember H0 as H0'. clear HeqH0'.
  rewrite Permutation_nth in H0.
  destruct H0 as [eq_len [f [bFunf [bInjf eq_nth]]]].
  rewrite Permutation_nth.
  split; try rewrite ! map_length, eq_len; auto. 
  exists f.
  repeat split; try rewrite map_length; auto.
  intros x H0.
  setoid_rewrite map_nth with (f := (fun i0 : nat => get_vec i0 M)).
  f_equal.
  apply eq_nth; auto.
  Unshelve.
  auto.
Qed.  

Lemma permutation_preserves_basis : forall {n m : nat} {indices_list1 indices_list2 : list nat} {P : Vector n -> Prop} {M : Matrix n m},
    WF_Matrix M -> subspace P -> Permutation indices_list1 indices_list2 ->
    (basis P (matrix_column_choose indices_list1 M) <-> basis P (matrix_column_choose indices_list2 M)).
Proof. intros n m indices_list1 indices_list2 P M H0 H1 H2.
  pose (permutation_preserves_map_get_vec_matrix M H2).
  unfold basis, matrix_column_choose. 
  split; intros H3; destruct H3 as [H4 [H5 [H6 H7]]]; repeat (split; intros; auto).
  - pose (permutation_preserves_subspace_containment H4 p).
    rewrite ! map_length in p0.
    specialize (p0 H5).
    apply p0; auto.
  -  pose (permutation_preserves_span H4 p).
     rewrite ! map_length in s.
     specialize (s H6).
     apply s; auto.
  - pose (permutation_preserves_linearly_indep p).
    rewrite ! map_length in l.
    specialize (l H7); auto.
  - apply Permutation_sym in p.
    pose (permutation_preserves_subspace_containment H4 p).
    rewrite ! map_length in p0.
    specialize (p0 H5).
    apply p0; auto.
  - apply Permutation_sym in p.
    pose (permutation_preserves_span H4 p).
    rewrite ! map_length in s.
    specialize (s H6).
    apply s; auto.
  - apply Permutation_sym in p.
    pose (permutation_preserves_linearly_indep p).
    rewrite ! map_length in l.
    specialize (l H7); auto.
Qed.

(* Theorem 41 Let V be a nontrivial vector space over a field F, and suppose {u1,u2,...,um} spans V. Then a subset of {u1,u2,...,um} is a basis for V. *)
(*** Classical Logic used ***)
Lemma subset_basis : forall {n m : nat} {P : Vector n -> Prop} {M : Matrix n m},
    WF_Matrix M -> (m > 0)%nat -> subspace P -> (forall i, (i < m)%nat -> P (get_vec i M)) -> (forall v, P v -> span M v) ->
    (exists v, v <> Zero /\ P v) -> 
    (exists indices_list, incl indices_list (List.seq 0 m) /\ NoDup indices_list /\
                       basis P (matrix_column_choose indices_list M)).
Proof. intros n m P M H0 H1 H2 H3 H4 H5.
  destruct (Classical_Prop.classic (linearly_dependent M)).
  - induction m.
    + inversion H1.
    + destruct m.
      * assert (M <> Zero).
        { destruct (Classical_Prop.classic (M = Zero)).
          - destruct H5 as [v [H5 H5']].
            specialize (H4 v H5').
            unfold span in H4.
            destruct H4 as [a [H4 H4']].
            rewrite H4' in H5.
            rewrite H7 in H5.
             rewrite Mmult_0_l in H5.
             contradiction.
          - assumption. }
        pose (lin_indep_vec M H0 H7) as H8.
        apply lindep_implies_not_linindep in H6.
        contradiction.
      * destruct (lin_dep_gen_elem M H0 H6) as [i [H7 [v [H8 H9]]]].
        assert (span (reduce_col M i) (get_vec i M)).
        { unfold span.
          exists ((Copp C1) .* v).
          split; auto with wf_db.
          distribute_scale.
          rewrite H9.
          distribute_scale.
          lma'. }
        pose (equal_span_reduce_col M i H7 H10) as H11.
        assert (WF_Matrix (reduce_col M i)); auto with wf_db.
        assert (s m > 0)%nat; try lia.
        assert (forall i0 : nat, (i0 < s m)%nat -> P (get_vec i0 (reduce_col M i))).
        { intros i0 H14.
          bdestruct (i0 <? i).
          - rewrite get_col_reduce_col; auto.
          - rewrite get_vec_reduce_col_back; auto; apply H3; lia. }
        assert (forall v : Vector n, P v -> span (reduce_col M i) v).
        { intros v0 H15.
          apply H11; auto. }
        destruct (Classical_Prop.classic (linearly_dependent (reduce_col M i))).
        -- specialize (IHm (reduce_col M i) H12 H13 H14 H15 H16).
           destruct IHm as [indices_list [incl_indices_list basis_P]].
           exists (map (fun n => if (n <? i) then n else s n) indices_list).
           split.
           ++ unfold incl.
              intros a H17.
              rewrite in_map_iff in H17.
              destruct H17 as [x [H17 H18]].
              bdestruct (x <? i).
              ** simpl in H17.
                 rewrite <- H17.
                 rewrite in_seq.
                 lia.
              ** simpl in H17.
                 rewrite <- H17.
                 unfold incl in incl_indices_list.
                 specialize (incl_indices_list x H18).
                 rewrite in_seq in incl_indices_list.
                 rewrite in_seq.
                 lia.
           ++ split.
              ** apply NoDup_map_inv
                   with (f := fun n0 : nat => if (n0 <? i)%nat then n0 else (Nat.pred n0)).
                 rewrite map_map.
                 assert ((fun x : nat =>
                            if (if x <? i then x else s x) <? i
                            then if x <? i then x else s x
                            else Nat.pred (if x <? i then x else s x))
                         = (fun x : nat => x)).
                 { apply functional_extensionality.
                   intros x.
                   bdestruct_all; auto. }
                 rewrite H17.
                 rewrite map_id.
                 destruct basis_P; auto.
              ** unfold basis.
                 assert ((matrix_column_choose (map (fun n0 : nat => if n0 <? i then n0 else s n0) indices_list) M) = (matrix_column_choose indices_list (reduce_col M i))).
                 { unfold matrix_column_choose, list_vector_to_matrix.
                   prep_matrix_equality.
                   rewrite map_map.
                   unfold reduce_col.
                   assert (Zero = ((fun x0 : nat => get_vec (if x0 <? i then x0 else s x0) M) (s m))).
                   { prep_matrix_equality.
                     unfold get_vec.
                     bdestruct_all; auto.
                     rewrite H0; auto; lia. }
                   rewrite H17 at 1.
                   rewrite map_nth with (d := s m).
                   assert (Zero = (fun i0 : nat => @get_col n (s m) (fun x0 y0 : nat => if y0 <? i then M x0 y0 else M x0 (1 + y0)%nat) i0) (s m)).
                   { prep_matrix_equality.
                     unfold get_vec.
                     bdestruct_all; auto.
                     rewrite H0; auto; lia. }
                   rewrite H18.
                   rewrite map_nth with (d := s m).
                   bdestruct_all.
                   - unfold get_vec.
                     bdestruct_all.
                     reflexivity.
                   - unfold get_vec.
                     bdestruct_all.
                     reflexivity. }
                 rewrite ! H17.
                 destruct basis_P as [subspaceP [in_P [spans_P lin_ind]]].
                 rewrite ! map_length.
                 repeat (split; auto).
        -- apply not_lindep_implies_linindep in H16.
           exists (delete_nth (List.seq 0 (s (s m))) i).
           split.
           ++ unfold incl.
              intros a H17.
              unfold delete_nth in H17.
              rewrite in_app_iff in H17.
              destruct H17.
              ** apply firstn_subset in H17; auto.
              ** apply skipn_subset in H17; auto.
           ++ split.
              ** unfold delete_nth.
                 apply NoDup_remove_1 with (a := i).
                 assert (i :: skipn (i + 1) (List.seq 0 (s (s m))) = skipn i (List.seq 0 (s (s m)))).
                 { setoid_rewrite nth_helper with (x := 0%nat) at 2.
                   replace (s i) with (i + 1)%nat by lia.
                   rewrite seq_nth.
                   all : try rewrite seq_length; auto. }
                 rewrite H17.
                 rewrite firstn_skipn.
                 apply seq_NoDup.
              ** unfold basis.
                 rewrite <- ! reduce_col_matrix_column_choose_delete; auto.
                 2: rewrite seq_length; assumption.
                 rewrite ! matrix_column_choose_original; auto.
                 rewrite ! length_delete_nth.
                 2: rewrite seq_length; assumption.
                 rewrite ! seq_length.
                 replace ((s (s m)) - 1)%nat with (s m) by lia.
                 repeat (split; auto).
  - apply not_lindep_implies_linindep in H6.
    exists (List.seq 0 m).
    split.
    + apply incl_refl.
    + split.
      * apply seq_NoDup.
      * unfold basis.
        rewrite matrix_column_choose_original; auto.
        rewrite ! seq_length.
        repeat (split; try assumption).
Qed.


(* Exercise 2.5.4 Let V be a vector space over a field F and let {u1,...,uk} be a linearly independent subset of V . Prove that if v ̸∈ sp{u1, . . . , uk}, then {u1,...,uk,v} is also linearly independent. *)

(*** Classical Logic used ***)
Lemma extend1_lin_indep : forall {n m : nat} {P : Vector n -> Prop} {A : Matrix n m} {v : Vector n},
    subspace P -> WF_Matrix A -> WF_Matrix v -> linearly_independent A ->
    (forall i, (i < m)%nat -> P (get_vec i A)) ->
    ~ span A v -> linearly_independent (col_append A v).
Proof. intros n m P A v H0 H1 H2 H3 H4 H5.
  unfold span in H5.
  unfold linearly_independent in H3.
  unfold linearly_independent.
  intros a H6 H7.
  destruct (Classical_Prop.classic (a = Zero)); auto.
  assert (a m 0%nat <> C0).
  { intro.
    assert (col_append A v × a = A × (reduce_row a m)).
    { unfold col_append, col_wedge, reduce_row, Mmult.
      prep_matrix_equality.
      simpl.
      bdestruct_all. clear H11.
      bdestruct (y =? 0)%nat;
        [rewrite H11; rewrite H9 | rewrite H6; try lia];
        Csimpl;
        apply big_sum_eq_bounded;
        intros x0 H12;
        bdestruct_all;
        reflexivity. }
    rewrite H10 in H7.
    assert (WF_Matrix (reduce_row a m)); auto with wf_db.
    specialize (H3 (reduce_row a m) H11 H7).
    assert (a = Zero).
    { prep_matrix_equality.
      bdestruct (y =? 0)%nat.
      - subst.
        bdestruct (x <? m)%nat.
        + unfold reduce_row in H3.
          apply f_equal_inv with (x := x) in H3.
          apply f_equal_inv with (x := 0%nat) in H3.
          rewrite <- Nat.ltb_lt in H12.
          rewrite H12 in H3.
          assumption.
        + bdestruct (x =? m)%nat.
          * subst.
            assumption.
          * rewrite H6; auto; lia.
      - rewrite H6; auto; lia. }
    contradiction. }
  assert (v = A × (((- C1)%C * /(a m 0%nat)) .* (reduce_row a m))).
  { assert (col_append A v × a = A × (reduce_row a m) .+ (a m 0%nat) .* v).
    { unfold col_append, col_wedge, reduce_row, Matrix.scale, Mmult, Mplus.
      prep_matrix_equality.
      simpl.
      bdestruct_all. clear H11.
      bdestruct (y =? 0)%nat.
      - subst.
        f_equal.
        + apply big_sum_eq_bounded.
          intros x0 H11.
          bdestruct_all.
          reflexivity.
        + rewrite Cmult_comm.
          reflexivity.
      - setoid_rewrite H6 at 2; try lia.
        setoid_rewrite H2 at 3; try lia.
        Csimpl.
        apply big_sum_eq_bounded.
        intros x0 H12.
        bdestruct_all.
        reflexivity. }
    rewrite H10 in H7.
    rewrite Mplus_comm in H7.
    apply Mplus_inj_r with (m := (- C1) .* (A × reduce_row a m)) in H7.
    rewrite Mplus_assoc in H7.
    assert (forall {n m} (A : Matrix n m), WF_Matrix A -> A .+ - C1 .* A = Zero).
    { intros n0 m0 A0 H11. lma'. }
    rewrite H11 in H7; auto with wf_db.
    rewrite Mplus_0_r, Mplus_0_l in H7.
    apply Mscale_cancel with (c := a m 0%nat); auto.
    rewrite H7.
    distribute_scale.
    f_equal.
    setoid_rewrite Cmult_comm at 2.
    rewrite Cmult_assoc.
    rewrite Cinv_r; auto.
    lca. }
  assert (WF_Matrix (- C1 * / a m 0%nat .* reduce_row a m)); auto with wf_db.
  pose (Classical_Pred_Type.not_ex_all_not (Vector m) (fun a : Vector m => WF_Matrix a /\ v = A × a) H5 (- C1 * / a m 0%nat .* reduce_row a m)) as H12.
  simpl in H12.
  apply Classical_Prop.not_and_or in H12.
  destruct H12; contradiction.
Qed.


Definition trichotomy (A B C : Prop) := (A /\ ~ B /\ ~ C) \/ (~ A /\ B /\ ~ C) \/ (~ A /\ ~ B /\ C).


(* Theorem 43 Let V be a finite-dimensional vector space over a field F, and suppose {u1, u2, . . . , uk} ⊂ V is linearly independent. If {u1, u2, . . . , uk} does not span V , then there exist vectors uk+1 , . . . , un such that
{u1,u2,...,uk,uk+1,...,un}
is a basis for V. *)

Definition temp_before {n k : nat} (P : Vector n -> Prop) (A : Matrix n k) (m : nat) :=
  (exists (B : Matrix n (m - k)), (WF_Matrix B) /\ (forall i, (i < (m - k))%nat -> P (get_vec i B)) /\
                               (linearly_independent (smash A B)) /\
                               ~ (forall v, P v -> span (smash A B) v)).

Definition temp_middle {n k : nat} (P : Vector n -> Prop) (A : Matrix n k) (m : nat) :=
  (exists (B : Matrix n (m - k)), (WF_Matrix B) /\ (forall i, (i < (m - k))%nat -> P (get_vec i B)) /\
                               (linearly_independent (smash A B)) /\
                               (forall v, P v -> span (smash A B) v)).

Definition temp_after {n k : nat} (P : Vector n -> Prop) (A : Matrix n k) (m : nat) :=
  (forall (B : Matrix n (m - k)), (WF_Matrix B) -> (forall i, (i < (m - k))%nat -> P (get_vec i B)) ->
                             linearly_dependent (smash A B)).

(*** Classical Logic Used ***)
Lemma temp_begin : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    ~ (forall v, P v -> span A v) ->
    ((temp_before P A (k + 1)%nat) \/ (temp_middle P A (k + 1)%nat)).
Proof. intros n k P A H0 H1 H2 H3 H4. 
  apply Classical_Pred_Type.not_all_ex_not in H4.
  destruct H4 as [v H4].
  apply Classical_Prop.imply_to_and in H4.
  destruct H4.
  assert (WF_Matrix v) by (apply (WF_subspace H1 H4); auto).
  pose (extend1_lin_indep H1 H0 H6 H3 H2 H5).
  unfold col_append in l.
  rewrite smash_append in l; auto.
  destruct (Classical_Prop.classic (forall w, P w -> span (smash A v) w)).
  - right.
    unfold temp_middle.
    exists v.
    replace (k + 1 - k)%nat with 1%nat by lia.
    replace (s k) with (k + 1)%nat by lia.
    repeat (split; auto).
    + intros i0 H8.
      replace i0 with 0%nat by lia.
      rewrite get_vec_vec; auto.
    + replace (k + 1)%nat with (s k) by lia; auto.
  - left.
    unfold temp_before.
    exists v.
    replace (k + 1 - k)%nat with 1%nat by lia.
    replace (s k) with (k + 1)%nat by lia.
    repeat (split; auto).
    + intros i0 H8.
      replace i0 with 0%nat by lia.
      rewrite get_vec_vec; auto.
    + replace (k + 1)%nat with (s k) by lia; auto.
Qed.

Lemma temp_end : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (temp_after P A (n + 1)%nat).
Proof. intros n k P A H0 H1 H2 H3.
  unfold temp_after.
  intros B H4 H5.
  apply gt_dim_lindep; auto with wf_db; lia.
Qed.

(*** Classical Logic Used ***)
Lemma temp_before_step : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (forall m, (k < m)%nat -> (temp_before P A m) ->
          ((temp_before P A (s m)) \/ (temp_middle P A (s m)))). 
Proof. intros n k P A H0 H1 H2 H3 m H4 H5.
  unfold temp_before in H5.
  destruct H5 as [B [WFB [BinP [linindAB notspanP]]]].
  apply Classical_Pred_Type.not_all_ex_not in notspanP.
  destruct notspanP as [v notspanP].
  apply Classical_Prop.imply_to_and in notspanP.
  destruct notspanP as [vinP vnotinspan].
  assert (WF_Matrix (smash A B)); auto with wf_db.
  assert (forall i : nat, (i < m)%nat -> P (get_vec i (smash A B))).
  { intros i0 H6.
    bdestruct (i0 <? k)%nat.
    - rewrite get_vec_smash_left; try apply H2; lia.
    - rewrite get_vec_smash_right; try apply BinP; lia. }
  replace m with (k + (m - k))%nat in H6 by lia.
  assert (WFv : WF_Matrix v) by (apply (WF_subspace H1 vinP); auto).
  pose (extend1_lin_indep H1 H5 WFv linindAB H6 vnotinspan).
  unfold col_append in l.
  rewrite smash_append in l; auto with wf_db.
  rewrite smash_assoc in l.
  assert (forall i : nat, (i < (m - k) + 1)%nat -> P (get_vec i (smash B v))).
  { intros i0 H7.
    bdestruct (i0 <? m - k)%nat.
    - rewrite get_vec_smash_left; try apply BinP; lia.
    - rewrite get_vec_smash_right; replace (i0 - (m - k))%nat with 0%nat by lia;
        try rewrite get_vec_vec; try apply vinP; auto with wf_db; lia. }
  destruct (Classical_Prop.classic (forall w, P w -> span (smash A (smash B v)) w)).
  - right.
    unfold temp_middle.
    exists (smash B v).
    replace (s m - k)%nat with ((m - k) + 1)%nat by lia.
    repeat (split; auto with wf_db).
    replace (k + (m - k + 1))%nat with (s (k + (m - k)))%nat by lia. 
    apply l.
  - left.
    unfold temp_before.
    exists (smash B v).
    replace (s m - k)%nat with ((m - k) + 1)%nat by lia.
    repeat (split; auto with wf_db).
    replace (k + (m - k + 1))%nat with (s (k + (m - k)))%nat by lia. 
    apply l.
Qed.

Lemma temp_middle_step : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (forall m, (k < m)%nat -> (temp_middle P A m) ->
          (temp_after P A (s m))).
Proof. intros n k P A H0 H1 H2 H3 m H4 H5.
  unfold temp_middle in H5.
  destruct H5 as [B [WFB [BinP [linindAB ABspansP]]]].
  assert (basis P (smash A B)).
  repeat (split; auto).
  - intros i0 H5.
    bdestruct (i0 <? k)%nat.
    + rewrite get_vec_smash_left; try apply H2; lia.
    + rewrite get_vec_smash_right; try apply BinP; lia.
  - unfold temp_after.
    intros B0 H6 H7.
    apply (dimension_overflow P (smash A B) (smash A B0)); auto with wf_db; try lia.
    intros i0 H8.
    bdestruct (i0 <? k).
    + rewrite get_vec_smash_left; auto.
    + rewrite get_vec_smash_right; auto; apply H7; lia.
Qed.

Lemma temp_after_step : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (forall m, (k < m)%nat -> (temp_after P A m) ->
          (temp_after P A (s m))).
Proof. intros n k P A H0 H1 H2 H3 m H4 H5.
  unfold temp_after.
  intros B H6 H7.
  assert ((smash A B)
          = (col_append (submatrix_column m (smash A B)) (get_vec (m - k)%nat B))).
  { prep_matrix_equality.
    assert (WF_Matrix (smash A B)); auto with wf_db.
    assert (WF_Matrix (col_append (submatrix_column m (smash A B)) (get_vec (m - k)%nat B))). unfold col_append. auto with wf_db.
    bdestruct (x <? n)%nat.
    - bdestruct (y <? s m)%nat.
      + unfold smash, submatrix_column, col_append, col_wedge, get_vec.
        bdestruct_all; auto.
      + rewrite H8; try lia.
        rewrite H9; try lia.
        reflexivity.
    - rewrite H8; try lia.
      rewrite H9; try lia.
      reflexivity. }
  rewrite H8.
  replace (k + (s m - k))%nat with (s m) by lia.
  unfold col_append.
  apply lin_dep_col_wedge. lia.
  unfold temp_after in H5.
  setoid_rewrite submatrix_column_smash_right; auto.
  assert (WF_Matrix (submatrix_column (m - k) B)); auto with wf_db.
  assert (forall i : nat, (i < m - k)%nat -> P (get_vec i (submatrix_column (m - k) B))).
  { intros i0 H10.
    rewrite get_vec_submatrix_column; auto.
    apply H7; lia. }
  replace (k + (m - k))%nat with m in H5 by lia.
  apply (H5 (submatrix_column (m - k) B) H9 H10).
Qed.

Lemma temp_no_middle_all_before : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    ~ (forall v, P v -> span A v) ->
     (forall m, (k < m)%nat -> ~ (temp_middle P A m)) ->
    (forall m, (k < m)%nat -> (temp_before P A m)).
Proof. intros n k P A H0 H1 H2 H3 H4 H5 m H6.
  induction m.
  - inversion H6.
  - bdestruct (m =? k)%nat.
    + subst.
      replace (s k) with (k + 1)%nat in * by lia.
      assert (temp_before P A (k + 1)%nat \/ temp_middle P A (k + 1)%nat)
        by (apply temp_begin; auto).
      destruct H7; auto.
      contradict H7; auto.
    + assert (k < m)%nat by lia.
      apply IHm in H8.
      apply temp_before_step in H8; auto; try lia.
      destruct H8; auto.
      contradict H8; auto.
Qed.

Lemma temp_all_after_from_end : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (forall m, (n < m)%nat -> temp_after P A m).
Proof. intros n k P A H0 H1 H2 H3 m H4.
  induction m.
  - inversion H4.
  - bdestruct (m =? n)%nat.
    + subst.
      replace (s n) with (n + 1)%nat in * by lia.
      apply temp_end; auto.
    + assert (n < m)%nat by lia.
      apply temp_after_step; auto.
      pose (linearly_independent_dimensions A H0 H3).
      lia.
Qed.

(*** Classical Logic Used ***)
Lemma temp_trichotomy_subpart1 : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (forall m, (k < m)%nat ->
          (~ temp_after P A m <-> temp_before P A m \/ temp_middle P A m)).
Proof. intros n k P A H0 H1 H2 H3 m H4. 
  split.
  - intros H5.
    unfold temp_after in H5.
    apply Classical_Pred_Type.not_all_ex_not in H5.
    destruct H5 as [M H5].
    apply Classical_Prop.imply_to_and in H5.
    destruct H5 as [WFM H5].
    apply Classical_Prop.imply_to_and in H5.
    destruct H5 as [MinP linindep].
    apply not_lindep_implies_linindep in linindep.
    unfold temp_before, temp_middle.
    destruct (Classical_Prop.classic (forall v : Vector n, P v -> span (smash A M) v));
      [right | left]; exists M; auto.
  - intros H5.
    unfold temp_after.
    destruct H5 as [before | middle].
    + unfold temp_before in before.
      destruct before as [M [WFM [MinP [linindep notspanP]]]].
      intro.
      specialize (H5 M WFM MinP).
      apply lindep_implies_not_linindep in H5.
      contradiction.
    + unfold temp_middle in middle.
      destruct middle as [M [WFM [MinP [lindep spanP]]]].
      intro.
      specialize (H5 M WFM MinP).
      apply lindep_implies_not_linindep in H5.
      contradiction.
Qed.

(*** Classical Logic Used ***)
Lemma temp_trichotomy_subpart2 : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (forall m, (k < m)%nat -> (~ temp_before P A m \/ ~ temp_middle P A m)).
Proof. intros n k P A H0 H1 H2 H3 m H4.
  apply Classical_Prop.not_and_or.
  intro.
  destruct H5.
  apply temp_before_step in H5; auto.
  rewrite <- temp_trichotomy_subpart1 in H5; auto.
  apply temp_middle_step in H6; auto.
Qed.

(*** Classical Logic Used ***)
Lemma temp_trichotomy : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    (forall m, (k < m)%nat ->
          (trichotomy (temp_before P A m) (temp_middle P A m) (temp_after P A m))).
Proof. intros n k P A H0 H1 H2 H3 m H4.
  assert (~ temp_after P A m <-> temp_before P A m \/ temp_middle P A m) by
    (apply temp_trichotomy_subpart1; auto; lia).
  unfold trichotomy.
  destruct (Classical_Prop.classic (temp_after P A m)).
  - do 2 right.
    assert (~ temp_before P A m /\ ~ temp_middle P A m).
    { apply Classical_Prop.not_or_and.
      intro.
      rewrite <- H5 in H7; auto. }
    destruct H7.
    repeat split; auto.
  - remember H6 as H6'. clear HeqH6'.
    rewrite H5 in H6.
    assert (~ temp_before P A m \/ ~ temp_middle P A m)
      by (apply temp_trichotomy_subpart2; auto).
    destruct H6; destruct H7; try contradiction;
      try (left; repeat split; assumption);
      try (right; left; repeat split; assumption).
Qed.

(*** Classical Logic Used ***)
Lemma temp_exists_middle : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    ~ (forall v, P v -> span A v) ->
    (exists m, (k < m <= n)%nat /\ (temp_middle P A m)).
Proof. intros n k P A H0 H1 H2 H3 H4.
  pose (linearly_independent_dimensions A H0 H3).
  destruct (Classical_Prop.classic (forall m : nat, (k < m)%nat -> ~ temp_middle P A m)).
  - assert (temp_before P A (n + 1)%nat)
      by (apply temp_no_middle_all_before; auto; lia).
    assert (temp_after P A (n + 1)%nat)
      by (apply temp_end; auto).
    assert (k < n + 1)%nat by lia.
    destruct (temp_trichotomy H0 H1 H2 H3 (n + 1)%nat H8)
      as [[Hb [nHm nHa]] | [[nHb [Hm nHa]] | [nHb [nHm Ha]]]];
      contradiction.
  - apply Classical_Pred_Type.not_all_ex_not in H5.
    destruct H5 as [m H5].
    apply Classical_Prop.imply_to_and in H5.
    destruct H5.
    apply Classical_Prop.NNPP in H6.
    bdestruct (m <=? n)%nat.
    +  exists m.
       split; auto.
    + assert (temp_after P A m) by (apply temp_all_after_from_end; auto).
      destruct (temp_trichotomy H0 H1 H2 H3 m H5)
        as [[Hb [nHm nHa]] | [[nHb [Hm nHa]] | [nHb [nHm Ha]]]];
        contradiction.
Qed.

Lemma basis_extension : forall {n k : nat} {P : Vector n -> Prop} {A : Matrix n k},
    WF_Matrix A -> subspace P ->
    (forall i, (i < k)%nat -> P (get_vec i A)) -> linearly_independent A ->
    ~ (forall v, P v -> span A v) ->
    (exists d, (k < d <= n)%nat /\
            (exists (B : Matrix n (d - k)), WF_Matrix B /\
                (forall i, (i < (d - k))%nat -> P (get_vec i B)) /\ basis P (smash A B))).
Proof. intros n k P A H0 H1 H2 H3 H4.
  destruct (temp_exists_middle H0 H1 H2 H3 H4)
    as [m [mbound [B [WFB [BinP [linindepAB ABspansP]]]]]].
  exists m; repeat (split; auto);
    exists B; repeat (split; auto).
  replace (k + (m - k))%nat with m by lia.
  intros i0 H5. 
  bdestruct (i0 <? k)%nat.
  - setoid_rewrite get_vec_smash_left; auto.
  - setoid_rewrite get_vec_smash_right; auto.
    apply BinP; lia.
Qed.

(*** Classical Logic Used ***)
Lemma exists_dimension : forall {n : nat} {P : Vector n -> Prop},
    subspace P -> (exists d, dimension P d /\ (d <= n)%nat).
Proof. intros n P H0.
  destruct (Classical_Prop.classic (forall v : Vector n, P v -> v = Zero)).
  - exists 0%nat.
    split; try lia.
    unfold dimension.
    exists Zero.
    split; auto with wf_db.
    unfold basis.
    repeat (split; auto).
    + intros i0 H2.
      inversion H2.
    + intros v H2.
      unfold span.
      specialize (H1 v H2).
      subst.
      exists Zero.
      split; auto with wf_db.
    + unfold linearly_independent.
      intros a H2 H3.
      unfold WF_Matrix in H2.
      prep_matrix_equality.
      rewrite H2; auto; lia.
  - apply Classical_Pred_Type.not_all_ex_not in H1.
    destruct H1 as [v H1].
    apply Classical_Prop.imply_to_and in H1.
    destruct H1.
    assert (WF_Matrix v).
    { unfold subspace in H0.
      destruct H0.
      apply H0; auto. }
    assert (forall i : nat, (i < 1)%nat -> P (get_vec i v)).
    { intros i0 H4.
      replace i0 with 0%nat by lia.
      setoid_rewrite get_vec_vec; auto. }
    assert (linearly_independent v)
      by (apply lin_indep_vec; auto).
    destruct (Classical_Prop.classic (forall w : Vector n, P w -> span v w)).
    + pose (linearly_independent_dimensions v H3 H5).
      exists 1%nat; split; try lia.
      unfold dimension.
      exists v; split; auto with wf_db.
      unfold basis.
      repeat (split; auto).
    + destruct (basis_extension H3 H0 H4 H5 H6)
        as [d [dbound [B [WFB [BinP basisAB]]]]].
      exists (1 + (d - 1))%nat; split; try lia.
      unfold dimension.
      exists (smash v B); split;
        auto with wf_db.
Qed.

(* Theorem 45 Let V be an n-dimensional vector space over a field F, and let u1,u2,...,un be vectors in V .
1. If {u1,u2,...,un} spans V , then {u1,u2,...,un} is linearly independent and hence is a basis for V .
2. If {u1,u2,...,un} is linearly independent, then {u1,u2,...,un} spans V and hence is a basis for V. *)
Lemma equal_dimension_span_lin_indep : forall {n d : nat} {P : Vector n -> Prop} {A : Matrix n d},
    WF_Matrix A -> subspace P -> dimension P d ->
    (forall i, (i < d)%nat -> P (get_vec i A)) ->
    (forall v, P v -> span A v) -> linearly_independent A.
Proof. intros n d P A H0 H1 H2 H3 H4.
  bdestruct (d <=? 0)%nat.
  - unfold linearly_independent.
    intros a H6 H7.
    prep_matrix_equality.
    rewrite H6; auto; try lia.
  - remember H2 as H2'. clear HeqH2'.
    unfold dimension in H2.
    destruct H2 as [B [WFB basisB]].
    unfold basis in basisB.
    destruct basisB as [subspaceP [BinP [BspansP linindepB]]].
    assert (nonzerovec : @e_i d 0%nat <> Zero).
      { intro.
        unfold e_i in H2.
        apply f_equal_inv with (x := 0%nat) in H2.
        apply f_equal_inv with (x := 0%nat) in H2.
        simpl in H2.
        rewrite andb_true_r in H2.
        assert ((0 <? d)%nat = true) by (rewrite Nat.ltb_lt; auto).
        rewrite H6 in H2.
        simpl in H2.
        inversion H2.
        lra. }
      assert (WF_Matrix (@e_i d 0%nat)) by auto with wf_db.
      assert (forall m, (@Zero m d) × (@e_i d 0%nat) = Zero) by (intros; rewrite Mmult_0_l; auto).
    assert (n <> 0%nat).
    { intro.
      subst.
      assert (B = Zero).
      { prep_matrix_equality.
        rewrite WFB; auto.
        left. lia. }
      subst.
      unfold linearly_independent in linindepB.
      contradict nonzerovec.
      apply linindepB; auto. }
    assert (~ forall i : nat, (i < d)%nat -> get_vec i B = Zero).
    { intro.
      assert (B = Zero).
      { prep_matrix_equality.
        bdestruct (x <? n)%nat; [idtac | rewrite WFB; auto].
        bdestruct (y <? d)%nat; [idtac | rewrite WFB; auto].
        assert (B x y = get_vec y B x 0%nat) by (bdestruct_all; auto).
        rewrite H11.
        rewrite H8; auto. }
      subst.
      unfold linearly_independent in linindepB.
      contradict nonzerovec.
      apply linindepB; auto. }
    assert (exists v : Vector n, v <> Zero /\ P v).
    { apply Classical_Pred_Type.not_all_ex_not in H8.
      destruct H8 as [i H8].
      apply Classical_Prop.imply_to_and in H8.
      destruct H8.
      exists (get_vec i B).
      split; auto. }
    destruct (subset_basis H0 H5 H1 H3 H4 H9)
      as [indices_list [incl_list [NoDuplist basisP]]].
    assert (length (List.seq 0 d) <= length indices_list)%nat.
    { assert (dimension P (length indices_list)).
      { unfold dimension.
        exists (matrix_column_choose indices_list A).
        split; auto with wf_db. }
      pose (unique_dimension P H10 H2').
      rewrite seq_length, e; auto. }
    pose (NoDup_Permutation_bis NoDuplist H10 incl_list) as p.
    rewrite (permutation_preserves_basis H0 subspaceP p) in basisP.
    unfold basis in basisP.
    destruct basisP as [subspaceP' [AinP [AspansP linindepA]]].
    rewrite matrix_column_choose_original in *; auto.
    rewrite ! seq_length in *; auto.
Qed.

Lemma equal_dimension_span_basis : forall {n d : nat} {P : Vector n -> Prop} {A : Matrix n d},
    WF_Matrix A -> subspace P -> dimension P d ->
    (forall i, (i < d)%nat -> P (get_vec i A)) ->
    (forall v, P v -> span A v) -> basis P A.
Proof. intros n d P A H0 H1 H2 H3 H4.
  assert (linearly_independent A)
    by (apply @equal_dimension_span_lin_indep with (P := P); auto).
  unfold basis.
  repeat (split; auto).
Qed.

(*** Classical Logic Used ***)
Lemma equal_dimension_lin_indep_span : forall {n d : nat} {P : Vector n -> Prop} {A : Matrix n d},
    WF_Matrix A -> subspace P -> dimension P d ->
    (forall i, (i < d)%nat -> P (get_vec i A)) ->
    linearly_independent A -> (forall v, P v -> span A v).
Proof. intros n d P A H0 H1 H2 H3 H4 v H5.
  bdestruct (d <=? 0)%nat.
  - unfold span.
    exists Zero; split; auto with wf_db.
    rewrite Mmult_0_r.
    destruct H2 as [M [WFM basisM]].
    assert (d = 0)%nat by lia.
    subst.
    assert (M = Zero).
    { prep_matrix_equality.
      rewrite WFM; auto; lia. }
    subst.
    unfold basis in basisM.
    destruct basisM as [subspaceP' [ZeroinP [ZerospansP linindepZero]]].
    specialize (ZerospansP v H5).
    unfold span in ZerospansP.
    destruct ZerospansP as [a [WFa vZero]].
    rewrite Mmult_0_l in vZero.
    assumption.
  - destruct (Classical_Prop.classic (forall w, P w -> span A w)); auto.
    apply Classical_Pred_Type.not_all_ex_not in H7.
    destruct H7 as [w H7].
    apply Classical_Prop.imply_to_and in H7.
    destruct H7.
    remember H1 as H1'. clear HeqH1'.
    destruct H1' as [WFP [PZero [Psum Pscale]]].
    assert (WF_Matrix w) by (apply WFP; auto).
    pose (extend1_lin_indep H1 H0 H9 H4 H3 H8).
    destruct H2 as [B [WFB basisB]].
    assert (WF_Matrix (col_append A w)) by (unfold col_append; auto with wf_db).
    assert (forall i : nat, (i < s d)%nat -> P (get_vec i (col_append A w))).
    { intros i0 H10.
      bdestruct (i0 =? d)%nat.
      - subst.
        rewrite get_vec_col_append_back; auto.
      - rewrite get_vec_col_append_front; auto; try lia.
        apply H3; lia. }
    assert (s d > d)%nat by lia.
    pose (dimension_overflow P B (col_append A w) WFB H2 basisB H10 H11).
    apply lindep_implies_not_linindep in l0; contradiction.
Qed.

Lemma equal_dimension_lin_indep_basis : forall {n d : nat} {P : Vector n -> Prop} {A : Matrix n d},
    WF_Matrix A -> subspace P -> dimension P d ->
    WF_Matrix A -> (forall i, (i < d)%nat -> P (get_vec i A)) ->
    linearly_independent A -> basis P A.
Proof. intros n d P A H0 H1 H2 H3 H4 H5.
  assert (forall v, P v -> span A v)
    by (apply @equal_dimension_lin_indep_span with (P := P); auto).
  unfold basis.
  repeat (split; auto).
Qed.

Definition matrix_to_list_vector {n m : nat} (M : Matrix n m) :=
  map (fun i : nat => get_vec i M) (List.seq 0 m).

Lemma matrix_to_list_vector_to_matrix : forall {n m : nat} {M : Matrix n m},
    WF_Matrix M -> list_vector_to_matrix (matrix_to_list_vector M) = M.
Proof. intros n m M H0.
  unfold list_vector_to_matrix, matrix_to_list_vector.
  prep_matrix_equality.
  assert (@Zero n 1%nat = get_vec m M).
  { prep_matrix_equality.
    unfold get_vec.
    bdestruct_all; auto.
    rewrite H0; auto; lia. }
  rewrite H1.
  rewrite map_nth with (d := m).
  unfold get_vec.
  bdestruct_all.
  bdestruct (y <? m)%nat.
  - rewrite seq_nth; auto.
  - rewrite nth_overflow; try rewrite seq_length; auto.
    rewrite ! H0; auto.
Qed.

Lemma list_vector_to_matrix_to_list_vector : forall {n : nat} {list_vector : list (Vector n)},
    (Forall WF_Matrix list_vector) ->
    matrix_to_list_vector (list_vector_to_matrix list_vector) = list_vector.
Proof. intros n list_vector AllWFM.
  apply (nth_ext (matrix_to_list_vector (list_vector_to_matrix list_vector)) list_vector (@Zero n 1%nat) (@Zero n 1%nat)); unfold matrix_to_list_vector, list_vector_to_matrix;
    rewrite map_length, seq_length; auto.
  intros n0 H0.
  assert (@Zero n 1%nat = @get_col n (length list_vector) (fun r c : nat => nth c list_vector (@Zero n 1%nat) r 0%nat) (length list_vector)).
  { prep_matrix_equality.
    unfold get_vec.
    bdestruct_all; auto.
    rewrite nth_overflow; auto. }
  rewrite H1 at 1.
  rewrite map_nth with (d := length list_vector).
  unfold get_vec.
  prep_matrix_equality.
  bdestruct_all.
  - rewrite seq_nth; auto.
  - rewrite Forall_nth in AllWFM.
    specialize (AllWFM n0 (@Zero n 1%nat) H0).
    rewrite AllWFM; auto; lia.
Qed.


Fixpoint index_rec (i : nat) (list0 : list nat) (n : nat) {struct list0} : option nat :=
  match list0 with
  | nil => None
  | h :: t => if (n =? h)%nat then Some i else index_rec (s i) t n
  end.
Definition index := index_rec 0%nat.

Lemma index_rec_nil : forall i n : nat, index_rec i nil n = None.
Proof. intros; unfold index; easy. Qed.
Lemma index_nil : forall n : nat, index nil n = None.
Proof. apply index_rec_nil. Qed.

Definition add_Some (i : nat) (x : option nat) : option nat :=
  match x with
  | None => None
  | Some n => Some (n + i)%nat
  end.
Definition add_one := add_Some 1%nat.

Lemma add_one_Some : forall (i : nat), add_one (Some i) = Some (s i).
Proof. unfold add_one; simpl; setoid_rewrite Nat.add_1_r; auto. Qed.

Lemma add_Some_add_Some : forall (i j : nat) (x : option nat),
    add_Some i (add_Some j x) = add_Some (j + i) x.
Proof. intros i0 j x.
  induction x; auto; simpl; rewrite Nat.add_assoc; easy.
Qed.

Lemma index_rec_nat : forall (i : nat) (list0 : list nat) (n : nat),
    index_rec i list0 n = add_Some i (index list0 n).
Proof. intros i0 list0 n. unfold index.
  gen i0.
  induction list0.
  - intros; rewrite index_rec_nil, index_nil; easy.
  - intros; simpl; bdestruct_all; auto.
    setoid_rewrite IHlist0.
    rewrite add_Some_add_Some.
    f_equal; lia.
Qed.

Lemma index_rec_one : forall (list0 : list nat) (n : nat),
    index_rec 1%nat list0 n = add_one (index list0 n).
Proof. intros list0 n. apply index_rec_nat. Qed. 

Definition unwrap (x : option nat) : nat :=
  match x with
  | None => 0%nat
  | Some n => n
  end.
  
Lemma index_cons : forall (x : nat) (list0 : list nat) (n : nat),
    index (x :: list0) n = if (n =? x)%nat then Some 0%nat else add_one (index list0 n).
Proof. intros x list0 n.
  unfold index.
  bdestruct_all; subst; simpl; bdestruct_all; auto.
  apply index_rec_one.
Qed.

Lemma index_bound : forall (list0 : list nat) (n : nat),
    list0 <> [] -> (unwrap (index list0 n) < length list0)%nat.
Proof. intros list0 n H0.
  destruct (index list0 n) eqn:E.
  - simpl.
    gen n0.
    induction list0; intros n0 E.
    + rewrite index_nil in E.
      inversion E.
    + rewrite index_cons in E.
      bdestruct (n =? a)%nat.
      * inversion E.
        simpl. lia.
      * destruct (list_eq_dec Nat.eq_dec list0 nil) as [E' | E'].
        -- subst.
           rewrite index_nil in E.
           inversion E.
        -- specialize (IHlist0 E' ).
           destruct (index list0 n) eqn:E0.
           ++ simpl in *.
              inversion E.
              subst.
              specialize (IHlist0 n1 eq_refl).
              lia.
           ++ inversion E.
  - simpl. rewrite <- length_zero_iff_nil in H0. lia.
Qed.

Lemma In_index_Some : forall (list0 : list nat) (n : nat), In n list0 <-> (exists i, index list0 n = Some i).
Proof. intros list0 n.
  split; intros H0.
  - apply In_nth with (d := 0%nat) in H0.
    destruct H0 as [i [H0 H1]].
    gen i.
    induction list0; simpl in *.
    + intros; lia.
    + intros i0 H0 H1.
      rewrite index_cons.
      bdestruct_all.
      * exists 0%nat. easy.
      * destruct i0; try lia.
        assert (i0 < length list0)%nat by lia.
        destruct (IHlist0 i0 H3 H1) as [j H4].
        exists (s j).
        rewrite H4.
        rewrite add_one_Some.
        reflexivity.
  - destruct H0 as [i H0].
    unfold index in H0.
    gen i.
    induction list0.
    + intros; simpl in *; inversion H0.
    + intros; rewrite index_cons in H0.
      bdestruct (n =? a)%nat.
      * subst. apply in_eq.
      * destruct (index list0 n) eqn:E.
        -- simpl in H0.
           inversion H0.
           subst.
           specialize (IHlist0 n0 E).
           apply in_cons; auto.
        -- inversion H0.
Qed.

Lemma nth_index : forall (list0 : list nat) (n d : nat),
    In n list0 -> nth (unwrap (index list0 n)) list0 d = n.
Proof. intros list0 n d H0.
  (* remember H0 as H0'. clear HeqH0'. *)
  rewrite In_index_Some in H0.
  destruct H0 as [i H0].
  rewrite H0 in *.
  simpl.
  gen i.
  induction list0; intros.
  - rewrite index_nil in H0. inversion H0.
  - rewrite index_cons in H0.
    bdestruct (n =? a)%nat.
    + subst.
      inversion H0.
      subst.
      easy.
    + destruct (index list0 n) eqn:E.
      * simpl in H0.
        inversion H0.
        subst.
        rewrite Nat.add_1_r in *.
        simpl.
        apply IHlist0; easy.
      * simpl in H0. inversion H0.
Qed.

Lemma index_nth : forall (list0 : list nat) (i d : nat), NoDup list0 -> (i < length list0)%nat ->
                                                index list0 (nth i list0 d) = Some i.
Proof. intros list0 i d H0 H1.
  pose (nth_In list0 d H1) as H2.
  rewrite In_index_Some in H2.
  destruct H2 as [j H2].
  rewrite H2.
  rewrite NoDup_nth in H0.
 assert (length list0 <> 0%nat).
 { intro. rewrite length_zero_iff_nil in H3. subst. simpl in *. inversion H1. }
 rewrite length_zero_iff_nil in H3.
 pose (index_bound list0 (nth i list0 d) H3) as H4.
 rewrite H2 in H4.
 simpl in H4.
 specialize (H0 i j H1 H4).
 assert (nth (unwrap (index list0 (nth i list0 d))) list0 d = nth j list0 d) by (rewrite H2; auto).
 assert (In (nth i list0 d) list0) by (apply nth_In; lia).
 rewrite (nth_index list0 (nth i list0 d) d H6) in H5.
 specialize (H0 H5).
 rewrite H0 in *.
 reflexivity.
Qed.

Lemma vector_row_choose_inverse : forall (n : nat) (indices_list : list nat) (v : Vector (length indices_list)),
    NoDup indices_list -> incl indices_list (List.seq 0%nat n) -> WF_Matrix v ->
    exists (w : Vector n), WF_Matrix w /\ v = vector_row_choose indices_list w.
Proof. intros n indices_list v H0 H1 H2. 
  exists (fun r c =>
      if (c =? 0)%nat
      then
        if (ListDec.In_dec Nat.eq_dec r indices_list)
        then v (unwrap (index indices_list r)) 0%nat
        else C0
      else C0).
  split.
  - unfold WF_Matrix.
    intros x y H3.
    bdestruct_all; auto.
    destruct (ListDec.In_dec Nat.eq_dec x indices_list) as [H5 | H5]; auto.
    apply H1 in H5.
    rewrite in_seq in H5.
    lia.
  - unfold vector_row_choose.
    prep_matrix_equality.
    bdestruct (x <? length indices_list).
    + bdestruct_all.
      2 : rewrite H2; auto; lia.
      subst.
      destruct (ListDec.In_dec Nat.eq_dec (nth x indices_list n) indices_list) as [H4 | H4].
      2 : pose (nth_In indices_list n H3); contradiction.
      rewrite (index_nth indices_list x n H0 H3).
      easy.
    + destruct (ListDec.In_dec Nat.eq_dec (nth x indices_list n) indices_list) as [H4 | H4].
      * bdestruct_all.
        -- subst. apply H1 in H4.
           rewrite in_seq, nth_overflow in H4; lia.
        -- rewrite H2; auto; lia.
      * bdestruct_all; auto.
Qed.

Lemma WF_Unitary_implies_linearly_independent : forall {n : nat} {M : Square n},
    WF_Unitary M -> linearly_independent M.
Proof. intros n M H0.
  assert (invertible M) by (apply WF_Unitary_implies_invertible; auto).
  rewrite <- lin_indep_iff_invertible in H1; auto with wf_db.
Qed.

Lemma matrix_column_choose_Zero : forall {n m : nat} {indices_list : list nat},
    matrix_column_choose indices_list (@Zero n m) = @Zero n (length indices_list).
Proof. intros n m indices_list.
  unfold matrix_column_choose, list_vector_to_matrix.
  prep_matrix_equality.
  bdestruct (y <? length indices_list).
  - rewrite nth_indep with (d' := (fun i0 : nat => get_vec i0 (@Zero n m)) 0%nat).
    + rewrite map_nth with (f := (fun i0 : nat => get_vec i0 Zero)).
      unfold get_vec.
      bdestruct_all.
      easy.
    + rewrite map_length; auto.
  - rewrite nth_overflow; auto.
    rewrite map_length; auto.
Qed.

Lemma vector_row_choose_Zero : forall {n : nat} {indices_list : list nat},
    vector_row_choose indices_list (@Zero n 1) = @Zero (length indices_list) 1.
Proof. intros n indices_list.
  unfold vector_row_choose.
  prep_matrix_equality.
  easy.
Qed.

Lemma span_get_vec : forall {n m : nat} (M : Matrix n m) (i : nat),
    WF_Matrix M -> (i < m)%nat -> span M (get_vec i M).
Proof. intros n m M i0 H0 H1.
  unfold span.
  exists (e_i i0).
  split; auto with wf_db; rewrite e_i_get_vec; auto with wf_db.
Qed.

Lemma equivalent_subspace_basis : forall {n m : nat} {P1 P2 : Vector n -> Prop} {M : Matrix n m},
    (forall v : Vector n, P1 v <-> P2 v) -> (basis P1 M <-> basis P2 M).
Proof. intros n m P1 P2 M H0.
  unfold basis; split; intros H1; destruct H1 as [H1 [H2 [H3 H4]]];
    destruct H1 as [H5 [H6 [H7 H8]]];
    repeat (split; intros; auto with wf_db).
  - apply H5; rewrite H0; easy.
  - rewrite <- H0; easy.
  - rewrite <- H0; apply H7; rewrite H0; auto.
  - rewrite <- H0; apply H8; rewrite H0; auto.
  - rewrite <- H0; apply H2; auto.
  - apply H3; rewrite H0; auto.
  - apply H5; rewrite <- H0; easy.
  - rewrite H0; easy.
  - rewrite H0; apply H7; rewrite <- H0; auto.
  - rewrite H0; apply H8; rewrite <- H0; auto.
  - rewrite H0; apply H2; auto.
  - apply H3; rewrite <- H0; auto.
Qed.
    
Lemma span_WF_Matrix : forall {n m : nat} {M : Matrix n m} {v : Vector n},
    WF_Matrix M -> span M v -> WF_Matrix v.
Proof. intros n m M v H0 H1.
  unfold span in H1.
  destruct H1 as [a [H1 H2]].
  rewrite H2.
  auto with wf_db.
Qed.

Lemma span_in_subspace : forall {n m : nat} {M : Matrix n m} {P : Vector n -> Prop},
    subspace P ->
    (forall i : nat, (i < m)%nat -> P (get_vec i M)) ->
    (forall v : Vector n, span M v -> P v).
Proof. intros n m M P H0 H1 v H2.
  unfold span in H2.
  destruct H2 as [a [H2 H3]].
  rewrite H3.
  apply subspace_closed_under_linear_combinations;
    auto with wf_db.
Qed.

Lemma subspace_is_basis_span : forall {n m : nat} {P : Vector n -> Prop} {M : Matrix n m},
    basis P M -> (forall v : Vector n, P v <-> span M v).
Proof. intros n m P M H0 v.
  destruct H0 as [H0 [H1 [H2 H3]]];
    split; intros.
  - apply H2; easy.
  - apply (span_in_subspace H0 H1); easy.
Qed.

Lemma left_invertible_linearly_independent : forall {n m : nat} {M : Square n} {A : Matrix n m}, 
    WF_Matrix A -> invertible M -> (linearly_independent (M × A) <-> linearly_independent A).
Proof. intros n m M A H0 H1. 
  destruct H1 as [M0 H1].
  destruct H1 as [H1 H2].
  unfold linearly_independent.
  split; intros H3 a WFa eqn.
  - apply H3; auto.
    rewrite Mmult_assoc, eqn, Mmult_0_r; reflexivity.
  - apply H3; auto.
    apply @Mmult_inj_l with (i := n) (m := M0) in eqn.
    rewrite <- ! Mmult_assoc in eqn.
    destruct H2.
    rewrite H4, Mmult_1_l, Mmult_0_r in eqn; auto.
Qed.

Lemma get_vec_mult_matrix : forall {n m o : nat} (i : nat) (A : Matrix n m) (B : Matrix m o),
    A × get_vec i B = get_vec i (A × B).
Proof. intros n m o i0 A B.
  unfold get_vec, Mmult.
  prep_matrix_equality.
  bdestruct_all; auto.
  rewrite big_sum_0_bounded; intros; lca.
Qed.

  
Lemma det_by_get_vec_matrix : forall {n m : nat} (A B : Matrix n m),
    (forall i : nat, get_vec i A = get_vec i B) -> A = B.
Proof. intros n m A B H0.
  prep_matrix_equality.
  unfold get_vec in H0.
  specialize (H0 y).
  apply f_equal_inv with (x := x) in H0.
  apply f_equal_inv with (x := 0%nat) in H0; auto.
Qed.

Lemma unitary_columns_inner_product : forall {n : nat} (i j : nat) (U : Square n),
    WF_Unitary U -> inner_product (get_vec i U) (get_vec j U) = I n i j.
Proof. intros n i0 j U H0.
  rewrite inner_product_is_mult.
  destruct H0 as [WFU unitary_U].
  rewrite unitary_U.
  easy.
Qed.

Lemma single_element_matrix_equality : forall (A B : Matrix 1%nat 1%nat),
    WF_Matrix A -> WF_Matrix B -> (A = B <-> A 0%nat 0%nat = B 0%nat 0%nat).
Proof. intros A B H0 H1.
  split; intros.
  - rewrite H2; auto.
  - prep_matrix_equality.
    bdestruct (x <? 1%nat).
    + replace x with 0%nat by lia.
      bdestruct (y <? 1%nat).
      * replace y with 0%nat by lia; auto.
      * rewrite H0, H1; auto; lia.
    + rewrite H0, H1; auto; lia.
Qed.

Lemma unitary_adjoint_on_column_vector : forall {n : nat} (i : nat) (U : Square n),
    WF_Unitary U -> (get_vec i U)† × U = (e_i i)†.
Proof. intros n i0 U H0.
  apply det_by_get_vec_matrix.
  intros i1. 
  rewrite <- get_vec_mult_matrix.
  rewrite single_element_matrix_equality; auto with wf_db.
  replace ((adjoint (get_vec i0 U) × get_vec i1 U) 0%nat 0%nat)
    with (inner_product (get_vec i0 U) (get_vec i1 U))
    by auto.
  rewrite unitary_columns_inner_product; auto.
  unfold I, e_i, adjoint, get_vec, Cconj; simpl.
  bdestruct_all; simpl; lca.
Qed.

Lemma inner_product_vector_with_standard_basis : forall {n : nat} (i : nat) (v : Vector n),
    (i < n)%nat -> inner_product (e_i i) v = v i 0%nat.
Proof. intros n i0 v H0.
  unfold e_i, inner_product, adjoint, Mmult, Cconj.
  simpl.
  apply big_sum_unique.
  exists i0.
  repeat (split; intros; simpl; auto; bdestruct_all; simpl; auto; try lca).
Qed.

Lemma e_i_overflow : forall (n i : nat), (i >= n)%nat -> @e_i n i = @Zero n 1%nat.
Proof. intros n i0 H0.
  unfold e_i.
  prep_matrix_equality.
  bdestruct_all; auto.
Qed.

Lemma inner_product_vector_with_standard_basis' : forall {n : nat} (i : nat) (v : Vector n),
    WF_Matrix v -> inner_product (e_i i) v = v i 0%nat.
Proof. intros n i0 v H0.
  bdestruct (i0 <? n)%nat.
  - apply (inner_product_vector_with_standard_basis i0 v H1).
  - setoid_rewrite H0 at 1; try lia.
    rewrite e_i_overflow; auto.
    unfold inner_product.
    rewrite zero_adjoint_eq, Mmult_0_l; auto.
Qed.


(**************************************)
(** ** Semantical Definitions ** **)
(**************************************)

(** order is from left to right **)
Definition collect_fun {A : Type} (len : nat) (f : nat -> A) := map f (List.seq 0%nat len).
Definition to_fun {A : Type} (d : A) (ls : list A) := (fun n : nat => nth n ls d).

Lemma collect_fun_length : forall {A : Type} (len : nat) (f : nat -> A),
    length (collect_fun len f) = len.
Proof. intros A len f.
  unfold collect_fun.
  rewrite map_length, seq_length; auto.
Qed.

Lemma collect_fun_to_fun : forall {A : Type} (d : A) (ls : list A),
    collect_fun (length ls) (to_fun d ls) = ls.
Proof. intros A d ls. 
  unfold collect_fun, to_fun.
  apply nth_ext with (d := nth (length ls) ls d) (d' := d).
  - rewrite map_length, seq_length. auto.
  - intros n H0.
    rewrite map_nth with (d := length ls).
    rewrite map_length, seq_length in H0.
    rewrite seq_nth; auto.
Qed.

Lemma WF_collect_fun_perm_to_fun : forall {n m : nat} (d : Matrix n m) (ls : list (Matrix n m)) (p : nat -> nat),
    permutation (length ls) p -> Forall WF_Matrix ls -> WF_Matrix d ->
    Forall WF_Matrix (collect_fun (length ls) ((to_fun d ls) ∘ p)%prg).
Proof. intros n m d ls p H0 H1 H2. 
  unfold collect_fun, to_fun, compose.
  rewrite Forall_forall. intros x H3.
  rewrite in_map_iff in H3.
  destruct H3 as [y [H3 H4]].
  rewrite <- H3.
  rewrite in_seq in H4.
  assert (y < length ls)%nat by lia.
  apply Forall_nth; auto.
  unfold permutation in H0.
  destruct H0 as [g H0].
  destruct (H0 y H5) as [H6 [H7 [H8 H9]]].
 auto.
Qed.

Lemma to_fun_collect_fun : forall {A : Type} (d : A) (len : nat) (f : nat -> A),
    forall i : nat, (i < len)%nat -> to_fun d (collect_fun len f) i = f i.
Proof. intros A d len f i H0. 
  unfold collect_fun, to_fun.
  rewrite nth_indep with (d' := f 0%nat).
  rewrite map_nth with (d := 0%nat).
  rewrite seq_nth; auto.
  rewrite map_length, seq_length; auto.
Qed.

Lemma to_fun_seq : forall (d len : nat),
    forall i : nat, (i < len)%nat -> to_fun d (List.seq 0%nat len) i = i.
Proof. intros. unfold to_fun. rewrite seq_nth; auto. Qed.

Lemma to_fun_seq_permutation : forall (d len : nat),
    permutation len (to_fun d (List.seq 0%nat len)).
Proof. intros d len.
  unfold permutation. exists idn.
  intros x H0. rewrite to_fun_seq; auto.
Qed.

Lemma collect_fun_idn_seq : forall (len : nat),
    collect_fun len idn = List.seq 0%nat len.
Proof. intros. unfold collect_fun. rewrite map_id. auto. Qed.

Lemma collect_fun_to_fun_map : 
  forall {A B : Type} (f : A -> B) (n : nat) (a : A) (l : list A) (p : nat -> nat),
    map f (collect_fun n (to_fun a l ∘ p)%prg) = 
       collect_fun n (to_fun (f a) (map f l) ∘ p)%prg.
Proof. intros A B f n a l p.
  unfold collect_fun, to_fun, compose.
  rewrite map_map. f_equal.
  apply functional_extensionality; intros.
  rewrite map_nth. auto.
Qed.

Lemma Permutation_permutation_nth : forall {A : Type} (l l' : list A) (d : A),
  Permutation l l' <->
    length l' = length l /\ 
      (exists f : nat -> nat, permutation (length l) f /\ 
                      (forall x : nat, (x < length l)%nat -> nth x l' d = nth (f x) l d)).
Proof. intros A l l' d.
  split; intros.
  - rewrite Permutation_nth in H0.
    destruct H0 as [H [f [H0 [H1 H2]]]].
    split; auto. exists f. split; auto.
    + unfold permutation.
      remember H1 as H1'. clear HeqH1'.
     rewrite FinFun.bInjective_bSurjective in H1'; auto.
     destruct (FinFun.bSurjective_bBijective H0 H1') as [g [H3 H4]].
     exists g. intros. repeat split.
      * unfold FinFun.bFun in H0; auto.
      * unfold FinFun.bFun in H3; auto.
      * destruct (H4 x H5); auto.
      * destruct (H4 x H5); auto.
  - rewrite Permutation_nth.
    destruct H0 as [H [f [H0 H1]]].
    split; auto. exists f. repeat split; auto.
    + unfold FinFun.bFun. intros.
      unfold permutation in H0.
      destruct H0 as [g H0].
      destruct (H0 x H2) as [H3 [H4 [H5 H6]]]. auto.
    + unfold FinFun.bInjective. intros.
      unfold permutation in H0.
      destruct H0 as [g H0].
      destruct (H0 x H2) as [H5 [H6 [H7 H8]]].  rewrite <- H7. 
      destruct (H0 y H3) as [H9 [H10 [H11 H12]]].  rewrite <- H11. 
      rewrite H4; auto.
Qed.  

Lemma Permutation_permutation_to_fun : forall {A : Type} (d : A) (l l' : list A),
    Permutation l l' <-> length l' = length l /\ 
                         (exists f : nat -> nat, permutation (length l) f /\ 
                                         (forall x : nat, (x < length l)%nat -> to_fun d l' x = (to_fun d l ∘ f)%prg x)).
Proof. intros A d l l'.
  rewrite Permutation_permutation_nth.
  split; intros; destruct H0 as [H0 [f [H1 H2]]]; split; auto; exists f ; split; auto.
  - intros. unfold to_fun, compose. apply H2; auto.
  - intros. unfold to_fun, compose in H2. apply H2; auto.
Qed.

Lemma Permutation_permutation_collect_fun : forall {A : Type} (d : A) (l l' : list A),
    Permutation l l' <-> length l' = length l /\ 
                         (exists f : nat -> nat, permutation (length l) f /\ 
                                         l' = collect_fun (length l) (to_fun d l ∘ f)%prg).
Proof. intros A d l l'.
  rewrite Permutation_permutation_to_fun.
  split; intros H0; destruct H0 as [H0 [f [H1 H2]]]; split; auto; exists f ; split; auto.
  - unfold collect_fun.
    apply nth_ext with (d := d) (d' := d).
    rewrite map_length, seq_length; auto.
    intros n H3. rewrite H0 in H3.
    setoid_rewrite nth_indep with (d' := (to_fun d l ∘ f)%prg 0%nat) at 2.
    rewrite map_nth. rewrite seq_nth; auto; simpl.
    unfold to_fun, compose. apply H2; auto.
    rewrite map_length, seq_length; auto.
  - intros. rewrite H2. rewrite to_fun_collect_fun; auto.
Qed.

Lemma perm_eq_permutation_swap : forall (n : nat) (f g : nat -> nat),
    perm_eq n f g -> (permutation n f <-> permutation n g).
Proof. intros n f g H0; split; intros H1.
  - unfold permutation in *.
    destruct H1 as [h H1].
    exists h. intros x H2.
    specialize (H1 x H2).
    destruct H1 as [H1 [H3 [H4 H5]]].
    repeat split; try rewrite <- H0; auto.
  - unfold permutation in *.
    destruct H1 as [h H1].
    exists h. intros x H2.
    specialize (H1 x H2).
    destruct H1 as [H1 [H3 [H4 H5]]].
    repeat split; try rewrite H0; auto.
Qed.

Lemma Permutation_permutation_seq : forall (n : nat) (orderlist : list nat),
    Permutation orderlist (List.seq 0%nat n) ->
    permutation n (to_fun 0%nat orderlist).
Proof. intros n orderlist H0.
  apply Permutation_sym in H0.
  rewrite Permutation_permutation_to_fun in H0.
  rewrite ! seq_length in H0.
  destruct H0 as [len [f [permf permeq]]].
  rewrite (perm_eq_permutation_swap n (to_fun 0%nat orderlist) (to_fun 0%nat (List.seq 0 n) ∘ f)%prg permeq).
  apply permutation_compose; auto.
  apply to_fun_seq_permutation.
Qed.

Module Import NatSort := Sort NatOrder.
Compute sort [1;3;0;2;5;4]%nat.

Lemma sort_seq_Permutation : forall (l : list nat),
  sort l = (List.seq 0%nat (length l)) -> Permutation l (List.seq 0%nat (length l)).
Proof. intros l H0.
  rewrite <- H0.
  apply Permuted_sort.
Qed.

Lemma perm_inv_involutive : forall (n : nat) (p : nat -> nat),
    permutation n p ->
    perm_eq n p (perm_inv n (perm_inv n p)).
Proof. intros n p H0.
  apply permutation_inverse_injective with (f := perm_inv n p).
  apply perm_inv_permutation; auto.
  split. pose (perm_inv_is_linv_of_permutation n p H0); auto.
  pose (perm_inv_is_rinv_of_permutation n p H0); auto.
  pose (perm_inv_permutation n p H0) as H1.
  split. pose (perm_inv_is_rinv_of_permutation n (perm_inv n p) H1); auto.
  pose (perm_inv_is_linv_of_permutation n (perm_inv n p) H1); auto.
Qed.

Lemma collect_fun_perm_to_fun_involutive : forall {A : Type} (ls : list A) (d : A) (p : nat -> nat),
    permutation (length ls) p ->
    (collect_fun (length ls) (to_fun d ls ∘ p)%prg) = 
      (collect_fun (length ls) (to_fun d ls ∘ (perm_inv (length ls) (perm_inv (length ls) p)))%prg).
Proof. intros A ls d p H0.
  unfold collect_fun, to_fun, compose.
  pose (perm_inv_involutive (length ls) p H0) as H1.
  apply nth_ext with (d := (fun x : nat => nth (p x) ls d) 0%nat) (d' := (fun x : nat => nth (perm_inv (length ls) (perm_inv (length ls) p) x) ls d) 0%nat);
    rewrite ! map_length, ! seq_length; auto.
  intros. rewrite ! map_nth with (d := 0%nat).
  rewrite ! seq_nth; auto. simpl.
  rewrite H1; auto.
Qed.

Lemma perm_mat_inv : forall (n : nat) (p : nat -> nat),
  permutation n p ->
  perm_mat n (perm_inv n p) = (perm_mat n p)†.
Proof. intros n p H0.
  assert (I n × perm_mat n (perm_inv n p) = perm_mat n (perm_inv n p)).
  { rewrite Mmult_1_l; auto with wf_db. }
  rewrite <- H1.
  assert (I n × adjoint (perm_mat n p) = adjoint (perm_mat n p)).
  { rewrite Mmult_1_l; auto with wf_db. }
  rewrite <- H2.
  destruct (perm_mat_unitary n p H0).
  rewrite <- ! H4. rewrite ! Mmult_assoc.
  apply Mmult_inj_l.
  rewrite perm_mat_Mmult; try apply perm_inv_permutation;
    try apply perm_inv_bounded; auto.
  apply Minv_flip in H4; auto with wf_db.
  rewrite H4.
  assert (perm_eq n (p ∘ perm_inv n p)%prg idn).
  { unfold compose. pose (perm_inv_is_rinv_of_permutation n p H0); auto. }
  unfold perm_mat, I. prep_matrix_equality. bdestruct_all; simpl; auto. 
  all : rewrite H5 in H8; auto; try contradiction.
Qed.

Lemma perm_to_matrix_inv : forall (n : nat) (p : nat -> nat),
  permutation n p ->
  perm_to_matrix n (perm_inv n p) = (perm_to_matrix n p)†.
Proof. intros n p H0.
  assert (I (2 ^ n) × perm_to_matrix n (perm_inv n p) = perm_to_matrix n (perm_inv n p)).
  { rewrite Mmult_1_l; auto with wf_db. }
  rewrite <- H1.
  assert (I (2 ^ n) × adjoint (perm_to_matrix n p) = adjoint (perm_to_matrix n p)).
  { rewrite Mmult_1_l; auto with wf_db. }
  rewrite <- H2.
  destruct (perm_to_matrix_unitary n p H0).
  rewrite <- ! H4. rewrite ! Mmult_assoc.
  apply Mmult_inj_l.
  rewrite perm_to_matrix_Mmult; try apply perm_inv_permutation;  auto.
  apply Minv_flip in H4; auto with wf_db.
  rewrite H4.
  unfold perm_to_matrix.
  unfold perm_mat, I. prep_matrix_equality.
  bdestruct_all; simpl; auto.
  assert (qubit_perm_to_nat_perm n (perm_inv n p ∘ p)%prg y = y).
  { unfold qubit_perm_to_nat_perm, compose. 
    erewrite funbool_to_nat_eq.
    2: { intros x0 H9. rewrite perm_inv_is_linv_of_permutation; auto. }
    setoid_rewrite nat_to_funbool_inverse; auto. bdestruct_all; auto. }
  rewrite H9 in H7; contradiction.
  assert (qubit_perm_to_nat_perm n (perm_inv n p ∘ p)%prg y = y).
  { unfold qubit_perm_to_nat_perm, compose. 
    erewrite funbool_to_nat_eq.
    2: { intros x0 H9. rewrite perm_inv_is_linv_of_permutation; auto. }
    setoid_rewrite nat_to_funbool_inverse; auto. bdestruct_all; auto. }
  rewrite H9 in H7; contradiction.
Qed.

(* Not Needed
Definition swapfun (i j : nat) := fswap idn i j.

Lemma swapfun_permutation : forall (n i j : nat),
    (i < n)%nat -> (j < n)%nat -> permutation n (swapfun i j).
Proof. intros. unfold swapfun. apply fswap_permutation; auto. apply idn_permutation. Qed.

Lemma swap_to_perm_mat : (perm_mat 4 (swapfun 1 2)) = swap.
Proof. unfold swapfun. rewrite perm_mat_col_swap_I; try lia. lma'. Qed.

Lemma swap_kron : forall (A B : Square 2),
    WF_Matrix A -> WF_Matrix B -> swap × (A ⊗ B) × swap = B ⊗ A.
Proof. intros. lma'. Qed.
*)

Local Coercion Nat.b2n : bool >-> nat.

Fixpoint ls_by_f_to_vec (n : nat) (ls : list (Square 2)) (f g : nat -> bool) : Vector 1 :=
  match n with 
  | 0%nat => I 1
  | Datatypes.S n' => 
      (ls_by_f_to_vec n' ls f g) ⊗ ( bra (f n') × (nth n' ls (I 2)) × (ket ( g n')))
  end.

Fixpoint ls_by_f_to_vec_list' (n : nat) (ls : list (Square 2)) (f g : nat -> bool) : list (Vector 1) :=
  match n with 
  | 0%nat => []
  | Datatypes.S n' => 
      ( bra (f n') × (nth n' ls (I 2)) × (ket ( g n'))) :: (ls_by_f_to_vec_list' n' ls f g)
  end.

Lemma WF_ls_by_f_to_vec_list' : forall (n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    Forall WF_Matrix ls -> Forall WF_Matrix (ls_by_f_to_vec_list' n ls f g).
Proof. intros n ls f g H0.
  induction n; auto. simpl.
  apply Forall_cons; auto.
  apply WF_mult; auto with wf_db.
  apply WF_mult; auto with wf_db.
  bdestruct (n <? length ls).
  - apply Forall_nth; auto.
  - rewrite nth_overflow; auto with wf_db.
Qed.

Definition ls_by_f_to_vec_list (n : nat) (ls : list (Square 2)) (f g : nat -> bool) := rev (ls_by_f_to_vec_list' n ls f g).

Lemma WF_ls_by_f_to_vec_list : forall (n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    Forall WF_Matrix ls -> Forall WF_Matrix (ls_by_f_to_vec_list n ls f g).
Proof. intros n ls f g H0.
  unfold ls_by_f_to_vec_list. apply Forall_rev. apply WF_ls_by_f_to_vec_list'; auto.
Qed.

Lemma ls_by_f_to_vec_list'_length : forall (n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    length (ls_by_f_to_vec_list' n ls f g) = n.
Proof. intros n ls f g.
  induction n; auto. simpl. auto.
Qed.

Lemma ls_by_f_to_vec_list_length : forall (n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    length (ls_by_f_to_vec_list n ls f g) = n.
Proof. intros n ls f g. unfold ls_by_f_to_vec_list. rewrite rev_length. rewrite ls_by_f_to_vec_list'_length. auto.
Qed.

Lemma ls_by_f_to_vec_list'_firstn : forall (n m : nat) (ls : list (Square 2)) (f g : nat -> bool),
    (n <= length ls)%nat -> (n <= m)%nat ->
    ls_by_f_to_vec_list' n ls f g = ls_by_f_to_vec_list' n (firstn m ls) f g.
Proof. intros n m ls f g H0 H1. 
  gen m f g ls. induction n; intros; auto.
  simpl. f_equal. f_equal. f_equal. rewrite nth_firstn; try lia. auto.
  rewrite IHn with (m := m); try lia. auto.
Qed.

Lemma ls_by_f_to_vec_list'_perm_eq : forall (n : nat) (ls : list (Square 2)) (f f' g g' : nat -> bool),
    perm_eq n f f' -> perm_eq n g g' ->
    ls_by_f_to_vec_list' n ls f g = ls_by_f_to_vec_list' n ls f' g'.
Proof. intros n ls f f' g g' H0 H1.
  induction n; auto.
  simpl. f_equal.
  rewrite H0, H1; try lia; auto.
  apply IHn; unfold perm_eq; intros.
  rewrite H0; auto; lia.
  rewrite H1; auto; lia.
Qed.

Lemma nth_ls_by_f_to_vec_list' : forall (k n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    (k < n)%nat ->
    nth k (ls_by_f_to_vec_list' n ls f g) (I 1) = ( bra (f (n - s k)%nat) × (nth (n - s k)%nat ls (I 2)) × (ket ( g (n - s k)%nat))).
Proof. intros k n ls f g H0. gen k. induction n; intros. simpl. inversion H0.
  induction k. simpl. replace (n - 0)%nat with n by lia. auto.
  assert (k < n)%nat by lia. clear H0.
  replace (s n - s k)%nat with (n - k)%nat in * by lia.
  replace (s n - s (s k))%nat with (n - s k)%nat in * by lia.
  simpl. auto.
Qed.

Lemma nth_ls_by_f_to_vec_list : forall (k n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    (k < n)%nat ->
    nth k (ls_by_f_to_vec_list n ls f g) (I 1) = ( bra (f k) × (nth k ls (I 2)) × (ket ( g k))).
Proof. intros k n ls f g H0. unfold  ls_by_f_to_vec_list. rewrite rev_nth. 2: rewrite ls_by_f_to_vec_list'_length; auto.
  rewrite ls_by_f_to_vec_list'_length. rewrite nth_ls_by_f_to_vec_list'.
  2: lia. replace (n - s (n - s k))%nat with (k) by lia. auto.
Qed.


Lemma ls_by_f_to_vec_list_iff : forall (n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    Forall WF_Matrix ls ->
    big_kron (ls_by_f_to_vec_list n ls f g) = ls_by_f_to_vec n ls f g.
Proof. intros n ls f g H.
  induction n; auto. unfold ls_by_f_to_vec_list in *. simpl. rewrite big_kron_app. 
  2: { intros. bdestruct (i <? n)%nat.
       - rewrite rev_nth. 
           all: rewrite ls_by_f_to_vec_list'_length; auto.
           pose (WF_ls_by_f_to_vec_list' n ls f g H) as E.
           apply Forall_nth; auto; rewrite ls_by_f_to_vec_list'_length; lia.
       - rewrite nth_overflow; auto with wf_db.
         rewrite rev_length, ls_by_f_to_vec_list'_length; lia. }
  2: { intros. bdestruct (i =? 0)%nat; subst.
       - simpl. apply WF_mult; auto with wf_db.
         apply WF_mult; auto with wf_db.
         bdestruct (n <? length ls)%nat.
         + apply Forall_nth; auto.
         + rewrite nth_overflow; auto with wf_db.
       - rewrite nth_overflow; auto with wf_db; simpl; lia. }
  rewrite IHn. f_equal. 
  1-2: rewrite Nat.pow_1_l; auto.
  simpl. rewrite kron_1_r. auto.
Qed.

Lemma ls_by_f_to_vec_S : forall (n : nat) (ls : list (Square 2)) (f g : nat -> bool),
    (n >= length ls)%nat ->
    ls_by_f_to_vec (Datatypes.S n) ls f g = ls_by_f_to_vec n ls f g ⊗ (bra (f n) × ket (g n)).
Proof. intros n ls f g H0.
  simpl. rewrite nth_overflow; auto. rewrite Mmult_1_r; auto with wf_db.
Qed.

Lemma big_kron_Permutation : forall (ls ls' : list (Vector 1)),
    Forall WF_Matrix ls ->
    Permutation ls ls' -> big_kron ls = big_kron ls'.
Proof. intros ls ls' H0 H1.  induction H1; auto; simpl. 
  - rewrite IHPermutation. f_equal. 
    1-2: rewrite ! Nat.pow_1_l; auto.
    rewrite Forall_cons_iff in H0; destruct H0; auto.
  - rewrite Forall_cons_iff in H0; destruct H0.
    rewrite Forall_cons_iff in H1; destruct H1.
    unfold kron. prep_matrix_equality. rewrite ! Nat.pow_1_l. rewrite ! Nat.add_0_r. simpl. 
    rewrite ! divmod_0. rewrite ! Cmult_assoc. f_equal. 
    bdestruct (x0 =? 0)%nat; subst.
    + bdestruct (y0 =? 0)%nat; subst; try lca.
      rewrite H0; try lia. rewrite Cmult_0_l. rewrite H1; try lia. lca.
    + rewrite H0; try lia. rewrite Cmult_0_l. rewrite H1; try lia. lca.
  - rewrite IHPermutation1; auto. apply IHPermutation2.
    rewrite Forall_forall. intros.
    apply Permutation_sym in H1_.
    apply (Permutation_in x H1_) in H1.
    rewrite Forall_forall in H0. apply H0; auto.
Qed.

Lemma ls_by_f_to_vec_permutation : forall (ls : list (Square 2)) (f g : nat -> bool) (p : nat -> nat),
    Forall WF_Matrix ls ->
    permutation (length ls) p -> 
    ls_by_f_to_vec (length ls) ls (f ∘ p)%prg (g ∘ p)%prg = 
      ls_by_f_to_vec (length ls) (collect_fun (length ls) ((to_fun (I 2) ls) ∘ (perm_inv (length ls) p))%prg) f g.
Proof. intros ls f g p H H0.
  unfold collect_fun, to_fun, compose.
  rewrite <- ! ls_by_f_to_vec_list_iff; auto.
  apply big_kron_Permutation. 
  apply WF_ls_by_f_to_vec_list; auto.
  rewrite Permutation_permutation_nth. split. 
  rewrite ! ls_by_f_to_vec_list_length; auto.
  exists (perm_inv (length ls) p). split. 
  rewrite ls_by_f_to_vec_list_length; apply perm_inv_permutation; auto.
  intros. 
  rewrite ! ls_by_f_to_vec_list_length in *.
  rewrite ! nth_ls_by_f_to_vec_list; auto. 
  2: { pose (perm_inv_permutation (length ls) p H0) as E.
       unfold permutation in E.
       destruct E as [pinv H2].
       destruct (H2 x H1) as [H3 [H4 [H5 H6]]].
       auto. }
  2: { rewrite Forall_forall. intros.
       rewrite in_map_iff in H1.
       destruct H1 as [y [H1 H2]].
       rewrite <- H1.
       apply Forall_nth; auto.
       rewrite in_seq in H2.
       pose (perm_inv_permutation (length ls) p H0) as E.
       unfold permutation in E.
       destruct E as [pinv H3]. assert (y < length ls)%nat by lia.
       destruct (H3 y H4) as [H5 [H6 [H7 H8]]].
       auto. }
  assert ((p (perm_inv (length ls) p x)) = x). 
  { rewrite perm_inv_is_rinv_of_permutation; auto. }
  rewrite ! H2. f_equal. f_equal.
  rewrite nth_indep with (d' := (fun x0 : nat => nth (perm_inv (length ls) p x0) ls (I 2)) 0%nat).
  2: rewrite map_length, seq_length; auto.
  rewrite map_nth with (d := 0%nat).
  rewrite seq_nth; auto.
Qed.

Lemma ls_by_f_to_vec_by_f_to_vec_rev : forall (ls : list (Square 2)) (f g : nat -> bool),
    Forall WF_Matrix ls ->
 (ls_by_f_to_vec (length ls) (rev ls) f g) = (f_to_vec (length ls) f) † × (big_kron (rev ls)) × (f_to_vec (length ls) g).
Proof. intros ls f g H.
  induction ls. simpl. lma'.
  rewrite <- ! ls_by_f_to_vec_list_iff in *. unfold ls_by_f_to_vec_list in *.
  simpl. rewrite big_kron_app. 
  5: apply Forall_rev; auto.
  4: apply Forall_rev; rewrite Forall_cons_iff in H; destruct H; auto.
  2: { rewrite ls_by_f_to_vec_list'_firstn with (m := length ls); auto.
       2: rewrite app_length; simpl; rewrite rev_length; lia.
       intros. rewrite firstn_app. rewrite rev_length.
       replace (length ls - length ls)%nat with 0%nat by lia. simpl. 
       rewrite app_nil_r. rewrite firstn_all2; try rewrite rev_length; try lia.
       bdestruct (i <? length ls).
       - rewrite rev_nth. all: rewrite ls_by_f_to_vec_list'_length; auto.
         rewrite Forall_cons_iff in H; destruct H.
         assert (Forall WF_Matrix (rev ls)). { apply Forall_rev; auto. }
         pose (WF_ls_by_f_to_vec_list' (length ls) (rev ls) f g H3) as E.
         apply Forall_nth; try rewrite ls_by_f_to_vec_list'_length; auto; lia.
       - rewrite nth_overflow; auto with wf_db.
         rewrite rev_length, ls_by_f_to_vec_list'_length; lia. }
  2: { intros. bdestruct (i =? 0)%nat; subst.
       - simpl. apply WF_mult; auto with wf_db.
         apply WF_mult; auto with wf_db. 
         rewrite app_nth2; rewrite rev_length; try lia.
         replace (length ls - length ls)%nat with 0%nat by lia. simpl.
         rewrite Forall_cons_iff in H; destruct H; auto.
       - rewrite nth_overflow; auto with wf_db. simpl. lia. }
  simpl. rewrite big_kron_app. 
  2: { intros. bdestruct (i <? length ls).
       - rewrite rev_nth; auto.
         rewrite Forall_cons_iff in H; destruct H.
         apply Forall_nth; auto; lia.
       - rewrite nth_overflow; auto with wf_db.
         rewrite rev_length; lia. }
  2: { intros. bdestruct (i =? 0)%nat; subst.
       - simpl. rewrite Forall_cons_iff in H; destruct H; auto.
       - rewrite nth_overflow; auto with wf_db. simpl. lia. }
  simpl. rewrite ! kron_1_r.
  setoid_rewrite kron_adjoint. 
  setoid_rewrite Mmult_assoc.
  setoid_rewrite kron_mixed_product'; try rewrite rev_length; simpl; auto; try lia.
  setoid_rewrite kron_mixed_product'; try rewrite rev_length; simpl; auto; try lia.
  assert ((ls_by_f_to_vec_list' (length ls) (rev ls ++ [a]) f g) =
            (ls_by_f_to_vec_list' (length ls) (rev ls) f g)).
  { rewrite ls_by_f_to_vec_list'_firstn with (m := length ls) at 1. 
    rewrite firstn_app, ! rev_length.
    replace (length ls - length ls)%nat with 0%nat by lia. simpl. rewrite app_nil_r.
    rewrite firstn_all2; try rewrite rev_length; try lia; auto.
    rewrite app_length, rev_length; simpl. all: lia. }
  rewrite H0. rewrite Forall_cons_iff in H; destruct H. rewrite IHls; auto. f_equal.
  1-2: rewrite Nat.pow_1_l; auto.
  rewrite Mmult_assoc; auto.
  rewrite app_nth2; try rewrite rev_length; try lia.
  replace (length ls - length ls)%nat with 0%nat by lia. simpl. f_equal.
  destruct (f (length ls)); lma'.
Qed.

Lemma ls_by_f_to_vec_by_f_to_vec : forall (ls : list (Square 2)) (f g : nat -> bool),
    Forall WF_Matrix ls ->
    (ls_by_f_to_vec (length ls) ls f g) = (f_to_vec (length ls) f) † × (big_kron ls) × (f_to_vec (length ls) g).
Proof. intros ls f g H0. 
  rewrite <- (rev_involutive ls).
  rewrite rev_length.
  rewrite ls_by_f_to_vec_by_f_to_vec_rev; auto.
  apply Forall_rev; auto.
Qed.

Lemma basis_vector_e_i : forall len n,
    (n < len)%nat ->
  basis_vector len n = @e_i len n.
Proof. intros len n H. prep_matrix_equality.
  unfold basis_vector, e_i. 
  bdestruct_all; simpl; try lca.
Qed.

Lemma equal_by_basis_vectors_implies_equal : forall m n (A B : Matrix m n),
  WF_Matrix A -> 
  WF_Matrix B ->
  (forall j k, (j < m)%nat -> (k < n)%nat -> (basis_vector m j) † × A × (basis_vector n k) =
                  (basis_vector m j) † × B × (basis_vector n k)) ->
  A = B.
Proof. intros m n A B H0 H1 H2.
  assert (forall j k : nat,
       (j < m)%nat ->
       (k < n)%nat ->
       adjoint (@e_i m j) × A × @e_i n k =
       adjoint (@e_i m j) × B × @e_i n k).
  { intros j k H3 H4. rewrite <- ! basis_vector_e_i; auto. }
  prep_matrix_equality.
  bdestruct (x <? m)%nat. 
  - bdestruct (y <? n)%nat. 
    + setoid_rewrite get_entry_with_e_i; auto.
      rewrite H3; auto.
    + rewrite H0, H1; try lia; auto.
  - rewrite H0, H1; try lia; auto.
Qed.

Lemma equal_by_basis_states_implies_equal : forall n (A B : Square (2 ^ n)),
  WF_Matrix A -> 
  WF_Matrix B ->
  (forall f g, (f_to_vec n f) † × A × (f_to_vec n g) =
                  (f_to_vec n f) † × B × (f_to_vec n g)) ->
  A = B.
Proof. intros n A B H0 H1 H2.
  apply equal_by_basis_vectors_implies_equal; auto.
  intros j k H3 H4.
  rewrite ! basis_f_to_vec_alt; auto.
Qed.

Lemma permute_kron_rev : forall (ls : list (Square 2)) (p : nat -> nat),
    Forall WF_Matrix (rev ls) ->
    permutation (length (rev ls)) p -> 
    (big_kron (rev ls)) =
      (perm_to_matrix (length (rev ls)) p)† × big_kron (collect_fun (length (rev ls)) ((to_fun (I 2) (rev ls)) ∘ p)%prg) × (perm_to_matrix (length (rev ls)) p).
Proof. intros ls p H0 H1.
  apply equal_by_basis_states_implies_equal.
  apply WF_big_kron'; rewrite <- Forall_forall; auto.
  apply WF_mult; auto with wf_db. apply WF_mult; auto with wf_db.
  pose (WF_big_kron' 2 2 (collect_fun (length (rev ls)) (to_fun (I 2) (rev ls) ∘ p)%prg)) as E. 
  rewrite ! collect_fun_length in E. apply E. rewrite <- Forall_forall.
  apply WF_collect_fun_perm_to_fun; auto with wf_db.
  intros f g.
  rewrite ! Mmult_assoc. rewrite perm_to_matrix_permutes_qubits; auto.
  rewrite <- ! Mmult_assoc. rewrite <- Mmult_adjoint.
  rewrite perm_to_matrix_permutes_qubits; auto.
  rewrite <- ls_by_f_to_vec_by_f_to_vec; auto.
  assert ((collect_fun (length (rev ls)) (to_fun (I 2) (rev ls) ∘ p)%prg) = 
            (collect_fun (length (rev ls)) (to_fun (I 2) (rev ls) ∘ (perm_inv (length (rev ls)) (perm_inv (length (rev ls)) p)))%prg)).
  { rewrite collect_fun_perm_to_fun_involutive; auto. }
  rewrite H2.
  assert (adjoint (f_to_vec (length (rev ls)) (fun x : nat => f (p x))) = adjoint (f_to_vec (length (collect_fun (length (rev ls))
         (to_fun (I 2) (rev ls) ∘ perm_inv (length (rev ls)) (perm_inv (length (rev ls)) p))%prg)) (f ∘ p)%prg)).
  { rewrite collect_fun_length. unfold compose. auto. }
  rewrite H3.
  assert (f_to_vec (length (rev ls)) (fun x : nat => g (p x)) = f_to_vec (length (collect_fun (length (rev ls))
         (to_fun (I 2) (rev ls) ∘ perm_inv (length (rev ls)) (perm_inv (length (rev ls)) p))%prg)) (g ∘ p)%prg).
  { rewrite collect_fun_length. unfold compose. auto. }
  rewrite H4.
  pose (ls_by_f_to_vec_by_f_to_vec (collect_fun (length (rev ls))
             (to_fun (I 2) (rev ls) ∘ perm_inv (length (rev ls)) (perm_inv (length (rev ls)) p))%prg) (f ∘ p)%prg (g ∘ p)%prg) as E.
  rewrite collect_fun_length in *.
  rewrite <- E. rewrite <- ls_by_f_to_vec_permutation; auto.
  rewrite <- ! ls_by_f_to_vec_list_iff; auto.
  unfold ls_by_f_to_vec_list. do 2 f_equal.
  apply ls_by_f_to_vec_list'_perm_eq.
  - intros. unfold compose. 
    pose (perm_inv_is_rinv_of_permutation (length (rev ls)) p H1) as H5.
    unfold perm_eq; intros. rewrite H5; lia.
  - intros. unfold compose. 
    pose (perm_inv_is_rinv_of_permutation (length (rev ls)) p H1) as H5.
    unfold perm_eq; intros. rewrite H5; lia.
  - apply perm_inv_permutation; auto.
  - apply WF_collect_fun_perm_to_fun; auto with wf_db.
    do 2 apply perm_inv_permutation; auto.
  - apply permutation_is_bounded; auto.
  - apply permutation_is_bounded; auto.
Qed.

Lemma permute_kron : forall (ls : list (Square 2)) (p : nat -> nat),
    Forall WF_Matrix ls ->
    permutation (length ls) p -> 
    (big_kron ls) =
      (perm_to_matrix (length ls) p)† × big_kron (collect_fun (length ls) ((to_fun (I 2) ls) ∘ p)%prg) × (perm_to_matrix (length ls) p).
Proof. intros ls p H0 H1.
  assert (rev (rev ls) = ls). { rewrite rev_involutive; auto. }
  rewrite <- H2 in *.
  apply permute_kron_rev; rewrite rev_involutive in *; auto.
Qed.

Lemma permute_kron_inv : forall (ls : list (Square 2)) (p : nat -> nat),
    Forall WF_Matrix ls ->
    permutation (length ls) p -> 
    (perm_to_matrix (length ls) p) × (big_kron ls) × (perm_to_matrix (length ls) p) † =
      big_kron (collect_fun (length ls) ((to_fun (I 2) ls) ∘ p)%prg).
Proof. intros ls p H0 H1.
  rewrite permute_kron with (p := p); auto.
  destruct (perm_to_matrix_unitary (length ls) p H1).
  apply Minv_flip in H3; auto with wf_db.
  rewrite ! Mmult_assoc, H3, Mmult_1_r.
  rewrite <- ! Mmult_assoc, H3, Mmult_1_l. auto.
  - pose (WF_big_kron' 2 2 (collect_fun (length ls) (to_fun (I 2) ls ∘ p)%prg)) as E.
    rewrite ! collect_fun_length in E. apply E.
    rewrite <- Forall_forall. apply WF_collect_fun_perm_to_fun; auto with wf_db.
  - pose (WF_big_kron' 2 2 (collect_fun (length ls) (to_fun (I 2) ls ∘ p)%prg)) as E.
    rewrite ! collect_fun_length in E. apply E.
    rewrite <- Forall_forall. apply WF_collect_fun_perm_to_fun; auto with wf_db.
Qed.

(*****************************************)
(* Defining Eigenvector Semantics *)
(*****************************************)




Definition ExtendQubitsToRight {n : nat} (Lt1 : list (TType n)) (m : nat) :=
  (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1)))).

Lemma ExtendQubitsToRight_length : forall {n : nat} (Lt1 : list (TType n)) (m : nat),
    length (ExtendQubitsToRight Lt1 m) = length Lt1.
Proof. intros n Lt1 m.
  unfold ExtendQubitsToRight.
  rewrite map_length, combine_length, repeat_length.
  minmax_breakdown. auto.
Qed.

Lemma ExtendQubitsToRight_nil : forall {n m : nat},
    @ExtendQubitsToRight n [] m = [].
Proof. intros. unfold ExtendQubitsToRight. auto. Qed.

Lemma ExtendQubitsToRight_zero : forall {n : nat} (Lt1 : list (TType n)),
    ExtendQubitsToRight Lt1 0%nat = Lt1.
Proof. intros n Lt1.
  unfold ExtendQubitsToRight.
  unfold defaultT_I. simpl.
  apply nth_ext with (d := (uncurry gTensorT) (defaultT_I n, (C1, []))) (d' := defaultT_I n).
  rewrite map_length, combine_length, repeat_length. minmax_breakdown. auto.
  intros n0 H0.
  rewrite ! map_nth. rewrite combine_nth. rewrite nth_repeat.
  unfold uncurry. simpl. unfold gTensorT. 
  replace (n+0)%nat with n by lia.
  destruct (nth n0 Lt1 (defaultT_I n)) eqn:E.
  rewrite Cmult_1_r, app_nil_r; auto.
  rewrite repeat_length; auto.
Qed.

Definition ExtendQubitsToLeft {m : nat} (Lt2 : list (TType m)) (n : nat) :=
  (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2)).

Lemma ExtendQubitsToLeft_length : forall {m : nat} (Lt2 : list (TType m)) (n : nat),
    length (ExtendQubitsToLeft Lt2 n) = length Lt2.
Proof. intros m Lt2 n.
  unfold ExtendQubitsToLeft.
  rewrite map_length, combine_length, repeat_length.
  minmax_breakdown. auto.
Qed.

Lemma ExtendQubitsToLeft_nil : forall {m n : nat},
    @ExtendQubitsToLeft m [] n = [].
Proof. intros. unfold ExtendQubitsToLeft. auto. Qed.

Lemma ExtendQubitsToLeft_zero : forall {m : nat} (Lt2 : list (TType m)),
    ExtendQubitsToLeft Lt2 0%nat = Lt2.
Proof. intros m Lt2.
  unfold ExtendQubitsToLeft.
  unfold defaultT_I. simpl.
  apply nth_ext with (d := (uncurry gTensorT) ((C1, []) : TType 0%nat, defaultT_I m)) (d' := defaultT_I m).
  rewrite map_length, combine_length, repeat_length. minmax_breakdown. auto.
  intros n0 H0.
  rewrite ! map_nth. rewrite combine_nth. rewrite nth_repeat.
  unfold uncurry. simpl. unfold gTensorT. 
  replace (0+m)%nat with m by lia.
  destruct (nth n0 Lt2 (defaultT_I m)) eqn:E.
  rewrite Cmult_1_l; auto.
  rewrite repeat_length; auto.
Qed.

Definition DiagonalTwice {n m : nat} (Lt1 : list (TType n)) (Lt2 : list (TType m)) :=
  (ExtendQubitsToRight Lt1 m) ++ (ExtendQubitsToLeft Lt2 n).

Lemma DiagonalTwice_length : forall {n m : nat} (Lt1 : list (TType n)) (Lt2 : list (TType m)),
    length Lt1 = n -> length Lt2 = m ->
    length (DiagonalTwice Lt1 Lt2) = (n + m)%nat.
Proof. intros n m Lt1 Lt2 H0 H1. 
  unfold DiagonalTwice.
  rewrite app_length.
  rewrite ExtendQubitsToRight_length, ExtendQubitsToLeft_length.
  lia.
Qed.

Fixpoint DiagonalQubits (Ln : list nat) (LLT : list (list TTypes)) : list (TType (fold_right Nat.add 0%nat Ln)) :=
  match Ln, LLT with
  | [], _ => ([] : list (TType 0%nat))
  | _, [] => ([] : list (TType 0%nat))
  | (n :: Ln'), (LT :: LLT') => DiagonalTwice (map (AssignT n) LT) (DiagonalQubits Ln' LLT')
  end.

Lemma DiagonalQubits_length : forall (Ln : list nat) (LLT : list (list TTypes)),
    length Ln = length LLT -> Forall2 (fun n LT => length LT = n) Ln LLT ->
    length (DiagonalQubits Ln LLT) = (fold_right Nat.add 0%nat Ln).
Proof. intros Ln LLT H0 H1. 
  gen Ln. induction LLT; intros.
  - destruct Ln; try discriminate. simpl. auto.
  - destruct Ln; try discriminate. simpl in *.
    apply Nat.succ_inj in H0.
    inversion H1; subst. clear H1.
    rewrite DiagonalTwice_length; auto.
    rewrite map_length; auto.
Qed.                                    

Compute DiagonalQubits [3;2;4]%nat 
[ 
[(C1, repeat gX 3);(C1, repeat gX 3);(C1, repeat gX 3)];
[(C1, repeat gY 2);(C1, repeat gY 2)];
[(C1, repeat gZ 4);(C1, repeat gZ 4);(C1, repeat gZ 4);(C1, repeat gZ 4)]
 ].



Definition vecSatisfies {n} (v : Vector n) (U : Square n) : Prop :=
  WF_Matrix v /\ Eigenpair U (v, C1).

Fixpoint vecSatisfiesP {n} (v : Vector (2 ^ n)) (P : Predicate n) {struct P} : Prop :=
  match P with
  | AtoPred s0 => vecSatisfies v (translateA s0)
  | Cap la => WF_Matrix v /\ Forall (fun a0 : AType n => vecSatisfies v (translateA a0)) la
  | Sep Ln_LLT_Perm => WF_Matrix v /\
       Forall (fun T => 
       vecSatisfies v (
                         (perm_to_matrix n (perm_inv n (to_fun 0%nat (snd Ln_LLT_Perm)))) × 
                         translate T
                         × (perm_to_matrix n (perm_inv n (to_fun 0%nat (snd Ln_LLT_Perm)))) †
             ))
        (DiagonalQubits (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm)))
  | Cup A B => (vecSatisfiesP v A) \/ (vecSatisfiesP v B)
  | Err => False
  end.

Lemma WFA_excluded_middle_semantics : forall {n : nat} (v : Vector (2 ^ n)) (A : AType n),
    WF_AType A -> (vecSatisfiesP v A /\ vecSatisfiesP v (- A)) -> v = Zero.
Proof. intros n v A H0. intro H1. destruct H1. simpl in *.
  destruct H1, H2.
  unfold Eigenpair in *. simpl in *. rewrite Mscale_1_l in *.
  rewrite translateA_gScaleA in H4.
  rewrite Mscale_mult_dist_l in H4.
  rewrite H3 in H4.
  symmetry in H4.
  rewrite <- Mplus_zero_iff_equals_minus in H4; auto.
  replace (v .+ v) with (C2 .* v) in H4 by lma'.
  replace Zero with (C2 .* @Zero (2 ^ n) 1%nat) in H4 by lma'.
  apply Mscale_cancel in H4; auto; try nonzero.
  inversion H0.
  apply restricted_addition_syntactic_implies_proper_length_AType in H5; auto.
Qed.

Lemma vecSatisfies_Zero_r : forall {n : nat} (v : Vector n),
    vecSatisfies v Zero -> v = Zero.
Proof. intros n v H0.
  unfold vecSatisfies in H0.
  destruct H0.
  unfold Eigenpair in H1.
  simpl in H1.
  rewrite Mscale_1_l, Mmult_0_l in H1; subst; auto.
Qed.

Lemma vecSatisfies_Zero_l : forall {n : nat} (A : Square n), vecSatisfies Zero A.
Proof. intros n A.
  unfold vecSatisfies.
  split; auto with wf_db.
  unfold Eigenpair; simpl.
  rewrite Mmult_0_r.
  rewrite Mscale_0_r.
  auto.
Qed.

Lemma vecSatisfies_I : forall {n : nat} (v : Vector n), 
    WF_Matrix v -> vecSatisfies v (I n).
Proof. intros n v.
  unfold vecSatisfies.
  split; auto.
  unfold Eigenpair.
  simpl.
  rewrite Mscale_1_l, Mmult_1_l; auto.
Qed.

Lemma vecSatisfiesP_implies_WF_Matrix : forall {n : nat} (v : Vector (2 ^ n)%nat) (P : Predicate n), vecSatisfiesP v P -> WF_Matrix v.
Proof. intros n v P H0. 
    induction P.
    - simpl in H0. unfold vecSatisfies in H0.
      destruct H0; auto.
    - destruct H0. auto.
    - inversion H0; auto.
    - inversion H0; auto.
    - inversion H0.
Qed.

Lemma vecSatisfiesP_defaultP_I : forall {n : nat} (v : Vector (2 ^ n)),
    WF_Matrix v -> vecSatisfiesP v (defaultP_I n).
Proof. intros n v H0. unfold defaultP_I. simpl.
  unfold translateA; simpl.
  rewrite Mplus_0_l.
  rewrite translate_defaultT_I.
  apply vecSatisfies_I; auto.
Qed.


(** ** Separability Proof ** **)

Lemma vecSatisfiesP_iff_stabilizeByListT : forall {n : nat} (Lt : list (TType n)),
(forall v : Vector (2 ^ n)%nat, 
    vecSatisfiesP v (Cap (map TtoA Lt)) <->
      stabilizeByListT (fun v => WF_Matrix v) Lt v).
Proof. intros n Lt v.
  unfold vecSatisfiesP, stabilizeByListT.
  split; intros H; destruct H; split; auto; try rewrite <- Forall_forall in *;
    induction Lt; auto; simpl; constructor; simpl in *; 
    rewrite Forall_cons_iff in H1; destruct H1; auto; clear IHLt.
  - unfold vecSatisfies in H1. destruct H1. unfold Eigenpair in H3. simpl in H3. 
    rewrite Mscale_1_l in H3. unfold translateA in H3. simpl in H3. rewrite Mplus_0_l in H3.
    auto.
  - unfold vecSatisfies. split; auto. unfold Eigenpair. simpl. 
    rewrite Mscale_1_l. unfold translateA. simpl. rewrite Mplus_0_l.
    auto.
 Qed.

Lemma e_i_kron : forall (n m i j : nat),
    (i < n)%nat -> (j < m)%nat -> @e_i n i ⊗ @e_i m j = @e_i (n*m) (m*i+j).
Proof. intros.
  unfold e_i, kron.
  prep_matrix_equality.
  bdestruct_all; simpl in *; auto; try lca. 
  all: try rewrite divmod_0 in *; try contradiction.
  all: try (rewrite <- H5, <- H7 in H9; rewrite <- Nat.div_mod_eq in H9; contradiction).
  all: try (contradict H7; symmetry; apply Nat.mod_unique with (q := i); easy).
  all: try (contradict H5; symmetry; apply Nat.div_unique with (r := j); easy).
  nia.
Qed.

Lemma e_i_kron_inv : forall (n m k : nat),
    m <> 0%nat -> (k < n*m)%nat -> @e_i (n*m) k = @e_i n (k/m)%nat ⊗ @e_i m (k mod m)%nat.
Proof. intros n m k H H0.
  rewrite (Nat.div_mod_eq k m) at 1. rewrite <- e_i_kron; auto.
  apply Nat.Div0.div_lt_upper_bound. lia.
  apply Nat.mod_upper_bound. auto.
Qed.
 
Lemma fold_right_Mplus_Zero_Mscale_distr : 
  forall {m n : nat} (c : C) (Lm : list (Matrix m n)),
    fold_right Mplus Zero (map (fun M => c .* M) Lm) =
      c .* fold_right Mplus Zero (map (fun M => M) Lm).
Proof. intros m n c Lm.
  induction Lm.
  simpl. lma'.
  simpl. rewrite Mscale_plus_distr_r. f_equal. auto.
Qed.

Definition vector_slice {n : nat} (v : Vector n) (k : nat) : Vector n :=
  (fun r c => if (r <? k)%nat then v r c else C0).

Lemma vector_slice_all : forall {n : nat} (v : Vector n) (k : nat),
    WF_Matrix v -> (k >= n)%nat -> vector_slice v k = v.
Proof. intros n v k H H0. 
  unfold vector_slice. 
  prep_matrix_equality. 
  bdestruct_all; auto.
  rewrite H; auto; lia.
Qed.

Lemma vector_slice_none : forall {n : nat} (v : Vector n),
    vector_slice v 0%nat = Zero.
Proof. intros n v.
  unfold vector_slice, Zero.
  prep_matrix_equality.
  bdestruct_all. auto.
Qed.

Lemma vector_slice_step : forall {n : nat} (v : Vector n) (k : nat),
  WF_Matrix v -> vector_slice v k .+ (v k 0%nat) .* (e_i k) = vector_slice v (Datatypes.S k).
Proof. intros n v k H0.
  unfold vector_slice, Matrix.scale, e_i, Mplus.
  prep_matrix_equality.
  bdestruct_all; simpl; subst; auto; try lca; try setoid_rewrite H0 at 2; auto; try lia; try lca.
Qed.

Lemma vector_slice_as_e_i_sum : forall {n : nat} (v : Vector n) (k : nat),
    WF_Matrix v -> (k <= n)%nat ->
    vector_slice v k = fold_right Mplus Zero (map (fun i => (v i 0%nat) .* e_i i) (List.seq 0 k)).
Proof. intros n v k H H0.
  induction k.
  - simpl. apply vector_slice_none.
  - rewrite seq_S. simpl. rewrite map_app. rewrite fold_right_Mplus_Zero_app.
    rewrite <- IHk; try lia. simpl. rewrite <- vector_slice_step; auto. f_equal. lma'.
Qed.

Lemma vector_as_e_i_sum : forall {n : nat} (v : Vector n),
    WF_Matrix v -> 
    v = fold_right Mplus Zero (map (fun i => (v i 0%nat) .* e_i i) (List.seq 0 n)).
Proof. intros n v H0.
  rewrite <- vector_slice_as_e_i_sum; auto.
  rewrite vector_slice_all; auto.
Qed.

Lemma WF_vector_slice : forall {n : nat} (v : Vector n) (k : nat),
    WF_Matrix v -> WF_Matrix (vector_slice v k).
Proof. intros n v k H0.
  unfold WF_Matrix. intros x y H1.
  unfold vector_slice. bdestruct_all; auto.
Qed.

Lemma WF_e_i_sum : 
  forall {n : nat} (v : Vector n) (k : nat),
  WF_Matrix v -> (k <= n)%nat ->
  @WF_Matrix n 1%nat (fold_right Mplus Zero (map (fun i => (v i 0%nat) .* e_i i) (List.seq 0 k))).
Proof. intros n v k H0 H1.
  rewrite <- vector_slice_as_e_i_sum; auto.
  apply WF_vector_slice; auto.
Qed.

Lemma matrix_times_vector_slice_as_get_col_sum : forall {m n : nat} (M : Matrix m n) (v : Vector n) (k : nat),
WF_Matrix v -> (k <= n)%nat ->
M × (vector_slice v k) = fold_right Mplus Zero (map (fun i => ((v i 0%nat) .* get_col M i)) (List.seq 0 k)).
Proof. intros m n M v k H0 H1.
  induction k. rewrite vector_slice_none. rewrite Mmult_0_r. auto.
  rewrite <- vector_slice_step; auto.
  rewrite seq_S. simpl. rewrite map_app.
  rewrite fold_right_Mplus_Zero_app. simpl. 
  rewrite Mmult_plus_distr_l.
  rewrite IHk; try lia. f_equal.
  distribute_scale. rewrite Mplus_0_r.
  f_equal. rewrite matrix_by_basis; auto; lia.
Qed.

Lemma matrix_span_as_get_col_sum : forall {m n : nat} (M : Matrix m n) (v : Vector n),
    WF_Matrix v -> 
    M × v = fold_right Mplus Zero (map (fun i => ((v i 0%nat) .* get_col M i)) (List.seq 0 n)).
Proof. intros m n M v H0.
  rewrite (vector_as_e_i_sum v) at 1; auto.
  rewrite <- matrix_times_vector_slice_as_get_col_sum; auto.
  rewrite vector_slice_as_e_i_sum; auto.
Qed.

Lemma fold_right_Mplus_Zero_double_swap : forall {m n : nat} (F : nat -> nat -> Matrix m n) (l1 l2 : list nat),
  fold_right Mplus Zero (map (fun i : nat => fold_right Mplus Zero (map (fun j : nat => F i j) l2)) l1) =
    fold_right Mplus Zero (map (fun j : nat => fold_right Mplus Zero (map (fun i : nat => F i j) l1)) l2).
Proof. intros m n F0 l1 l2.
  gen l1. induction l2; intros.
  - simpl. induction l1; auto. simpl. rewrite Mplus_0_l. auto.
  - simpl. rewrite <- IHl2.
    gen l2. induction l1; intros. simpl. lma'.
    simpl. rewrite ! Mplus_assoc. f_equal.
    rewrite IHl1; auto.
    rewrite <- ! Mplus_assoc. setoid_rewrite Mplus_comm at 2.
    rewrite ! Mplus_assoc. f_equal. 
Qed.

Lemma fold_right_Mplus_Zero_collect_scalar : 
  forall {m n : nat} (M : Matrix m n) (c_i : nat -> C) (l : list nat),
  fold_right Mplus Zero (map (fun i : nat => (c_i i) .* M) l) = 
    (fold_right Cplus C0 (map (fun i : nat => c_i i) l)) .* M.
Proof. intros m n M c_i l.
  induction l. 
  - simpl. rewrite Mscale_0_l. auto. 
  - simpl. rewrite Mscale_plus_distr_l. f_equal. auto.
Qed.

Lemma fold_right_Mplus_Zero_big_sum : forall {m n : nat} (M_i : nat -> (Matrix m n)) (k : nat),
    fold_right Mplus Zero (map (fun i : nat => M_i i) (List.seq 0 k)) =
      big_sum (fun i : nat => M_i i) k.
Proof. intros m n M_i k.
  induction k; auto.
  rewrite seq_S. simpl. rewrite map_app, fold_right_Mplus_Zero_app. 
  simpl. rewrite Mplus_0_r. 
  replace (CM.GMplus (big_sum (fun i : nat => M_i i) k) (M_i k)) with
            (Mplus (big_sum (fun i : nat => M_i i) k) (M_i k)) by auto.
  f_equal. auto.
Qed.
  

Lemma fold_right_Cplus_C0_big_sum : forall (C_i : nat -> C) (k : nat),
  fold_right Cplus C0 (map (fun i : nat => C_i i) (List.seq 0 k)) =
    big_sum (fun i : nat => C_i i) k.
Proof. intros C_i k.
  induction k; auto.
  rewrite seq_S. simpl. rewrite map_app. 
  rewrite <- fold_symmetric. simpl. rewrite fold_left_Cplus_app. simpl.
  rewrite Cplus_0_l. f_equal. rewrite fold_symmetric. auto.
  all : try apply Cplus_assoc; intros; lca.
Qed.

Lemma fold_right_Mplus_Zero_scaled_vector_sum :
  forall {n : nat} (c_i : nat -> C) (v_i : nat -> Vector n) (k : nat),
    Forall (fun i : nat => WF_Matrix (v_i i)) (List.seq 0 k) ->
    fold_right Mplus Zero (map  (fun i : nat => c_i i .* v_i i) (List.seq 0%nat k)) =
      @Mmult n k 1%nat (fun r c : nat => v_i c r 0%nat) (fun r c : nat => if (c =? 0)%nat then c_i r else C0).
Proof. intros n c_i v_i k H.
  induction k. 
  - simpl. unfold Mmult. simpl. lma'.
  - rewrite seq_S. rewrite Nat.add_0_l, map_app, fold_right_Mplus_Zero_app. simpl.
    rewrite Mplus_0_r. rewrite IHk.
    unfold Mmult, Mplus, Matrix.scale. prep_matrix_equality. simpl. bdestruct_all; subst. 
    f_equal. lca.
    rewrite Forall_forall in H. setoid_rewrite in_seq in H. rewrite H; try lia.
    rewrite ! Cmult_0_r, ! Cplus_0_r. auto.
    rewrite seq_S, Nat.add_0_l, Forall_app in H. destruct H. auto.
Qed.
    
Lemma delete_right_kron_from_vector : forall {n j k : nat} (A_i B_i : nat -> Vector n),
    j <> 0%nat -> (k <= j)%nat ->
    Forall (fun i : nat => WF_Matrix (A_i i)) (List.seq 0 k) ->
    Forall (fun i : nat => WF_Matrix (B_i i)) (List.seq 0 k) ->
(@eq (Vector (n * j))
(fun x y : nat =>
         if (y =? 0)%nat
         then
          @big_sum (Vector (n * j)) (M_is_monoid (n * j) 1%nat)
            (fun y0 : nat =>
             A_i y0 ⊗ @e_i j y0) (k) x 0%nat
         else 0)
  (fun x y : nat =>
         if (y =? 0)%nat
         then
          @big_sum  (Vector (n * j)) (M_is_monoid (n * j) 1%nat)
            (fun y0 : nat =>
             B_i y0 ⊗ @e_i j y0) (k) x 0%nat
         else 0))
->
(forall i, (0 <= i < k)%nat -> A_i i = B_i i).
Proof. intros n j k A_i B_i H0 H1 H2 H3 H4 i H5. 
  induction k.
  - intros. lia.
  - intros. 
    prep_matrix_equality. remember H4 as H4'. clear HeqH4'.
    apply f_equal_inv with (x := (x * j + k)%nat) in H4.
    apply f_equal_inv with (x := y) in H4.
    bdestruct (y =? 0)%nat; subst.
    + rewrite ! Msum_Csum in H4.
      unfold kron in H4. simpl in H4.
      rewrite seq_S in H2, H3. rewrite Nat.add_0_l in H2, H3.
      rewrite Forall_app in H2, H3. destruct H2, H3.
      inversion H6; subst; clear H6. clear H11.
      inversion H7; subst; clear H7. clear H11.
      bdestruct (i =? k)%nat; subst.
      * clear IHk. 
        rewrite ! Nat.div_add_l in H4; auto.
        rewrite ! Nat.div_small in H4; try lia.
        rewrite ! Nat.add_0_r in H4.
        rewrite ! (Nat.add_comm (x * j) k) in H4.
        rewrite ! Nat.Div0.mod_add in H4.
        rewrite ! Nat.mod_small in H4; try lia.
        assert (Σ (fun x0 : nat => A_i x0 x 0%nat * @e_i j x0 k 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H6 in H4. rewrite Cplus_0_l in H4. clear H6.
        assert (Σ (fun x0 : nat => B_i x0 x 0%nat * @e_i j x0 k 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H6 in H4. rewrite Cplus_0_l in H4. clear H6.
        unfold e_i in H4. simpl in H4. 
        bdestruct (k =? k)%nat; bdestruct (k <? j)%nat; try lia. 
        simpl in H4. rewrite ! Cmult_1_r in H4. auto.
      * rewrite ! Nat.div_add_l in H4; auto.
        rewrite ! Nat.div_small in H4; try lia.
        rewrite ! Nat.add_0_r in H4.
        rewrite ! (Nat.add_comm (x * j) k) in H4.
        rewrite ! Nat.Div0.mod_add in H4.
        rewrite ! Nat.mod_small in H4; try lia.
        assert (Σ (fun x0 : nat => A_i x0 x 0%nat * @e_i j x0 k 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H7 in H4. rewrite Cplus_0_l in H4. clear H7.
        assert (Σ (fun x0 : nat => B_i x0 x 0%nat * @e_i j x0 k 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H7 in H4. rewrite Cplus_0_l in H4. clear H7.
        unfold e_i in H4. simpl in H4. 
        bdestruct (k =? k)%nat; bdestruct (k <? j)%nat; try lia. 
        simpl in H4. rewrite ! Cmult_1_r in H4.

        assert (k <= j)%nat by lia.
        specialize (IHk H11 H2 H3).
        assert ((fun x y : nat =>
         if (y =? 0)%nat
         then @big_sum  (Vector (n * j)) (M_is_monoid (n * j) 1%nat) (fun y0 : nat => A_i y0 ⊗ @e_i j y0) k x 0%nat
         else 0) =
        (fun x y : nat =>
         if (y =? 0)%nat
         then @big_sum  (Vector (n * j)) (M_is_monoid (n * j) 1%nat) (fun y0 : nat => B_i y0 ⊗ @e_i j y0) k x 0%nat
         else 0)).
        { prep_matrix_equality. bdestruct_all; subst; auto.
          assert (forall x : nat, @big_sum (Vector (n*j)%nat) (M_is_monoid (n*j)%nat 1%nat) (fun y0 : nat => A_i y0 ⊗ @e_i j y0) (s k) x 0%nat =
                             @big_sum (Vector (n*j)%nat) (M_is_monoid (n*j)%nat 1%nat) (fun y0 : nat => B_i y0 ⊗ @e_i j y0) (s k) x 0%nat).
          { intros x1. apply f_equal_inv with (x := x1) in H4'.
            apply f_equal_inv with (x := 0%nat) in H4'. simpl in *. auto. }
          
          simpl in H12. unfold Mplus in H12. 
          setoid_rewrite Msum_Csum in H12.
          unfold kron in H12. simpl in H12.
          setoid_rewrite Msum_Csum. unfold kron. simpl.
          
          assert ((A_i k ⊗ @e_i j k) x0 0%nat = (B_i k ⊗ @e_i j k) x0 0%nat).
          { unfold kron. simpl. unfold e_i. bdestruct_all; simpl; try lca. rewrite ! Cmult_1_r.
            specialize (H12 x0). rewrite ! H14 in H12.
            assert (Σ (fun x : nat => A_i x (x0 / j)%nat 0%nat * @e_i j x k 0%nat) k = C0).
            { rewrite big_sum_0_bounded; auto; intros.
              unfold e_i. bdestruct_all; simpl; try lca. }
            rewrite H16 in H12. rewrite Cplus_0_l in H12.
            assert (Σ (fun x : nat => B_i x (x0 / j)%nat 0%nat * @e_i j x k 0%nat) k = C0).
            { rewrite big_sum_0_bounded; auto; intros.
              unfold e_i. bdestruct_all; simpl; try lca. }
            rewrite H17 in H12. rewrite Cplus_0_l in H12.
            unfold e_i in H12. bdestruct (k =? k)%nat; bdestruct (k <? j)%nat; try lia.
            simpl in H12. rewrite ! Cmult_1_r in H12. auto. }
          specialize (H12 x0).
          unfold kron in H13. simpl in H13. rewrite H13 in H12.
          apply Cplus_inv_r in H12. auto. }
        assert (0 <= i < k)%nat by lia.
        specialize (IHk H12 H13).
        rewrite IHk. auto.
    + rewrite Forall_forall in H2, H3.
      rewrite H2; auto; try rewrite in_seq; try lia.
      rewrite H3; auto; try rewrite in_seq; try lia.
Qed.

Lemma delete_left_kron_from_vector : forall {m j k : nat} (A_i B_i : nat -> Vector m),
    m <> 0%nat -> (k <= j)%nat ->
    Forall (fun i : nat => WF_Matrix (A_i i)) (List.seq 0 k) ->
    Forall (fun i : nat => WF_Matrix (B_i i)) (List.seq 0 k) ->
(@eq (Vector (j * m)%nat)
(fun x y : nat =>
         if (y =? 0)%nat
         then
          @big_sum (Vector (j * m)%nat) (M_is_monoid (j * m)%nat 1%nat)
            (fun x0 : nat =>
            @e_i j x0 ⊗ A_i x0) (k) x 0%nat
         else 0)
(fun x y : nat =>
         if (y =? 0)%nat
         then
          @big_sum (Vector (j * m)%nat) (M_is_monoid (j * m)%nat 1%nat)
            (fun x0 : nat =>
            @e_i j x0 ⊗ B_i x0) (k) x 0%nat
         else 0))
->
(forall i, (0 <= i < k)%nat -> A_i i = B_i i).
Proof. intros m j k A_i B_i H0 H1 H2 H3 H4 i H5. 
  induction k.
  - intros. lia.
  - intros. 
    prep_matrix_equality. 
    bdestruct (x <? m)%nat.
    2: { rewrite Forall_nth in H2, H3.
         assert (WF_Matrix (A_i i)).
         { specialize (H2 i).
           setoid_rewrite seq_nth in H2; try lia.
           setoid_rewrite seq_length in H2.
           apply H2; auto; lia. }
         assert (WF_Matrix (B_i i)).
         { specialize (H3 i).
           setoid_rewrite seq_nth in H3; try lia.
           setoid_rewrite seq_length in H3.
           apply H3; auto; lia. }
         rewrite H7, H8; auto; lia. }
    remember H4 as H4'. clear HeqH4'.
    apply f_equal_inv with (x := (k * m + x)%nat) in H4.
    apply f_equal_inv with (x := y) in H4.
    bdestruct (y =? 0)%nat; subst.
    + rewrite ! Msum_Csum in H4.
      unfold kron in H4. simpl in H4.
      rewrite seq_S in H2, H3. rewrite Nat.add_0_l in H2, H3.
      rewrite Forall_app in H2, H3. destruct H2, H3.
      inversion H7; subst; clear H7. clear H12.
      inversion H8; subst; clear H8. clear H12.
      bdestruct (i =? k)%nat; subst.
      * clear IHk. 
        rewrite ! Nat.div_add_l in H4; auto.
        rewrite ! Nat.div_small in H4; try lia.
        rewrite ! Nat.add_0_r in H4.
        rewrite ! (Nat.add_comm (k * m) x) in H4.
        rewrite ! Nat.Div0.mod_add in H4.
        rewrite ! Nat.mod_small in H4; try lia.
        assert (Σ (fun x0 : nat => @e_i j x0 k 0%nat * A_i x0 x 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H7 in H4. rewrite Cplus_0_l in H4. clear H7.
        assert (Σ (fun x0 : nat => @e_i j x0 k 0%nat * B_i x0 x 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H7 in H4. rewrite Cplus_0_l in H4. clear H7.
        unfold e_i in H4. simpl in H4. 
        bdestruct (k =? k)%nat; bdestruct (k <? j)%nat; try lia. 
        simpl in H4. rewrite ! Cmult_1_l in H4. auto.
      * rewrite ! Nat.div_add_l in H4; auto.
        rewrite ! Nat.div_small in H4; try lia.
        rewrite ! Nat.add_0_r in H4.
        rewrite ! (Nat.add_comm (k * m) x) in H4.
        rewrite ! Nat.Div0.mod_add in H4.
        rewrite ! Nat.mod_small in H4; try lia.
        assert (Σ (fun x0 : nat => @e_i j x0 k 0%nat * A_i x0 x 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H8 in H4. rewrite Cplus_0_l in H4. clear H8.
        assert (Σ (fun x0 : nat => @e_i j x0 k 0%nat * B_i x0 x 0%nat) k = C0).
        { rewrite big_sum_0_bounded; auto; intros.
          unfold e_i. bdestruct_all; simpl; auto; lca. }
        rewrite H8 in H4. rewrite Cplus_0_l in H4. clear H8.
        unfold e_i in H4. simpl in H4. 
        bdestruct (k =? k)%nat; bdestruct (k <? j)%nat; try lia. 
        simpl in H4. rewrite ! Cmult_1_l in H4.

        assert (k <= j)%nat by lia.
        specialize (IHk H12 H2 H3). 
        assert ((fun x y : nat =>
         if (y =? 0)%nat
         then @big_sum (Vector (j * m)%nat) (M_is_monoid (j * m)%nat 1%nat) (fun x0 : nat => e_i x0 ⊗ A_i x0) k x 0%nat
         else 0) =
        (fun x y : nat =>
         if (y =? 0)%nat
         then @big_sum (Vector (j * m)%nat) (M_is_monoid (j * m)%nat 1%nat) (fun x0 : nat => e_i x0 ⊗ B_i x0) k x 0%nat
         else 0)). 
        { prep_matrix_equality. bdestruct_all; subst; auto.
          assert (forall x : nat, @big_sum (Vector (j * m)%nat) (M_is_monoid (j * m)%nat 1%nat) (fun x0 : nat => e_i x0 ⊗ A_i x0) (s k) x 0%nat =
                             @big_sum (Vector (j * m)%nat) (M_is_monoid (j * m)%nat 1%nat) (fun x0 : nat => e_i x0 ⊗ B_i x0) (s k) x 0%nat).
          { intros x1. apply f_equal_inv with (x := x1) in H4'.
            apply f_equal_inv with (x := 0%nat) in H4'. simpl in *. auto. }
          
          simpl in H13. unfold Mplus in H13. 
          setoid_rewrite Msum_Csum in H13.
          unfold kron in H13. simpl in H13.
          setoid_rewrite Msum_Csum. unfold kron. simpl.
          
          assert ((@e_i j k ⊗ A_i k) x0 0%nat = (@e_i j k ⊗ B_i k) x0 0%nat).
          { unfold kron. simpl. unfold e_i. bdestruct_all; simpl; try lca. rewrite ! Cmult_1_l.
            specialize (H13 x0). rewrite ! H15 in H13.
            assert (Σ (fun x : nat => @e_i j x k 0%nat * A_i x (x0 mod m) 0%nat) k = C0).
            { rewrite big_sum_0_bounded; auto; intros.
              unfold e_i. bdestruct_all; simpl; try lca. }
            rewrite H17 in H13. rewrite Cplus_0_l in H13.
            assert (Σ (fun x : nat => @e_i j x k 0%nat * B_i x (x0 mod m) 0%nat) k = C0).
            { rewrite big_sum_0_bounded; auto; intros.
              unfold e_i. bdestruct_all; simpl; try lca. }
            rewrite H18 in H13. rewrite Cplus_0_l in H13.
            unfold e_i in H13. bdestruct (k =? k)%nat; bdestruct (k <? j)%nat; try lia.
            simpl in H13. rewrite ! Cmult_1_l in H13. auto. }
          specialize (H13 x0).
          unfold kron in H14. simpl in H14. rewrite H14 in H13.
          apply Cplus_inv_r in H13. auto. }
        assert (0 <= i < k)%nat by lia.
        specialize (IHk H13 H14).
        rewrite IHk. auto.
    + rewrite Forall_forall in H2, H3.
      rewrite H2; auto; try rewrite in_seq; try lia.
      rewrite H3; auto; try rewrite in_seq; try lia.
Qed.


Definition submatrix_row {n m : nat} (M : Matrix n m) (k : nat) : Matrix k m :=
  (fun r c : nat => if (r <? k)%nat then M r c else C0).

Lemma WF_submatrix_row : forall {n m : nat} (M : Matrix n m) (k : nat),
    WF_Matrix M -> (k < n)%nat -> WF_Matrix (submatrix_row M k).
Proof. intros n m M k H0 H1. 
  unfold submatrix_row.
  unfold WF_Matrix. intros x y H2.
  bdestruct_all; auto. destruct H2; try lia.
  rewrite H0; auto; lia.
Qed.

Lemma submatrix_row_mult_distr : forall {m n o : nat} (A : Matrix m n) (B : Matrix n o) (k : nat),
    submatrix_row (A × B) k = (submatrix_row A k) × B.
Proof. intros m n o A B k.
  unfold submatrix_row, Mmult.
  prep_matrix_equality.
  bdestruct_all; auto.
  rewrite big_sum_0_bounded; auto; intros; lca.
Qed.

Lemma collect_kron1 : forall {m n : nat} (v : Vector n) (u : Matrix 1%nat m) (M : Vector (n*m)%nat),
    WF_Matrix v -> WF_Matrix u -> WF_Matrix M ->
    v × u = ((fun r c : nat => if (r <? n)%nat && (c <? m) then M (m * r + c)%nat 0%nat else C0) : Matrix n m) -> M = v ⊗ u⊤.
Proof. intros m n v u M H0 H1 H2 H3.
  bdestruct (m =? 0)%nat; subst.
  - assert (M = Zero).
    { prep_matrix_equality. rewrite H2; auto; lia. }
    assert (u = Zero).
    { prep_matrix_equality. rewrite H1; auto; lia. }
    subst. rewrite kron_0_r. auto.
  - unfold transpose.
    unfold Mmult in H3. simpl in H3.
    unfold kron. prep_matrix_equality.
    bdestruct (y =? 0)%nat; subst; simpl.
    + apply f_equal_inv with (x := (x/m)%nat) in H3.
      apply f_equal_inv with (x := (x mod m)%nat) in H3.
      rewrite Cplus_0_l in H3.
      rewrite H3. bdestruct_all; simpl.
      * rewrite <- Nat.div_mod_eq. auto.
      * pose (Nat.mod_bound_pos x m) as E.
        assert (0 <= x)%nat by lia.
        assert (0 < m)%nat by lia.
        specialize (E H7 H8). lia.
      * bdestruct (x <? m*n)%nat.
        -- apply Nat.Div0.div_lt_upper_bound in H7. lia.
        -- rewrite H2; auto; lia.
      * pose (Nat.mod_bound_pos x m) as E.
        assert (0 <= x)%nat by lia.
        assert (0 < m)%nat by lia.
        specialize (E H7 H8). lia.
    + rewrite divmod_0. rewrite H2, H0; try lia; lca.
Qed.

Lemma collect_kron2 : forall {m n : nat} (v : Vector m) (u : Matrix 1%nat n) (M : Vector (n*m)%nat),
    WF_Matrix v -> WF_Matrix u -> WF_Matrix M ->
    v × u = ((fun r c : nat => if (r <? m)%nat && (c <? n) then M (m * c + r)%nat 0%nat else C0) : Matrix n m) -> M = u⊤ ⊗ v.
Proof. intros m n v u M H0 H1 H2 H3. 
  bdestruct (m =? 0)%nat; subst.
  - assert (M = Zero).
    { prep_matrix_equality. rewrite H2; auto; lia. }
    assert (v = Zero).
    { prep_matrix_equality. rewrite H0; auto; lia. }
    subst. rewrite kron_0_r. auto.
  - unfold transpose.
    unfold Mmult in H3. simpl in H3.
    unfold kron. prep_matrix_equality.
    bdestruct (y =? 0)%nat; subst; simpl. 
    + apply f_equal_inv with (x := (x mod m)%nat) in H3.
      apply f_equal_inv with (x := (x/m)%nat) in H3.
      rewrite Cplus_0_l in H3. rewrite Cmult_comm in H3.
      rewrite H3. bdestruct_all; simpl.
      * rewrite <- Nat.div_mod_eq. auto.
      * bdestruct (x <? m*n)%nat.
        -- apply Nat.Div0.div_lt_upper_bound in H7. lia.
        -- rewrite H2; auto; lia.
      * pose (Nat.mod_bound_pos x m) as E.
        assert (0 <= x)%nat by lia.
        assert (0 < m)%nat by lia.
        specialize (E H7 H8). lia. 
      * pose (Nat.mod_bound_pos x m) as E.
        assert (0 <= x)%nat by lia.
        assert (0 < m)%nat by lia.
        specialize (E H7 H8). lia.
    + rewrite divmod_0. rewrite H1, H2; try lia; lca.
Qed.


(* Original Statement:

For independent, pairwise commutative, non-identity k-qubit matrices 
U(1), . . . , U(k) ∈ {±I, ±X, ±Y, ±Z}^k such that 
U(i) ∩ U(j) ≠ ∅ for all i ≠ j, 

the eigenstate of (U(1) ⊗ I^{n−k}) ∩ . . . ∩ (U(k) ⊗ I^{n−k}) are 
all vectors of the form |Ψ⟩ ⊗ |u⟩ where |Ψ⟩ is an eigenstate of U(1), . . . , U(k). *)

(** Implemented Statement (mathematically equivalent):

For independent, pairwise commutative k-qubit matrices 
U(1), . . . , U(k) ∈ {±I, ±X, ±Y, ±Z}^k such that 
-I^k is not generated from < U(1), . . . , U(k) >,
(this last part is checked by 
  linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)))

the eigenstate of (U(1) ⊗ I^{n−k}) ∩ . . . ∩ (U(k) ⊗ I^{n−k}) are 
all vectors of the form |Ψ⟩ ⊗ |u⟩ where |Ψ⟩ is an eigenstate of U(1), . . . , U(k).



forall w, u WF u -> WF w ->
vecSatP w  <->  vecSatP w ⊗ u 


forall x, (exists y, exists z, x = f(y,z) /\ P y) <-> Q x

forall y z, P y <-> Q (f(y,z))


LtoR OK
forall x y z, x = f(y,z) /\ P y -> Q x


RtoL NOT OK
forall x, Q x -> (exists y, exists z, x = f(y,z) /\ P y) 

How do we know x in the image of f?




Coersion :  give name

map Coersion :  give name

** Unicode <- Cap

Cap map Coersion :  give name



Create function/Lemma to make this more usable


**** Soundness results for separability
Predicate holds -> translate into matrices also holds.
Proof should go into semantics


Separable : Predicate -> Prop


Lemma test : forall ,
Separable (Predicate).

Proof. intros.
...

Qed.





Examples & Automation



 **)

(*** This is only for +1 eigenstates*)
Lemma separability_proof_left :
  forall (n m : nat) (Lt : list (TType n)),
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> n <> 0%nat ->
    Lt <> [] -> Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt ->
    commutingListT Lt -> length Lt = n -> 
    (forall v : Vector (2 ^ (n + m))%nat,
      (exists w : Vector (2 ^ n)%nat, WF_Matrix w /\ (exists u : Vector (2 ^ m)%nat, WF_Matrix u /\
        vecSatisfiesP w (Cap (map TtoA Lt)) /\ v = w ⊗ u)) <->
        vecSatisfiesP v (Cap (map (uncurry gTensorA)
                                (combine 
                                   (map TtoA Lt) 
                                   (map TtoA (repeat (defaultT_I m) (length Lt))))))).
Proof. intros n m Lt H0 H1 H2 H3 H4 H5 H6 v.
  split; intros.
  - destruct H7 as [w [WFw [u [WFu [vecSatisfiesPw vwu]]]]].
    rewrite vwu.
    simpl. split; auto with wf_db.
    clear - vecSatisfiesPw WFw WFu H3.
    induction Lt; auto.
    simpl in *. destruct vecSatisfiesPw. 
    rewrite Forall_cons_iff in *. destruct H1, H3.
    assert (H5 := conj H0 H2).
    specialize (IHLt H4 H5).
    constructor; auto.
    unfold uncurry. simpl.
    unfold translateA in *. simpl in *. rewrite Mplus_0_l in *.
    unfold vecSatisfies in *.
    destruct H1. split; auto with wf_db.
    unfold Eigenpair in *. simpl in *.
    rewrite Mscale_1_l in *.
    rewrite translate_gTensorT.
    + rewrite translate_defaultT_I. setoid_rewrite kron_mixed_product'; auto.
      2-3: rewrite Nat.pow_add_r; auto.
      rewrite Mmult_1_l; auto. f_equal; auto.
    + destruct H3. auto.
    + unfold defaultT_I. simpl. rewrite repeat_length. auto.
  - assert (H8 : forall A B : Prop, ~ (A /\ B) <-> (A -> ~ B)).
    { intros A B. split; intros.
      - apply Classical_Prop.not_and_or in H8. destruct H8; auto.
      - apply Classical_Prop.or_not_and. destruct (Classical_Prop.classic A); auto. }
    assert (H9 : ((forall w : Vector (2 ^ n)%nat, WF_Matrix w ->  
                           (forall u : Vector (2 ^ m)%nat, WF_Matrix u ->
                                   vecSatisfiesP w (Cap (map TtoA Lt)) ->
                                          ~ v = w ⊗ u)) -> False) <->
                   (exists w : Vector (2 ^ n),
                       WF_Matrix w /\
                         (exists u : Vector (2 ^ m),
                             WF_Matrix u /\
                               vecSatisfiesP w (Cap (map TtoA Lt)) /\ 
                               v = w ⊗ u))).
    { split; intros. 
      - apply Classical_Prop.NNPP. intro.
        contradict H9.
        intros w H9 u H11 H12. 
        apply Classical_Pred_Type.not_ex_all_not with (n := w) in H10.
        rewrite H8 in H10. specialize (H10 H9).
         apply Classical_Pred_Type.not_ex_all_not with (n := u) in H10.
         rewrite H8 in H10. specialize (H10 H11).
         apply Classical_Prop.not_and_or in H10.
         destruct H10; auto.
      - destruct H9 as [w [WFw [u [WFu [vecSatisfiesPw vwu]]]]].
        apply (H10 w WFw u WFu vecSatisfiesPw vwu). }
    rewrite <- H9. clear H8 H9.
    intros H8.
    assert (WF_Matrix v).
    { destruct H7; auto. }
    destruct (SVD v H9) as [U [L [V [WFUU [WFUV [WFDL [WFNL AULVd]]]]]]].
    bdestruct (m =? 0)%nat.
    + subst.
      assert (@eq (list (AType (n + 0))) (map (uncurry gTensorA)
               (combine (map TtoA Lt)
                  (map TtoA (repeat (defaultT_I 0) (length Lt)))))
                (map TtoA Lt)).
      { unfold defaultT_I. simpl. rewrite map_repeat.
        apply nth_ext with (d := (uncurry gTensorA) (([defaultT_I n]), ([(C1,[])]))) (d' := defaultT_I (n + 0)).
        * rewrite ! map_length. rewrite combine_length. rewrite repeat_length, map_length.
          minmax_breakdown. auto.
        * intros n0 H10. rewrite ! map_nth.
          rewrite combine_nth.
          2: rewrite map_length, repeat_length; auto.
          rewrite map_nth with (d := defaultT_I n).
          rewrite nth_repeat.
          unfold uncurry.
          simpl. unfold TtoA. do 2 f_equal.
          unfold gTensorT. replace (n + 0)%nat with n by lia.
          destruct (nth n0 Lt (defaultT_I n)). rewrite Cmult_1_r, app_nil_r. auto. }
      rewrite H10 in H7. 
      assert (n + 0 = n)%nat by lia.
      rewrite H11 in *.
      replace (2 ^ n)%nat with (2 ^ (n + 0))%nat in * by (rewrite Nat.add_0_r; auto).
      specialize (H8 (U × L × (V) †) H9 (I 1) WF_I1 H7).
      rewrite kron_1_r in H8. contradiction.
    + assert (v = (V 0%nat 0%nat)^* .* (U × L)).
      { rewrite AULVd.
        unfold Mmult, Matrix.scale, adjoint. simpl.
        prep_matrix_equality. destruct WFUV.
        bdestruct (y =? 0)%nat.
        - subst. lca.
        - rewrite H11 at 1; auto; try lia. rewrite Cconj_0, Cmult_0_r, Cplus_0_l.
          assert (Σ (fun y0 : nat => U x y0 * L y0 y) (2 ^ (n + m)) = C0).
          { destruct WFDL.
            rewrite big_sum_0_bounded; auto; intros.
            rewrite H14; auto; try lia; try lca. }
          rewrite H14. lca. }
      assert ((2 ^ (n + m)) = (2 ^ n) * (2 ^ m))%nat by apply Nat.pow_add_r.

      simpl in H7. destruct H7.

      rewrite matrix_span_as_get_col_sum in H11.
      2: destruct WFDL; auto.

      assert ( fold_right Mplus Zero
                 (map (fun i : nat => L i 0%nat .* get_col U i)
                    (List.seq 0 (2 ^ (n + m)))) = 
                 fold_right Mplus Zero
                         (map (fun M => M)   
                   (map (fun i : nat => L i 0%nat .* get_col U i)
                      (List.seq 0 (2 ^ (n + m))))))
      by (rewrite map_map; auto).
      rewrite H14 in H11.
      rewrite <- fold_right_Mplus_Zero_Mscale_distr with (c := (V 0%nat 0%nat) ^* ) in H11.
      rewrite map_map in H11.
      assert ((map (fun i : nat => (V 0%nat 0%nat) ^* .* (L i 0%nat .* get_col U i))
             (List.seq 0 (2 ^ (n + m)))) =
                (map (fun i : nat => 
                        fold_right Mplus Zero
                          (map
                             (fun j : nat =>
                                (V 0%nat 0%nat) ^* * (L i 0%nat) * (U j i) .* 
                                                               (@e_i (2 ^ n)%nat (j / (2 ^ m)%nat) ⊗ @e_i (2 ^ m)%nat (j mod (2 ^ m)%nat)))
                          (List.seq 0 (2 ^ (n + m)))))
                  (List.seq 0 (2 ^ (n + m))))).
      { apply map_ext_Forall. rewrite Forall_forall. intros x H15.  rewrite in_seq in H15.
        rewrite (vector_as_e_i_sum (get_col U x)) at 1.
        assert ((map (fun i : nat => get_col U x i 0%nat .* @ e_i (2 ^ (n + m))  i)
              (List.seq 0 (2 ^ (n + m)))) = 
                  (map (fun M => M) (map (fun i : nat => get_col U x i 0%nat .* e_i i)
              (List.seq 0 (2 ^ (n + m)))))) by (rewrite map_map; auto).
        rewrite H16.
        rewrite Mscale_assoc.
        rewrite <- fold_right_Mplus_Zero_Mscale_distr.
        rewrite ! map_map.
        f_equal.
        apply map_ext_Forall. rewrite Forall_forall. intros x0 H17. rewrite in_seq in H17.
        rewrite ! H12.
        rewrite e_i_kron_inv; auto; try lia.
        rewrite ! Mscale_assoc. f_equal.
        destruct WFUU. auto with wf_db. }
      rewrite H15 in H11.
      rewrite fold_right_Mplus_Zero_double_swap 
        with (F := (fun i j : nat =>
                     (V 0%nat 0%nat) ^* * L i 0%nat * U j i .* (e_i (j / 2 ^ m) ⊗ e_i (j mod 2 ^ m))))
        in H11.
      assert ((fun j : nat =>
              fold_right Mplus Zero
                (map
                   (fun i : nat =>
                    (V 0%nat 0%nat) ^* * L i 0%nat * U j i
                    .* (@e_i (2 ^ n)%nat (j / 2 ^ m) ⊗ @e_i (2 ^ m)%nat (j mod 2 ^ m)))
                   (List.seq 0 (2 ^ (n + m))))) =
                (fun j : nat =>
              (fold_right Cplus C0
                (map
                   (fun i : nat =>
                    (V 0%nat 0%nat) ^* * L i 0%nat * U j i)
                   (List.seq 0 (2 ^ (n + m))))) .* (e_i (j / 2 ^ m) ⊗ e_i (j mod 2 ^ m)))).
      { apply functional_extensionality. intros x.
        rewrite fold_right_Mplus_Zero_collect_scalar. auto. }
      rewrite H16 in H11.
      clear H14 H15 H16.

      assert (forall k : nat, (k < length Lt)%nat -> translate (gTensorT (nth k Lt (defaultT_I n)) (defaultT_I m)) × v = v).
      { rewrite Forall_map in H13.
        rewrite Forall_forall in H13.
        intros k H14. specialize (H13 (nth k (combine (map TtoA Lt)
             (map TtoA (repeat (defaultT_I m) (length Lt)))) ([defaultT_I n],[defaultT_I m] ))).  
        assert (In
          (nth k
             (combine (map TtoA Lt)
                (map TtoA
                   (repeat (defaultT_I m) (length Lt))))
             ([defaultT_I n], [defaultT_I m]))
          (combine (map TtoA Lt)
             (map TtoA (repeat (defaultT_I m) (length Lt))))).
        { apply nth_In. rewrite combine_length, ! map_length, repeat_length. 
          minmax_breakdown. auto. }
        specialize (H13 H15). clear H15.
        rewrite combine_nth in H13.
        rewrite map_nth with (d := defaultT_I n) in H13.
        rewrite map_nth with (d := defaultT_I m) in H13.
        rewrite nth_repeat in H13.
        unfold uncurry. simpl in H13. 
        2 : rewrite ! map_length, repeat_length; auto.
        unfold translateA in H13. simpl in H13. rewrite Mplus_0_l in H13.
        unfold vecSatisfies in H13. destruct H13. unfold Eigenpair in H15. simpl in H15.
        rewrite Mscale_1_l in H15. auto. }
      
      setoid_rewrite translate_gTensorT in H14.
      2: { bdestruct (k <? length Lt)%nat.
           rewrite Forall_nth in H3. specialize (H3 k (defaultT_I n) H15).
           destruct H3. auto. rewrite nth_overflow; try lia. unfold defaultT_I. simpl. 
           rewrite repeat_length. auto. }
      2: { unfold defaultT_I. simpl. rewrite repeat_length. auto. }

      rewrite translate_defaultT_I in H14.
      rewrite H11 in H14. rewrite ! H12 in H14.
      setoid_rewrite <- fold_right_Mplus_Zero_map_Mmult_distr in H14.
      setoid_rewrite map_map in H14.

      assert (forall k : nat, (fun x : nat =>
              translate (nth k Lt (defaultT_I n)) ⊗ I (2 ^ m)
              × (fold_right Cplus 0
                   (map (fun i : nat => (V 0%nat 0%nat) ^* * L i 0%nat * U x i)
                      (List.seq 0 (2 ^ n * 2 ^ m)))
                 .* (e_i (x / 2 ^ m) ⊗ e_i (x mod 2 ^ m)))) =
                         (fun x : nat =>
              fold_right Cplus 0
    (map (fun i : nat => (V 0%nat 0%nat) ^* * L i 0%nat * U x i)
       (List.seq 0 (2 ^ n * 2 ^ m)))
  .* (translate (nth k Lt (defaultT_I n)) × e_i (x / 2 ^ m)
      ⊗ (e_i (x mod 2 ^ m))))).
      { intro. apply functional_extensionality. intro. rewrite Mscale_mult_dist_r. 
        rewrite kron_mixed_product. rewrite Mmult_1_l; auto with wf_db. }
      setoid_rewrite H15 in H14. clear H15.
      setoid_rewrite fold_right_Mplus_Zero_big_sum in H14.
      
      assert (forall k : nat, (fun i : nat =>
           fold_right Cplus 0
             (map (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0)
                (List.seq 0 (2 ^ n * 2 ^ m)))
           .* (translate (nth k Lt (defaultT_I n)) × @e_i (2 ^ n)%nat (i / 2 ^ m)
               ⊗ @e_i (2 ^ m)%nat (i mod 2 ^ m))) =
                (fun i : nat =>
           (big_sum (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0) (2 ^ n * 2 ^ m))
           .* (translate (nth k Lt (defaultT_I n)) × e_i (i / 2 ^ m)
               ⊗ e_i (i mod 2 ^ m)))).
      { intro. apply functional_extensionality. intro.
        rewrite fold_right_Cplus_C0_big_sum. auto. }
      setoid_rewrite H15 in H14. clear H15.

      assert ((fun i : nat =>
           fold_right Cplus 0
             (map (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0)
                (List.seq 0 (2 ^ n * 2 ^ m)))
           .* (@e_i (2 ^ n)%nat (i / 2 ^ m) ⊗ @e_i (2 ^ m)%nat (i mod 2 ^ m))) = 
                (fun i : nat =>
           (big_sum (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0) (2 ^ n * 2 ^ m))
             .* (e_i (i / 2 ^ m) ⊗ e_i (i mod 2 ^ m)))).
      { apply functional_extensionality. intro.
        rewrite fold_right_Cplus_C0_big_sum. auto. }
      setoid_rewrite H15 in H14. clear H15.
      
     setoid_rewrite <- fold_right_Mplus_Zero_big_sum in H14.
     setoid_rewrite fold_right_Mplus_Zero_scaled_vector_sum in H14.
     
     2: { rewrite Forall_forall. intros x H15. apply WF_kron; auto with wf_db.
          apply WF_mult; auto with wf_db. bdestruct (k <? length Lt)%nat.
          apply WF_translate. rewrite Forall_nth in H3. apply H3; auto.
          rewrite nth_overflow; auto. rewrite translate_defaultT_I. auto with wf_db. }

     2: { rewrite Forall_forall. intros x H15. apply WF_kron; auto with wf_db. }

     assert (forall k : nat, (k < length Lt)%nat -> @Mmult (2 ^ n * 2 ^ m)%nat (2 ^ n * 2 ^ m)%nat 1%nat
         (fun r c : nat =>
         ((translate (nth k Lt (defaultT_I n)) .+ (- C1)%C .* (I (2^n)%nat)) × @e_i (2^n)%nat (c / 2 ^ m) ⊗ @e_i (2^m)%nat (c mod 2 ^ m))
           r 0%nat) 
         (fun r c : nat =>
           if (c =? 0)%nat
           then
            Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0)
              (2 ^ n * 2 ^ m)
           else 0) = Zero).
     { intros k H15. specialize (H14 k H15).
       prep_matrix_equality. 
       apply f_equal_inv with (x := x) in H14.
       apply f_equal_inv with (x := y) in H14.
       unfold Mmult at 1 in H14. unfold Mmult at 2 in H14.
       unfold Mmult at 1. unfold Zero.
       apply Cplus_inv_r with (c :=
          (@Mmult (2 ^ n * 2 ^ m)%nat (2 ^ n * 2 ^ m)%nat 1%nat
            (fun r c : nat => (@e_i (2^n)%nat (c / 2 ^ m) ⊗ @e_i (2^m)%nat (c mod 2 ^ m)) r 0%nat)
              (fun r c : nat =>
           if (c =? 0)%nat
           then
            Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0)
              (2 ^ n * 2 ^ m)
           else 0)) x y).
       unfold Mmult at 2. unfold Mmult at 2. rewrite Cplus_0_l.
       rewrite <- H14 at 2.
       rewrite <- @big_sum_plus with (H0 := C_is_group).
       apply big_sum_eq_bounded. intros x0 H16. 
       rewrite <- ! Cmult_plus_distr_r. f_equal. unfold Mplus, Matrix.scale, Mmult.
       unfold kron. simpl. rewrite <- ! Cmult_plus_distr_r. f_equal.
       unfold I. bdestruct_all.
       - replace (2 ^ n)%nat with ((x / 2 ^ m) + 1 + ((2 ^ n) - (Datatypes.S (x / 2 ^ m))))%nat by lia.
         rewrite ! big_sum_sum; simpl. rewrite ! Cplus_0_l.
         rewrite ! andb_true_r. rewrite ! Nat.add_0_r. bdestruct_all.
         rewrite Cmult_1_r. rewrite Cmult_plus_distr_r.
         rewrite <- ! Cplus_assoc. setoid_rewrite Cplus_comm at 5.
         
         assert (Σ
    (fun y0 : nat =>
     (translate (nth k Lt (defaultT_I n)) (x / 2 ^ m)%nat y0 +
      (- C1) * (if (x / 2 ^ m =? y0)%nat && true then C1 else 0)) *
     @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) y0 0%nat) (x / 2 ^ m) +
  (translate (nth k Lt (defaultT_I n)) (x / 2 ^ m)%nat (x / 2 ^ m)%nat *
   @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat +
   (- C1 * @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat +
    (@e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat +
     Σ
       (fun x1 : nat =>
        (translate (nth k Lt (defaultT_I n)) (x / 2 ^ m)%nat
           (x / 2 ^ m + 1 + x1)%nat +
         (- C1) * (if (x / 2 ^ m =? x / 2 ^ m + 1 + x1)%nat && true then C1 else 0)) *
        @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m + 1 + x1)%nat 0%nat) 
       (2 ^ n - s (x / 2 ^ m)))))  =
                   Σ
    (fun y0 : nat =>
     (translate (nth k Lt (defaultT_I n)) (x / 2 ^ m)%nat y0 +
      (- C1) * (if (x / 2 ^ m =? y0)%nat && true then C1 else 0)) *
     @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) y0 0%nat) (x / 2 ^ m) +
  (translate (nth k Lt (defaultT_I n)) (x / 2 ^ m)%nat (x / 2 ^ m)%nat *
   @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat +
   (- C1 * @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat +
    (@e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat)) +
     Σ
       (fun x1 : nat =>
        (translate (nth k Lt (defaultT_I n)) (x / 2 ^ m)%nat
           (x / 2 ^ m + 1 + x1)%nat +
         (- C1) * (if (x / 2 ^ m =? x / 2 ^ m + 1 + x1)%nat && true then C1 else 0)) *
        @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m + 1 + x1)%nat 0%nat) 
       (2 ^ n - s (x / 2 ^ m)))) by (rewrite ! Cplus_assoc; auto). 
         rewrite H19. clear H19.
         assert (- C1 * @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat +
                   @e_i ((((x / 2 ^ m) + 1) + (2 ^ n - Datatypes.S (x / 2 ^ m))))%nat (x0 / 2 ^ m) (x / 2 ^ m)%nat 0%nat = C0) by lca.
         rewrite H19. clear H19. rewrite Cplus_0_r.
         f_equal.
         + apply big_sum_eq_bounded. intros x1 H19. 
           bdestruct_all; simpl; auto; try lia; try lca. 
         + f_equal. apply big_sum_eq_bounded. intros x1 H19. 
           bdestruct_all; simpl; auto; try lia; try lca. 
       - assert (WF_Matrix (@e_i (2^n)%nat (x0 / 2 ^ m))) by auto with wf_db.
         rewrite H18; try lia. rewrite Cplus_0_r.
         apply big_sum_eq_bounded. intros x1 H19.
         bdestruct_all. simpl. rewrite Cmult_0_r, Cplus_0_r. auto.
       - apply C_is_comm_group. }
     
     assert (forall r : nat, Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0) (2 ^ n * 2 ^ m) =
                        (V 0%nat 0%nat) ^* * L 0%nat 0%nat * U r 0%nat).
     { intros r. destruct WFDL.
       rewrite big_sum_unique with (k := (V 0%nat 0%nat) ^* * L 0%nat 0%nat * U r 0%nat); auto.
       exists 0%nat. repeat split; auto. rewrite <- H12.
       assert (0 < 2 ^ (n + m))%nat.
       { assert (0 ^ (n + m) = 0)%nat. { apply Nat.pow_0_l; lia. }
         rewrite <- H18 at 1.
         apply Nat.pow_lt_mono_l; lia. }
       auto.
       intros x' H18 H19.
       rewrite H17; try lia; lca. }

     assert ((fun r c : nat =>
           if (c =? 0)%nat
           then
            Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0)
              (2 ^ n * 2 ^ m)
           else 0) =
               (fun r c : nat =>
           if (c =? 0)%nat
           then
            (V 0%nat 0%nat) ^* * L 0%nat 0%nat * U ((2^m * (r / 2^m) + r mod 2^m)%nat) 0%nat
           else 0)).
     { prep_matrix_equality. bdestruct_all; try rewrite H16; auto.
       rewrite <- Nat.div_mod_eq. auto. }
     rewrite H17 in H15.

     assert ((2 ^ n * 2 ^ m) = (2 ^ m * 2 ^ n))%nat by (apply Nat.mul_comm).

     unfold Mmult in H15 at 1.

assert (forall k : nat,
(fun x z : nat =>
         Σ
           (fun y : nat =>
            ((translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n))
             × @e_i (2^n)%nat (y / 2 ^ m) ⊗ @e_i (2^m)%nat (y mod 2 ^ m)) x 0%nat *
            (if (z =? 0)%nat
             then
              (V 0%nat 0%nat) ^* * L 0%nat 0%nat *
              U (2 ^ m * (y / 2 ^ m) + y mod 2 ^ m)%nat 0%nat
             else 0)) (2 ^ n * 2 ^ m)) =
  (fun x y : nat =>
         if (y =? 0)%nat then
(@big_sum (Matrix (2 ^ n * 2 ^ m) 1%nat) (M_is_monoid (2 ^ n * 2 ^ m) 1%nat)
    (fun y0 : nat =>
     (@kron (2^n)%nat 1%nat (2^m)%nat 1%nat 
       (fun r c : nat =>
       (Σ
       (fun x0 : nat =>
        ((translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) × @e_i (2^n)%nat x0)
          r c  *
        ((V 0%nat 0%nat) ^* * L 0%nat 0%nat * U (2 ^ m * x0 + y0)%nat 0%nat)) (2 ^ n)))
       
       (@e_i (2^m)%nat y0))
) 

(2 ^ m)) x 0%nat

else C0

)).
{ intros k. prep_matrix_equality. bdestruct_all; subst.
  rewrite Msum_Csum.
     rewrite ! H18.
     rewrite <- big_sum_double_sum
with 
(f := (fun i j : nat =>
     ((translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) × e_i (i)
      ⊗ e_i (j)) x 0%nat *
     ( (*if (y =? 0)%nat
      then *)
       (V 0%nat 0%nat) ^* * L 0%nat 0%nat *
       U (2 ^ m * (i) + j)%nat 0%nat
      (* else 0 *)))).
     unfold kron. simpl.
     rewrite big_sum_swap_order at 1.
     apply big_sum_eq_bounded. intros x0 H19.
     rewrite @big_sum_mult_r with (H2 := C_is_ring).
     apply big_sum_eq_bounded. intros x1 H20. simpl.
     lca. 
     rewrite big_sum_0_bounded; auto; intros; lca. }
setoid_rewrite H19 in H15. clear H19.

assert (@Zero (2 ^ n * 2 ^ m)%nat 1%nat =
          (fun x y : nat =>
         if (y =? 0)%nat
         then
          @big_sum (Vector (2^n * 2^m)%nat) (M_is_monoid (2^n * 2^m)%nat 1%nat)
            (fun y0 : nat =>
             (@Zero (2^n)%nat 1%nat) ⊗ @e_i (2^m)%nat y0) (2 ^ m) x 0%nat
         else 0)).
{ prep_matrix_equality. unfold Zero.
  bdestruct_all; simpl; subst.
  rewrite big_sum_0_bounded; auto; intros.
  rewrite kron_0_l. lma'. auto. }
rewrite H19 in H15.

assert (forall k : nat, (k < length Lt)%nat -> 
                 forall i, (0 <= i < 2^m)%nat ->
              (fun r c : nat =>
              Σ
                (fun x0 : nat =>
                 ((translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n))
                  × e_i x0) r c *
                 ((V 0%nat 0%nat) ^* * L 0%nat 0%nat *
                  U (2 ^ m * x0 + i)%nat 0%nat)) (2 ^ n)) =
                @Zero (2^n)%nat 1%nat).
{ intros k H20 i H21.
  apply @delete_right_kron_from_vector
          with (j := (2^m)%nat) (k := (2^m)%nat)
          (A_i := (fun y0 : nat =>
             (fun r c : nat =>
              Σ
                (fun x0 : nat =>
                 ((translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n))
                  × e_i x0) r c *
                 ((V 0%nat 0%nat) ^* * L 0%nat 0%nat *
                  U (2 ^ m * x0 + y0)%nat 0%nat)) (2 ^ n))))
               (B_i := (fun y0 : nat => @Zero (2^n)%nat 1%nat)); auto; try lia.
  - rewrite Forall_forall. intros x H22. rewrite in_seq in H22.
    unfold WF_Matrix. intros x0 y H23.
    destruct H23.
    + rewrite big_sum_0_bounded; auto; intros. unfold Mmult.
      rewrite big_sum_0_bounded; intros; try lca.
      assert (WF_Matrix (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n))).
      { apply WF_plus; auto with wf_db. apply WF_translate.
        rewrite Forall_nth in H3. apply H3; lia. }
      rewrite H26; try lia; lca.
    + rewrite big_sum_0_bounded; auto; intros. unfold Mmult.
      pose (@WF_e_i (2^n)%nat x1) as WFei.
      rewrite big_sum_0_bounded; intros; try lca.
      rewrite WFei; try lia; lca.
  - rewrite Forall_forall. intros x H22. auto with wf_db. }
unfold Mmult in H20.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ m)%nat ->
        @eq (Vector (2^n)%nat)
        (fun r c : nat =>
         Σ
           (fun x0 : nat =>
            Σ
              (fun y : nat =>
               (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) r y *
               @e_i (2^n)%nat x0 y c) (2 ^ n) *
            ((V 0%nat 0%nat) ^* * L 0%nat 0%nat * U (2 ^ m * x0 + i)%nat 0%nat))
           (2 ^ n))
        (@Matrix.scale (2^n)%nat 1%nat
        ((V 0%nat 0%nat) ^* * L 0%nat 0%nat)
        (fun r c : nat =>
         Σ
           (fun x0 : nat =>
            Σ
              (fun y : nat =>
               (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) r y *
               @e_i (2^n)%nat x0 y c) (2 ^ n) *
            (U (2 ^ m * x0 + i)%nat 0%nat))
           (2 ^ n)))).
{ intros k H21 i H22.
  prep_matrix_equality. unfold Matrix.scale.
  rewrite @big_sum_mult_l with (H2 := C_is_ring).
  apply big_sum_eq_bounded; intros. simpl. lca. }

  assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ m)%nat ->
        (V 0%nat 0%nat) ^* * L 0%nat 0%nat
        .* (fun r c : nat =>
            Σ
              (fun x0 : nat =>
               Σ
                 (fun y : nat =>
                  (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) r y *
                  @e_i (2^n)%nat x0 y c) (2 ^ n) * U (2 ^ m * x0 + i)%nat 0%nat) 
              (2 ^ n)) = @Zero (2^n)%nat 1%nat).
{ intros k H22 i H23. specialize (H20 k H22 i H23).  specialize (H21 k H22 i H23).
  rewrite <- H21. rewrite H20. auto. }
clear H20 H21.

assert (((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (@Zero (2^n)%nat 1%nat) = (@Zero (2^n)%nat 1%nat)).
{ rewrite Mscale_0_r. auto. }
setoid_rewrite <- H20 in H22.

assert ((V 0%nat 0%nat) <> C0). 
{ intro. assert (V = Zero).
  { prep_matrix_equality. unfold Zero. destruct WFUV.
    bdestruct (x =? 0)%nat; bdestruct (y =? 0)%nat; subst; auto; rewrite H23; auto; try lia. }
  destruct WFUV. rewrite H23 in H25. rewrite Mmult_0_r in H25.
  contradict_matrix_equalities. }
assert ((V 0%nat 0%nat) ^* <> C0).
{ apply Cconj_neq_0; auto. }
assert (L 0%nat 0%nat <> C0).
{ intro. assert (L = Zero).
  { prep_matrix_equality. unfold Zero. destruct WFDL.
    bdestruct (x =? 0)%nat; bdestruct (y =? 0)%nat; subst; auto.
    rewrite H25; auto; lia. }
  rewrite H25 in AULVd. rewrite Mmult_0_r, Mmult_0_l in AULVd.
  subst.
  assert (WF_Matrix (@Zero (2^n)%nat 1%nat)) as zero2n by auto with wf_db.
  assert (WF_Matrix (@Zero (2^m)%nat 1%nat)) as zero2m by auto with wf_db.
  assert (vecSatisfiesP (@Zero (2^n)%nat 1%nat) (Cap (map TtoA Lt))).
  { unfold vecSatisfiesP. split; auto with wf_db.
    unfold vecSatisfies. unfold Eigenpair. simpl.
    rewrite Forall_forall. intros x H25.
    split; auto with wf_db. rewrite Mmult_0_r, Mscale_0_r. auto. }
  specialize (H8 (@Zero (2^n)%nat 1%nat) zero2n (@Zero (2^m)%nat 1%nat) zero2m H25).
  rewrite kron_0_l in H8. contradiction. } 
remember H24 as Lnonzero. clear HeqLnonzero.
assert ((V 0%nat 0%nat) ^* * L 0%nat 0%nat <> C0).
{ intro. apply Cmult_integral in H25. destruct H25; contradiction. }
clear H20 H21 H23 H24.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ m)%nat ->
        (fun r c : nat =>
            Σ
              (fun x0 : nat =>
               Σ
                 (fun y : nat =>
                  (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) r y *
                  @e_i (2^n)%nat x0 y c) (2 ^ n) * U (2 ^ m * x0 + i)%nat 0%nat) 
              (2 ^ n)) = (@Zero (2^n)%nat 1%nat)).
{ intros. specialize (H22 k H20 i H21). apply Mscale_cancel in H22; auto. }

clear H22 H25.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ m)%nat ->
        (fun r c : nat =>
           (if (c =? 0)%nat then
            Σ
              (fun y : nat =>
               (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) r y * U (2 ^ m * y + i)%nat 0%nat) 
           (2 ^ n) else C0)) = @Zero (2^n)%nat 1%nat).
{ intros k H21 i H22.
  specialize (H20 k H21 i H22).
  rewrite <- H20.
  prep_matrix_equality. bdestruct_all; subst.
  - apply big_sum_eq_bounded; intros. f_equal.
    unfold e_i. simpl. symmetry. apply big_sum_unique. exists x0.
    repeat split; auto. bdestruct (x0 =? x0)%nat; bdestruct (x0 <? 2^n)%nat; try lia. simpl. lca.
    intros x' H24 H25. bdestruct (x' =? x0)%nat; bdestruct (x' <? 2^n)%nat; try lia. simpl. lca.
  - rewrite big_sum_0_bounded; auto; intros.
    assert (Σ
    (fun y0 : nat =>
     (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n)) x y0 * @e_i (2^n)%nat x0 y0 y)
    (2 ^ n) = C0).
    { rewrite big_sum_0_bounded; auto; intros.
      rewrite (@WF_e_i (2^n)%nat x0); try lca; try lia. }
    rewrite H25. lca. }

clear H20.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ m)%nat ->
        @Mmult (2^n)%nat (2^n)%nat 1%nat
          (translate (nth k Lt (defaultT_I n)) .+ - C1 .* I (2 ^ n))
        (fun r c : nat =>
         if (c =? 0)%nat
         then U (2 ^ m * r + i)%nat 0%nat
         else 0) = @Zero (2^n)%nat 1%nat).
{ intros k H20 i H22.
  unfold Mmult. specialize (H21 k H20 i H22).
  rewrite <- H21. prep_matrix_equality.
  bdestruct_all; subst; auto.
  rewrite big_sum_0_bounded; auto; intros. lca. }

assert (forall i j : nat, (i <> 0)%nat \/ (j <> 0)%nat -> L i j = C0).
{ intros i j H22. destruct WFDL. destruct H22.
  - bdestruct (j =? 0)%nat; subst.
    + apply H24. lia.
    + rewrite H23; auto; lia.
  - rewrite H23; auto; lia. }

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ m)%nat ->
       @eq (Vector (2^n)%nat)
        (@Mmult (2^n)%nat (2^n)%nat 1%nat (translate (nth k Lt (defaultT_I n))) 
              (fun r c : nat => if (c =? 0)%nat then U (2 ^ m * r + i)%nat 0%nat else 0))
        (fun r c : nat => if (c =? 0)%nat then U (2 ^ m * r + i)%nat 0%nat else 0)).
{ intros k H23 i H24.
  specialize (H20 k H23 i H24).
  setoid_rewrite <- Mplus_0_r at 5.
  rewrite <- H20.
  setoid_rewrite <- Mmult_1_l at 6.
  rewrite <- Mmult_plus_distr_r.
  f_equal. setoid_rewrite Mplus_comm at 2.
  rewrite <- Mplus_assoc.
  setoid_rewrite <- Mplus_0_l at 1. f_equal.
  lma'.
  unfold WF_Matrix. intros x y H25.
  bdestruct_all; simpl; subst; auto.
  destruct WFUU.
  rewrite H26; auto. rewrite H12. nia. }

assert (forall i : nat,
        (0 <= i < 2 ^ m)%nat ->
        @vecSatisfiesP n
          (fun r c : nat => if (c =? 0)%nat then U (2 ^ m * r + i)%nat 0%nat else 0)
          (Cap (map TtoA Lt))).
{ intros i H24. unfold vecSatisfiesP. split.
  - unfold WF_Matrix. intros.
    bdestruct_all; simpl; subst; auto.
    destruct WFUU.
    rewrite H26; auto. rewrite H12. nia. 
  - rewrite Forall_forall. intros x H25.
    apply In_nth with (d := defaultT_I n) in H25.
    destruct H25 as [k [kbound kth]]. subst.
    rewrite map_nth with (d := defaultT_I n).
    simpl. unfold translateA. simpl. rewrite Mplus_0_l.
    unfold vecSatisfies.
    split. 
    + unfold WF_Matrix. intros.
      bdestruct_all; simpl; subst; auto.
      destruct WFUU.
      rewrite H26; auto. rewrite H12. nia.
    + unfold Eigenpair. simpl. rewrite Mscale_1_l.
      apply H23; auto. rewrite map_length in kbound; auto. }

setoid_rewrite vecSatisfiesP_iff_stabilizeByListT in H24.
setoid_rewrite vecSatisfiesP_iff_stabilizeByListT in H8.

assert (@CM.dimension (2^n)%nat (stabilizeByListT (fun v => WF_Matrix v) Lt) 1%nat).
{ assert (@CM.subspace (2 ^ n)%nat (stabilizeByListT (fun v => WF_Matrix v) Lt)).
  { apply stabilizeByListT_is_subspace. apply CM.totalspace_is_subspace. }
  destruct (CM.exists_dimension H25) as [dim [isdim dimbound]].
  assert (length Lt <= n)%nat by lia.
  pose (dimension_stabilizeByListT dim Lt H0 H1 H2 H3 H4 H5 H26 isdim) as E.
  rewrite H6 in E. replace (n - n)%nat with 0%nat in E by lia.
 rewrite Nat.pow_0_r in E. subst. auto. }

unfold CM.dimension in H25.
destruct H25 as [B [WFB basisB]].
pose (CM.subspace_is_basis_span basisB) as E.

assert (@CM.WF_GenMatrix (2^n)%nat (2^m)%nat 
            (fun r c : nat => if (r <? 2^n)%nat && (c <? 2^m)%nat 
                          then U (2 ^ m * r + c)%nat 0%nat else C0)).
  { unfold CM.WF_GenMatrix. intros. bdestruct_all; simpl; auto. }

assert (exists A : Matrix 1 (2^m)%nat, WF_Matrix A /\
           @Mmult (2^n)%nat 1%nat (2^m)%nat B A = 
             (fun r c : nat => if (r <? 2^n)%nat && (c <? 2^m)%nat 
                          then U (2 ^ m * r + c)%nat 0%nat else C0)).
{pose (CM.collect_columns_in_span H25 WFB) as E'.
  assert (forall i : nat,
      (i < 2 ^ m)%nat ->
      CM.span B
        (@CM.get_col (2^n)%nat (2^m)%nat 
           (fun r c : nat =>
            if (r <? 2 ^ n) && (c <? 2 ^ m) then U (2 ^ m * r + c)%nat 0%nat else C0)
           i)).
  { intros i H26.
    assert ((@CM.get_col (2^n)%nat (2^m)%nat 
       (fun r c : nat =>
        if (r <? 2 ^ n) && (c <? 2 ^ m) then U (2 ^ m * r + c)%nat 0%nat else C0) i) =
              (fun r c : nat => if (c =? 0)%nat then U (2 ^ m * r + i)%nat 0%nat else C0)).
    { unfold CM.get_col. prep_matrix_equality. bdestruct_all; simpl; auto; subst. 
      destruct WFUU. rewrite H29; auto; nia. }
    rewrite H27, <- E. apply H24. lia. }
  specialize (E' H26).
  destruct E' as [A [WFA BA]].
  exists A. auto. }
destruct H26 as [A [WFA BA]].
destruct WFUU.
assert (WF_Matrix (get_col U 0%nat)) by auto with wf_db.
rewrite H12 in H28.
pose (collect_kron1 B A (get_col U 0%nat) WFB WFA H28) as E'.
unfold get_col in E'. simpl in E'. specialize (E' BA).
replace (fun x y : nat => if (y =? 0)%nat then U x 0%nat else 0) with (get_col U 0%nat) in E' by (unfold get_col; simpl; auto).
assert (stabilizeByListT (fun v : Vector (2 ^ n) => WF_Matrix v) Lt B).
{ rewrite E. unfold CM.span. exists (I 1). split. apply CM.WF_I1. lma'. }
assert (v = ((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (get_col U 0%nat)).
{ rewrite AULVd.
  unfold adjoint, Mmult, Matrix.scale, get_col.
  prep_matrix_equality.
  apply big_sum_unique.
  exists 0%nat. repeat split; simpl; auto; try lia.
  bdestruct_all; subst; simpl. 
  - rewrite <- Cmult_assoc. setoid_rewrite Cmult_comm at 3. f_equal.
    apply big_sum_unique. exists 0%nat. rewrite H12. repeat split; try lca.
    + assert (1 < 2 ^ m)%nat. { apply Nat.pow_gt_1; try lia. }
      assert (1 < 2 ^ n)%nat. { apply Nat.pow_gt_1; try lia. }
      lia.
    + intros x' H30 H31. rewrite H22; try lca; lia.
  - destruct WFUV. rewrite H31; try lia. lca. }
rewrite E' in H30.
setoid_rewrite <- Mscale_kron_dist_r in H30.
assert (WF_Matrix (((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (A ⊤))) by auto with wf_db.
specialize (H8 B WFB (((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (A ⊤)) H31 H29).
contradiction.
Qed.


Lemma separability_proof_right :
  forall (n m : nat) (Lt : list (TType m)),
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt)) -> m <> 0%nat ->
    Lt <> [] -> Forall proper_length_TType Lt -> Forall coef_plus_minus_1 Lt ->
    commutingListT Lt -> length Lt = m -> 
    (forall v : Vector (2 ^ (n + m))%nat,
      (exists w : Vector (2 ^ n)%nat, WF_Matrix w /\ (exists u : Vector (2 ^ m)%nat, WF_Matrix u /\
        vecSatisfiesP u (Cap (map TtoA Lt)) /\ v = w ⊗ u)) <->
        vecSatisfiesP v (Cap (map (uncurry gTensorA)
                                (combine 
                                   (map TtoA (repeat (defaultT_I n) (length Lt)))
                                   (map TtoA Lt))))).
Proof. intros n m Lt H0 H1 H2 H3 H4 H5 H6 v.
  split; intros.
  - destruct H7 as [w [WFw [u [WFu [vecSatisfiesPu vwu]]]]].
    rewrite vwu.
    simpl. split; auto with wf_db.
    clear - vecSatisfiesPu WFw WFu H3.
    induction Lt; auto.
    simpl in *. destruct vecSatisfiesPu. 
    rewrite Forall_cons_iff in *. destruct H1, H3.
    assert (H5 := conj H0 H2).
    specialize (IHLt H4 H5).
    constructor; auto.
    unfold uncurry. simpl.
    unfold translateA in *. simpl in *. rewrite Mplus_0_l in *.
    unfold vecSatisfies in *.
    destruct H1. split; auto with wf_db.
    unfold Eigenpair in *. simpl in *.
    rewrite Mscale_1_l in *.
    assert (H' : (let (c2, g7) := a in (C1 * c2, repeat gI n ++ g7)) =
              gTensorT (defaultT_I n) a) by auto.
    setoid_rewrite H'.
    rewrite translate_gTensorT.
    + rewrite translate_defaultT_I. setoid_rewrite kron_mixed_product'; auto.
      2-3: rewrite Nat.pow_add_r; auto.
      rewrite Mmult_1_l; auto. f_equal; auto.
    + unfold defaultT_I. simpl. rewrite repeat_length. auto.
    + destruct H3. auto.
  - assert (H8 : forall A B : Prop, ~ (A /\ B) <-> (A -> ~ B)).
    { intros A B. split; intros.
      - apply Classical_Prop.not_and_or in H8. destruct H8; auto.
      - apply Classical_Prop.or_not_and. destruct (Classical_Prop.classic A); auto. }
    assert (H9 : ((forall w : Vector (2 ^ n)%nat, WF_Matrix w ->  
                           (forall u : Vector (2 ^ m)%nat, WF_Matrix u ->
                                   vecSatisfiesP u (Cap (map TtoA Lt)) ->
                                          ~ v = w ⊗ u)) -> False) <->
                   (exists w : Vector (2 ^ n),
                       WF_Matrix w /\
                         (exists u : Vector (2 ^ m),
                             WF_Matrix u /\
                               vecSatisfiesP u (Cap (map TtoA Lt)) /\ 
                               v = w ⊗ u))).
    { split; intros. 
      - apply Classical_Prop.NNPP. intro.
        contradict H9.
        intros w H9 u H11 H12. 
        apply Classical_Pred_Type.not_ex_all_not with (n := w) in H10.
        rewrite H8 in H10. specialize (H10 H9).
         apply Classical_Pred_Type.not_ex_all_not with (n := u) in H10.
         rewrite H8 in H10. specialize (H10 H11).
         apply Classical_Prop.not_and_or in H10.
         destruct H10; auto.
      - destruct H9 as [w [WFw [u [WFu [vecSatisfiesPw vwu]]]]].
        apply (H10 w WFw u WFu vecSatisfiesPw vwu). }
    rewrite <- H9. clear H8 H9.
    intros H8.
    assert (WF_Matrix v).
    { destruct H7; auto. }
    destruct (SVD v H9) as [U [L [V [WFUU [WFUV [WFDL [WFNL AULVd]]]]]]].
    bdestruct (n =? 0)%nat.
    + subst.
      assert (@eq (list (AType (0 + m))) (map (uncurry gTensorA)
               (combine (map TtoA (repeat (defaultT_I 0) (length Lt)))
                  (map TtoA Lt)))
                (map TtoA Lt)).
      { unfold defaultT_I. simpl. rewrite map_repeat.
        apply nth_ext with (d := (uncurry (@gTensorA 0%nat m)) (([(C1,[])]), ([defaultT_I m]))) (d' := defaultT_I (0 + m)).
        * rewrite ! map_length. rewrite combine_length. rewrite repeat_length, map_length.
          minmax_breakdown. auto.
        * intros n0 H10. rewrite ! map_nth.
          rewrite combine_nth.
          2: rewrite map_length, repeat_length; auto.
          rewrite map_nth with (d := defaultT_I m).
          rewrite nth_repeat.
          unfold uncurry.
          simpl. unfold TtoA.
          destruct (nth n0 Lt (defaultT_I m)).
           do 2 f_equal. lca. }
      rewrite H10 in H7. 
      assert (0 + m = m)%nat by lia.
      rewrite H11 in *.
      replace (2 ^ m)%nat with (2 ^ (0 + m))%nat in * by (rewrite Nat.add_0_l; auto).
      specialize (H8 (I 1) WF_I1 (U × L × (V) †) H9 H7).
      rewrite kron_1_l in H8; auto.
    + assert (v = (V 0%nat 0%nat)^* .* (U × L)).
      { rewrite AULVd.
        unfold Mmult, Matrix.scale, adjoint. simpl.
        prep_matrix_equality. destruct WFUV.
        bdestruct (y =? 0)%nat.
        - subst. lca.
        - rewrite H11 at 1; auto; try lia. rewrite Cconj_0, Cmult_0_r, Cplus_0_l.
          assert (Σ (fun y0 : nat => U x y0 * L y0 y) (2 ^ (n + m)) = C0).
          { destruct WFDL.
            rewrite big_sum_0_bounded; auto; intros.
            rewrite H14; auto; try lia; try lca. }
          rewrite H14. lca. }
      assert ((2 ^ (n + m)) = (2 ^ n) * (2 ^ m))%nat by apply Nat.pow_add_r.

      simpl in H7. destruct H7.

      rewrite matrix_span_as_get_col_sum in H11.
      2: destruct WFDL; auto.

      assert ( fold_right Mplus Zero
                 (map (fun i : nat => L i 0%nat .* get_col U i)
                    (List.seq 0 (2 ^ (n + m)))) = 
                 fold_right Mplus Zero
                         (map (fun M => M)   
                   (map (fun i : nat => L i 0%nat .* get_col U i)
                      (List.seq 0 (2 ^ (n + m))))))
      by (rewrite map_map; auto).
      rewrite H14 in H11.
      rewrite <- fold_right_Mplus_Zero_Mscale_distr with (c := (V 0%nat 0%nat) ^* ) in H11.
      rewrite map_map in H11.
      assert ((map (fun i : nat => (V 0%nat 0%nat) ^* .* (L i 0%nat .* get_col U i))
             (List.seq 0 (2 ^ (n + m)))) =
                (map (fun i : nat => 
                        fold_right Mplus Zero
                          (map
                             (fun j : nat =>
                                (V 0%nat 0%nat) ^* * (L i 0%nat) * (U j i) .* 
                                                               (@e_i (2 ^ n)%nat (j / (2 ^ m)%nat) ⊗ @e_i (2 ^ m)%nat (j mod (2 ^ m)%nat)))
                          (List.seq 0 (2 ^ (n + m)))))
                  (List.seq 0 (2 ^ (n + m))))).
      { apply map_ext_Forall. rewrite Forall_forall. intros x H15.  rewrite in_seq in H15.
        rewrite (vector_as_e_i_sum (get_col U x)) at 1.
        assert ((map (fun i : nat => get_col U x i 0%nat .* @ e_i (2 ^ (n + m))  i)
              (List.seq 0 (2 ^ (n + m)))) = 
                  (map (fun M => M) (map (fun i : nat => get_col U x i 0%nat .* e_i i)
              (List.seq 0 (2 ^ (n + m)))))) by (rewrite map_map; auto).
        rewrite H16.
        rewrite Mscale_assoc.
        rewrite <- fold_right_Mplus_Zero_Mscale_distr.
        rewrite ! map_map.
        f_equal.
        apply map_ext_Forall. rewrite Forall_forall. intros x0 H17. rewrite in_seq in H17.
        rewrite ! H12.
        rewrite e_i_kron_inv; auto; try lia.
        rewrite ! Mscale_assoc. f_equal.
        destruct WFUU. auto with wf_db. }
      rewrite H15 in H11.
      rewrite fold_right_Mplus_Zero_double_swap 
        with (F := (fun i j : nat =>
                     (V 0%nat 0%nat) ^* * L i 0%nat * U j i .* (e_i (j / 2 ^ m) ⊗ e_i (j mod 2 ^ m))))
        in H11.
      assert ((fun j : nat =>
              fold_right Mplus Zero
                (map
                   (fun i : nat =>
                    (V 0%nat 0%nat) ^* * L i 0%nat * U j i
                    .* (@e_i (2 ^ n)%nat (j / 2 ^ m) ⊗ @e_i (2 ^ m)%nat (j mod 2 ^ m)))
                   (List.seq 0 (2 ^ (n + m))))) =
                (fun j : nat =>
              (fold_right Cplus C0
                (map
                   (fun i : nat =>
                    (V 0%nat 0%nat) ^* * L i 0%nat * U j i)
                   (List.seq 0 (2 ^ (n + m))))) .* (e_i (j / 2 ^ m) ⊗ e_i (j mod 2 ^ m)))).
      { apply functional_extensionality. intros x.
        rewrite fold_right_Mplus_Zero_collect_scalar. auto. }
      rewrite H16 in H11.
      clear H14 H15 H16.

      assert (forall k : nat, (k < length Lt)%nat -> (translate (gTensorT (defaultT_I n) (nth k Lt (defaultT_I m)))) × v = v).
      { rewrite Forall_map in H13.
        rewrite Forall_forall in H13.
        intros k H14. specialize (H13 (nth k (combine 
             (map TtoA (repeat (defaultT_I n) (length Lt)))
             (map TtoA Lt)) ([defaultT_I n],[defaultT_I m] ))).  
        assert (In
          (nth k
             (combine 
                (map TtoA
                   (repeat (defaultT_I n) (length Lt)))
                (map TtoA Lt))
             ([defaultT_I n], [defaultT_I m]))
          (combine (map TtoA (repeat (defaultT_I n) (length Lt)))
               (map TtoA Lt))).
        { apply nth_In. rewrite combine_length, ! map_length, repeat_length. 
          minmax_breakdown. auto. }
        specialize (H13 H15). clear H15.
        rewrite combine_nth in H13.
        rewrite map_nth with (d := defaultT_I n) in H13.
        rewrite map_nth with (d := defaultT_I m) in H13.
        rewrite nth_repeat in H13.
        unfold uncurry. simpl in H13. 
        2 : rewrite ! map_length, repeat_length; auto.
        unfold translateA in H13. simpl in H13. rewrite Mplus_0_l in H13.
        unfold vecSatisfies in H13. destruct H13. unfold Eigenpair in H15. simpl in H15.
        rewrite Mscale_1_l in H15. auto. }
      
      setoid_rewrite translate_gTensorT in H14.
      2: { unfold defaultT_I. simpl. rewrite repeat_length. auto. }
      2: { bdestruct (k <? length Lt)%nat.
           rewrite Forall_nth in H3. specialize (H3 k (defaultT_I m) H15).
           destruct H3. auto. rewrite nth_overflow; try lia. unfold defaultT_I. simpl. 
           rewrite repeat_length. auto. }

      rewrite translate_defaultT_I in H14.
      rewrite H11 in H14. rewrite ! H12 in H14.
      setoid_rewrite <- fold_right_Mplus_Zero_map_Mmult_distr in H14.
      setoid_rewrite map_map in H14.

      assert (forall k : nat, (fun x : nat =>
              I (2 ^ n) ⊗ translate (nth k Lt (defaultT_I m))
              × (fold_right Cplus 0
                   (map (fun i : nat => (V 0%nat 0%nat) ^* * L i 0%nat * U x i)
                      (List.seq 0 (2 ^ n * 2 ^ m)))
                 .* (e_i (x / 2 ^ m) ⊗ e_i (x mod 2 ^ m)))) =
                         (fun x : nat =>
              fold_right Cplus 0
    (map (fun i : nat => (V 0%nat 0%nat) ^* * L i 0%nat * U x i)
       (List.seq 0 (2 ^ n * 2 ^ m)))
  .* (e_i (x / 2 ^ m)
      ⊗ (translate (nth k Lt (defaultT_I m)) × e_i (x mod 2 ^ m))))).
      { intro. apply functional_extensionality. intro. rewrite Mscale_mult_dist_r. 
        rewrite kron_mixed_product. rewrite Mmult_1_l; auto with wf_db. }
      setoid_rewrite H15 in H14. clear H15.
      setoid_rewrite fold_right_Mplus_Zero_big_sum in H14.
      
      assert (forall k : nat, (fun i : nat =>
           fold_right Cplus 0
             (map (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0)
                (List.seq 0 (2 ^ n * 2 ^ m)))
           .* (@e_i (2 ^ n)%nat (i / 2 ^ m)
               ⊗ (translate (nth k Lt (defaultT_I m)) × @e_i (2 ^ m)%nat (i mod 2 ^ m)))) =
                (fun i : nat =>
           (big_sum (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0) (2 ^ n * 2 ^ m))
           .* (e_i (i / 2 ^ m)
               ⊗ (translate (nth k Lt (defaultT_I m)) × e_i (i mod 2 ^ m))))).
      { intro. apply functional_extensionality. intro.
        rewrite fold_right_Cplus_C0_big_sum. rewrite Nat.mul_1_l. auto. }
      rewrite ! Nat.mul_1_l in H15. setoid_rewrite H15 in H14. clear H15.

      assert ((fun i : nat =>
           fold_right Cplus 0
             (map (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0)
                (List.seq 0 (2 ^ n * 2 ^ m)))
           .* (@e_i (2 ^ n)%nat (i / 2 ^ m) ⊗ @e_i (2 ^ m)%nat (i mod 2 ^ m))) = 
                (fun i : nat =>
           (big_sum (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U i i0) (2 ^ n * 2 ^ m))
             .* (e_i (i / 2 ^ m) ⊗ e_i (i mod 2 ^ m)))).
      { apply functional_extensionality. intro.
        rewrite fold_right_Cplus_C0_big_sum. auto. }
      setoid_rewrite H15 in H14. clear H15.
      
     setoid_rewrite <- fold_right_Mplus_Zero_big_sum in H14.
     setoid_rewrite fold_right_Mplus_Zero_scaled_vector_sum in H14.

     2: { rewrite Forall_forall. intros x H15. apply WF_kron; auto with wf_db.
          apply WF_mult; auto with wf_db. bdestruct (k <? length Lt)%nat.
          apply WF_translate. rewrite Forall_nth in H3. apply H3; auto.
          rewrite nth_overflow; auto. rewrite translate_defaultT_I. auto with wf_db. }
     
     2: { rewrite Forall_forall. intros x H15. apply WF_kron; auto with wf_db.}

     assert (forall k : nat, (k < length Lt)%nat -> @Mmult (2 ^ n * 2 ^ m)%nat (2 ^ n * 2 ^ m)%nat 1%nat
         (fun r c : nat =>
         (@e_i (2^n)%nat (c / 2 ^ m) ⊗ ((translate (nth k Lt (defaultT_I m)) .+ (- C1)%C .* (I (2^m)%nat)) × @e_i (2^m)%nat (c mod 2 ^ m)))
           r 0%nat) 
         (fun r c : nat =>
           if (c =? 0)%nat
           then
            Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0)
              (2 ^ n * 2 ^ m)
           else 0) = Zero).
     { intros k H15. specialize (H14 k H15).
       prep_matrix_equality. 
       apply f_equal_inv with (x := x) in H14.
       apply f_equal_inv with (x := y) in H14.
       unfold Mmult at 1 in H14. unfold Mmult at 2 in H14.
       unfold Mmult at 1. unfold Zero.
       apply Cplus_inv_r with (c :=
          (@Mmult (2 ^ n * 2 ^ m)%nat (2 ^ n * 2 ^ m)%nat 1%nat
            (fun r c : nat => (@e_i (2^n)%nat (c / 2 ^ m) ⊗ @e_i (2^m)%nat (c mod 2 ^ m)) r 0%nat)
              (fun r c : nat =>
           if (c =? 0)%nat
           then
            Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0)
              (2 ^ n * 2 ^ m)
           else 0)) x y).
       unfold Mmult at 2. unfold Mmult at 2. rewrite Cplus_0_l.
       rewrite <- H14 at 2.
       rewrite <- @big_sum_plus with (H0 := C_is_group).
       apply big_sum_eq_bounded. intros x0 H16. 
       rewrite <- ! Cmult_plus_distr_r. f_equal. unfold Mplus, Matrix.scale, Mmult.
       unfold kron. simpl. rewrite <- ! Cmult_plus_distr_l. f_equal.
       unfold I. bdestruct_all.
       - replace (2 ^ m)%nat with ((x mod 2 ^ m) + 1 + ((2 ^ m) - (Datatypes.S (x mod 2 ^ m))))%nat by lia.
         rewrite ! big_sum_sum; simpl. rewrite ! Cplus_0_l.
         rewrite ! andb_true_r. rewrite ! Nat.add_0_r. 
         replace (x mod 2 ^ m + 1 + (2 ^ m - s (x mod 2 ^ m)))%nat with (2 ^ m)%nat by lia.
         bdestruct_all.
         rewrite Cmult_1_r. rewrite Cmult_plus_distr_r.
         rewrite <- ! Cplus_assoc. setoid_rewrite Cplus_comm at 5.

         assert (Σ
    (fun y0 : nat =>
     (translate (nth k Lt (defaultT_I m)) (x mod 2 ^ m) y0 +
      - C1 * (if (x mod 2 ^ m =? y0)%nat && true then C1 else 0)) *
     @e_i (2 ^ m)%nat (x0 mod 2 ^ m) y0 0%nat) (x mod 2 ^ m) +
  (translate (nth k Lt (defaultT_I m)) (x mod 2 ^ m) (x mod 2 ^ m) *
   @e_i (2 ^ m)%nat (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat +
   (- C1 * @e_i (2 ^ m)%nat (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat +
    (@e_i (2 ^ m)%nat (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat +
     Σ
       (fun x1 : nat =>
        (translate (nth k Lt (defaultT_I m)) (x mod 2 ^ m)
           (x mod 2 ^ m + 1 + x1)%nat +
         - C1 *
         (if (x mod 2 ^ m =? x mod 2 ^ m + 1 + x1)%nat && true then C1 else 0)) *
        @e_i (2 ^ m)%nat (x0 mod 2 ^ m) (x mod 2 ^ m + 1 + x1)%nat 0%nat)
       (2 ^ m - s (x mod 2 ^ m))))) = 
Σ
    (fun y0 : nat =>
     (translate (nth k Lt (defaultT_I m)) (x mod 2 ^ m) y0 +
      - C1 * (if (x mod 2 ^ m =? y0)%nat && true then C1 else 0)) *
     e_i (x0 mod 2 ^ m) y0 0%nat) (x mod 2 ^ m) +
  (translate (nth k Lt (defaultT_I m)) (x mod 2 ^ m) (x mod 2 ^ m) *
   e_i (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat +
   (- C1 * e_i (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat +
    (e_i (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat)) +
     Σ
       (fun x1 : nat =>
        (translate (nth k Lt (defaultT_I m)) (x mod 2 ^ m)
           (x mod 2 ^ m + 1 + x1)%nat +
         - C1 *
         (if (x mod 2 ^ m =? x mod 2 ^ m + 1 + x1)%nat && true then C1 else 0)) *
        e_i (x0 mod 2 ^ m) (x mod 2 ^ m + 1 + x1)%nat 0%nat)
       (2 ^ m - s (x mod 2 ^ m)))) by (rewrite ! Cplus_assoc; auto). 
         rewrite H19. clear H19.
         assert (- C1 * @e_i (2 ^ m)%nat (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat +
    @e_i (2 ^ m)%nat (x0 mod 2 ^ m) (x mod 2 ^ m) 0%nat = C0) by lca.
         rewrite H19. clear H19. rewrite Cplus_0_r.
         f_equal.
         + apply big_sum_eq_bounded. intros x1 H19. 
           bdestruct_all; simpl; auto; try lia; try lca. 
         + f_equal. apply big_sum_eq_bounded. intros x1 H19. 
           bdestruct_all; simpl; auto; try lia; try lca.
       - assert (WF_Matrix (@e_i (2^m)%nat (x0 mod 2 ^ m))) by auto with wf_db.
         rewrite H18; try lia. rewrite Cplus_0_r.
         apply big_sum_eq_bounded. intros x1 H19.
         bdestruct_all. simpl. rewrite Cmult_0_r, Cplus_0_r. auto.
       - apply C_is_comm_group. }
     
     assert (forall r : nat, Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0) (2 ^ n * 2 ^ m) =
                        (V 0%nat 0%nat) ^* * L 0%nat 0%nat * U r 0%nat).
     { intros r. destruct WFDL.
       rewrite big_sum_unique with (k := (V 0%nat 0%nat) ^* * L 0%nat 0%nat * U r 0%nat); auto.
       exists 0%nat. repeat split; auto. rewrite <- H12.
       assert (0 < 2 ^ (n + m))%nat.
       { assert (0 ^ (n + m) = 0)%nat. { apply Nat.pow_0_l; lia. }
         rewrite <- H18 at 1.
         apply Nat.pow_lt_mono_l; lia. }
       auto.
       intros x' H18 H19.
       rewrite H17; try lia; lca. }

     assert ((fun r c : nat =>
           if (c =? 0)%nat
           then
            Σ (fun i0 : nat => (V 0%nat 0%nat) ^* * L i0 0%nat * U r i0)
              (2 ^ n * 2 ^ m)
           else 0) =
               (fun r c : nat =>
           if (c =? 0)%nat
           then
            (V 0%nat 0%nat) ^* * L 0%nat 0%nat * U ((2^m * (r / 2^m) + r mod 2^m)%nat) 0%nat
           else 0)).
     { prep_matrix_equality. bdestruct_all; try rewrite H16; auto.
       rewrite <- Nat.div_mod_eq. auto. }
     rewrite H17 in H15.

     assert ((2 ^ n * 2 ^ m) = (2 ^ m * 2 ^ n))%nat by (apply Nat.mul_comm).

     unfold Mmult in H15 at 1.

assert (forall k : nat,
(fun x z : nat =>
         Σ
           (fun y : nat =>
            (@e_i (2^n)%nat (y / 2 ^ m) ⊗ ((translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) × @e_i (2^m)%nat (y mod 2 ^ m))) x 0%nat *
            (if (z =? 0)%nat
             then
              (V 0%nat 0%nat) ^* * L 0%nat 0%nat *
              U (2 ^ m * (y / 2 ^ m) + y mod 2 ^ m)%nat 0%nat
             else 0)) (2 ^ n * 2 ^ m)) =


  (fun x y : nat =>
         if (y =? 0)%nat then
(@big_sum (Matrix (2 ^ n * 2 ^ m) 1%nat) (M_is_monoid (2 ^ n * 2 ^ m) 1%nat)


(fun x0 : nat =>
     (@kron (2^n)%nat 1%nat (2^m)%nat 1%nat 
        (@e_i (2^n)%nat x0)
(fun r c : nat =>

       (Σ
       (fun y0 : nat =>
        
((V 0%nat 0%nat) ^* * L 0%nat 0%nat * U (2 ^ m * x0 + y0)%nat 0%nat) *
(((translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) × @e_i (2^m)%nat y0) r c)

) (2 ^ m)))
       )
)

(2 ^ n)) x 0%nat

else C0

)).
{ intros k. prep_matrix_equality. bdestruct_all; subst.
  rewrite Msum_Csum.
     rewrite ! H18.
     rewrite <- big_sum_double_sum
with 
(f := (fun i j : nat =>
     ( e_i (i)
      ⊗ ((translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) × e_i (j))) x 0%nat *
     ( (*if (y =? 0)%nat
      then *)
       (V 0%nat 0%nat) ^* * L 0%nat 0%nat *
       U (2 ^ m * (i) + j)%nat 0%nat
      (* else 0 *)))).
     unfold kron. simpl.
     apply big_sum_eq_bounded. intros x0 H19.
     rewrite @big_sum_mult_l with (H2 := C_is_ring).
     apply big_sum_eq_bounded. intros x1 H20. simpl. 
     lca. 
     rewrite big_sum_0_bounded; auto; intros; lca. }
setoid_rewrite H19 in H15. clear H19.

assert (@Zero (2 ^ n * 2 ^ m)%nat 1%nat =
          (fun x y : nat =>
         if (y =? 0)%nat
         then
          @big_sum (Vector (2^n * 2^m)%nat) (M_is_monoid (2^n * 2^m)%nat 1%nat)
            (fun x0 : nat =>
             (@e_i (2^n)%nat x0) ⊗ @Zero (2^m)%nat 1%nat) (2 ^ n) x 0%nat
         else 0)).
{ prep_matrix_equality. unfold Zero.
  bdestruct_all; simpl; subst.
  rewrite big_sum_0_bounded; auto; intros.
  rewrite kron_0_r. lma'. auto. }
rewrite H19 in H15.

assert (forall k : nat, (k < length Lt)%nat -> 
                 forall i, (0 <= i < 2^n)%nat ->
             (fun r c : nat =>
                Σ
                  (fun y0 : nat =>
                   (V 0%nat 0%nat) ^* * L 0%nat 0%nat *
                   U (2 ^ m * i + y0)%nat 0%nat *
                   ((translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m))
                    × e_i y0) r c) (2 ^ m)) =
                @Zero (2^m)%nat 1%nat).
{ intros k H20 i H21.
  apply @delete_left_kron_from_vector
          with (j := (2^n)%nat) (k := (2^n)%nat)
          (A_i := (fun x0 : nat =>
              (fun r c : nat =>
                Σ
                  (fun y0 : nat =>
                   (V 0%nat 0%nat) ^* * L 0%nat 0%nat *
                   U (2 ^ m * x0 + y0)%nat 0%nat *
                   ((translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m))
                    × e_i y0) r c) (2 ^ m))))
               (B_i := (fun x0 : nat => @Zero (2^m)%nat 1%nat)); auto; try lia.
  - intro. rewrite Nat.pow_eq_0_iff in H22. destruct H22. lia.
  - rewrite Forall_forall. intros x H22. rewrite in_seq in H22.
    unfold WF_Matrix. intros x0 y H23.
    destruct H23.
    + rewrite big_sum_0_bounded; auto; intros. unfold Mmult.
      rewrite big_sum_0_bounded; intros; try lca.
      assert (WF_Matrix (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m))).
      { apply WF_plus; auto with wf_db. apply WF_translate.
        rewrite Forall_nth in H3. apply H3; lia. }
      rewrite H26; try lia; lca.
    + rewrite big_sum_0_bounded; auto; intros. unfold Mmult.
      pose (@WF_e_i (2^m)%nat x1) as WFei.
      rewrite big_sum_0_bounded; intros; try lca.
      rewrite WFei; try lia; lca.
  - rewrite Forall_forall. intros x H22. auto with wf_db. }

unfold Mmult in H20.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ n)%nat ->
        @eq (Vector (2^m)%nat)
        (fun r c : nat =>
         Σ
           (fun y0 : nat =>
              ((V 0%nat 0%nat) ^* * L 0%nat 0%nat * U (2 ^ m * i + y0)%nat 0%nat) *
            Σ
              (fun y : nat =>
               (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) r y *
               @e_i (2^m)%nat y0 y c) (2 ^ m))
           (2 ^ m))
        (@Matrix.scale (2^m)%nat 1%nat
        ((V 0%nat 0%nat) ^* * L 0%nat 0%nat)
        (fun r c : nat =>
         Σ
           (fun y0 : nat =>
              (U (2 ^ m * i + y0)%nat 0%nat) *
            Σ
              (fun y : nat =>
               (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) r y *
               @e_i (2^m)%nat y0 y c) (2 ^ m))
           (2 ^ m)))).
{ intros k H21 i H22.
  prep_matrix_equality. unfold Matrix.scale.
  rewrite @big_sum_mult_l with (H2 := C_is_ring).
  apply big_sum_eq_bounded; intros. simpl. lca. }

  assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ n)%nat ->
        (V 0%nat 0%nat) ^* * L 0%nat 0%nat
        .* (fun r c : nat =>
            Σ
              (fun y0 : nat =>
                 (U (2 ^ m * i + y0)%nat 0%nat) *
               Σ
                 (fun y : nat =>
                  (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) r y *
                  @e_i (2^m)%nat y0 y c) (2 ^ m)) 
              (2 ^ m)) = @Zero (2^m)%nat 1%nat).
{ intros k H22 i H23. specialize (H20 k H22 i H23).  specialize (H21 k H22 i H23).
  rewrite <- H21. rewrite H20. auto. }
clear H20 H21.

assert (((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (@Zero (2^m)%nat 1%nat) = (@Zero (2^m)%nat 1%nat)).
{ rewrite Mscale_0_r. auto. }
setoid_rewrite <- H20 in H22.

assert ((V 0%nat 0%nat) <> C0). 
{ intro. assert (V = Zero).
  { prep_matrix_equality. unfold Zero. destruct WFUV.
    bdestruct (x =? 0)%nat; bdestruct (y =? 0)%nat; subst; auto; rewrite H23; auto; try lia. }
  destruct WFUV. rewrite H23 in H25. rewrite Mmult_0_r in H25.
  contradict_matrix_equalities. }
assert ((V 0%nat 0%nat) ^* <> C0).
{ apply Cconj_neq_0; auto. }
assert (L 0%nat 0%nat <> C0).
{ intro. assert (L = Zero).
  { prep_matrix_equality. unfold Zero. destruct WFDL.
    bdestruct (x =? 0)%nat; bdestruct (y =? 0)%nat; subst; auto.
    rewrite H25; auto; lia. }
  rewrite H25 in AULVd. rewrite Mmult_0_r, Mmult_0_l in AULVd.
  subst.
  assert (WF_Matrix (@Zero (2^n)%nat 1%nat)) as zero2n by auto with wf_db.
  assert (WF_Matrix (@Zero (2^m)%nat 1%nat)) as zero2m by auto with wf_db.
  assert (vecSatisfiesP (@Zero (2^m)%nat 1%nat) (Cap (map TtoA Lt))).
  { unfold vecSatisfiesP. split; auto with wf_db.
    unfold vecSatisfies. unfold Eigenpair. simpl.
    rewrite Forall_forall. intros x H25.
    split; auto with wf_db. rewrite Mmult_0_r, Mscale_0_r. auto. }
  specialize (H8 (@Zero (2^n)%nat 1%nat) zero2n (@Zero (2^m)%nat 1%nat) zero2m H25).
  rewrite kron_0_l in H8. contradiction. } 
remember H24 as Lnonzero. clear HeqLnonzero.
assert ((V 0%nat 0%nat) ^* * L 0%nat 0%nat <> C0).
{ intro. apply Cmult_integral in H25. destruct H25; contradiction. }
clear H20 H21 H23 H24.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ n)%nat ->
        (fun r c : nat =>
            Σ
              (fun y0 : nat =>
                 (U (2 ^ m * i + y0)%nat 0%nat) *
               Σ
                 (fun y : nat =>
                  (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) r y *
                  @e_i (2^m)%nat y0 y c) (2 ^ m)) 
              (2 ^ m)) = (@Zero (2^m)%nat 1%nat)).
{ intros. specialize (H22 k H20 i H21). apply Mscale_cancel in H22; auto. }

clear H22 H25.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ n)%nat ->
        (fun r c : nat =>
           (if (c =? 0)%nat then
            Σ
              (fun y : nat => 
                 (U (2 ^ m * i + y)%nat 0%nat) *
               (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) r y) 
           (2 ^ m) else C0)) = @Zero (2^m)%nat 1%nat).
{ intros k H21 i H22.
  specialize (H20 k H21 i H22).
  rewrite <- H20.
  prep_matrix_equality. bdestruct_all; subst.
  - apply big_sum_eq_bounded; intros. f_equal.
    unfold e_i. simpl. symmetry. apply big_sum_unique. exists x0.
    repeat split; auto. bdestruct (x0 =? x0)%nat; bdestruct (x0 <? 2^m)%nat; try lia. simpl. lca.
    intros x' H24 H25. bdestruct (x' =? x0)%nat; bdestruct (x' <? 2^m)%nat; try lia. simpl. lca.
  - rewrite big_sum_0_bounded; auto; intros.
    assert (Σ
    (fun y0 : nat =>
     (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m)) x y0 * @e_i (2^m)%nat x0 y0 y)
    (2 ^ m) = C0).
    { rewrite big_sum_0_bounded; auto; intros.
      rewrite (@WF_e_i (2^m)%nat x0); try lca; try lia. }
    rewrite H25. lca. }

clear H20.

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ n)%nat ->
        @Mmult (2^m)%nat (2^m)%nat 1%nat
          (translate (nth k Lt (defaultT_I m)) .+ - C1 .* I (2 ^ m))
        (fun r c : nat =>
         if (c =? 0)%nat && (r <? 2 ^ m)%nat
         then U (2 ^ m * i + r)%nat 0%nat
         else 0) = @Zero (2^m)%nat 1%nat).
{ intros k H20 i H22.
  unfold Mmult. specialize (H21 k H20 i H22).
  rewrite <- H21. prep_matrix_equality.
  bdestruct_all; subst; auto.
  apply big_sum_eq_bounded; intros; simpl; bdestruct_all; auto; lca.
  rewrite big_sum_0_bounded; intros; bdestruct_all; auto; lca. }

assert (forall i j : nat, (i <> 0)%nat \/ (j <> 0)%nat -> L i j = C0).
{ intros i j H22. destruct WFDL. destruct H22.
  - bdestruct (j =? 0)%nat; subst.
    + apply H24. lia.
    + rewrite H23; auto; lia.
  - rewrite H23; auto; lia. }

assert (forall k : nat,
        (k < length Lt)%nat ->
        forall i : nat,
        (0 <= i < 2 ^ n)%nat ->
       @eq (Vector (2^m)%nat)
        (@Mmult (2^m)%nat (2^m)%nat 1%nat (translate (nth k Lt (defaultT_I m))) 
              (fun r c : nat => if (c =? 0)%nat && (r <? 2 ^ m)%nat then U (2 ^ m * i + r)%nat 0%nat else 0))
        (fun r c : nat => if (c =? 0)%nat && (r <? 2 ^ m)%nat then U (2 ^ m * i + r)%nat 0%nat else 0)).
{ intros k H23 i H24.
  specialize (H20 k H23 i H24).
  setoid_rewrite <- Mplus_0_r at 5.
  rewrite <- H20.
  setoid_rewrite <- Mmult_1_l at 6.
  rewrite <- Mmult_plus_distr_r.
  f_equal. setoid_rewrite Mplus_comm at 2.
  rewrite <- Mplus_assoc.
  setoid_rewrite <- Mplus_0_l at 1. f_equal.
  lma'.
  unfold WF_Matrix. intros x y H25.
  bdestruct_all; simpl; subst; auto. }

assert (forall i : nat,
        (0 <= i < 2 ^ n)%nat ->
        @vecSatisfiesP m
          (fun r c : nat => if (c =? 0)%nat && (r <? 2 ^ m)%nat then U (2 ^ m * i + r)%nat 0%nat else 0)
          (Cap (map TtoA Lt))).
{ intros i H24. unfold vecSatisfiesP. split.
  - unfold WF_Matrix. intros.
    bdestruct_all; simpl; subst; auto.
  - rewrite Forall_forall. intros x H25.
    apply In_nth with (d := defaultT_I m) in H25.
    destruct H25 as [k [kbound kth]]. subst.
    rewrite map_nth with (d := defaultT_I m).
    simpl. unfold translateA. simpl. rewrite Mplus_0_l.
    unfold vecSatisfies.
    split. 
    + unfold WF_Matrix. intros.
      bdestruct_all; simpl; subst; auto.
    + unfold Eigenpair. simpl. rewrite Mscale_1_l.
      apply H23; auto. rewrite map_length in kbound; auto. }

setoid_rewrite vecSatisfiesP_iff_stabilizeByListT in H24.
setoid_rewrite vecSatisfiesP_iff_stabilizeByListT in H8.

assert (@CM.dimension (2^m)%nat (stabilizeByListT (fun v => WF_Matrix v) Lt) 1%nat).
{ assert (@CM.subspace (2 ^ m)%nat (stabilizeByListT (fun v => WF_Matrix v) Lt)).
  { apply stabilizeByListT_is_subspace. apply CM.totalspace_is_subspace. }
  destruct (CM.exists_dimension H25) as [dim [isdim dimbound]].
  assert (length Lt <= m)%nat by lia.
  pose (dimension_stabilizeByListT dim Lt H0 H1 H2 H3 H4 H5 H26 isdim) as E.
  rewrite H6 in E. replace (m - m)%nat with 0%nat in E by lia.
 rewrite Nat.pow_0_r in E. subst. auto. }

unfold CM.dimension in H25.
destruct H25 as [B [WFB basisB]].
pose (CM.subspace_is_basis_span basisB) as E.

assert (@CM.WF_GenMatrix (2^m)%nat (2^n)%nat 
            (fun r c : nat => if (r <? 2^m)%nat && (c <? 2^n)%nat 
                          then U (2 ^ m * c + r)%nat 0%nat else C0)).
  { unfold CM.WF_GenMatrix. intros. bdestruct_all; simpl; auto. }

assert (exists A : Matrix 1 (2^n)%nat, WF_Matrix A /\
           @Mmult (2^m)%nat 1%nat (2^n)%nat B A = 
             (fun r c : nat => if (r <? 2^m)%nat && (c <? 2^n)%nat 
                          then U (2 ^ m * c + r)%nat 0%nat else C0)).
{pose (CM.collect_columns_in_span H25 WFB) as E'.
  assert (forall i : nat,
      (i < 2 ^ n)%nat ->
      CM.span B
        (@CM.get_col (2^m)%nat (2^n)%nat 
           (fun r c : nat =>
            if (r <? 2 ^ m) && (c <? 2 ^ n) then U (2 ^ m * c + r)%nat 0%nat else C0)
           i)).
  { intros i H26.
    assert ((@CM.get_col (2^m)%nat (2^n)%nat 
       (fun r c : nat =>
        if (r <? 2 ^ m) && (c <? 2 ^ n) then U (2 ^ m * c + r)%nat 0%nat else C0) i) =
              (fun r c : nat => if (c =? 0)%nat && (r <? 2 ^ m) then U (2 ^ m * i + r)%nat 0%nat else C0)).
    { unfold CM.get_col. prep_matrix_equality. bdestruct_all; simpl; auto; subst. }
    rewrite H27, <- E. apply H24. lia. }
  specialize (E' H26).
  destruct E' as [A [WFA BA]].
  exists A. auto. }
destruct H26 as [A [WFA BA]].
destruct WFUU.
assert (WF_Matrix (get_col U 0%nat)) by auto with wf_db.
rewrite H12 in H28.
pose (collect_kron2 B A (get_col U 0%nat) WFB WFA H28) as E'.
unfold get_col in E'. simpl in E'. specialize (E' BA).
replace (fun x y : nat => if (y =? 0)%nat then U x 0%nat else 0) with (get_col U 0%nat) in E' by (unfold get_col; simpl; auto).
assert (stabilizeByListT (fun v : Vector (2 ^ m) => WF_Matrix v) Lt B).
{ rewrite E. unfold CM.span. exists (I 1). split. apply CM.WF_I1. lma'. }
assert (v = ((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (get_col U 0%nat)).
{ rewrite AULVd.
  unfold adjoint, Mmult, Matrix.scale, get_col.
  prep_matrix_equality.
  apply big_sum_unique.
  exists 0%nat. repeat split; simpl; auto; try lia.
  bdestruct_all; subst; simpl. 
  - rewrite <- Cmult_assoc. setoid_rewrite Cmult_comm at 3. f_equal.
    apply big_sum_unique. exists 0%nat. rewrite H12. repeat split; try lca.
    + assert (1 < 2 ^ m)%nat. { apply Nat.pow_gt_1; try lia. }
      assert (1 < 2 ^ n)%nat. { apply Nat.pow_gt_1; try lia. }
      lia.
    + intros x' H30 H31. rewrite H22; try lca; lia.
  - destruct WFUV. rewrite H31; try lia. lca. }
rewrite E' in H30.
setoid_rewrite <- Mscale_kron_dist_r in H30.
assert (WF_Matrix (((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (A ⊤))) by auto with wf_db.
specialize (H8 (((V 0%nat 0%nat) ^* * L 0%nat 0%nat) .* (A ⊤)) H31 B WFB H29).
rewrite Mscale_kron_dist_r in H30. rewrite <- Mscale_kron_dist_l in H30.
contradiction.
Qed.


Lemma separability_proof2 :
  forall (n m : nat) (Lt1 : list (TType n)) (Lt2 : list (TType m)),
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt1)) -> n <> 0%nat ->
    Lt1 <> [] -> Forall proper_length_TType Lt1 -> Forall coef_plus_minus_1 Lt1 ->
    commutingListT Lt1 -> length Lt1 = n -> 
    linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 Lt2)) -> m <> 0%nat ->
    Lt2 <> [] -> Forall proper_length_TType Lt2 -> Forall coef_plus_minus_1 Lt2 ->
    commutingListT Lt2 -> length Lt2 = m -> 
    (forall v : Vector (2 ^ (n + m))%nat,
      (exists w : Vector (2 ^ n)%nat, WF_Matrix w /\ (exists u : Vector (2 ^ m)%nat, WF_Matrix u /\
        vecSatisfiesP w (Cap (map TtoA Lt1)) /\ vecSatisfiesP u (Cap (map TtoA Lt2)) 
                                                                      /\ v = w ⊗ u)) <->
        vecSatisfiesP v (Cap ((map (uncurry gTensorA)
                                (combine 
                                   (map TtoA Lt1) 
                                   (map TtoA (repeat (defaultT_I m) (length Lt1))))) ++ 
                           (map (uncurry gTensorA)
                              (combine 
                                 (map TtoA (repeat (defaultT_I n) (length Lt2)))
                                 (map TtoA Lt2)))))).
Proof. intros n m Lt1 Lt2 H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 v.
  pose (separability_proof_left n m Lt1 H0 H1 H2 H3 H4 H5 H6 v) as E.
  pose (separability_proof_right n m Lt2 H7 H8 H9 H10 H11 H12 H13 v) as E'.
  simpl in *. rewrite Forall_app. 
  split; intros.
  - destruct H14 as [w [WFw [u [WFu [[WFw' Forallw] [[WFu' Forallu] vwu]]]]]].
    assert (exists w : Vector (2 ^ n),
        WF_Matrix w /\
        (exists u : Vector (2 ^ m),
           WF_Matrix u /\
           (WF_Matrix w /\
            Forall (fun a0 : AType n => vecSatisfies w (translateA a0))
              (map TtoA Lt1)) /\ v = w ⊗ u)).
    { exists w. split; auto. exists u. auto. }
    rewrite E in H14.
    destruct H14 as [WFv Forallv1].
    assert (exists w : Vector (2 ^ n),
        WF_Matrix w /\
        (exists u : Vector (2 ^ m),
           WF_Matrix u /\
           (WF_Matrix u /\
            Forall (fun a0 : AType m => vecSatisfies u (translateA a0))
              (map TtoA Lt2)) /\ v = w ⊗ u)).
    { exists w. split; auto. exists u. auto. }
    rewrite E' in H14.
    destruct H14 as [WFv' Forallv2].
    repeat split; auto.
  - destruct H14 as [WFv [Forallv1 Forallv2]].
    assert (WF_Matrix v /\
     Forall (fun a0 : AType (n + m) => vecSatisfies v (translateA a0))
       (map (uncurry gTensorA)
          (combine (map TtoA Lt1) (map TtoA (repeat (defaultT_I m) (length Lt1)))))) by auto.
    rewrite <- E in H14.
    assert (WF_Matrix v /\
     Forall (fun a0 : AType (n + m) => vecSatisfies v (translateA a0))
       (map (uncurry gTensorA)
          (combine (map TtoA (repeat (defaultT_I n) (length Lt2))) (map TtoA Lt2)))) by auto.
    rewrite <- E' in H15.
    destruct H14 as [w [WFw [u [WFu [[WF_w Forallw] vwu]]]]].
    destruct H15 as [w' [WFw' [u' [WFu' [[WF_u' Forallu'] vw'u']]]]].
    assert (w ⊗ u = w' ⊗ u') by (rewrite vwu in vw'u'; auto).
    destruct (Classical_Prop.classic (v = Zero)).
    + rewrite H15 in *. 
      exists Zero. split; auto with wf_db.
      exists Zero. split; auto with wf_db.
      repeat split; auto with wf_db.
      * rewrite Forall_forall. intros.
        apply vecSatisfies_Zero_l.
      * rewrite Forall_forall. intros.
        apply vecSatisfies_Zero_l.
      * rewrite kron_0_l. auto.
    + rewrite vwu in H15.
      destruct (tensor_nonzero_exists w w' u u' WFw WFu WFw' WFu' H15 H14)
        as [c1 [c2 [c1mult [c2mult c1c2]]]].
      exists w. split; auto with wf_db.
      exists u. repeat split; auto with wf_db.
      rewrite c2mult.
      rewrite Forall_forall. intros x H16.
      rewrite Forall_forall in Forallu'.
      specialize (Forallu' x H16).
      unfold vecSatisfies in *.
      destruct Forallu'.
      split; auto with wf_db.
      unfold Eigenpair in *.
      simpl in *.
      rewrite Mscale_1_l in *.
      rewrite Mscale_mult_dist_r.
      rewrite H18; auto.
Qed.


Inductive separability_precondition {n : nat} (lt : list (TType n)) : Prop :=
| SepPrecond : linearly_independentF2 (transposeF2 (fromLtToCheckMatrixF2 lt)) -> n <> 0%nat ->
    lt <> [] -> Forall proper_length_TType lt -> Forall coef_plus_minus_1 lt ->
    commutingListT lt -> length lt = n -> separability_precondition lt.

Lemma map_combine_TtoA : forall {n m : nat} (Lt1 : list (TType n)) (Lt2 : list (TType m)),
    length Lt1 = length Lt2 ->
    map (uncurry gTensorA) (combine (map TtoA Lt1) (map TtoA Lt2)) =
      map TtoA (map (uncurry gTensorT) (combine Lt1 Lt2)).
Proof. intros n m Lt1 Lt2 H.
  rewrite map_map. unfold TtoA.
  apply nth_ext with (d := (uncurry gTensorA) ([defaultT_I n], [defaultT_I m]))
                     (d' := (fun x : TType n * TType m => [uncurry gTensorT x]) (defaultT_I n, defaultT_I m)).
  rewrite ! map_length, ! combine_length, ! map_length; auto.
  intros n0 H0.
  rewrite map_nth with (d := ([defaultT_I n], [defaultT_I m])).
  rewrite map_nth with (d := (defaultT_I n, defaultT_I m)).
  rewrite ! combine_nth; try rewrite ! map_length; auto.
  rewrite map_nth with (d := defaultT_I n).
  rewrite map_nth with (d := defaultT_I m).
  unfold uncurry. simpl; auto.
Qed.


Lemma separability_proof2' :
  forall (n m : nat) (Lt1 : list (TType n)) (Lt2 : list (TType m)),
    separability_precondition Lt1 -> separability_precondition Lt2 ->
    (forall v : Vector (2 ^ (n + m))%nat,
      (exists w : Vector (2 ^ n)%nat, WF_Matrix w /\ (exists u : Vector (2 ^ m)%nat, WF_Matrix u /\
        vecSatisfiesP w (Cap (map TtoA Lt1)) /\ vecSatisfiesP u (Cap (map TtoA Lt2)) 
                                                                      /\ v = w ⊗ u)) <->
        vecSatisfiesP v (Cap (map TtoA (DiagonalTwice Lt1 Lt2)))).
Proof. intros n m Lt1 Lt2 H0 H1 v.
  unfold DiagonalTwice, ExtendQubitsToLeft, ExtendQubitsToRight.
  rewrite map_app. rewrite <- ! map_combine_TtoA.
  2-3: rewrite repeat_length; auto.
  inversion H0. inversion H1.
  apply separability_proof2; auto.
Qed.

Lemma commutingListT_app : forall {n : nat} (Lt1 Lt2 : list (TType n)),
    commutingListT (Lt1 ++ Lt2) -> commutingListT Lt1 /\ commutingListT Lt2.
Proof. intros n Lt1 Lt2 H0. split.
  - unfold commutingListT in *.
    intros t1 t2 H1 H2.
    assert (In t1 (Lt1 ++ Lt2)).
    { rewrite in_app_iff. left; auto. }
    assert (In t2 (Lt1 ++ Lt2)).
    { rewrite in_app_iff. left; auto. }
    apply H0; auto.
  - unfold commutingListT in *.
    intros t1 t2 H1 H2.
    assert (In t1 (Lt1 ++ Lt2)).
    { rewrite in_app_iff. right; auto. }
    assert (In t2 (Lt1 ++ Lt2)).
    { rewrite in_app_iff. right; auto. }
    apply H0; auto.
Qed.


Lemma separability_precondition_DiagonalTwice_inv : 
  forall {n m : nat} (Lt1 : list (TType n)) (Lt2 : list (TType m)),
    separability_precondition (DiagonalTwice Lt1 Lt2) ->
    n <> 0%nat -> m <> 0%nat -> Lt1 <> [] -> Lt2 <> [] -> length Lt1 = n -> length Lt2 = m ->
    separability_precondition Lt1 /\ separability_precondition Lt2.
Proof. intros n m Lt1 Lt2 H0 H1 H2 H3 H4 H5 H6. 
  split.
  - unfold DiagonalTwice in H0.
    unfold ExtendQubitsToRight, ExtendQubitsToLeft in H0.
    inversion H0. clear H0.
    constructor; auto.
    + assert (properLt1 : Forall proper_length_TType Lt1).
      {  rewrite Forall_app in H10. destruct H10.
         rewrite Forall_forall in H0.
         rewrite Forall_forall. intros x H14.
         specialize (H0 ((uncurry gTensorT) (x, defaultT_I m))).
         assert (In (uncurry gTensorT (x, defaultT_I m))
                   (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1))))).
         { rewrite in_map_iff. exists (x, defaultT_I m). split; auto.
           apply In_nth with (d := defaultT_I n) in H14.
           destruct H14 as [n0 [n0bound nthn0]].
           assert ((repeat (defaultT_I m) (length Lt1)) = (repeat (defaultT_I m) (length (repeat (defaultT_I m) (length Lt1))))).
           { rewrite repeat_length; auto. }
           rewrite repeat_nth in H14.
           specialize (H14 n0).
           rewrite <- nthn0 at 1. rewrite <- H14 at 1.
           rewrite <- combine_nth.
           apply nth_In.
           rewrite combine_length, repeat_length.
           minmax_breakdown. auto.
           rewrite repeat_length. auto. }
         specialize (H0 H15).
         unfold uncurry in H0. simpl in H0.
         destruct H0. unfold defaultT_I in H16.
         destruct x. simpl in H16. rewrite app_length in H16.
         rewrite repeat_length in H16.
         constructor; simpl; auto. lia. }
      assert (properLt2 : Forall proper_length_TType Lt2).
      { rewrite Forall_app in H10. destruct H10.
        rewrite Forall_forall in H10.
        rewrite Forall_forall. intros x H14.
        specialize (H10 ((uncurry gTensorT) (defaultT_I n, x))).
        assert (In (uncurry gTensorT (defaultT_I n, x))
                  (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2))).
        { rewrite in_map_iff. exists (defaultT_I n, x). split; auto.
          apply In_nth with (d := defaultT_I m) in H14.
          destruct H14 as [n0 [n0bound nthn0]].
          assert ((repeat (defaultT_I n) (length Lt2)) = (repeat (defaultT_I n) (length (repeat (defaultT_I n) (length Lt2))))).
          { rewrite repeat_length; auto. }
          rewrite repeat_nth in H14.
          specialize (H14 n0).
          rewrite <- nthn0 at 1. rewrite <- H14 at 1.
          rewrite <- combine_nth.
          apply nth_In.
          rewrite combine_length, repeat_length.
          minmax_breakdown. auto.
          rewrite repeat_length. auto. }
        specialize (H10 H15).
        unfold uncurry in H10. simpl in H10.
        destruct H10. unfold defaultT_I in H16.
        destruct x. simpl in H16. rewrite app_length in H16.
        rewrite repeat_length in H16.
        constructor; simpl; auto. lia. }
      rewrite Forall_app in H10. destruct H10.
      apply linearly_independentF2_transposeF2_fromLtToCheckMatrixF2_app_split in H7;
        auto.
      destruct H7.
      apply @linearly_independentF2_transposeF2_fromLtToCheckMatrixF2_ExtendQubitsToRight with (m := m); auto.
    + rewrite Forall_app in H10. destruct H10.
      rewrite Forall_forall in H0.
      rewrite Forall_forall. intros x H14.
      specialize (H0 ((uncurry gTensorT) (x, defaultT_I m))).
      assert (In (uncurry gTensorT (x, defaultT_I m))
         (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1))))).
      { rewrite in_map_iff. exists (x, defaultT_I m). split; auto.
        apply In_nth with (d := defaultT_I n) in H14.
        destruct H14 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I m) (length Lt1)) = (repeat (defaultT_I m) (length (repeat (defaultT_I m) (length Lt1))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H14.
        specialize (H14 n0).
        rewrite <- nthn0 at 1. rewrite <- H14 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      specialize (H0 H15).
      unfold uncurry in H0. simpl in H0.
      destruct H0. unfold defaultT_I in H16.
      destruct x. simpl in H16. rewrite app_length in H16.
      rewrite repeat_length in H16.
      constructor; simpl; auto. lia.
    + rewrite Forall_app in H11. destruct H11.
      rewrite Forall_forall in H0.
      rewrite Forall_forall. intros x H14.
      specialize (H0 ((uncurry gTensorT) (x, defaultT_I m))).
      assert (In (uncurry gTensorT (x, defaultT_I m))
         (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1))))).
      { rewrite in_map_iff. exists (x, defaultT_I m). split; auto.
        apply In_nth with (d := defaultT_I n) in H14.
        destruct H14 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I m) (length Lt1)) = (repeat (defaultT_I m) (length (repeat (defaultT_I m) (length Lt1))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H14.
        specialize (H14 n0).
        rewrite <- nthn0 at 1. rewrite <- H14 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      specialize (H0 H15).
      unfold uncurry in H0. simpl in H0.
      destruct H0. 
      unfold defaultT_I in H0. destruct x. simpl in H0. rewrite Cmult_1_r in H0. left; auto.
      unfold defaultT_I in H0. destruct x. simpl in H0. rewrite Cmult_1_r in H0. right; auto.
    + assert (H' : Forall proper_length_TType Lt1).
      { rewrite Forall_app in H10. destruct H10.
        rewrite Forall_forall in H0.
        rewrite Forall_forall. intros x H14.
        specialize (H0 ((uncurry gTensorT) (x, defaultT_I m))).
        assert (In (uncurry gTensorT (x, defaultT_I m))
                  (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1))))).
        { rewrite in_map_iff. exists (x, defaultT_I m). split; auto.
          apply In_nth with (d := defaultT_I n) in H14.
          destruct H14 as [n0 [n0bound nthn0]].
          assert ((repeat (defaultT_I m) (length Lt1)) = (repeat (defaultT_I m) (length (repeat (defaultT_I m) (length Lt1))))).
          { rewrite repeat_length; auto. }
          rewrite repeat_nth in H14.
          specialize (H14 n0).
          rewrite <- nthn0 at 1. rewrite <- H14 at 1.
          rewrite <- combine_nth.
          apply nth_In.
          rewrite combine_length, repeat_length.
          minmax_breakdown. auto.
          rewrite repeat_length. auto. }
        specialize (H0 H15).
        unfold uncurry in H0. simpl in H0.
        destruct H0. unfold defaultT_I in H16.
        destruct x. simpl in H16. rewrite app_length in H16.
        rewrite repeat_length in H16.
        constructor; simpl; auto. lia. }
      apply commutingListT_app in H12. destruct H12.
      unfold commutingListT in H0.
      unfold commutingListT. intros t1 t2 H14 H15. 
      specialize (H0 ((uncurry gTensorT) (t1, defaultT_I m)) ((uncurry gTensorT) (t2, defaultT_I m))).
      assert (In (uncurry gTensorT (t1, defaultT_I m))
         (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1))))).
      { rewrite in_map_iff. exists (t1, defaultT_I m). split; auto.
        apply In_nth with (d := defaultT_I n) in H14.
        destruct H14 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I m) (length Lt1)) = (repeat (defaultT_I m) (length (repeat (defaultT_I m) (length Lt1))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H14.
        specialize (H14 n0).
        rewrite <- nthn0 at 1. rewrite <- H14 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      assert (In (uncurry gTensorT (t2, defaultT_I m))
         (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1))))).
      { rewrite in_map_iff. exists (t2, defaultT_I m). split; auto.
        apply In_nth with (d := defaultT_I n) in H15.
        destruct H15 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I m) (length Lt1)) = (repeat (defaultT_I m) (length (repeat (defaultT_I m) (length Lt1))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H15.
        specialize (H15 n0).
        rewrite <- nthn0 at 1. rewrite <- H15 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      specialize (H0 H16 H17).
      unfold uncurry in H0. simpl in H0.
      rewrite Forall_forall in H'.
      apply @commute_T_gTensorT_defaultT_I_right with (m := m); auto.
  - unfold DiagonalTwice in H0.
    unfold ExtendQubitsToRight, ExtendQubitsToLeft in H0.
    inversion H0. clear H0.
    constructor; auto.
    + assert (properLt1 : Forall proper_length_TType Lt1).
      {  rewrite Forall_app in H10. destruct H10.
         rewrite Forall_forall in H0.
         rewrite Forall_forall. intros x H14.
         specialize (H0 ((uncurry gTensorT) (x, defaultT_I m))).
         assert (In (uncurry gTensorT (x, defaultT_I m))
                   (map (uncurry gTensorT) (combine Lt1 (repeat (defaultT_I m) (length Lt1))))).
         { rewrite in_map_iff. exists (x, defaultT_I m). split; auto.
           apply In_nth with (d := defaultT_I n) in H14.
           destruct H14 as [n0 [n0bound nthn0]].
           assert ((repeat (defaultT_I m) (length Lt1)) = (repeat (defaultT_I m) (length (repeat (defaultT_I m) (length Lt1))))).
           { rewrite repeat_length; auto. }
           rewrite repeat_nth in H14.
           specialize (H14 n0).
           rewrite <- nthn0 at 1. rewrite <- H14 at 1.
           rewrite <- combine_nth.
           apply nth_In.
           rewrite combine_length, repeat_length.
           minmax_breakdown. auto.
           rewrite repeat_length. auto. }
         specialize (H0 H15).
         unfold uncurry in H0. simpl in H0.
         destruct H0. unfold defaultT_I in H16.
         destruct x. simpl in H16. rewrite app_length in H16.
         rewrite repeat_length in H16.
         constructor; simpl; auto. lia. }
      assert (properLt2 : Forall proper_length_TType Lt2).
      { rewrite Forall_app in H10. destruct H10.
        rewrite Forall_forall in H10.
        rewrite Forall_forall. intros x H14.
        specialize (H10 ((uncurry gTensorT) (defaultT_I n, x))).
        assert (In (uncurry gTensorT (defaultT_I n, x))
                  (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2))).
        { rewrite in_map_iff. exists (defaultT_I n, x). split; auto.
          apply In_nth with (d := defaultT_I m) in H14.
          destruct H14 as [n0 [n0bound nthn0]].
          assert ((repeat (defaultT_I n) (length Lt2)) = (repeat (defaultT_I n) (length (repeat (defaultT_I n) (length Lt2))))).
          { rewrite repeat_length; auto. }
          rewrite repeat_nth in H14.
          specialize (H14 n0).
          rewrite <- nthn0 at 1. rewrite <- H14 at 1.
          rewrite <- combine_nth.
          apply nth_In.
          rewrite combine_length, repeat_length.
          minmax_breakdown. auto.
          rewrite repeat_length. auto. }
        specialize (H10 H15).
        unfold uncurry in H10. simpl in H10.
        destruct H10. unfold defaultT_I in H16.
        destruct x. simpl in H16. rewrite app_length in H16.
        rewrite repeat_length in H16.
        constructor; simpl; auto. lia. }
      rewrite Forall_app in H10. destruct H10.
      apply linearly_independentF2_transposeF2_fromLtToCheckMatrixF2_app_split in H7;
        auto.
      destruct H7.
      apply @linearly_independentF2_transposeF2_fromLtToCheckMatrixF2_ExtendQubitsToLeft with (n := n); auto.
    + rewrite Forall_app in H10. destruct H10.
      rewrite Forall_forall in H10.
      rewrite Forall_forall. intros x H14.
      specialize (H10 ((uncurry gTensorT) (defaultT_I n, x))).
      assert (In (uncurry gTensorT (defaultT_I n, x))
         (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2))).
      { rewrite in_map_iff. exists (defaultT_I n, x). split; auto.
        apply In_nth with (d := defaultT_I m) in H14.
        destruct H14 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I n) (length Lt2)) = (repeat (defaultT_I n) (length (repeat (defaultT_I n) (length Lt2))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H14.
        specialize (H14 n0).
        rewrite <- nthn0 at 1. rewrite <- H14 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      specialize (H10 H15).
      unfold uncurry in H10. simpl in H10.
      destruct H10. unfold defaultT_I in H16.
      destruct x. simpl in H16. rewrite app_length in H16.
      rewrite repeat_length in H16.
      constructor; simpl; auto. lia.
    + rewrite Forall_app in H11. destruct H11.
      rewrite Forall_forall in H11.
      rewrite Forall_forall. intros x H14.
      specialize (H11 ((uncurry gTensorT) (defaultT_I n, x))).
      assert (In (uncurry gTensorT (defaultT_I n, x))
         (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2))).
      { rewrite in_map_iff. exists (defaultT_I n, x). split; auto.
        apply In_nth with (d := defaultT_I m) in H14.
        destruct H14 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I n) (length Lt2)) = (repeat (defaultT_I n) (length (repeat (defaultT_I n) (length Lt2))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H14.
        specialize (H14 n0).
        rewrite <- nthn0 at 1. rewrite <- H14 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      specialize (H11 H15).
      unfold uncurry in H11. simpl in H11.
      destruct H11. 
      unfold defaultT_I in H11. destruct x. simpl in H11. rewrite Cmult_1_l in H11. left; auto.
      unfold defaultT_I in H11. destruct x. simpl in H11. rewrite Cmult_1_l in H11. right; auto.
    + assert (H' : Forall proper_length_TType Lt2).
      { rewrite Forall_app in H10. destruct H10.
        rewrite Forall_forall in H10.
        rewrite Forall_forall. intros x H14.
        specialize (H10 ((uncurry gTensorT) (defaultT_I n, x))).
        assert (In (uncurry gTensorT (defaultT_I n, x))
                  (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2))).
        { rewrite in_map_iff. exists (defaultT_I n, x). split; auto.
          apply In_nth with (d := defaultT_I m) in H14.
          destruct H14 as [n0 [n0bound nthn0]].
          assert ((repeat (defaultT_I n) (length Lt2)) = (repeat (defaultT_I n) (length (repeat (defaultT_I n) (length Lt2))))).
          { rewrite repeat_length; auto. }
          rewrite repeat_nth in H14.
          specialize (H14 n0).
          rewrite <- nthn0 at 1. rewrite <- H14 at 1.
          rewrite <- combine_nth.
          apply nth_In.
          rewrite combine_length, repeat_length.
          minmax_breakdown. auto.
          rewrite repeat_length. auto. }
        specialize (H10 H15).
        unfold uncurry in H10. simpl in H10.
        destruct H10. unfold defaultT_I in H16.
        destruct x. simpl in H16. rewrite app_length in H16.
        rewrite repeat_length in H16.
        constructor; simpl; auto. lia. }
      apply commutingListT_app in H12. destruct H12.
      unfold commutingListT in H12.
      unfold commutingListT. intros t1 t2 H14 H15. 
      specialize (H12 ((uncurry gTensorT) (defaultT_I n, t1)) ((uncurry gTensorT) (defaultT_I n, t2))).
      assert (In (uncurry gTensorT (defaultT_I n, t1))
         (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2))).
      { rewrite in_map_iff. exists (defaultT_I n, t1). split; auto.
        apply In_nth with (d := defaultT_I m) in H14.
        destruct H14 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I n) (length Lt2)) = (repeat (defaultT_I n) (length (repeat (defaultT_I n) (length Lt2))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H14.
        specialize (H14 n0).
        rewrite <- nthn0 at 1. rewrite <- H14 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      assert (In (uncurry gTensorT (defaultT_I n, t2))
         (map (uncurry gTensorT) (combine (repeat (defaultT_I n) (length Lt2)) Lt2))).
      { rewrite in_map_iff. exists (defaultT_I n, t2). split; auto.
        apply In_nth with (d := defaultT_I m) in H15.
        destruct H15 as [n0 [n0bound nthn0]].
        assert ((repeat (defaultT_I n) (length Lt2)) = (repeat (defaultT_I n) (length (repeat (defaultT_I n) (length Lt2))))).
        { rewrite repeat_length; auto. }
        rewrite repeat_nth in H15.
        specialize (H15 n0).
        rewrite <- nthn0 at 1. rewrite <- H15 at 1.
        rewrite <- combine_nth.
        apply nth_In.
        rewrite combine_length, repeat_length.
        minmax_breakdown. auto.
        rewrite repeat_length. auto. }
      specialize (H12 H16 H17).
      unfold uncurry in H12. simpl in H12.
      rewrite Forall_forall in H'.
      apply @commute_T_gTensorT_defaultT_I_left with (n := n); auto.
Qed.



Fixpoint big_kron_sigT_Vector (Lnw : list {n : nat & Vector (2 ^ n)}) : Vector (2 ^ (fold_right Nat.add 0%nat (map (@projT1 nat (fun n : nat => Vector (2 ^ n))) Lnw))) :=
  match Lnw with
  | [] => I 1
  | nw :: Lnw' => @kron (2^(projT1 nw))%nat 1%nat (2 ^ (fold_right Nat.add 0%nat (map (@projT1 nat (fun n : nat => Vector (2 ^ n))) Lnw')))%nat 1%nat (projT2 nw) (big_kron_sigT_Vector Lnw')
  end.

Lemma WF_big_kron_sigT_Vector : forall (Lnw : list {n : nat & Vector (2 ^ n)}),
  Forall (fun nw : {n : nat & Vector (2 ^ n)} => WF_Matrix (projT2 nw)) Lnw ->
  WF_Matrix (big_kron_sigT_Vector Lnw).
Proof. intros Lnw H0.
  induction Lnw; simpl; auto with wf_db.
  rewrite Forall_cons_iff in H0. destruct H0.
  apply WF_kron; auto.
  rewrite Nat.pow_add_r; auto.
Qed.
#[export] Hint Resolve WF_big_kron_sigT_Vector : wf_db.

Lemma fold_right_add_nonzero : forall (Ln : list nat),
    Forall (fun n : nat => n <> 0%nat) Ln -> Ln <> [] ->
    fold_right Nat.add 0%nat Ln <> 0%nat.
Proof. intros Ln H0 H1.
  induction Ln; try contradiction. clear H1.
  destruct (list_eq_dec Nat.eq_dec Ln []) as [H1 | H1]; subst.
  - inversion H0; subst. simpl. lia.
  - rewrite Forall_cons_iff in H0. destruct H0. simpl.
    specialize (IHLn H2 H1). lia.
Qed.

Lemma separability_proof_n :
  forall (Ln : list nat) (LLT : list (list TTypes)),
    LLT <> [] -> length Ln = length LLT -> 
    Forall (fun n => n <> 0%nat) Ln -> Forall (fun LT => LT <> []) LLT ->
    Forall2 (fun n LT => length LT = n) Ln LLT ->
    separability_precondition (DiagonalQubits Ln LLT) ->
    (forall v : Vector (2 ^ (fold_right Nat.add 0%nat Ln)),
        (exists Lnw : list {n : nat & Vector (2 ^ n)},
            map (@projT1 nat (fun n : nat => Vector (2 ^ n))) Lnw = Ln /\
              Forall (fun nw => @WF_Matrix (2^(projT1 nw))%nat 1%nat (projT2 nw)) Lnw /\
              Forall2 
                (fun nw LT => vecSatisfiesP (projT2 nw) (Cap (map TtoA (map (AssignT (projT1 nw)) LT)))) Lnw LLT /\ 
              v = big_kron_sigT_Vector Lnw) <->
          vecSatisfiesP v (Cap (map TtoA (DiagonalQubits Ln LLT)))).
Proof. intros Ln LLT H0 H1 H2 H3 lenLT H4 v. 
  gen Ln. induction LLT as [| t LLT]; intros; try contradiction.
  destruct Ln; try discriminate.
  destruct (Classical_Prop.classic (LLT = [])).
  - subst. clear H0. destruct Ln; try discriminate. clear H1.
    clear IHLLT. inversion H3; subst. clear H3 H6. 
    inversion H2; subst. clear H2 H6.
    simpl in *. unfold DiagonalTwice in H4.
    rewrite ExtendQubitsToRight_zero, ExtendQubitsToLeft_nil in H4.
    rewrite app_nil_r in H4.
    split; intros.
    + destruct H0 as [Lnw [H1 [H2 [H6 H7]]]].
      destruct Lnw as [| nw]. inversion H1.
      simpl in *. inversion H1. subst. destruct Lnw; try discriminate.
      clear H9. clear H1. inversion H2; subst. clear H2 H8.
      inversion H6; subst. clear H6 H10. destruct H8.
      destruct nw as [n w]. simpl in *.
      replace (n + 0)%nat with n in * by lia.
      split; auto with wf_db. rewrite kron_1_r.
      unfold DiagonalTwice.
      rewrite ExtendQubitsToRight_zero, ExtendQubitsToLeft_nil.
      rewrite app_nil_r. auto.
    + destruct H0.
      unfold DiagonalTwice in H1.
      rewrite ExtendQubitsToRight_zero, ExtendQubitsToLeft_nil in H1.
      rewrite app_nil_r in H1.
      exists [existT (fun n => Vector (2 ^ n)%nat) n v].
      simpl in *. 
      repeat split; repeat constructor; simpl; replace (n + 0)%nat with n in * by lia; auto.
      rewrite kron_1_r. auto.
  - clear H0.
    simpl in H1. apply Nat.succ_inj in H1.
    rewrite Forall_cons_iff in H2. destruct H2.
    rewrite Forall_cons_iff in H3. destruct H3.
    inversion lenLT; subst. clear lenLT. rename H12 into lenLT.
    simpl in H4.
    apply separability_precondition_DiagonalTwice_inv in H4.
    destruct H4.
    specialize (IHLLT H5 H6 Ln H1 H2 lenLT H7).
    2: auto.
    2: { assert (Ln <> []).
         { intro. subst. contradict H5. rewrite <- length_zero_iff_nil. auto. }
         apply fold_right_add_nonzero; auto. }
    2: { intro. contradict H3. apply map_eq_nil in H7. auto. }
    2: { destruct LLT; try contradiction. destruct Ln; try discriminate.
         simpl. unfold DiagonalTwice. unfold ExtendQubitsToRight, ExtendQubitsToLeft.
         intro.
         assert (length (@nil (TType (Nat.add n (@fold_right nat nat Nat.add O Ln)))) <> 0%nat).
         { rewrite <- H7.
           rewrite ! app_length, ! map_length, ! combine_length, ! repeat_length, ! map_length.
           minmax_breakdown.
           rewrite Forall_cons_iff in H6. destruct H6.
           intro. contradict H6. rewrite <- length_zero_iff_nil. lia. }
         simpl in H8. contradiction. }
    2: { rewrite map_length. auto. }
    2: { apply DiagonalQubits_length; auto. }
    split; intros.
    + destruct H8 as [Lnw [H9 [H10 [H11 H12]]]].
      destruct Lnw as [| nw Lnw]; try discriminate.
      rewrite Forall_cons_iff in H10. destruct H10.
      inversion H11; subst. destruct nw as [m w]. clear H11.
      inversion H9. subst m. clear H9. rewrite ! H13 in *.
      simpl in *. destruct H16.
      split. 
      * apply WF_kron; auto. rewrite ! H13. rewrite Nat.pow_add_r; auto.
        auto with wf_db.
      * assert (Forall
    (fun a0 : AType (length t + fold_right Nat.add 0%nat Ln) =>
     vecSatisfies (w ⊗ big_kron_sigT_Vector Lnw) (translateA a0))
    (map TtoA (DiagonalTwice (map (AssignT (length t)) t) (DiagonalQubits Ln LLT))) <->
                  vecSatisfiesP (w ⊗ big_kron_sigT_Vector Lnw) 
                                (Cap (map TtoA (DiagonalTwice (map (AssignT (length t)) t) (DiagonalQubits Ln LLT))))).
        { simpl. split; intros; try split.
          - apply WF_kron; auto. rewrite ! H13. rewrite Nat.pow_add_r; auto.
            auto with wf_db.
          - rewrite ! H13 in *. rewrite Nat.pow_add_r in *. auto.
          - destruct H12. rewrite ! H13 in *. rewrite Nat.pow_add_r in *. auto. }
         rewrite ! H13 in *. rewrite Nat.pow_add_r in *. rewrite H12. clear H12.
        rewrite <- separability_proof2'; auto.
        specialize (IHLLT (big_kron_sigT_Vector Lnw)).
        assert (exists Lnw0 : list {n : nat & Vector (2 ^ n)},
             map (projT1 (P:=fun n : nat => Vector (2 ^ n))) Lnw0 = Ln /\
             Forall (fun nw : {n : nat & Vector (2 ^ n)} => WF_Matrix (projT2 nw))
               Lnw0 /\
             Forall2
               (fun (nw : {n : nat & Vector (2 ^ n)}) (LT : list TTypes) =>
                WF_Matrix (projT2 nw) /\
                Forall
                  (fun a0 : AType (projT1 nw) =>
                   vecSatisfies (projT2 nw) (translateA a0))
                  (map TtoA (map (AssignT (projT1 nw)) LT))) Lnw0 LLT /\
             big_kron_sigT_Vector Lnw = big_kron_sigT_Vector Lnw0).
        { exists Lnw. repeat split; auto. }
        rewrite IHLLT in H12.
        destruct H12.
        exists w. split; auto. exists (big_kron_sigT_Vector Lnw). repeat split; auto.
    + simpl in H8. destruct H8.
      assert (vecSatisfiesP v
                (Cap (map TtoA (DiagonalTwice (map (AssignT (length t)) t) (DiagonalQubits Ln LLT))))) by (simpl; auto).
      rewrite <- separability_proof2'
        with (Lt1 := map (AssignT (length t)) t)
             (Lt2 := DiagonalQubits Ln LLT)
        in H10; auto.
      destruct H10 as [w [H10 [u [H11 [H12 [H13 H14]]]]]].
      specialize (IHLLT u).
      remember H13 as H13'. clear HeqH13'.
      rewrite <- IHLLT in H13'.
      destruct H13' as [Lnw [H15 [H16 [H17 H18]]]].
      exists ((existT (fun n => Vector (2 ^ n)%nat) (length t) w) :: Lnw). repeat split; simpl; auto.
      rewrite ! H15 in *. auto.
      subst. auto.
Qed.


Lemma vecSatisfiesP_DiagonalQubits_CapSep : 
  forall (Ln Perm : list nat) (LLT : list (list TTypes)) (v : Vector (2 ^ (fold_right Nat.add 0%nat Ln))),
    Permutation (List.seq 0%nat (fold_right Nat.add 0%nat Ln)) Perm ->
     vecSatisfiesP v (Cap (map TtoA (DiagonalQubits Ln LLT))) -> 
    vecSatisfiesP ((perm_to_matrix (fold_right Nat.add 0%nat Ln) (perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))) × v) (Sep (Ln, LLT, Perm)). 
Proof. intros Ln Perm LLT v PermPerm H0. 
  destruct H0.
  split; auto with wf_db.
  rewrite Forall_forall in *.
  intros x H2. simpl in H2.
  assert (In (TtoA x) (map TtoA (DiagonalQubits Ln LLT))).
  { rewrite in_map_iff. exists x. auto. }
  specialize (H1 (TtoA x) H3).
  unfold TtoA, translateA in H1.
  simpl in H1. rewrite Mplus_0_l in H1.
  unfold vecSatisfies in *.
  destruct H1.
  split; auto with wf_db.
  unfold Eigenpair in *. simpl in *. rewrite Mscale_1_l in *.
  rewrite ! Mmult_assoc.
  f_equal.
  setoid_rewrite <- Mmult_assoc at 2.
  pose (perm_to_matrix_unitary (fold_right Nat.add 0%nat Ln) (perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))) as U.
  assert (permutation (fold_right Nat.add 0%nat Ln)
            (perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))).
  { apply perm_inv_permutation. 
    apply Permutation_sym in PermPerm.
    apply Permutation_permutation_seq; auto. }
  specialize (U H5).
  destruct U.
  rewrite H7, Mmult_1_l; auto.
Qed.


Lemma vecSatisfiesP_DiagonalQubits_SepCap : 
  forall (Ln_LLT_Perm : (list nat) * (list (list TTypes)) * (list nat)) (v : Vector (2 ^ (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))))),
    Forall proper_length_TType (DiagonalQubits (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm))) ->
    Permutation (List.seq 0%nat (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm)))) (snd Ln_LLT_Perm) ->
    vecSatisfiesP v (Sep Ln_LLT_Perm) ->
    vecSatisfiesP ((perm_to_matrix (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) (perm_inv (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) (to_fun 0%nat (snd Ln_LLT_Perm))))† × v) (Cap (map TtoA (DiagonalQubits (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm))))).
Proof. intros Ln_LLT_Perm v H0 H1 H2.
  simpl in *. destruct H2.
  split; auto with wf_db.
  rewrite Forall_forall in *.
  intros x H4.
  rewrite in_map_iff in H4.
  destruct H4 as [x0 [x0x inx0]].
  specialize (H3 x0 inx0).
  unfold vecSatisfies in *.
  destruct H3.
  split; auto with wf_db.
  unfold Eigenpair in *. simpl in *.
  rewrite Mscale_1_l in *.
  subst. unfold TtoA, translateA in *. simpl in *.
  rewrite Mplus_0_l.
  apply (Mmult_inj_l (adjoint
           (perm_to_matrix (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm)))
              (perm_inv (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm)))
                 (to_fun 0%nat (snd Ln_LLT_Perm)))))) in H4.
  rewrite <- ! Mmult_assoc in H4. rewrite <- ! Mmult_assoc.
  pose (perm_to_matrix_unitary (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) (perm_inv (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) (to_fun 0%nat (snd Ln_LLT_Perm)))) as U.
  assert (permutation (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm)))
            (perm_inv (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) (to_fun 0%nat (snd Ln_LLT_Perm)))).
  { apply perm_inv_permutation. 
    apply Permutation_sym in H1.
    apply Permutation_permutation_seq; auto. }
  specialize (U H5).
  destruct U.
  rewrite H7 in H4.
  rewrite Mmult_1_l in H4; auto.
  apply WF_translate.
  apply H0; auto.
Qed.



(*

Lemma separability_proof_n :
  forall (Ln : list nat) (LLT : list (list TTypes)),
    LLT <> [] -> length Ln = length LLT -> 
    Forall (fun n => n <> 0%nat) Ln -> Forall (fun LT => LT <> []) LLT ->
    separability_precondition (DiagonalQubits Ln LLT) ->
    (forall v : Vector (2 ^ (fold_right Nat.add 0%nat Ln)),
        (exists Lnw : list {n : nat & Vector (2 ^ n)},
            map (@projT1 nat (fun n : nat => Vector (2 ^ n))) Lnw = Ln /\
              Forall (fun nw => @WF_Matrix (2^(projT1 nw))%nat 1%nat (projT2 nw)) Lnw /\
              Forall2 
                (fun nw LT => vecSatisfiesP (projT2 nw) (Cap (map TtoA (map (AssignT (projT1 nw)) LT)))) Lnw LLT /\ 
              v = big_kron_sigT_Vector Lnw) <->
          vecSatisfiesP v (Cap (map TtoA (DiagonalQubits Ln LLT)))).


*)




(** ** Hoare triples ** **)

Definition triple {n} (A : Predicate n) (g : prog) (B : Predicate n) :=
  forall (v : Vector (2 ^ n)), vecSatisfiesP v A -> vecSatisfiesP ((translate_prog n g) × v) B.

Notation "{{ A }} g {{ B }}" := (triple A g B) (at level 70, no associativity).


(** *** Heisenberg semantics should work for ATypes. *)
Lemma Eigenvector_Heisenberg_semantics {n} (a b : AType n) (g : prog) :
  proper_length_AType_nil a -> proper_length_AType_nil b ->
  WF_Unitary (translateA a) -> (translateA a) † = translateA a -> trace (translateA a) = 0 ->
  WF_Unitary (translateA b) -> (translateA b) † = translateA b -> trace (translateA b) = 0 ->
   {{ a }} g {{ b }} ->
  ((translate_prog n g) × translateA a = translateA b × (translate_prog n g)).
Proof. intros Pa Pb Ua Ha Ta Ub Hb Tb Triple.
  unfold triple in Triple.
  unfold vecSatisfiesP in Triple.

  assert (WFU_g : WF_Unitary (translate_prog n g)).
  { apply unit_prog. }
  
  (*
  specialize (Unitary_Hermitian_trace_zero_eigenvalues_plus_minus_1 (translateA a) Ua Ha Ta); intros [UA [DA [WFDDA [WFUUA [SpecA [traceDA0 EigenA]]]]]].
  specialize (Unitary_Hermitian_trace_zero_eigenvalues_plus_minus_1 (translateA b) Ub Hb Tb); intros [UB [DB [WFDDB [WFUUB [SpecB [traceDB0 EigenB]]]]]].
  *)
  
  specialize (Unitary_Hermitian_trace_zero_index_split (translateA a) Ua Ha Ta);
    intros [plus1idxA [minus1idxA [UA [DA [PermA [equal_len_A [WFDDA [WFUUA [SpecA [traceDA0 [Eigen_plus1_A Eigen_minus1_A]]]]]]]]]]].
 
  specialize (Unitary_Hermitian_trace_zero_index_split (translateA b) Ub Hb Tb);
    intros [plus1idxB [minus1idxB [UB [DB [PermB [equal_len_B [WFDDB [WFUUB [SpecB [traceDB0 [Eigen_plus1_B Eigen_minus1_B]]]]]]]]]]].


  assert (plusA_Eigen : forall x : nat, In x plus1idxA -> Eigenpair (translateA b) (translate_prog n g × UA × e_i x, C1)).
  { intros.
    specialize (Eigen_plus1_A x H0).
    unfold vecSatisfies in Triple.
     assert (WF_Matrix (UA × e_i x) /\ Eigenpair (translateA a) (UA × e_i x, C1)).
    { destruct WFUUA. split; auto with wf_db. }
    specialize (Triple (UA × e_i x) H1).
    destruct Triple.
    rewrite Mmult_assoc.
    easy. }

(* U maps the -1-eigenspace of P precisely "onto" the -1-eigenspace of Q:
        1. since { U v1, U v2, ..., U vn } "spans" the +1 eigenspace of Q,
            and since the linear combination of +1 eigenspace and -1 eigenspace 
                    spans the 'whole' space
            and since { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } forms an orthonormal basis,
            { U w1, U w2, ..., U wn } "spans" the 'whole' -1 eigenspace of Q.


            (* WRONG *)
            ( Let u be a -1 eigenvector of Q. Then Q u = - u  and 
              u = a1 U v1 + ... + an U vn + b1 U w1 + ... + bn U wn  and
              Qu = - u = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).
              Then 0 = u - u = (b1 U w1 + ... + bn U wn) + Q (b1 U w1 + ... + bn U wn)  so
              Q (b1 U w1 + ... + bn U wn) = - (b1 U w1 + ... + bn U wn).
              Then u = - (a1 U v1 + ... + an U vn) + (b1 U w1 + ... + bn U wn)  and so
              2 u = 2 (b1 U w1 + ... + bn U wn)  which gives
              u = b1 U w1 + ... + bn U wn. )

              2. since { U w1, U w2, ..., U wn } "spans" the 'whole' -1 eigenspace
                  and since the dimension of { U w1, U w2, ..., U wn } and -1 eigenspace are equal
                  { U w1, U w2, ..., U wn } is a basis of the -1 eigenspace of Q
                  
               3. U wi is an -1 eigenvector of Q 
*)
  assert (total_length_idxA : length (plus1idxA ++ minus1idxA) = (2 ^ n)%nat).
  { apply Permutation_length in PermA.
    rewrite seq_length in PermA.
    assumption. }

  assert (total_length_idxB : length (plus1idxB ++ minus1idxB) = (2 ^ n)%nat).
  { apply Permutation_length in PermB.
    rewrite seq_length in PermB.
    assumption. }

  assert (spans_whole_space_A : forall (v : Vector n),
             @WF_Matrix (2 ^ n) 1 v ->
             v = matrix_column_choose
                   (plus1idxA ++ minus1idxA)
                   UA
                   × (vector_row_choose
                        (plus1idxA ++ minus1idxA)
                        ((UA)† × v))).
  { intros.
    destruct WFUUA as [WFUA UUA].
    rewrite matrix_column_choose_vector_row_choose_original.
    - apply Minv_flip in UUA; auto with wf_db.
      rewrite <- Mmult_assoc.
      rewrite UUA.
      rewrite Mmult_1_l; auto with wf_db.
    - auto with wf_db.
    - apply Permutation_sym; auto. }
  
  assert (spans_whole_space_B : forall (v : Vector n),
             @WF_Matrix (2 ^ n) 1 v ->
             v = matrix_column_choose
                   (plus1idxA ++ minus1idxA)
                   (translate_prog n g × UA)
                   × (vector_row_choose
                        (plus1idxA ++ minus1idxA)
                        ((translate_prog n g × UA)† × v))).
  { intros.
    rewrite matrix_column_choose_vector_row_choose_original.
    - rewrite Mmult_adjoint.
      assert ((@Mmult (Nat.pow (Datatypes.S (Datatypes.S O)) n)
       (Nat.pow (Datatypes.S (Datatypes.S O)) n) (Datatypes.S O)
       (@Mmult (Nat.pow (Datatypes.S (Datatypes.S O)) n)
          (Nat.pow (Datatypes.S (Datatypes.S O)) n)
          (Nat.pow (Datatypes.S (Datatypes.S O)) n) (translate_prog n g) UA)
       (@Mmult (Nat.pow (Datatypes.S (Datatypes.S O)) n)
          (Nat.pow (Datatypes.S (Datatypes.S O)) n) (Datatypes.S O)
          (@Mmult (Nat.pow (Datatypes.S (Datatypes.S O)) n)
             (Nat.pow (Datatypes.S (Datatypes.S O)) n)
             (Nat.pow (Datatypes.S (Datatypes.S O)) n)
             (@adjoint (Nat.pow (Datatypes.S (Datatypes.S O)) n)
                (Nat.pow (Datatypes.S (Datatypes.S O)) n) UA)
             (@adjoint (Nat.pow (Datatypes.S (Datatypes.S O)) n)
                (Nat.pow (Datatypes.S (Datatypes.S O)) n) 
                (translate_prog n g))) v)) =
                (translate_prog n g × (UA × (UA) †) × (translate_prog n g) †) × v).
      { rewrite ! Mmult_assoc. easy. }
      rewrite H1.
      destruct WFUUA as [WFUA UUA].
      destruct WFU_g as [WF_g U_g].
      apply Minv_flip in UUA; auto with wf_db.
      rewrite UUA.
      rewrite Mmult_1_r; auto with wf_db.
      apply Minv_flip in U_g; auto with wf_db.
      rewrite U_g.
      rewrite Mmult_1_l; auto with wf_db.
    - destruct WFUUA as [WFUA UUA].
      destruct WFU_g as [WF_g U_g].
      auto with wf_db.
    - apply Permutation_sym in PermA. easy. }
  
  assert (spans_whole_space_idxB : forall (v : Vector n),
             @WF_Matrix (2 ^ n) 1 v ->
             v = matrix_column_choose
                   (plus1idxB ++ minus1idxB)
                   UB
                   × (vector_row_choose
                        (plus1idxB ++ minus1idxB)
                        ((UB)† × v))).
  { intros.
    destruct WFUUB as [WFUB UUB].
    rewrite matrix_column_choose_vector_row_choose_original.
    - apply Minv_flip in UUB; auto with wf_db.
      rewrite <- Mmult_assoc.
      rewrite UUB.
      rewrite Mmult_1_l; auto with wf_db.
    - auto with wf_db.
    - apply Permutation_sym; auto. }
(** u = b1 U w1 + ... + bn U wn
       = U A α

(U A)† u = α 
bi = α [i]
     *)

  assert (half_length_idxA : length (minus1idxA) = (2 ^ (n-1))%nat).
  { rewrite app_length in total_length_idxA.
    rewrite equal_len_A in total_length_idxA.
    assert (H' : (2 ^ n = 2 * (2 ^ (n - 1)))%nat).
    { setoid_rewrite <- Nat.pow_1_r at 7.
      rewrite <- Nat.pow_add_r.
      assert (H' : (1 + (n - 1) = n)%nat).
      { simpl.
        rewrite Nat.sub_1_r.
        rewrite Nat.succ_pred; try easy.
        destruct Pa as [ | t a Pt Pa].
        - unfold translateA in Ua. simpl in Ua.
          apply zero_not_unitary in Ua. contradiction.
        - destruct Pt as [n_nonzero length_snd_t_is_n].
          replace (1 + (n - 1))%nat with ((n - 1) + 1)%nat by lia.
          assumption. }
      rewrite H'. reflexivity. }
    rewrite H' in total_length_idxA.
    lia. }

  assert (half_length_idxB : length (minus1idxB) = (2 ^ (n-1))%nat).
  { rewrite app_length in total_length_idxB.
    rewrite equal_len_B in total_length_idxB.
    assert (H' : (2 ^ n = 2 * (2 ^ (n - 1)))%nat).
    { setoid_rewrite <- Nat.pow_1_r at 7.
      rewrite <- Nat.pow_add_r.
      assert (H' : (1 + (n - 1) = n)%nat).
      { simpl.
        rewrite Nat.sub_1_r.
        rewrite Nat.succ_pred; try easy.
        destruct Pb as [ | t b Pt Pb].
        - unfold translateA in Ub. simpl in Ub.
          apply zero_not_unitary in Ub. contradiction.
        - destruct Pt as [n_nonzero length_snd_t_is_n].
          replace (1 + (n - 1))%nat with ((n - 1) + 1)%nat by lia.
          assumption. }
      rewrite H'. reflexivity. }
    rewrite H' in total_length_idxB.
    lia. }

  assert (NoDup_plus1_minus1_idxA : NoDup (plus1idxA ++ minus1idxA)).
  { apply Permutation_NoDup with (l := List.seq 0 (2 ^ n)).
    - apply Permutation_sym; trivial.
    - apply seq_NoDup. }

  assert (NoDup_plus1_idxA : NoDup plus1idxA).
  { apply NoDup_app_remove_r in NoDup_plus1_minus1_idxA; trivial. }

  assert (NoDup_minus1_idxA : NoDup minus1idxA).
  { apply NoDup_app_remove_l in NoDup_plus1_minus1_idxA; trivial. }

  assert (NoDup_plus1_minus1_idxB : NoDup (plus1idxB ++ minus1idxB)).
  { apply Permutation_NoDup with (l := List.seq 0 (2 ^ n)).
    - apply Permutation_sym; trivial.
    - apply seq_NoDup. }

  assert (NoDup_plus1_idxB : NoDup plus1idxB).
  { apply NoDup_app_remove_r in NoDup_plus1_minus1_idxB; trivial. }

  assert (NoDup_minus1_idxB : NoDup minus1idxB).
  { apply NoDup_app_remove_l in NoDup_plus1_minus1_idxB; trivial. }


  (** here for reference **)
  (* <Q (U A α) = (U A α') :: use if then else to split the multiplication in the Matrix > *)
    (** spans_minus_one_space *)
    (* 
      (* WRONG *)
    ( Let u be a -1 eigenvector of Q. Then Q u = - u  and 
              u* = a1 U v1 + ... + an U vn + b1 U w1 + ... + bn U wn  and
<done>
              Qu = - u** = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).
              Then 0 = u - u = (b1 U w1 + ... + bn U wn) + Q (b1 U w1 + ... + bn U wn)  so
              Q (b1 U w1 + ... + bn U wn) = - (b1 U w1 + ... + bn U wn).
              Then u = - (a1 U v1 + ... + an U vn) + (b1 U w1 + ... + bn U wn)  and so
              2 u = 2 (b1 U w1 + ... + bn U wn)  which gives
              u = b1 U w1 + ... + bn U wn. ) *)

   (*** Not needed? ***)
(*  assert (spans_minus_one_space_B : forall (v : Vector (2 ^ n)),
             Eigenpair (translateA b) (v, Copp C1) -> @WF_Matrix (2^n)%nat 1 v ->  
               v = matrix_column_choose
                     minus1idxA
                     (translate_prog n g × UA)
                     × (vector_row_choose minus1idxA ((translate_prog n g × UA)† × v))).
  { unfold Eigenpair. simpl. 
    intros v H0 H1. 

    specialize (spans_whole_space_B v H1).
    
    remember spans_whole_space_B as v_is. clear Heqv_is.

    rewrite matrix_column_choose_vector_row_choose_app_split in v_is.
    all : try (destruct WFU_g as [WF_g U_g];
               destruct WFUUA as [WFUA UUA];
               auto with wf_db).

    
    setoid_rewrite matrix_column_choose_pop_square_id in v_is.
    setoid_rewrite vector_row_choose_matrix_column_choose in v_is.
    

    assert (H2: @Mplus (2 ^ n) 1 (translate_prog n g × UA × matrix_column_choose plus1idxA (I (2 ^ n))
              × ((matrix_column_choose plus1idxA (I (2 ^ n))) ⊤
                   × ((translate_prog n g × UA) † × v)))
               (translate_prog n g × UA × matrix_column_choose minus1idxA (I (2 ^ n))
              × ((matrix_column_choose minus1idxA (I (2 ^ n))) ⊤
                   × ((translate_prog n g × UA) † × v))) =
              translate_prog n g × UA × (matrix_column_choose plus1idxA (I (2 ^ n))
                × (matrix_column_choose plus1idxA (I (2 ^ n))) ⊤)
                     × ((translate_prog n g × UA) † × v)
                .+ translate_prog n g × UA × (matrix_column_choose minus1idxA (I (2 ^ n))
                × (matrix_column_choose minus1idxA (I (2 ^ n))) ⊤)
                × ((translate_prog n g × UA) † × v)).
    { rewrite ! Mmult_assoc. easy. }
    rewrite H2 in v_is.
    clear H2.
    
    rewrite ! matrix_column_choose_selective_diagonal in v_is.
    
    remember v_is as v_is'. clear Heqv_is'.

    apply eigenpair_to_selective_diagonal' in plusA_Eigen.
                  
    apply @Mmult_inj_l with (i := (2^n)%nat) (j := (2^n)%nat) (m := translateA b) in v_is.
    rewrite H0 in v_is.
    rewrite Mmult_plus_distr_l in v_is.
    rewrite <- ! Mmult_assoc in v_is.
    all : auto with wf_db.

    rewrite <- ! Mmult_assoc in plusA_Eigen.
    rewrite plusA_Eigen in v_is.
    rewrite Mscale_1_l in v_is.

    apply Mscale_inj with (c := Copp C1) in v_is.
    replace (- C1 .* (- C1 .* v)) with v in v_is by lma'; auto with wf_db.
    
    pose (Mplus_double_side _ _ _ _ v_is v_is') as e.
    replace (v .+ v) with (2 .* v) in e by lma'.

    rewrite matrix_column_choose_vector_row_choose_app_split in spans_whole_space_B.

    admit. all: auto with wf_db. } *)

  
(** 
    In x plus1idxA ->
       Eigenpair (translateA b) (translate_prog n g × UA × e_i x, C1)
                 
         ( forall x,  In x indices_list -> Eigenpair (M1) (M2 × e_i x, c) )
       -> M1 M2 e_i x = c M2 e_i x
       -> M1 M2 selective_diagonal n indices_list = c M2 selective_diagonal n indices_list
     *)
    (*** is there a good way to express v_is ?? *)

    

    
    (** the following may be redundant if we can figure it out in the above *)
    (*
    unfold matrix_column_choose.
    unfold list_vector_to_matrix.
    unfold vector_row_choose.

    unfold Mmult at 1.

    rewrite ! half_length.
    do 2 (apply functional_extensionality; intros).
    
     assert (Zero_equals: Zero = (fun i0 : nat => get_vec i0 (translate_prog n g × UA)) (2 ^ n)%nat).
      { simpl.
        remember WFU_g as WFg.  clear HeqWFg.
        remember WFUUA as WFUA. clear HeqWFUA.
        destruct WFg as [WFg Ug].
        destruct WFUA as [WFUA UUA].
        unfold WF_Matrix in WFg, WFUA.
        unfold Mmult. unfold get_vec.
        do 2 (apply functional_extensionality; intros).
        bdestruct_all. 2: easy.
        rewrite big_sum_0. 1: easy.
        intros x'. specialize (WFUA x' (2 ^ n)%nat).
        assert (precond : (x' >= 2 ^ n)%nat \/ (2 ^ n >= 2 ^ n)%nat). 1: right; lia.
        specialize (WFUA precond).
        rewrite WFUA.
        lca. }
      rewrite Zero_equals.
      
      assert (H' : (fun y : nat =>
                 nth y
                   (map
                      (fun i0 : nat => get_vec i0 (translate_prog n g × UA))
                      minus1idxA)
                   (get_vec (2 ^ n) (translate_prog n g × UA))
                   x 0%nat *
                   (@Mmult (2^n)%nat (2^n)%nat 1 (translate_prog n g × UA) † v)
                     (nth y minus1idxA 0%nat) x0) =
                (fun y : nat =>
                   get_vec
                     (nth y minus1idxA (2 ^ n)%nat)
                     (translate_prog n g × UA)
                     x 0%nat *
                     (@Mmult (2^n)%nat (2^n)%nat 1 (translate_prog n g × UA) † v)
                       (nth y minus1idxA 0%nat) x0)).
      { apply functional_extensionality; intros.
        rewrite map_nth with (d := (2 ^ n)%nat) (f := (fun i0 : nat => get_vec i0 (translate_prog n g × UA))) (l := minus1idxA).
        easy. }
      rewrite H'.

      
      admit. } *)

    

(** here for reference **)
  (* <Q (U A α) = (U A α') :: use if then else to split the multiplication in the Matrix > *)
             (** spans_minus_one_space *)


    (* WRONG *)
    (* ( Let u be a -1 eigenvector of Q. Then Q u = - u  and 
              u = a1 U v1 + ... + an U vn + b1 U w1 + ... + bn U wn  and
              Qu = - u = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).
              Then 0 = u - u = (b1 U w1 + ... + bn U wn) + Q (b1 U w1 + ... + bn U wn)  so
              Q (b1 U w1 + ... + bn U wn) = - (b1 U w1 + ... + bn U wn).
              Then u = - (a1 U v1 + ... + an U vn) + (b1 U w1 + ... + bn U wn)  and so
              2 u = 2 (b1 U w1 + ... + bn U wn)  which gives
              u = b1 U w1 + ... + bn U wn. ) *)


  
(* assert (spans_minus_one_space : forall (v : Vector n),
             Eigenpair (translateA b) (v, Copp C1) -> 
             exists list_coef : list C,
             v =
               fold_left Mplus
                 (map (uncurry Matrix.scale)
                    (combine list_coef
                       (map (fun i : nat => @Mmult (2^n) (2^n) 1 (translate_prog n g × UA) (e_i i))
                          minus1idxA)))
                 Zero).
  { intros.
    pose (coef := map (fun (i:nat) => (@Mmult (2^n) (2^n) 1
                                   (@Mmult (2^n) (2^n) (2^n) (translate_prog n g) UA)†
                                   v) i 0%nat) 
                   minus1idxA).
    exists coef. unfold coef.
    
    admit. } *)


  
(** non-working old version
Lemma spans_whole_space {n} (P : Vector n -> Prop) (l : list (Vector n)) :
  forall v, P v -> exists list_coef, v = fold_left Mplus (map (uncurry Matrix.scale) (zipWith pair list_coef l)) Zero. Admitted. *)

  assert (spans_whole_space_Eigen_A : forall v : Vector (2 ^ n)%nat, WF_Matrix v ->
           exists w1 w2 : Vector (2 ^ n)%nat, WF_Matrix w1 /\ WF_Matrix w2 /\
             (translateA a) × w1 = w1 /\ (translateA a) × w2 = (Copp C1) .* w2 /\
               v = w1 .+ w2).
  { intros.
    apply eigenpair_to_selective_diagonal'' in Eigen_plus1_A.
    apply eigenpair_to_selective_diagonal'' in Eigen_minus1_A.
    specialize (spans_whole_space_A v H0).

    rewrite matrix_column_choose_vector_row_choose_selective_diagonal in spans_whole_space_A.
    rewrite selective_diagonal_app_split in spans_whole_space_A.
    rewrite ! Mmult_plus_distr_l, ! Mmult_plus_distr_r in spans_whole_space_A.
    rewrite Mscale_1_l in Eigen_plus1_A.
    apply @Mmult_inj_r with (k := 1%nat) (m := v) in Eigen_plus1_A.
    rewrite <- ! Mmult_assoc in spans_whole_space_A.
    exists (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v).
    exists (UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v).
    rewrite <- ! Mmult_assoc.
    rewrite Eigen_plus1_A.
    rewrite Eigen_minus1_A.
    split; auto with wf_db.
    split; auto with wf_db.
    split; trivial.
    split; distribute_scale; trivial.
    all : auto with wf_db. }

  assert (spans_whole_space_Eigen_B : forall v : Vector (2 ^ n)%nat, WF_Matrix v ->
           exists w1 w2 : Vector (2 ^ n)%nat, WF_Matrix w1 /\ WF_Matrix w2 /\
             (translateA b) × w1 = w1 /\ (translateA b) × w2 = (Copp C1) .* w2 /\
               v = w1 .+ w2).
  { intros.
    apply eigenpair_to_selective_diagonal'' in Eigen_plus1_B.
    apply eigenpair_to_selective_diagonal'' in Eigen_minus1_B.
    specialize (spans_whole_space_idxB v H0).

    rewrite matrix_column_choose_vector_row_choose_selective_diagonal in spans_whole_space_idxB.
    rewrite selective_diagonal_app_split in spans_whole_space_idxB.
    rewrite ! Mmult_plus_distr_l, ! Mmult_plus_distr_r in spans_whole_space_idxB.
    rewrite Mscale_1_l in Eigen_plus1_B.
    apply @Mmult_inj_r with (k := 1%nat) (m := v) in Eigen_plus1_B.
    rewrite <- ! Mmult_assoc in spans_whole_space_idxB.
    exists (UB × selective_diagonal (2 ^ n) plus1idxB × (UB) † × v).
    exists (UB × selective_diagonal (2 ^ n) minus1idxB × (UB) † × v).
    rewrite <- ! Mmult_assoc.
    rewrite Eigen_plus1_B.
    rewrite Eigen_minus1_B.
    split; auto with wf_db.
    split; auto with wf_db.
    split; trivial.
    split; distribute_scale; trivial.
    all : auto with wf_db. }


  assert (plus1space_orth_is_minus1space_A : forall v : Vector (2 ^ n),
             WF_Matrix v -> 
             ((forall w : Vector (2 ^ n), WF_Matrix w -> (translateA a) × w = w ->
                                    inner_product w v = 0) <->
              (translateA a) × v = (Copp C1) .* v)).
  { intros.
    split; intros.
    - specialize (spans_whole_space_Eigen_A v H0).
      destruct spans_whole_space_Eigen_A as [w1 [w2 [H2 [H3 [H4 [H5 H6]]]]]].
      specialize (H1 w1 H2 H4).
      rewrite H6 in H1.
      rewrite inner_product_plus_r in H1.
      assert (inner_product w1 w2 = 0).
      { apply Hermitian_different_eigenvalue_orthogonal_eigenvector
          with (M := translateA a) (c1 := C1) (c2 := Copp C1); auto with wf_db.
        + intro. inversion H7. lra.
        + rewrite Mscale_1_l. assumption. }
      rewrite H7 in H1.
      rewrite Cplus_0_r in H1.
      rewrite inner_product_zero_iff_zero in H1.
      rewrite H1 in H6.
      rewrite Mplus_0_l in H6.
      rewrite H6.
      all: assumption.
    - apply Hermitian_different_eigenvalue_orthogonal_eigenvector
        with (M := translateA a) (c1 := C1) (c2 := Copp C1); auto with wf_db.
      + intro. inversion H4. lra.
      + rewrite Mscale_1_l. assumption. }
  
  assert (plus1space_orth_is_minus1space_B : forall v : Vector (2 ^ n),
             WF_Matrix v -> 
             ((forall w : Vector (2 ^ n), WF_Matrix w -> (translateA b) × w = w ->
                                    inner_product w v = 0) <->
              (translateA b) × v = (Copp C1) .* v)).
  { intros.
    split; intros.
    - specialize (spans_whole_space_Eigen_B v H0).
      destruct spans_whole_space_Eigen_B as [w1 [w2 [H2 [H3 [H4 [H5 H6]]]]]].
      specialize (H1 w1 H2 H4).
      rewrite H6 in H1.
      rewrite inner_product_plus_r in H1.
      assert (inner_product w1 w2 = 0).
      { apply Hermitian_different_eigenvalue_orthogonal_eigenvector
          with (M := translateA b) (c1 := C1) (c2 := Copp C1); auto with wf_db.
        + intro. inversion H7. lra.
        + rewrite Mscale_1_l. assumption. }
      rewrite H7 in H1.
      rewrite Cplus_0_r in H1.
      rewrite inner_product_zero_iff_zero in H1.
      rewrite H1 in H6.
      rewrite Mplus_0_l in H6.
      rewrite H6.
      all: assumption.
    - apply Hermitian_different_eigenvalue_orthogonal_eigenvector
        with (M := translateA b) (c1 := C1) (c2 := Copp C1); auto with wf_db.
      + intro. inversion H4. lra.
      + rewrite Mscale_1_l. assumption. }

  assert (spans_plus_one_space_idxB : forall (v : Vector (2 ^ n)),
             Eigenpair (translateA b) (v, C1) -> @WF_Matrix (2^n)%nat 1 v ->  
             v = matrix_column_choose plus1idxB UB
                   × (vector_row_choose plus1idxB ((UB)† × v))).
  { intros. unfold Eigenpair in *; simpl in *.
    rewrite matrix_column_choose_vector_row_choose_selective_diagonal.
    apply eigenpair_to_selective_diagonal' in Eigen_plus1_B.
    apply eigenpair_to_selective_diagonal' in Eigen_minus1_B.
    specialize (spans_whole_space_idxB v H1).
    setoid_rewrite matrix_column_choose_vector_row_choose_selective_diagonal in spans_whole_space_idxB.
    setoid_rewrite selective_diagonal_app_split in spans_whole_space_idxB.
    setoid_rewrite Mmult_plus_distr_l in spans_whole_space_idxB.
    setoid_rewrite Mmult_plus_distr_r in spans_whole_space_idxB.
    remember spans_whole_space_idxB as spans_whole_space_idxB'.
    clear Heqspans_whole_space_idxB'.
    apply @Mmult_inj_l with (m := translateA b) (i := (2 ^ n)%nat) (j := (2 ^ n)%nat) in spans_whole_space_idxB'.
    rewrite H0 in spans_whole_space_idxB'.
    rewrite Mmult_plus_distr_l in spans_whole_space_idxB'.
    rewrite <- ! Mmult_assoc in spans_whole_space_idxB'.
    rewrite Eigen_plus1_B in spans_whole_space_idxB'.
    rewrite Eigen_minus1_B in spans_whole_space_idxB'.
    apply (Mplus_double_side spans_whole_space_idxB) in spans_whole_space_idxB'.
    assert (v .+ C1 .* v = C2 .* v). { lma'. }
    assert (UB × selective_diagonal (2 ^ n) plus1idxB × ((UB) † × v)
              .+ UB × selective_diagonal (2 ^ n) minus1idxB × ((UB) † × v)
              .+ (C1 .* UB × selective_diagonal (2 ^ n) plus1idxB × (UB) † × v
                    .+ - C1 .* UB × selective_diagonal (2 ^ n) minus1idxB × (UB) † × v) =
              C2 .* (UB × selective_diagonal (2 ^ n) plus1idxB × (UB) † × v)).
    { assert (forall (v1 v2 : Vector (2 ^ n)%nat), WF_Matrix v1 -> WF_Matrix v2 -> v1 .+ v2 .+ (C1 .* v1 .+ (- C1)%C .* v2) = C2 .* v1).
      { intros. lma'. }
      rewrite <- ! Mmult_assoc.
      distribute_scale.
      apply H3.
      1-2: auto with wf_db. }
    setoid_rewrite H2 in spans_whole_space_idxB'.
    setoid_rewrite H3 in spans_whole_space_idxB'.
    apply (Mscale_cancel v (UB × selective_diagonal (2 ^ n) plus1idxB × (UB) † × v) C2) in spans_whole_space_idxB'.
    rewrite <- Mmult_assoc.
    all : auto with wf_db.
    nonzero. }

  assert (spans_minus_one_space_idxB : forall (v : Vector (2 ^ n)),
             Eigenpair (translateA b) (v, Copp C1) -> @WF_Matrix (2^n)%nat 1 v ->  
             v = matrix_column_choose minus1idxB UB
                   × (vector_row_choose minus1idxB ((UB)† × v))).
  { intros. unfold Eigenpair in *; simpl in *.
    rewrite matrix_column_choose_vector_row_choose_selective_diagonal.
    apply eigenpair_to_selective_diagonal' in Eigen_plus1_B.
    apply eigenpair_to_selective_diagonal' in Eigen_minus1_B.
    specialize (spans_whole_space_idxB v H1).
    setoid_rewrite matrix_column_choose_vector_row_choose_selective_diagonal in spans_whole_space_idxB.
    setoid_rewrite selective_diagonal_app_split in spans_whole_space_idxB.
    setoid_rewrite Mmult_plus_distr_l in spans_whole_space_idxB.
    setoid_rewrite Mmult_plus_distr_r in spans_whole_space_idxB.
    remember spans_whole_space_idxB as spans_whole_space_idxB'.
    clear Heqspans_whole_space_idxB'.
    apply @Mmult_inj_l with (m := translateA b) (i := (2 ^ n)%nat) (j := (2 ^ n)%nat) in spans_whole_space_idxB'.
    rewrite H0 in spans_whole_space_idxB'.
    rewrite Mmult_plus_distr_l in spans_whole_space_idxB'.
    rewrite <- ! Mmult_assoc in spans_whole_space_idxB'.
    rewrite Eigen_plus1_B in spans_whole_space_idxB'.
    rewrite Eigen_minus1_B in spans_whole_space_idxB'.
    apply Mscale_inj with (c := (- C1)%C) in spans_whole_space_idxB'.
    apply (Mplus_double_side spans_whole_space_idxB) in spans_whole_space_idxB'.
    assert (v .+ - C1 .* (- C1 .* v) = C2 .* v). { lma'. }
    assert (UB × selective_diagonal (2 ^ n) plus1idxB × ((UB) † × v)
              .+ UB × selective_diagonal (2 ^ n) minus1idxB × ((UB) † × v)
              .+ - C1 .* (C1 .* UB × selective_diagonal (2 ^ n) plus1idxB × (UB) † × v
                            .+ - C1 .* UB × selective_diagonal (2 ^ n) minus1idxB × (UB) † × v) =
              C2 .* (UB × selective_diagonal (2 ^ n) minus1idxB × (UB) † × v)).
    { assert (forall (v1 v2 : Vector (2 ^ n)%nat), WF_Matrix v1 -> WF_Matrix v2 -> v1 .+ v2 .+ (- C1)%C .* (C1 .* v1 .+ (- C1)%C .* v2) = C2 .* v2).
      { intros. lma'. }
      rewrite <- ! Mmult_assoc.
      distribute_scale.
      apply H3.
      1-2: auto with wf_db. }
    setoid_rewrite H2 in spans_whole_space_idxB'.
    setoid_rewrite H3 in spans_whole_space_idxB'.
    apply (Mscale_cancel v (UB × selective_diagonal (2 ^ n) minus1idxB × (UB) † × v) C2) in spans_whole_space_idxB'.
    rewrite <- Mmult_assoc.
    all : auto with wf_db.
    nonzero. }
  
  
  (** U : Unitary
P Q : Unitary Hermitian Trace-Zero


1. { v1, v2, ..., vn, w1, w2, ..., wn } forms an orthonormal basis (for the eigenspaces of P)
<< WFUUA >>

2. U preserves innerproducts
<< unfold inner_product, WF_Unitary >>

3. { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } forms an orthonormal basis.

⋆4. By the assertion {P} U {Q}, given any linear combination v = a1 v1 + ... + an vn, we have QUv = Uv. Thus the span of { U v1, U v2, ..., U vn } is a subspace of the +1 eigenspace of Q.
<< plusA_Eigen >>

5. The only eigenvalues are +1 and -1. So, the only eigenspaces that exists are +1 and -1 .
<< Lemma: Unitary_Hermitian_eigenvalue_plusminus1 >>

⋆6. The "dimension of the +1 eigenspace" is equal to the "dimension of the -1 eigenspace".
<< equal_len_A, half_length_idxA, equal_len_B, half_length_idxB:
      length plus1idxA = length plus1idxB = length minus1idxB >>


⋆⋆ "dimension of the +1 eigenspace of Q"
= the size of a matrix M such that the columns of M are 'linearly independent' and 'span the +1 eigenspace of Q' (i.e. " forall u, Qu = u -> u = Mα for some column vector α ")

= the size of the matrix that 'spans' it and is 'linear independent' columns of a matrix M 
 which satisfy the property "forall u, Qu = u -> u = Mα for some column vector α".

= the maximal number of linearly independent columns of a matrix M 
 which satisfy the property "forall u, Qu = u -> u = Mα for some column vector α".


Problems
1. two ways to define subspace: 1) list of vectors, 2) vectorspace filtered by a Prop
1) Let (n : nat), (l : list Vector n), and M := (list_vector_to_matrix l). 
    Define S := { v : Vector n | exists (α : Vector (length l)), v = M α }.
2) Let (P : Prop). Define S := { v : Vector n | P v }.




2. if S is a " subspace " of S' and if " dim S = dim S' " then S = S'



equivalence relation? <- spans the same space

S := { v∈R^n | P v }
v∈S, Q v
∀v:Vector n, P v -> Q v



forall v, P v -> Q v, where P defines the subspace and Q defines the application of v.
usually Q := (v = M × v)


m S
{ n : nat | exists A : Matrix m n, A spans S /\ linearly_independent A}

{ n : nat & {A : Matrix m n | A spans S & linearly_independent A} }

Could be inductive.
Definition subspace_dimension {m} (S : Subspace m)  (n : nat) : Prop := 
  exists A : Matrix m n,  A spans S /\ linearly_independent A.

Lemma subspace_dimension_unique : Prop := forall m S n n',
subspace_dimension S n ->
subspace_dimension S n' ->
n = n'.

Lemma subspace_dimension_exists


⋆7. Since the whole space has 2n dimension, the "+1 eigenspace has n dimension".
<< equal_len_A, half_length_idxA >>

8. Hence the span of { U v1, U v2, ..., U vn } is the +1 eigenspace of Q.

9. Hence { U v1, U v2, ..., U vn } forms an orthonormal basis for the +1 eigenspace of Q.

10. Let Q u = u. (u is in the +1 eigenspace of Q)
      Let V := [v1 v2 ... vn], W := [w1 w2 ... wn], β := (U [V W])† u.
      Then there exists some α such that U V α = u.
      Since (U wi)† u = (U wi)† (U V α) = wi† V α = 0 for each i,
      and since U [V W] β = u, 0 = (U wi)† u = (U wi)† U [V W] β = [0 0..1(ith)..0] β = βi
      for each i > n. Therefore, βw = 0 and U V (α - βv) = 0 -> α = βv since V is lin. indep.
   *)


  assert (lin_indep_plus1idxA : linearly_independent (matrix_column_choose plus1idxA (translate_prog n g × UA))).
  { apply @lin_indep_smash with (n2 := (2 ^ (n - 1))%nat) (A2 := matrix_column_choose minus1idxA (translate_prog n g × UA)).
    setoid_rewrite <- matrix_column_choose_app_smash; auto with wf_db.
    unfold linearly_independent.
    intros a0 H0 H1.
    rewrite matrix_column_choose_pop_square in H1; auto with wf_db.
    unfold WF_Unitary in WFU_g.
    destruct WFU_g as [WF_g left_cancel_g].
    apply @Mmult_inj_l with (i := (2 ^ n)%nat) (j := (2 ^ n)%nat) (m := (translate_prog n g) †) in H1.
    rewrite ! app_length, ! equal_len_A, ! half_length_idxA in H1.
    assert (n <> 0%nat).
    { destruct Pa.
      - unfold translateA, translate in Ua. simpl in Ua.
        unfold WF_Unitary in Ua. destruct Ua as [WFz ZeqI].
        rewrite Mmult_0_r in ZeqI.
        do 2 apply f_equal_inv with (x := 0%nat) in ZeqI.
        unfold Zero, I in ZeqI. simpl in ZeqI.
        assert (2 ^ n <> 0)%nat.
        { intro. rewrite Nat.pow_eq_0_iff in H2. destruct H2. lia. }
        assert (0 < 2 ^ n)%nat by lia.
        rewrite <- Nat.ltb_lt in H3.
        rewrite H3 in ZeqI.
        inversion ZeqI.
        lra.
      - destruct H2. auto. }
    replace (2 ^ (n - 1) + 2 ^ (n - 1))%nat with (2 ^ n)%nat in H1
        by (replace (2 ^ (n - 1) + 2 ^ (n - 1))%nat with (2 ^ (s (n - 1)))%nat by (simpl; lia);
            replace (s (n - 1)) with n by lia; reflexivity).
    rewrite <- ! Mmult_assoc in H1.
    rewrite left_cancel_g in H1.
    rewrite Mmult_0_r, Mmult_1_l in H1.
    2 : { pose ( WF_Matrix_matrix_column_choose_indices_list (plus1idxA ++ minus1idxA) UA).
          assert (WF_Matrix UA) by auto with wf_db.
          apply w in H3.
          rewrite total_length_idxA in H3.
          apply H3. }
    unfold matrix_column_choose in H1.
    pose (permutation_preserves_map_get_vec_matrix UA PermA) as p.
    destruct (permutation_list_vector_to_matrix_times_vector p a0) as [b0 [WFb0 [Heq Perm_a0b0]]].
    - assert ((@length nat plus1idxA + 2 ^ (n - 1))%nat =
                (@length (Vector (2 ^ n))
                   (@map nat (Vector (2 ^ n)) (fun i : nat => @get_col (2 ^ n) (2 ^ n) UA i)
                      (plus1idxA ++ minus1idxA)))).
      { rewrite map_length, app_length.
        rewrite ! equal_len_A, half_length_idxA.
        reflexivity. }
      rewrite <- H3.
      apply H0.
    - rewrite ! map_length, total_length_idxA in Heq.
      rewrite H1 in Heq.
      symmetry in Heq.
      destruct WFUUA as [WFUA UAinv].
      pose (matrix_column_choose_original UA WFUA) as e.
      unfold matrix_column_choose in e.
      rewrite e in Heq.
      rewrite seq_length in Heq.
      apply (Mmult_inj_l UA†) in Heq.
      rewrite <- Mmult_assoc in Heq.
      rewrite UAinv in Heq.
      rewrite Mmult_1_l, Mmult_0_r in Heq.
      2 : rewrite map_length, seq_length in WFb0; apply WFb0.
      rewrite Heq in Perm_a0b0.
      assert ((fun i : nat => @Zero (2 ^ n)%nat 1%nat i 0%nat) = (fun _ : nat => C0)) by auto.
      rewrite H3 in Perm_a0b0.
      rewrite
        ! map_length,
        seq_length,
        total_length_idxA,
        map_const_repeat
        in Perm_a0b0.
      rewrite <- map_length with (f := (fun i : nat => a0 i 0%nat)) in Perm_a0b0.
      rewrite permutation_repeat_nth in Perm_a0b0.
      rewrite <- zero_all_zero; auto.
      intros i0 H4.
      specialize (Perm_a0b0 i0).
      rewrite equal_len_A, half_length_idxA in H4.
      replace (2 ^ (n - 1))%nat with ((2 ^ (n - 1)) * 1)%nat in H4 by lia.
      rewrite <- Nat.mul_add_distr_l in H4.
      replace (1 + 1)%nat with 2%nat in H4 by lia.
      setoid_rewrite <- Nat.pow_1_r in H4 at 11.
      rewrite <- Nat.pow_add_r in H4.
      replace (n - 1 + 1)%nat with n in H4 by lia.
      rewrite (nth_indep (map (fun i : nat => a0 i 0%nat) (List.seq 0 (2 ^ n)))
                 C0 (a0 0%nat 0%nat)) in Perm_a0b0.
      2 : rewrite map_length, seq_length; apply H4.
      rewrite (map_nth (fun i : nat => a0 i 0%nat) (List.seq 0 (2 ^ n))) in Perm_a0b0.
      rewrite seq_nth in Perm_a0b0; auto. }

  (* We define the span of UB with indices in plus1idxB as
Splus1idxB : Vector (2^n) -> Prop
Splus1idxB (v : Vector (2^n)) := span (matrix_column_choose plus1idxB UB) v
where we can use "span_is_subspace" to show (subspace Splus1idxB). *)
  pose (span (matrix_column_choose plus1idxB UB)) as Splus1idxB.
  assert (subspace_Splus1idxB : subspace Splus1idxB)
    by (apply span_is_subspace; auto with wf_db).

  (* We define the +1 eigenspace of Q as
Splus1B : Vector (2^n) -> Prop
Splus1B (v : Vector (2^n)) := WF_Matrix v /\ v = translateA b × v
where we need to show (subspace Splus1B). *)
  pose (fun (v : Vector (2 ^ n)%nat) => WF_Matrix v /\ v = translateA b × v) as Splus1B.
  assert (subspace_Splus1B : subspace Splus1B).
  { unfold subspace, Splus1B.
    repeat (split; intros);
      repeat match goal with [H : ?A /\ ?B |- _] => destruct H; auto with wf_db end.
    - rewrite Mmult_0_r; auto.
    - rewrite Mmult_plus_distr_l, <- H2, <- H3; auto.
    - rewrite Mscale_mult_dist_r, <- H1; auto. }

  (*  We define the span of { U v1, U v2, ..., U vn } as
Splus1gA : Vector (2^n) -> Prop
Splus1gA (v : Vector (2^n)) := span ((translate_prog n g) × (matrix_column_choose plus1idxA UA)) v
where we can use "span_is_subspace" to show (subspace Splus1gA). *)
  pose (span ((translate_prog n g) × (matrix_column_choose plus1idxA UA))) as Splus1gA.
  assert (subspace_Splus1gA : subspace Splus1gA)
    by (apply span_is_subspace; auto with wf_db).

  (* << Eigen_plus1_B >> shows that Splus1idxB is a subspace of Splus1B. *)
  assert (forall (v : Vector (2 ^ n)%nat), Splus1idxB v -> Splus1B v).
  { intros v H0.
    remember H0 as H0'. clear HeqH0'.
    unfold Splus1B. unfold Splus1idxB in H0'.
    remember subspace_Splus1idxB as subspace_Splus1idxB'.
    unfold subspace in subspace_Splus1idxB'. clear Heqsubspace_Splus1idxB'.
    destruct subspace_Splus1idxB'
      as [WF_Splus1idxB [Splus1idxB_Zero [Splus1idxB_plus Splus1idxB_scale]]].
    specialize (WF_Splus1idxB v H0).
    split; auto.
    destruct WFUUB as [WFUB UBinv].
    pose (eigenpair_to_selective_diagonal' plus1idxB C1 (translateA b) UB
            WFUB Eigen_plus1_B) as e.
    unfold span in H0'.
    rewrite equal_len_B, half_length_idxB in H0'.
    destruct H0' as [w [WFw eqw]].
    pose (vector_row_choose_inverse (2 ^ n)%nat plus1idxB) as e0.
    rewrite equal_len_B, half_length_idxB in e0.
    assert (incl_plus1idxB_seq : incl plus1idxB (List.seq 0 (2 ^ n))).
    { apply Permutation_incl in PermB.
      apply incl_app_inv in PermB.
      destruct PermB; auto. }
    destruct (e0 w NoDup_plus1_idxB incl_plus1idxB_seq WFw) as [w' [WFw' He0]].
    apply (@Mmult_inj_r (2 ^ n)%nat (2 ^ n)%nat 1%nat w') in e.
    rewrite Mscale_1_l in e.
    replace (translateA b × UB × selective_diagonal (2 ^ n) plus1idxB × w')
      with (translateA b × (UB × selective_diagonal (2 ^ n) plus1idxB × w'))
      in e
        by (rewrite ! Mmult_assoc; reflexivity).
    rewrite <- ! (matrix_column_choose_vector_row_choose_selective_diagonal plus1idxB UB w' NoDup_plus1_idxB WFUB WFw') in e.
    rewrite <- ! He0, ! equal_len_B, ! half_length_idxB in e.
    rewrite <- ! eqw in e.
    auto. }
(* <<spans_plus_one_space_idxB>> shows that Splus1B is a subspace of Splus1idxB. *)
  assert (forall (v : Vector (2 ^ n)%nat), Splus1B v -> Splus1idxB v).
  { intros v H1.
    remember H1 as H1'. clear HeqH1'.
    unfold Splus1B in H1'. unfold Splus1idxB.
    destruct H1' as [WFv H1'].
    unfold span.
    assert (Eigenpair (translateA b) (v, C1)).
    { unfold Eigenpair.
      simpl.
      rewrite Mscale_1_l.
      auto. }
    pose (spans_plus_one_space_idxB v H2 WFv) as v_spaned.
    exists (vector_row_choose plus1idxB ((UB) † × v)).
    split; auto with wf_db. }
  (* Use "matrix_column_choose_app_smash", "lin_indep_smash", " matrix_column_choose_vector_row_choose_original"  to show (matrix_column_choose plus1idxB UB) is linearly independent.  *)
  assert (linearly_independent (matrix_column_choose plus1idxB UB)).
  { apply @lin_indep_smash with (A2 := matrix_column_choose minus1idxB UB) (n2 :=  length minus1idxB).
    setoid_rewrite <- matrix_column_choose_app_smash; auto with wf_db.
    unfold linearly_independent.
    rewrite <- ! app_length.
    intros a0 H2 H3.
    destruct (vector_row_choose_inverse (2 ^ n) (plus1idxB ++ minus1idxB) a0)
      as [w [WFw eqw]]; auto with wf_db.
    1 : apply Permutation_incl; auto.
    rewrite eqw in H3.
    rewrite matrix_column_choose_vector_row_choose_original in H3;
      auto with wf_db.
    2: apply Permutation_sym; auto.
    assert (linearly_independent UB)
      by (apply WF_Unitary_implies_linearly_independent; auto).
    unfold linearly_independent in H4.
    specialize (H4 w WFw H3).
    rewrite H4 in eqw.
    rewrite vector_row_choose_Zero in eqw; auto. }
  (* Then we have (basis Splus1idxB (matrix_column_choose plus1idxB UB)). *)
  assert (basis Splus1idxB (matrix_column_choose plus1idxB UB)).
  { unfold basis.
    repeat (split; auto with wf_db).
    intros i0 H3.
    unfold Splus1idxB.
    apply span_get_vec; auto with wf_db. }
  (* Thus, (dimension Splus1idxB (length plus1idxB)). *)
  assert (dimension Splus1idxB (length plus1idxB)).
  { unfold dimension.
    exists (matrix_column_choose plus1idxB UB).
    split; auto with wf_db. }
  (* Therefore (forall v, Splus1B v <-> Splus1idxB v) and (dimension Splus1B (length plus1idxB)). *)
  assert (forall v, Splus1B v <-> Splus1idxB v) by (intros; split; auto).
  assert (basis Splus1B (matrix_column_choose plus1idxB UB))
    by (rewrite (equivalent_subspace_basis H5); auto).
  assert (dimension Splus1B (length plus1idxB)).
  { unfold dimension.
    exists (matrix_column_choose plus1idxB UB).
    split; auto with wf_db. }
  (* <<plusA_Eigen>> shows that Splus1gA is a subspace of Splus1B *)
  assert (forall v, Splus1gA v -> Splus1B v).
  { intros v H8. 
    unfold Splus1gA in H8.
    unfold Splus1B.
    split;
      try apply @span_WF_Matrix with
      (M := translate_prog n g × matrix_column_choose plus1idxA UA)
      (m := length plus1idxA);
      auto with wf_db.
    apply eigenpair_to_selective_diagonal' in plusA_Eigen; auto with wf_db.
    rewrite Mscale_1_l in plusA_Eigen.
    unfold span in H8.
    destruct H8 as [w [WFw eqw]].
    assert (incl_plus1idxA_seq : incl plus1idxA (List.seq 0%nat (2 ^ n))).
    { apply Permutation_incl in PermA.
      apply incl_app_inv in PermA.
      destruct PermA; auto. }
    destruct (vector_row_choose_inverse (2 ^ n)%nat plus1idxA w NoDup_plus1_idxA
                 incl_plus1idxA_seq WFw)
      as [w0 [WFw0 eqw0]].
    rewrite eqw0 in eqw.
    rewrite Mmult_assoc in eqw.
    rewrite matrix_column_choose_vector_row_choose_selective_diagonal in eqw;
      auto with wf_db.
    rewrite ! eqw, <- ! Mmult_assoc.
    rewrite <- ! Mmult_assoc in plusA_Eigen.
    rewrite plusA_Eigen.
    reflexivity. }
  (* Using "matrix_column_choose_app_smash", "lin_indep_smash", " matrix_column_choose_vector_row_choose_original", we can show (linearly_independent (translate_prog n g × matrix_column_choose plus1idxA UA)). *)
  assert (linearly_independent (translate_prog n g × matrix_column_choose plus1idxA UA)).
  { assert (invertible (translate_prog n g)) by (apply WF_Unitary_implies_invertible; auto).
    rewrite left_invertible_linearly_independent; auto with wf_db.
    apply @lin_indep_smash with
      (n2 := length minus1idxA)
      (A2 := matrix_column_choose minus1idxA UA).
    rewrite <- matrix_column_choose_app_smash; auto with wf_db.
    unfold linearly_independent.
    rewrite <- ! app_length.
    intros a0 H10 H11.
    assert (incl_plusminus1idxA_seq : incl (plus1idxA ++ minus1idxA) (List.seq 0 (2 ^ n))).
    { apply Permutation_incl in PermA; auto. }
    destruct (vector_row_choose_inverse (2 ^ n)%nat (plus1idxA ++ minus1idxA) a0 NoDup_plus1_minus1_idxA incl_plusminus1idxA_seq H10)
      as [w [WFw eqw]].
    rewrite eqw in H11.
    rewrite matrix_column_choose_vector_row_choose_original in H11;
      auto with wf_db.
    2 : apply Permutation_sym; auto.
    assert (linearly_independent UA)
      by (apply WF_Unitary_implies_linearly_independent; auto).
    unfold linearly_independent in H12.
    specialize (H12 w WFw H11).
    rewrite H12 in eqw.
    rewrite vector_row_choose_Zero in eqw.
    auto with wf_db. }
    (* Then, by the definition of Splus1gA, we have (basis Splus1gA (translate_prog n g × matrix_column_choose plus1idxA UA)). *)
  assert (basis Splus1gA (translate_prog n g × matrix_column_choose plus1idxA UA)).
  { unfold basis.
    repeat (split; auto with wf_db).
    intros i0 H10.
    unfold Splus1gA.
    apply span_get_vec; auto with wf_db. }
  (* Thus, (dimension Splus1gA (length plus1idxB)). *)
  assert (dimension Splus1gA (length plus1idxB)).
  { unfold dimension.
    rewrite equal_len_B, half_length_idxB, <- half_length_idxA, <- equal_len_A.
    exists (translate_prog n g × matrix_column_choose plus1idxA UA).
    split; auto with wf_db. }
  (* We can show by using "equal_dimension_lin_indep_basis" that a basis of Splus1gA is also a  basis of Splus1B.
   Hence { U v1, U v2, ..., U vn } forms a basis for the +1 eigenspace of Q. *)
  assert (basis Splus1B (translate_prog n g × matrix_column_choose plus1idxA UA)).
  { apply equal_dimension_lin_indep_basis; auto with wf_db.
    1 : rewrite equal_len_A, half_length_idxA, <- half_length_idxB, <- equal_len_B; auto.
    intros i0 H12.
    unfold Splus1B; split; auto with wf_db.
    (** we need a lemma for get_vec_mult with non-square matrices **)
    (* Use "get_vec_matrix_column_choose", "nth_In", and "plusA_Eigen" *)
    rewrite get_vec_mult_matrix with (A := translateA b).
    rewrite <- ! Mmult_assoc.
    rewrite <- ! matrix_column_choose_pop_square; auto with wf_db.
    rewrite ! get_vec_matrix_column_choose with (d := 0%nat); try lia; auto with wf_db.
    pose (@nth_In nat i0 plus1idxA 0%nat) as H13.
    specialize (H13 H12).
    apply plusA_Eigen in H13.
    unfold Eigenpair in H13; simpl in H13.
    rewrite Mscale_1_l, <- ! Mmult_assoc, ! e_i_get_vec in H13; auto with wf_db. }
  (* Then, by "subspace_is_basis_span", (forall v, Splus1gA v <-> Splus1B v). *)
  assert (forall v, Splus1gA v <-> Splus1B v).
  { intros; split; auto; intros.
    unfold Splus1gA.
    rewrite <- @subspace_is_basis_span with (P := Splus1B); auto. }
  (* Let Q u = u. (u is in the +1 eigenspace of Q)
      Let V := [v1 v2 ... vn], W := [w1 w2 ... wn], β := (U [V W])† u.
      Since we have (forall v : Vector (2 ^ n), Splus1gA v <-> Splus1B v) above,
      there exists some α such that U V α = u.
      Since (U wi)† u = (U wi)†  (U V α) = wi† V α = 0 for each i,
      and since U [V W] β = u, 0 = (U wi)† u = (U wi)† U [V W] β = [0 0..1(ith)..0] β = β_i
      for each i > n. Therefore, β_w = 0 and U V (α - β_v) = 0 -> α = β_v since V is lin. indep.
      Therefore U V β_v = u. *)
  assert (spans_plus_one_space_B : forall (u : Vector (2 ^ n)),
             Eigenpair (translateA b) (u, C1) -> @WF_Matrix (2^n)%nat 1 u ->  
             u = matrix_column_choose
                   plus1idxA
                   (translate_prog n g × UA)
                   × (vector_row_choose plus1idxA ((translate_prog n g × UA)† × u))).
  { intros u H14 H15.
    (* Let Q u = u. (u is in the +1 eigenspace of Q)
       <- H14, H15 *)
    assert (Splus1B u).
    { unfold Splus1B.
      unfold Eigenpair in H14; simpl in H14.
      rewrite Mscale_1_l in H14.
      split; auto. }
    rewrite <- H13 in H16.
    unfold Splus1gA, span in H16.
    destruct H16 as [v [WFv eqv]].
    (* Let V := [v1 v2 ... vn], W := [w1 w2 ... wn], β := (U [V W])† u.
      Since we have (forall v : Vector (2 ^ n), Splus1gA v <-> Splus1B v) above,
      there exists some α such that U V α = u.
      <- eqv *)
    assert (forall i j : nat, In i minus1idxA -> In j plus1idxA ->
                       (get_vec i UA)† × (get_vec j UA) = Zero).
    { intros i0 j H16 H17.
      assert (@WF_Matrix 1%nat 1%nat (adjoint (get_vec i0 UA) × get_vec j UA))
        by auto with wf_db.
      unfold WF_Matrix in H18.
      prep_matrix_equality.
      bdestruct (x <? 1%nat).
      - bdestruct (y <? 1%nat).
        + replace x with 0%nat by lia.
          replace y with 0%nat by lia.
          replace ((adjoint (get_vec i0 UA) × get_vec j UA) 0%nat 0%nat)
            with (inner_product (get_vec i0 UA) (get_vec j UA))
            by (unfold inner_product; easy).
          rewrite unitary_columns_inner_product; auto.
          assert (~ In j minus1idxA)
            by (apply NoDup_app_in_neg_r with (list1 := plus1idxA) (list2 := minus1idxA); auto).
          bdestruct (i0 =? j)%nat.
          rewrite H22 in H16; contradiction.
          unfold I.
          bdestruct_all; simpl; lca.
        + rewrite H18; auto; lia.
      - rewrite H18; auto; lia. }
    assert (forall i : nat, In i minus1idxA ->
                     (get_vec i UA)† × matrix_column_choose plus1idxA UA = Zero).
    { intros i0 H17.
      apply det_by_get_vec_matrix.
      intros i1.
      rewrite <- get_vec_mult_matrix.
      replace (get_vec i1 Zero) with (@Zero 1%nat 1%nat) by lma'.
      bdestruct (i1 <? length plus1idxA).
      - rewrite get_vec_matrix_column_choose with (d := 0%nat); try lia; auto with wf_db.
        pose (@nth_In nat i1 plus1idxA 0%nat H18) as H19.
        specialize (H16 i0 (nth i1 plus1idxA 0%nat) H17 H19); auto.
      - assert (WF_Matrix (matrix_column_choose plus1idxA UA)) by auto with wf_db.
        prep_matrix_equality.
        unfold adjoint, Mmult; simpl.
        assert ((fun y0 : nat =>
                   (get_vec i0 UA y0 x) ^* *
                     get_vec i1 (matrix_column_choose plus1idxA UA) y0 y)
                = (fun _ : nat => C0)).
        { apply functional_extensionality. intros x0.
          unfold get_vec.
          bdestruct_all; try lca.
          rewrite H19; try lia.
          lca. }
        rewrite H20.
        replace (@Zero 1%nat 1%nat x y) with C0 by lca.
        rewrite big_sum_0_bounded; auto. }
    assert (forall i : nat, In i minus1idxA -> (translate_prog n g × get_vec i UA)† × u = Zero).
    { intros i0 H18.
      rewrite eqv.
      rewrite Mmult_adjoint.
      replace (adjoint (get_vec i0 UA) × adjoint (translate_prog n g)
                 × (translate_prog n g × matrix_column_choose plus1idxA UA × v))
        with (adjoint (get_vec i0 UA) ×
                (adjoint (translate_prog n g) × translate_prog n g) ×
                matrix_column_choose plus1idxA UA × v)
        by (rewrite ! Mmult_assoc; reflexivity).
      destruct WFU_g as [WF_g unitary_g].
      rewrite unitary_g, Mmult_1_r; auto with wf_db.
      rewrite H17; auto.
      rewrite Mmult_0_l; reflexivity. }
    (* Since (U wi)† u = (U wi)† (U V α) = wi† V α = 0 for each i
       <- H18 *)
    assert (translate_prog n g × UA × (adjoint (translate_prog n g × UA) × u) = u).
    { rewrite Mmult_adjoint.
      replace (translate_prog n g × UA × ((UA) † × adjoint (translate_prog n g) × u))
        with ((translate_prog n g × (UA × (UA) †) × adjoint (translate_prog n g)) × u)
        by (rewrite ! Mmult_assoc; reflexivity).
      destruct WFUUA as [WFUA unitary_UA].
      apply Minv_flip in unitary_UA; auto with wf_db.
      rewrite unitary_UA, Mmult_1_r; auto with wf_db.
      destruct WFU_g as [WF_g unitary_g].
      apply Minv_flip in unitary_g; auto with wf_db.
      rewrite unitary_g, Mmult_1_l; auto with wf_db. }
    (* since U [V W] β = u,
       <- H19 *)
    assert (forall i : nat, In i minus1idxA -> (adjoint (translate_prog n g × UA) × u) i 0%nat = C0).
    { intros i0 H20.
      rewrite <- inner_product_vector_with_standard_basis.
      unfold inner_product.
      rewrite <- unitary_adjoint_on_column_vector with (U := UA); auto with wf_db.
      setoid_rewrite <- Mmult_1_r at 2; auto with wf_db.
      destruct WFU_g as [WF_g unitary_g].
      rewrite <- unitary_g.
      rewrite <- ! Mmult_assoc.
      rewrite <- Mmult_adjoint.
      rewrite ! Mmult_assoc in H19.
      rewrite ! Mmult_assoc.
      setoid_rewrite H19; try apply H20.
      rewrite H18; auto.
      pose (Permutation_incl nat (plus1idxA ++ minus1idxA) (List.seq 0 (2 ^ n)) PermA)
        as incl_list.
      apply incl_app_inv in incl_list.
      destruct incl_list as [incl_list_plus incl_list_minus].
      apply incl_list_minus in H20.
      rewrite in_seq in H20.
      lia. }
    (* 0 = (U wi)† u = (U wi)† U [V W] β = [0 0..1(ith)..0] β = β_i for each i > n.
       <- H20 *)
    assert (vector_row_choose minus1idxA (adjoint (translate_prog n g × UA) × u) = Zero).
    { unfold vector_row_choose.
      prep_matrix_equality.
      assert (WF_Matrix (adjoint (translate_prog n g × UA) × u)) by auto with wf_db.
      bdestruct (y <? 1)%nat.
      - replace y with 0%nat by lia.
        bdestruct (x <? length minus1idxA).
        + rewrite (H20 (nth x minus1idxA (2 ^ n)%nat)
                     (@nth_In nat x minus1idxA (2 ^ n)%nat H23)).
          lca.
        + rewrite nth_overflow; auto.
      - rewrite H21; auto; try lia. }
    (* Therefore, β_w = 0
     <- H21 *)
    assert (linearly_independent
              (translate_prog n g × matrix_column_choose plus1idxA UA))
      by (rewrite <- matrix_column_choose_pop_square; auto with wf_db).
    (* V is lin. indep
       <- H22 *)
    rewrite Mmult_assoc in H19.
    rewrite <- matrix_column_choose_vector_row_choose_original
      with (indices_list := plus1idxA ++ minus1idxA)
           (M := UA)
           (v := (adjoint (translate_prog n g × UA) × u))
      in H19; auto with wf_db.
    2 : apply Permutation_sym; auto.
    rewrite matrix_column_choose_vector_row_choose_app_split in H19;
      auto with wf_db.
    rewrite H21, Mmult_0_r, Mplus_0_r in H19.
    (* U V α = u = U V β_v
     <- eqv, H19 *)
    assert ((translate_prog n g × matrix_column_choose plus1idxA UA) ×
              (v .+ (Copp C1) .* (vector_row_choose plus1idxA (adjoint (translate_prog n g × UA) × u))) = Zero).
    { assert (forall (n m : nat) (M : Matrix n m) (v w : Vector m),
                 WF_Matrix M -> WF_Matrix v -> WF_Matrix w ->
                 M × v = M × w -> M × (v .+ (Copp C1) .* w) = Zero).
      { intros n0 m M v0 w H23 H24 H25 H26. 
        rewrite Mmult_plus_distr_l.
        distribute_scale.
        rewrite H26.
        lma'. }
      apply H23;
        try apply WF_Matrix_vector_row_choose_indices_list; auto with wf_db.
      rewrite <- eqv.
      rewrite Mmult_assoc; auto. }
    (* U V (α - β_v) = 0
     <- H23 *)
    unfold linearly_independent in H22.
    apply H22 in H23.
    2 : apply WF_plus; 
    try apply WF_scale;
    try apply WF_Matrix_vector_row_choose_indices_list;
    auto with wf_db.
    assert (forall (n : nat) (v w : Vector n),
               WF_Matrix v -> WF_Matrix w ->
               v .+ (Copp C1) .* w = Zero -> v = w).
    { intros n0 v0 w H24 H25 H26.
      apply Mplus_inj_r with (m := w) in H26.
      rewrite Mplus_assoc in H26.
      rewrite Mplus_opp_l, Mplus_0_l, Mplus_0_r in H26; auto. }
    apply H24 in H23;
      try apply WF_Matrix_vector_row_choose_indices_list; auto with wf_db.
    (* α = β_v
     <- H23 *)
    rewrite H23 in eqv.
    (* Therefore U V β_v = u.
     <- eqv *)
    rewrite matrix_column_choose_pop_square; auto with wf_db. }
    
(* 
1. { v1, v2, ..., vn, w1, w2, ..., wn } forms an orthonormal basis (for the eigenspaces of P)
<< UA is unitary, UA† × UA = Id, columns of UA are vi, wi >>
2. U preserves innerproducts
<< WFU_g : WF_Unitary (translate_prog n g) >>
3. { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } forms an orthonormal basis.
<< (translate_prog n g) × UA is unitary: unitary × unitary = unitary >>
⋆4. By the assertion {P} U {Q}, given any linear combination v = a1 v1 + ... + an vn, we have QUv = Uv. Thus the span of { U v1, U v2, ..., U vn } is a subspace of the +1 eigenspace of Q.
<< plusA_Eigen >>

5. The only eigenvalues are +1 and -1. So, the only eigenspaces that exists are +1 and -1 .
<< Currently not in context >>

⋆6. The "dimension of the +1 eigenspace" is equal to the "dimension of the -1 eigenspace".
<< equal_len_A, half_length_idxA, equal_len_B, half_length_idxB:
      length plus1idxA = length minus1idxA = length plus1idxB = length minus1idxB = (2 ^ (n - 1))%nat >>


⋆⋆ "dimension of the +1 eigenspace of Q"
= the size of a matrix M such that the columns of M are 'linearly independent' and 'span the +1 eigenspace of Q' (i.e. " forall u, Qu = u -> u = Mα for some column vector α ") 


⋆⋆⋆⋆⋆⋆⋆⋆ We define the span of UB with indices in plus1idxB as
Splus1idxB : Vector (2^n) -> Prop
Splus1idxB (v : Vector (2^n)) := span (matrix_column_choose plus1idxB UB) v
where we can use "span_is_subspace" to show (subspace Splus1idxB).
⋆⋆⋆⋆⋆⋆⋆⋆ We define the +1 eigenspace of Q as
Splus1B : Vector (2^n) -> Prop
Splus1B (v : Vector (2^n)) := v = translateA b × v
where we need to show (subspace Splus1B).
⋆⋆⋆⋆⋆⋆⋆⋆ We define the span of { U v1, U v2, ..., U vn } as
Splus1gA : Vector (2^n) -> Prop
Splus1gA (v : Vector (2^n)) := span ((translate_prog n g) × (matrix_column_choose plus1idxA UA)) v
where we can use "span_is_subspace" to show (subspace Splus1gA).
⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆
⋆⋆⋆⋆<< Eigen_plus1_B >> shows that Splus1idxB is a subspace of Splus1B.
⋆⋆⋆⋆<<spans_plus_one_space_idxB>> shows that Splus1B is a subspace of Splus1idxB.
⋆⋆⋆⋆Use "matrix_column_choose_app_smash", "lin_indep_smash", " matrix_column_choose_vector_row_choose_original"  to show (matrix_column_choose plus1idxB UB) is linearly independent. Then we have (basis Splus1idxB (matrix_column_choose plus1idxB UB)).
Thus, (dimension Splus1idxB (length plus1idxB)).
⋆⋆⋆⋆Therefore (forall v, Splus1B v <-> Splus1idxB v) and (dimension Splus1B (length plus1idxB)).
⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆⋆
⋆⋆⋆⋆<<plusA_Eigen>> shows that Splus1gA is a subspace of Splus1B
⋆⋆⋆⋆Using "subspace_dimension" we can show that the dimension of Splus1gA is less than or equal to (length plus1idxB), and using "matrix_column_choose_app_smash", "lin_indep_smash", " matrix_column_choose_vector_row_choose_original" we can show that the dimension of Splus1gA is greater than or equal to (length plus1idxA) which is equal to (length plus1idxB) by 6. above.
⋆⋆⋆⋆Therefore (dimension Splus1gA (length plus1idxB)) and we can show by using "equal_dimension_lin_indep_basis" that (forall v, Splus1gA v <-> Splus1B v).








m S
{ n : nat | exists A : Matrix m n, A spans S /\ linearly_independent A}
{ n : nat & {A : Matrix m n | A spans S & linearly_independent A} }


Problems
1. two ways to define subspace: 1) list of vectors, 2) vectorspace filtered by a Prop
1) Let (n : nat), (l : list Vector n), and M := (list_vector_to_matrix l). 
    Define S := { v : Vector n | exists (α : Vector (length l)), v = M α }.
2) Let (P : Prop). Define S := { v : Vector n | P v }.




2. if S is a " subspace " of S' and if " dim S = dim S' " then S = S'



equivalence relation? <- spans the same space

S := { v∈R^n | P v }
v∈S, Q v
∀v:Vector n, P v -> Q v



forall v, P v -> Q v, where P defines the subspace and Q defines the application of v.
usually Q := (v = M × v)


m S
{ n : nat | exists A : Matrix m n, A spans S /\ linearly_independent A}

{ n : nat & {A : Matrix m n | A spans S & linearly_independent A} }

Could be inductive.
Definition subspace_dimension {m} (S : Subspace m)  (n : nat) : Prop := 
  exists A : Matrix m n,  A spans S /\ linearly_independent A.

Lemma subspace_dimension_unique : Prop := forall m S n n',
subspace_dimension S n ->
subspace_dimension S n' ->
n = n'.

Lemma subspace_dimension_exists


⋆7. Since the whole space has 2n dimension, the "+1 eigenspace has n dimension".
<< equal_len_A, half_length_idxA >>

8. Hence the span of { U v1, U v2, ..., U vn } is the +1 eigenspace of Q.

⋆⋆⋆⋆⋆⋆⋆⋆9. Hence { U v1, U v2, ..., U vn } forms a basis for the +1 eigenspace of Q.

10. Let Q u = u. (u is in the +1 eigenspace of Q)
      Let V := [v1 v2 ... vn], W := [w1 w2 ... wn], β := (U [V W])† u.
      By 9. above, there exists some α such that U V α = u.
      Since (U wi)† u = (U wi)† (U V α) = wi† V α = 0 for each i,
      and since U [V W] β = u, 0 = (U wi)† u = (U wi)† U [V W] β = [0 0..1(ith)..0] β = β_i
      for each i > n. Therefore, β_w = 0 and U V (α - β_v) = 0 -> α = β_v since V is lin. indep.
      Therefore U V β_v = u.

11. Using 10. we can get  'v = translate_prog n g × UA × selective_diagonal (2 ^ n) plus1idxA × (adjoint (translate_prog n g × UA) × v)'.
 *)

(*
The span of { U v1, U v2, ..., U vn } is a subspace of the +1 eigenspace of Q.

translateA b × (translate_prog n g × UA)
                × selective_diagonal (2 ^ n) plus1idxA =
                translate_prog n g × UA × selective_diagonal (2 ^ n) plus1idxA
*)
    (*
    Suppose {u1, u2, . . . , un} is linearly independent. As in the proof of Theorem 43, if there exists
v ∉ sp{u1,u2,...,un},
 then we could add that vector v to the set to obtain a set of n+1 linearly independent vectors. However, since V has dimension n, any set of n+1 vectors is linearly dependent. This shows that every v ∈ V belongs to sp{u1,u2,...,un}. Hence {u1,u2,...,un} spans V and is therefore a basis for V .
*)                                                              

  assert (minusA_Eigen: forall x : nat, In x minus1idxA -> Eigenpair (translateA b) (translate_prog n g × UA × e_i x, Copp C1)).
  { intros x H14. 
    unfold Eigenpair in *; simpl in *.
    pose (NoDup_app_in_neg_l nat x plus1idxA minus1idxA NoDup_plus1_minus1_idxA H14).

    specialize (Eigen_minus1_A x H14).
    
    rewrite <- plus1space_orth_is_minus1space_B.
    intros w H15 H16. 

    setoid_rewrite Mscale_1_l in spans_plus_one_space_B.
    specialize (spans_plus_one_space_B w H16 H15).

    rewrite matrix_column_choose_vector_row_choose_selective_diagonal in spans_plus_one_space_B.
    
    unfold inner_product.
    rewrite spans_plus_one_space_B.

    distribute_adjoint.
     rewrite ! adjoint_involutive. 
    replace (((w) † × (translate_prog n g × UA)
                × ((selective_diagonal (2 ^ n) plus1idxA) † × ((UA) † × (translate_prog n g) †))
                × (translate_prog n g × UA × e_i x)))
      with (w † × (translate_prog n g) × UA
              × (selective_diagonal (2 ^ n) plus1idxA) † × (UA † × ((translate_prog n g) †
                                                                      × (translate_prog n g)) × UA) × e_i x)
      by (rewrite <- ! Mmult_assoc; reflexivity). 
    destruct WFUUA as [WFUA UUA].
    destruct WFU_g as [WF_g U_g].
    rewrite U_g.
    rewrite Mmult_1_r.
    rewrite UUA.
    rewrite Mmult_1_r.
    rewrite selective_diagonal_hermitian.
    
    rewrite ! Mmult_assoc.
    rewrite selective_diagonal_e_i_zero.
    rewrite ! Mmult_0_r.
    lca.
    all : auto with wf_db. }
    

    

    (* ⟨ selective_diagonal plus1idxA (I n) × (translate_prog n g × UA) † × w , e_i x ⟩*)

    




    
    
    (* Since U is invertible, the assertion {P} U {Q} implies that 
        U maps the +1-eigenspace of P precisely "onto" the +1-eigenspace of Q:
        < every +1 eigenvector of Q is spanned by the image of the +1 eigenvectors of P >
        that is, forall x : nat, In x plus1idxA -> translate_prog n g × UA × e_i x 
                    "spans" the 'whole' +1 eigenspace*)

    (* Since eigenvectors corresponding to distinct eigenvalues are orthogonal, 
        +1 eigenspace is orthogonal to -1 eigenspace:
        that is, forall x : nat, (In x plus1idxA -> UA × e_i x) and (In x minus1idxA -> UA × e_i x)
                    are orthogonal *)
    
    (* U := (translate_prog n g) preserves orthogonality since it is unitary *)

    (* Since unitary matrices preserve innerproducts, 
        { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } also forms an orthonormal basis. *)

    (* U maps the -1-eigenspace of P precisely "onto" the -1-eigenspace of Q:
        1. since { U v1, U v2, ..., U vn } "spans" the +1 eigenspace of Q,
            and since the linear combination of +1 eigenspace and -1 eigenspace 
                    spans the 'whole' space
            and since { U v1, U v2, ..., U vn, U w1, U w2, ..., U wn } forms an orthonormal basis,
            { U w1, U w2, ..., U wn } "spans" the 'whole' -1 eigenspace of Q. *)


(* <Q (U A α) = (U A α') :: use if then else to split the multiplication in the Matrix > *)
    (** spans_minus_one_space *)

    
    (* WRONG *)
    (* ( Let u be a -1 eigenvector of Q. Then Q u = - u  and 
              u = a1 U v1 + ... + an U vn + b1 U w1 + ... + bn U wn  and
              Qu = - u = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).
              Then 0 = u - u = (Σ_i 2 ai U vi) + (Σ_i bi U wi) + Q (Σ_i bi U wi).

              Then 0 = u - u = (b1 U w1 + ... + bn U wn) + Q (b1 U w1 + ... + bn U wn)  so
              Q (b1 U w1 + ... + bn U wn) = - (b1 U w1 + ... + bn U wn).
              Then u = - (a1 U v1 + ... + an U vn) + (b1 U w1 + ... + bn U wn)  and so
              2 u = 2 (b1 U w1 + ... + bn U wn)  which gives
              u = b1 U w1 + ... + bn U wn. )

              
              *)(*** 2 ?????? ***)(*
              2. since { U w1, U w2, ..., U wn } "spans" the 'whole' -1 eigenspace
                  and since the dimension of { U w1, U w2, ..., U wn } and -1 eigenspace are equal
                  { U w1, U w2, ..., U wn } is a basis of the -1 eigenspace of Q
               
               3. U wi is an -1 eigenvector of Q


UA × e_i x = get_vec x UA

Matrix & index -> col vec : get_vec

l : list of vectors, lx : list of indeces,
call vectors of index in lx from list of vectors l : map (fun n:nat => nth n l (e_i 0)) lx

span_l (l) : forall v, exists lc, v = fold_left Cplus (map (uncurry Matrix.scale) (zipWith pair lc l)) C0 
                  l : list of vectors
 
is_basis l := span_l l /\ length l = n

l := { U w1, U w2, ..., U wn } is a basis of the -1 eigenspace of Q : 
forall v,  v in -1 eigenspace -> span_l l v




     *)

  assert (Eigen_plus1_A_inv : forall v : Vector (2 ^ n),
             Eigenpair (translateA a) (v, C1) ->
             WF_Matrix v ->
             v = matrix_column_choose plus1idxA UA ×
                      vector_row_choose plus1idxA (UA † × v)).
              (*The following is WRONG:  (exists x, In x plus1idxA /\ UA × e_i x = v)). *)
  { intros v H14 H15. 

    unfold Eigenpair in *; simpl in *.

    rewrite matrix_column_choose_vector_row_choose_selective_diagonal.
    
    rewrite <- ! Mmult_assoc.

    

    (* ( Let u be a +1 eigenvector of P. Then P u = u  and 
              u = a1 v1 + ... + an vn + b1 w1 + ... + bn wn  and
              P u = u = (a1 v1 + ... + an vn) + P (b1 w1 + ... + bn wn).
              Then 

              
              Qu = - u = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).
              Then 0 = u - u = (Σ_i 2 ai U vi) + (Σ_i bi U wi) + Q (Σ_i bi U wi).
              << WRONG >>
              Then 0 = u - u = (b1 U w1 + ... + bn U wn) + Q (b1 U w1 + ... + bn U wn)  so
              Q (b1 U w1 + ... + bn U wn) = - (b1 U w1 + ... + bn U wn).
              Then u = - (a1 U v1 + ... + an U vn) + (b1 U w1 + ... + bn U wn)  and so
              2 u = 2 (b1 U w1 + ... + bn U wn)  which gives
              u = b1 U w1 + ... + bn U wn. )

              
              *)(*** 2 ?????? ***)(*
              2. since { U w1, U w2, ..., U wn } "spans" the 'whole' -1 eigenspace
                  and since the dimension of { U w1, U w2, ..., U wn } and -1 eigenspace are equal
                  { U w1, U w2, ..., U wn } is a basis of the -1 eigenspace of Q
               
               3. U wi is an -1 eigenvector of Q *)

    
(*    apply eigenpair_to_selective_diagonal'' in Eigen_plus1_A. *)


    specialize (spans_whole_space_A v H15).
    rewrite matrix_column_choose_vector_row_choose_app_split in spans_whole_space_A.
    setoid_rewrite matrix_column_choose_vector_row_choose_selective_diagonal in spans_whole_space_A. 
    rewrite <- ! Mmult_assoc in spans_whole_space_A.



    apply eigenpair_to_selective_diagonal'' in Eigen_plus1_A.
    apply eigenpair_to_selective_diagonal'' in Eigen_minus1_A.

    remember spans_whole_space_A as spans_whole_space_A'.
    clear Heqspans_whole_space_A'.
    apply @Mmult_inj_l with (i := (2 ^ n)%nat) (j := (2 ^ n)%nat) (k := 1%nat) (m := translateA a) in spans_whole_space_A.

    rewrite Mmult_plus_distr_l with (A := translateA a) (B := UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v) (C := UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v) in spans_whole_space_A.

    rewrite <- ! Mmult_assoc in spans_whole_space_A.

    rewrite Eigen_minus1_A, Eigen_plus1_A in spans_whole_space_A.
    rewrite Mscale_1_l in H14, spans_whole_space_A.
    rewrite H14 in spans_whole_space_A.

    pose (@Mplus_double_side ((2 ^ n)%nat) (1%nat) (v)
                                 (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v
                                          .+ - C1 .* UA × selective_diagonal (2 ^ n) minus1idxA
                                                 × (UA) † × v)
                                 (v)
                                 (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v
                                    .+ UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v)
                                 (spans_whole_space_A)
                                 (spans_whole_space_A')).
    replace (v .+ v) with (C2 .* v) in e by lma'.

    assert ((UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v
      .+ - C1 .* UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v
      .+ (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v
            .+ UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v))
      = (C2 .* (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v))).
    { rewrite <- Mplus_assoc. distribute_scale.
      assert (forall n (v1 v2 : Vector n), WF_Matrix v1 -> WF_Matrix v2 -> v1 .+ -C1 .* v2 .+ v1 .+ v2 = C2 .* v1).
      { intros. lma'. }
      rewrite H16 with (v1 := UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v)
                      (v2 := UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v).
      all: auto with wf_db. }

    rewrite H16 in e.
    apply Mscale_cancel with (c := C2) in e.
    assumption.
    nonzero.
    all: auto with wf_db. }


  
    assert (Eigen_minus1_A_inv : forall v : Vector (2 ^ n),
               Eigenpair (translateA a) (v, (- C1)%C) ->
               WF_Matrix v ->
               (v = matrix_column_choose minus1idxA UA ×
                      vector_row_choose minus1idxA (UA † × v))).
  (*The following is WRONG:  (exists x, In x minus1idxA /\ UA × e_i x = v)). *)
  { intros v H14 H15. 

    unfold Eigenpair in *; simpl in *.

    rewrite matrix_column_choose_vector_row_choose_selective_diagonal.
    rewrite <- ! Mmult_assoc.

    

    (* ( Let u be a +1 eigenvector of P. Then P u = u  and 
              u = a1 v1 + ... + an vn + b1 w1 + ... + bn wn  and
              P u = u = (a1 v1 + ... + an vn) + P (b1 w1 + ... + bn wn).
              Then 

              
              Qu = - u = (a1 U v1 + ... + an U vn) + Q (b1 U w1 + ... + bn U wn).
              Then 0 = u - u = (Σ_i 2 ai U vi) + (Σ_i bi U wi) + Q (Σ_i bi U wi).
              << WRONG >>
              Then 0 = u - u = (b1 U w1 + ... + bn U wn) + Q (b1 U w1 + ... + bn U wn)  so
              Q (b1 U w1 + ... + bn U wn) = - (b1 U w1 + ... + bn U wn).
              Then u = - (a1 U v1 + ... + an U vn) + (b1 U w1 + ... + bn U wn)  and so
              2 u = 2 (b1 U w1 + ... + bn U wn)  which gives
              u = b1 U w1 + ... + bn U wn. )

              
              *)(*** 2 ?????? ***)(*
              2. since { U w1, U w2, ..., U wn } "spans" the 'whole' -1 eigenspace
                  and since the dimension of { U w1, U w2, ..., U wn } and -1 eigenspace are equal
                  { U w1, U w2, ..., U wn } is a basis of the -1 eigenspace of Q
               
               3. U wi is an -1 eigenvector of Q *)

    
(*    apply eigenpair_to_selective_diagonal'' in Eigen_plus1_A. *)


    specialize (spans_whole_space_A v H15).
    rewrite matrix_column_choose_vector_row_choose_app_split in spans_whole_space_A.
    setoid_rewrite matrix_column_choose_vector_row_choose_selective_diagonal in spans_whole_space_A.
    rewrite <- ! Mmult_assoc in spans_whole_space_A.



    apply eigenpair_to_selective_diagonal'' in Eigen_plus1_A.
    apply eigenpair_to_selective_diagonal'' in Eigen_minus1_A.

    remember spans_whole_space_A as spans_whole_space_A'.
    clear Heqspans_whole_space_A'.
    apply @Mmult_inj_l with (i := (2 ^ n)%nat) (j := (2 ^ n)%nat) (k := 1%nat) (m := translateA a) in spans_whole_space_A.

    rewrite Mmult_plus_distr_l with (A := translateA a) (B := UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v) (C := UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v) in spans_whole_space_A.

    rewrite <- ! Mmult_assoc in spans_whole_space_A.

    rewrite Eigen_minus1_A, Eigen_plus1_A in spans_whole_space_A.
    rewrite Mscale_1_l in spans_whole_space_A.
    rewrite H14 in spans_whole_space_A.

    apply @Mscale_inj with (m := (2 ^ n)%nat) (n := 1%nat) (A := - C1 .* v)
                             (B := UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v
                                    .+ - C1 .* UA × selective_diagonal (2 ^ n) minus1idxA
                                           × (UA) † × v)
                             (c := (- C1)%C) in spans_whole_space_A.

    rewrite Mscale_plus_distr_r in spans_whole_space_A.

    replace (- C1 .* (- C1 .* v)) with v in spans_whole_space_A by lma'.
    assert (- C1 .* (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v)
                .+ - C1 .* (- C1 .* UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v)
                     = - C1 .* (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v)
                           .+ UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v).
    { distribute_scale. lma'; auto 10 with wf_db. }
    rewrite H16 in spans_whole_space_A.
    
    pose (@Mplus_double_side ((2 ^ n)%nat) (1%nat) (v)
            (- C1 .* (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v)
                 .+ UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v)
            (v)
            (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v
               .+ UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v)
            (spans_whole_space_A)
            (spans_whole_space_A')).
    replace (v .+ v) with (C2 .* v) in e by lma'.

    assert (- C1 .* (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v)
      .+ UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v
      .+ (UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v
          .+ UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v)
           = (C2 .* (UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v))).
    { rewrite <- Mplus_assoc. distribute_scale.
      assert (forall n (v1 v2 : Vector n), WF_Matrix v1 -> WF_Matrix v2 -> -C1 .* v1 .+ v2 .+ v1 .+ v2 = C2 .* v2).
      { intros. lma'. }
      rewrite H17 with (v1 := UA × selective_diagonal (2 ^ n) plus1idxA × (UA) † × v)
                      (v2 := UA × selective_diagonal (2 ^ n) minus1idxA × (UA) † × v).
      all: auto with wf_db. }

    rewrite H17 in e.
    apply Mscale_cancel with (c := C2) in e.
    assumption.
    nonzero.
    all: auto with wf_db. }
  
   
  unfold Eigenpair in plusA_Eigen, minusA_Eigen; simpl in *.

  assert (H': eq_eigs (translateA a) ((translate_prog n g)† × (translateA b) × (translate_prog n g))).
  { unfold eq_eigs. intros p H14 H15.  destruct p. simpl in *.
    destruct (Mat_eq_dec (2 ^ n)%nat 1%nat m Zero); auto with wf_db.
    - rewrite e.
      unfold Eigenpair. simpl.
      rewrite ! Mmult_0_r, Mscale_0_r; auto.
    - specialize (Unitary_Hermitian_eigenvalue_plusminus1 (translateA a) m c Ua H14 n0 Ha H15);
        intro Unitary_Hermitian_eigenvalue_plusminus1.
      
      destruct Unitary_Hermitian_eigenvalue_plusminus1 as [H16 | H16]; rewrite H16 in *.
      + 

(* both the above and below have the same a_x coefficients

      forall x : nat, In x plus1idxA ->
      translateA a × (∑_x (UA × e_i x) a_x) = C1 .* (∑_x (UA × e_i x) a_x)

      forall x : nat, In x plus1idxA ->
      translateA b × (translate_prog n g ×  (∑_x (UA × e_i x) a_x) ) =
        C1 .* (translate_prog n g × (∑_x (UA × e_i x) a_x) )
 *)

      (** Use lemma : eigenpair_to_selective_diagonal

forall {n : nat} (indices_list : list nat) (c : C) (M1 M2 M3 : Square n),
WF_Matrix M2 ->
WF_Matrix M3 ->
(forall x : nat, In x indices_list -> Eigenpair M1 (M2 × M3 × e_i x, c)) ->
M1 × M2 × M3 × selective_diagonal n indices_list × (M3) † =
c .* M2 × M3 × selective_diagonal n indices_list × (M3) †



      (forall x : nat, In x indices_list ->
                M1 × M2 × M3 × e_i x = c .* M2 × M3 × e_i x)
      ->  
        (forall v : Vector (2 ^ n), v = matrix_column_choose indices_list M3
                                     × vector_row_choose indices_list ((M3) † × v) ->
                               M1 × M2 × v = c .* M2 × v)
       **)
        
(** 
  plusA_Eigen : forall x : nat,
                In x plus1idxA ->
                translateA b × (translate_prog n g × UA × e_i x) =
                C1 .* (translate_prog n g × UA × e_i x)
          
  Eigen_plus1_A_inv : forall v : Vector (2 ^ n),
                      translateA a × v = C1 .* v ->
                      v =
                      matrix_column_choose plus1idxA UA
                      × vector_row_choose plus1idxA ((UA) † × v)
          
      forall v : Vector (2 ^ n), translateA a × v = C1 .* v ->
                            translateA b × (translate_prog n g ×
                                              (matrix_column_choose plus1idxA UA
                                               × vector_row_choose plus1idxA ((UA) † × v)) ) =
                              C1 .* (translate_prog n g ×
                                       (matrix_column_choose plus1idxA UA
                                          × vector_row_choose plus1idxA ((UA) † × v)) )

      forall v : Vector (2 ^ n), translateA a × v = C1 .* v ->
                            translateA b × (translate_prog n g × v) =
                              C1 .* (translate_prog n g × v)
*)

        

        
        
        specialize (Eigen_plus1_A_inv m H15).
        apply eigenpair_to_selective_diagonal in plusA_Eigen.
        rewrite matrix_column_choose_vector_row_choose_selective_diagonal in Eigen_plus1_A_inv.
        rewrite Eigen_plus1_A_inv.
        apply @Mmult_inj_l with (i := (2 ^ n)%nat) (m := (translate_prog n g) †) in plusA_Eigen.
        rewrite <- ! Mmult_assoc in plusA_Eigen.
        rewrite ! Mscale_mult_dist_r  in plusA_Eigen.
        rewrite ! Mscale_mult_dist_l in plusA_Eigen.
        destruct WFU_g as [WF_g U_g].
        rewrite U_g in plusA_Eigen.
        rewrite Mmult_1_l in plusA_Eigen.
        unfold Eigenpair.
        simpl.
        rewrite <- ! Mmult_assoc.
        rewrite plusA_Eigen.
        distribute_scale.
        reflexivity.
        all: auto with wf_db.
      + specialize (Eigen_minus1_A_inv m  H15).
        apply eigenpair_to_selective_diagonal in minusA_Eigen.
        rewrite matrix_column_choose_vector_row_choose_selective_diagonal in Eigen_minus1_A_inv.
        rewrite Eigen_minus1_A_inv.
        apply @Mmult_inj_l with (i := (2 ^ n)%nat) (m := (translate_prog n g) †) in minusA_Eigen.
        rewrite <- ! Mmult_assoc in minusA_Eigen.
        rewrite ! Mscale_mult_dist_r  in minusA_Eigen.
        rewrite ! Mscale_mult_dist_l in minusA_Eigen.
        destruct WFU_g as [WF_g U_g].
        rewrite U_g in minusA_Eigen.
        rewrite Mmult_1_l in minusA_Eigen.
        unfold Eigenpair.
        simpl.
        rewrite <- ! Mmult_assoc.
        rewrite minusA_Eigen.
        distribute_scale.
        reflexivity.
        all: auto with wf_db. }

  apply eq_eigs_implies_eq_unit in H'.
  apply @Mmult_inj_l with (i := (2 ^ n)%nat) (m := translate_prog n g) in H'.
  rewrite <- ! Mmult_assoc in H'.
  destruct WFU_g as [WF_g U_g].
  apply Minv_flip in U_g.
  rewrite U_g in H'.
  rewrite Mmult_1_l in H'.
  assumption.
  all: auto with wf_db.
  auto with unit_db.
Qed.

    (** the following may be redundant if we can figure it out in the above *)
  (*
  intros H0 H1 H2. 
  unfold vecSatisfiesP in *.
  unfold vecSatisfies in *.
  simpl in *.
  assert (H': eq_eigs (translateA a) ((translate_prog n g)† × (translateA b) × (translate_prog n g))).
  { unfold eq_eigs. intros p H3 H4.
    destruct p. simpl in *.
    apply eig_unit_conv; auto with unit_db. *)


(*
    specialize (H2 m).
    simpl in *.
    assert (WF_Matrix m /\ Eigenpair (translateA a) (m, c)). { auto. } *)
(*
    apply H2 in H5.
    destruct H5.
    assumption. }
  apply eq_eigs_implies_eq_unit in H'; auto with unit_db.
  rewrite H'.
  rewrite <- ! Mmult_assoc.
  assert (WF_Unitary (translate_prog n g)). { auto with unit_db. }
  unfold WF_Unitary in H3.
  destruct H3.
  apply Minv_flip in H4; auto with wf_db.
  rewrite H4.
  rewrite Mmult_1_l.
  reflexivity.
  destruct H1.
  assumption.
Qed.*)


Lemma Eigenvector_Heisenberg_semantics' {n} (a b : AType n) (g : prog) :
  WF_AType a -> WF_AType b -> {{ a }} g {{ b }} ->
  ((translate_prog n g) × translateA a = translateA b × (translate_prog n g)).
Proof. intros H0 H1 H2.
  apply Eigenvector_Heisenberg_semantics.
  1 - 2 : apply proper_length_AType_implies_proper_length_AType_nil;
  apply restricted_addition_semantic_implies_proper_length_AType.
  3, 6 : apply restricted_addition_semantic_implies_Unitary.
  5, 7 : apply restricted_addition_semantic_implies_Hermitian.
  7, 8 : apply restricted_addition_semantic_implies_trace_zero.
  1 - 8 : apply restricted_addition_syntactic_implies_semantic.
  all : inversion H0; inversion H1; auto.
Qed.
  
Lemma Heisenberg_Eigenvector_semantics {n} (a b : AType n) (g : prog) : 
  ((translate_prog n g) × translateA a = translateA b × (translate_prog n g)) ->
  {{ a }} g {{ b }}.
Proof. 
  intros H0 v H1.
  unfold vecSatisfiesP in *.
  unfold vecSatisfies in *.
  simpl in *.
  destruct H1.
  split.
  - auto with wf_db.
  - unfold Eigenpair in *. simpl in *.
    rewrite <- Mmult_assoc.
    rewrite <- H0.
    rewrite Mmult_assoc.
    setoid_rewrite H2.
    distribute_scale.
    reflexivity.
Qed.





(** ** not needed?
(*** Admitted ***)
(** *** Heisenberg semantics should work for ATypes. *)
Lemma Eigenvector_Heisenberg_semantics' {n} (a b : AType n) (g : prog) : 
  WF_Unitary (translateA a) -> WF_Unitary (translateA b) ->
  (forall v : Vector (2^n), vecSatisfiesP' v (G a) -> vecSatisfiesP' ((translate_prog n g) × v) (G b)) -> ((translate_prog n g) × translateA a = translateA b × (translate_prog n g)).
Proof. 
  intros H0 H1 H2. 
  unfold vecSatisfiesP' in *.
  unfold vecSatisfies' in *.
  simpl in *.
  assert (H': eq_eigs (translateA a) ((translate_prog n g)† × (translateA b) × (translate_prog n g))).
  { unfold eq_eigs. intros p H3 H4.
    destruct p. simpl in *.
    apply eig_unit_conv; auto with unit_db.
    specialize (H2 m).
    simpl in *.
    assert (WF_Matrix m /\ Eigenpair (translateA a) (m, c)). { auto. }
(*
    apply H2 in H5.
    destruct H5.
    assumption. }
  apply eq_eigs_implies_eq_unit in H'; auto with unit_db.
  rewrite H'.
  rewrite <- ! Mmult_assoc.
  assert (WF_Unitary (translate_prog n g)). { auto with unit_db. }
  unfold WF_Unitary in H3.
  destruct H3.
  apply Minv_flip in H4; auto with wf_db.
  rewrite H4.
  rewrite Mmult_1_l.
  reflexivity.
  destruct H1.
  assumption.
Qed.*)
Admitted.


Lemma Heisenberg_Eigenvector_semantics' {n} (a b : AType n) (g : prog) : 
  ((translate_prog n g) × translateA a = translateA b × (translate_prog n g)) ->
  (forall v : Vector (2^n), vecSatisfiesP' v (G a) -> vecSatisfiesP' ((translate_prog n g) × v) (G b)).
Proof. 
  intros H0 v H1.
  unfold vecSatisfiesP' in *.
  unfold vecSatisfies' in *.
  simpl in *.
  destruct H1 as [H1 H2].
  split.
  - auto with wf_db.
  - unfold Eigenpair in *. simpl in *.
    rewrite <- Mmult_assoc.
    rewrite <- H0.
    rewrite Mmult_assoc.
    destruct H2 as [x H2].
    exists x.
    setoid_rewrite H2.
    distribute_scale.
    reflexivity.
Qed.
*)


(** ** implication rules ** **)

Reserved Infix "⇒" (at level 65, no associativity).

Inductive implies {n} : Predicate n -> Predicate n -> Prop :=
| ID_implies : forall (A : Predicate n), A ⇒ A
| CapElim : forall (La La' : list (AType n)), incl La La' -> Cap La' ⇒ Cap La
| CupIntro : forall (A B : Predicate n), (A) ⇒ (Cup A B)
| CupComm : forall (A B : Predicate n), (Cup A B) ⇒ (Cup B A)
| CupAssoc1 : forall (A B C : Predicate n), (Cup A (Cup B C)) ⇒ (Cup (Cup A B) C)
| CupAssoc2 : forall (A B C : Predicate n), (Cup (Cup A B) C) ⇒ (Cup A (Cup B C))
| PauliMultLeft : forall (Lt1 Lt2 : list (TType n)) (La1 La2 : list (AType n)),
    Forall proper_length_TType Lt1 -> Forall proper_length_TType Lt2 ->
    length Lt1 = length Lt2 -> length Lt1 <> 0%nat ->
    (exists j k : nat, (j <> k) /\ (j < length Lt1)%nat /\ (k < length Lt1)%nat /\
                  (Lt2 = (switch Lt1 
                            (gMulT (nth j Lt1 (defaultT_I n)) (nth k Lt1 (defaultT_I n))) k))) ->
    La1 = map TtoA Lt1 -> La2 = map TtoA Lt2 ->
    Cap La1 ⇒ Cap La2
| PauliMultLeft_inv : forall (Lt1 Lt2 : list (TType n)) (La1 La2 : list (AType n)),
    Forall proper_length_TType Lt1 -> Forall proper_length_TType Lt2 ->
    Forall coef_plus_minus_1 Lt1 ->
    length Lt1 = length Lt2 -> length Lt1 <> 0%nat ->
    (exists j k : nat, (j <> k) /\ (j < length Lt1)%nat /\ (k < length Lt1)%nat /\
                  (Lt2 = (switch Lt1 
                            (gMulT (nth j Lt1 (defaultT_I n)) (nth k Lt1 (defaultT_I n))) k))) ->
    La1 = map TtoA Lt1 -> La2 = map TtoA Lt2 ->
    Cap La2 ⇒ Cap La1
| AddComm : forall (A B : Predicate n), (A +' B) ⇒ (B +' A)
| AddAssoc1 : forall (A B C : Predicate n), ((A +' B) +' C) ⇒ (A +' (B +' C))
| AddAssoc2 : forall (A B C : Predicate n), (A +' (B +' C)) ⇒ ((A +' B) +' C)
| AddZeroElim : forall (A B C : Predicate n), (A +' ((C0 ·' C) *' B)) ⇒ (A) 
| SeptoCap : forall (la : list (AType n)) (Ln_LLT_Perm : (list nat) * (list (list TTypes)) * (list nat)),
    n = (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) ->
    Forall proper_length_TType (DiagonalQubits (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm))) ->
    Permutation (List.seq 0%nat n) (snd Ln_LLT_Perm) ->
    la = (map (fun t : TType (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) => 
                 TtoA (
(fst t, (collect_fun n ((to_fun gI (snd t)) ∘ (perm_inv n (to_fun 0%nat (snd Ln_LLT_Perm))))%prg))
)
)
(DiagonalQubits (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm)))
) ->
    Sep Ln_LLT_Perm ⇒ Cap la
| CaptoSep : forall (la : list (AType n)) (Ln_LLT_Perm : (list nat) * (list (list TTypes)) * (list nat)),
    n = (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) ->
    Forall proper_length_TType (DiagonalQubits (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm))) ->
    Permutation (List.seq 0%nat n) (snd Ln_LLT_Perm) ->
    la = (map (fun t : TType (fold_right Nat.add 0%nat (fst (fst Ln_LLT_Perm))) => 
                 TtoA (
(fst t, (collect_fun n ((to_fun gI (snd t)) ∘ (perm_inv n (to_fun 0%nat (snd Ln_LLT_Perm))))%prg))
)
)
(DiagonalQubits (fst (fst Ln_LLT_Perm)) (snd (fst Ln_LLT_Perm)))
) ->
Cap la ⇒ Sep Ln_LLT_Perm

where "x ⇒ y" := (implies x y).

(* Unfold: X2 Y0 Z1 => Y Z X
(to_fun [X; Y; Z]) ∘ (perm_inv 3 (to_fun [2; 0; 1])) = (to_fun [Y; Z; X])

Fold: Y Z X => X2 Y0 Z1
(to_fun [Y; Z; X]) ∘ (to_fun [2; 0; 1]) = (to_fun [X; Y; Z]) *)


Lemma pad_Sep_listP_succ : forall (l0 : list Pauli) (l : list nat) (n : nat),
    length l0 = length l -> (length l <= n)%nat -> incl l (List.seq 0 n) ->
    (pad_Sep_listP l0 l (s n)) = (pad_Sep_listP l0 l n) ++ [gI].
Proof. intros l0 l n H0 H1 H2.
  gen l0 n.
  induction l; intros.
  - rewrite ! pad_Sep_listP_nil_r.
    simpl. rewrite repeat_cons. auto.
  - simpl in *.
    destruct l0; simpl in *; try lia.
    apply Nat.succ_inj in H0.
    assert (length l <= n)%nat by lia.
    apply incl_cons_inv in H2.
    destruct H2.
    specialize (IHl l0 H0 n H3 H4).
    rewrite IHl.
    rewrite in_seq in H2.
    rewrite switch_inc at 1.
    rewrite skipn_app.
    rewrite pad_Sep_listP_length.
    assert (s a - n = 0)%nat by lia.
    rewrite H5.
    rewrite skipn_O.
    rewrite firstn_app.
    rewrite pad_Sep_listP_length.
    assert (a - n = 0)%nat by lia.
    rewrite H6.
    rewrite firstn_O.
    rewrite app_nil_r.
    rewrite switch_inc.
    rewrite ! app_assoc.
    f_equal.
    rewrite pad_Sep_listP_length; lia.
    rewrite app_length, pad_Sep_listP_length; lia.
Qed.

(** A ∩ B => A ∩ AB **)
Lemma PauliMultLeft_simpl : forall {n : nat} (v : Vector (2 ^ n)) (T1 T2 : TType n),
    proper_length_TType T1 -> proper_length_TType T2 ->
    vecSatisfiesP v T1 -> vecSatisfiesP v T2 -> vecSatisfiesP v (gMulT T1 T2).
Proof. intros n v T1 T2 H0 H1 H2 H3.
  simpl in *.
  unfold translateA in *. simpl in *.
  rewrite Mplus_0_l in *.
  destruct H2, H3; simpl in *.
  destruct T1. destruct T2.
  setoid_rewrite translate_gMulT.
  unfold translate in *. simpl in *.
  rewrite <- Mscale_assoc.
  rewrite <- Mscale_mult_dist_r.
  rewrite <- Mscale_mult_dist_l.
  rewrite map_length.
  split; auto.
  unfold Eigenpair in *.
  simpl in *.
  rewrite Mscale_1_l in *.
  destruct H0, H1; simpl in *.
  rewrite H6 in *.
  setoid_rewrite Mmult_assoc.
  setoid_rewrite H5.
  setoid_rewrite H4.
  reflexivity.
  destruct H0, H1; simpl in *.
  subst.
  assumption.
Qed.

(** A ∩ AB => A ∩ B **)
Lemma PauliMultLeft_inv_simpl : forall {n : nat} (v : Vector (2 ^ n)) (T1 T2 : TType n),
    proper_length_TType T1 -> proper_length_TType T2 ->
    (fst T1 = C1 \/ fst T1 = Copp C1) ->
    vecSatisfiesP v T1 -> vecSatisfiesP v (gMulT T1 T2) -> vecSatisfiesP v T2.
Proof. intros n v T1 T2 H0 H1 H2 H3 H4. 
  simpl in *.
  unfold translateA in *. simpl in *.
  rewrite Mplus_0_l in *.
  destruct H3, H4.
  split; auto.
  unfold Eigenpair in *. simpl in *.
  rewrite Mscale_1_l in *.
  rewrite translate_gMulT_split in H6.
  apply @Mmult_inj_l with (i:= (2^n)%nat) (m:= translate T1) in H6.
  rewrite <- ! Mmult_assoc in H6.
  rewrite translate_mult_inv in H6.
  rewrite Mmult_1_l in H6.
  rewrite H5 in H6; easy.
  apply WF_translate.
  all : auto; destruct H0, H1; auto.
Qed.


(** *** prove that the semantics are actually implications *** **)
Lemma interpret_implies {n} (A B : Predicate n) :
  A ⇒ B -> (forall v : Vector (2 ^ n), vecSatisfiesP v A -> vecSatisfiesP v B).
Proof.
  intros H0 v H1.
  induction H0.
  - auto.
  - inversion H1. constructor; auto.
    apply (incl_Forall H0); auto.
  - constructor; auto.
  - destruct H1; [right | left]; auto.
  - destruct H1 as [H' | [H' | H']]; 
      [left; left | left; right | right]; auto.
  - destruct H1 as [[H' | H'] | H']; 
      [left | right; left | right; right]; auto.
  - subst.
    simpl in *.
    destruct H1.
    split; auto.
    rewrite Forall_map.
    rewrite Forall_map in H6.
    simpl in *.
    destruct H5 as [j [k [H5 [H7 [H8 H9]]]]].
    rewrite Forall_nth in H6.
    rewrite Forall_nth.
    intros i d H10.
    rewrite H9.
    bdestruct (i =? j)%nat.
    + subst. 
      rewrite nth_switch_miss; auto.
    + bdestruct (i =? k)%nat.
      * subst.
        rewrite nth_switch_hit; auto.
        apply PauliMultLeft_simpl; simpl;
        try apply H6; auto; apply Forall_nth; auto.
      * rewrite nth_switch_miss; auto.
        assert (length Lt2 = length Lt1).
        { rewrite H9. rewrite switch_len; auto. }
        apply H6; rewrite <- H13; auto.
  - subst.
    assert (PauliMult_listT Lt1 Lt2).
    { constructor; auto. }
    apply PauliMult_listT_swap in H7; auto.
    inversion H7.
    simpl in *.
    destruct H1.
    split; auto.
    rewrite Forall_map.
    rewrite Forall_map in H11.
    simpl in *.
    destruct H10 as [j [k [H10 [H12 [H13 H14]]]]].
    rewrite Forall_nth in H11.
    rewrite Forall_nth.
    intros i d H15.
    rewrite H14.
    bdestruct (i =? j)%nat.
    + subst. 
      rewrite nth_switch_miss; auto.
    + bdestruct (i =? k)%nat.
      * subst.
        rewrite nth_switch_hit; auto.
        apply PauliMultLeft_simpl; simpl;
        try apply H11; auto; apply Forall_nth; auto.
      * rewrite nth_switch_miss; auto.
        assert (length Lt2 = length Lt1).
        { rewrite H14. rewrite switch_len; auto. }
        apply H11; rewrite H18; auto.
  - destruct A, B; try easy.
    simpl in *.
    unfold translateA in *.
    unfold gAddA in *.
    rewrite map_app in *.
    rewrite fold_left_Mplus_app_Zero in *.
    rewrite Mplus_comm.
    assumption.
  - destruct A, B, C; try easy.
    simpl in *.
    unfold gAddA in *.
    rewrite app_assoc.
    assumption.
  - destruct A, B, C; try easy.
    simpl in *.
    unfold gAddA in *.
    rewrite <- app_assoc.
    assumption.
  - destruct A, B, C; try easy.
    simpl in *.
    unfold gAddA in *.
    unfold translateA in *.
    rewrite map_app in H1.
    rewrite fold_left_Mplus_app_Zero in H1.
    assert (fold_left Mplus (map translate (gMulA (gScaleA C0 a1) a0)) Zero = Zero).
    { clear H1. clear a.
      unfold gScaleA in *.
      unfold gScaleT in *.
      induction a1.
      - easy.
      - simpl.
        rewrite map_app.
        rewrite map_map.
        rewrite fold_left_Mplus_app_Zero.
        rewrite IHa1.
        rewrite Mplus_0_r.
        destruct a.
        rewrite Cmult_0_l.
        clear IHa1.
        induction a0.
        + easy.
        + simpl in *. rewrite fold_left_Mplus.
          rewrite IHa0.
          rewrite Mplus_0_l.
          destruct a.
          unfold translate.
          simpl.
          rewrite ! Cmult_0_l.
          rewrite Mscale_0_l.
          reflexivity. }
    rewrite H0 in H1.
    rewrite Mplus_0_r in H1.
    assumption.
  - subst.
    destruct Ln_LLT_Perm as [[Ln LLT] Perm].
    simpl in *. destruct H1; split; auto.
    rewrite Forall_forall in *.
    intros a H4.
    rewrite in_map_iff in H4.
    destruct H4 as [t [H4 H5]].
    specialize (H1 t H5).
    rewrite <- H4.
    unfold TtoA, translateA in *.
    simpl in *.
    rewrite Mplus_0_l.
    unfold translate in *. simpl in *.
    assert (map translate_P
             (collect_fun (fold_right Nat.add 0%nat Ln)
                (to_fun gI (snd t)
                 ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg) =
              (collect_fun (fold_right Nat.add 0%nat Ln)
                           (to_fun (translate_P gI) (map translate_P (snd t)) ∘
                                   perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg)).
    { rewrite collect_fun_to_fun_map. auto. }
    rewrite H6. simpl.
    assert (length (map translate_P (snd t)) = (fold_right Nat.add 0%nat Ln)).
    { specialize (H2 t H5). destruct H2. rewrite map_length. auto. }
    assert ((fst t
     .* (⨂ collect_fun (fold_right Nat.add 0%nat Ln)
             (to_fun (I 2) (map translate_P (snd t))
              ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg)) =
              (fst t
     .* (⨂ collect_fun (length (map translate_P (snd t)))
             (to_fun (I 2) (map translate_P (snd t))
              ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg))).
    { rewrite H7. auto. }
    setoid_rewrite H8.
    rewrite <- permute_kron_inv.
    rewrite H7.
    rewrite map_length, collect_fun_length in *.
    rewrite <- Mscale_mult_dist_l. rewrite <- Mscale_mult_dist_r.
    apply H1.
    rewrite Forall_forall. intros x H9.
    rewrite in_map_iff in H9.
    destruct H9 as [P [tPx inx]].
    rewrite <- tPx. destruct P; simpl; auto with wf_db.
    rewrite map_length in *. rewrite H7.
    apply perm_inv_permutation.
    apply Permutation_permutation_seq.
    apply Permutation_sym; auto.
  - subst.
    destruct Ln_LLT_Perm as [[Ln LLT] Perm].
    simpl in *. destruct H1; split; auto.
    rewrite Forall_forall in *.
    intros t H4.
    specialize (H2 t H4).
    unfold TtoA, translateA in *.
    specialize (H1
                  [(fst t,
               collect_fun (fold_right Nat.add 0%nat Ln)
                 (to_fun gI (snd t)
                  ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg)]
               ).
    assert (In
         [(fst t,
           collect_fun (fold_right Nat.add 0%nat Ln)
             (to_fun gI (snd t)
              ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg)]
         (map
            (fun t : TType (fold_right Nat.add 0%nat Ln) =>
             [(fst t,
               collect_fun (fold_right Nat.add 0%nat Ln)
                 (to_fun gI (snd t)
                  ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg)])
            (DiagonalQubits Ln LLT))).
    { rewrite in_map_iff. exists t. split; auto. }
    specialize (H1 H5).
    simpl in H1.
    rewrite Mplus_0_l in H1.
    unfold translate in *. simpl in *.
    rewrite collect_fun_to_fun_map in H1.
    simpl in *.
    assert (length (map translate_P (snd t)) = (fold_right Nat.add 0%nat Ln)).
    { rewrite map_length. destruct H2. auto. }
    assert ((fst t
          .* (⨂ collect_fun (fold_right Nat.add 0%nat Ln)
                  (to_fun (I 2) (map translate_P (snd t))
                   ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg)) =
              (fst t
          .* (⨂ collect_fun (length (map translate_P (snd t)))
                  (to_fun (I 2) (map translate_P (snd t))
                   ∘ perm_inv (fold_right Nat.add 0%nat Ln) (to_fun 0%nat Perm))%prg))).
    { rewrite H6. auto. }
    setoid_rewrite H7 in H1.
    rewrite <- permute_kron_inv in H1.
    rewrite H6 in H1.
    rewrite map_length, collect_fun_length in *.
    rewrite <- Mscale_mult_dist_l in H1. rewrite <- Mscale_mult_dist_r in H1.
    apply H1.
    rewrite Forall_forall. intros x H8.
    rewrite in_map_iff in H8.
    destruct H8 as [P [tPx inx]].
    rewrite <- tPx. destruct P; simpl; auto with wf_db.
    rewrite map_length in *. rewrite H6.
    apply perm_inv_permutation.
    apply Permutation_permutation_seq.
    apply Permutation_sym; auto.
Qed.


(** ** rules ** **)

Lemma CONS : forall {n : nat} (A B : Predicate n) {A' B' : Predicate n} {g : prog},
    A' ⇒ A -> B ⇒ B' -> {{ A }} g {{ B }} -> {{ A' }} g {{ B' }}.
Proof. intros n A B A' B' g H0 H1 H2. 
  unfold triple in *.
  intros v H3.
  apply (interpret_implies B B' H1 (translate_prog n g × v)).
  apply H2.
  apply (interpret_implies A' A H0 v).
  assumption.
Qed.


(*** Normalization is admissible ***)
Lemma normalization_admissible :
  forall {n : nat} (P : Predicate n) (U : prog) (Lt : list (TType n)),
    Forall proper_length_TType Lt ->
    {{P}} U {{Cap (map TtoA Lt)}} ->
    {{P}} U {{Cap (map TtoA (normalize Lt))}}.
Proof. intros n P U Lt ForallPLT H0.
  bdestruct (length Lt =? 0)%nat.
  - rewrite length_zero_iff_nil in H1.
    subst. rewrite normalize_nil. auto.
  - destruct (normalize_PauliMult_listT_chain_Permutation n Lt H1) as [[Lt' [H2 H3]]].
    apply CONS with (A := P) (B := Cap (map TtoA Lt')).
    apply ID_implies. apply CapElim.
    apply Permutation_sym in H3.
    apply Permutation_incl in H3. 
    apply incl_map. auto.
    clear H1 H3.
    induction H2; subst; auto. 
    + inversion H1.
      apply CONS with (A := P) (B := Cap (map TtoA Lt1)); auto.
      apply ID_implies.
      apply PauliMultLeft with (Lt1 := Lt1) (Lt2 := Lt2); auto.
      apply PauliMult_listT_preserves_proper_length_TType with (Lt1 := Lt1); auto.
    + apply IHPauliMult_listT_chain2.
      apply PauliMult_listT_chain_preserves_proper_length_TType with (Lt1 := Lt1); auto.
      apply IHPauliMult_listT_chain1; auto.
Qed.

Lemma normalization_admissible' :
  forall {n : nat} (P : Predicate n) (U : prog) (Lt : list (TType n)),
    Forall WF_TType Lt ->
    {{P}} U {{Cap (map TtoA Lt)}} ->
    {{P}} U {{Cap (map TtoA (normalize Lt))}}.
Proof. intros n P U Lt H0 H1.
  apply normalization_admissible; auto.
  apply Forall_impl with (P := WF_TType); auto.
  intros a H2.
  inversion H2; auto.
Qed.


Definition ith_TType {n} (bit : nat) (T : TType n) : Pauli :=
  match T with
  | (c, l) => nth bit l gI
  end.

Compute @ith_TType 4 (0) (C1, [gI;gX;gY;gZ]).


Definition ith_switch_TType {n} (bit : nat) (T : TType n) (T' : TType 1) : TType n :=
  match T with
  | (c, l) => match T' with
              | (c', l') => ((c * c')%C, switch l (hd gI l') bit)
              end
  end.

Compute @ith_switch_TType 4 (0) (C1, [gI;gX;gY;gZ]) (C1, [gX]).


Local Open Scope nat_scope.

(** ** not needed?
Ltac unfold_triple  :=
  unfold triple in *;
  repeat (match goal with
          | H : _ /\ is_Heisenberg_triple _ _ _ |- _ => destruct H
          end;
          try match goal with
            | H : is_Heisenberg_triple (G _) _ (G _) |- _ => inversion H; clear H
            end;
          repeat match goal with
            | H : CPredicate (G _) |- _ => inversion H
            | H : APredicate (G _) |- _ => clear H
            | H : APredicate _ |- _ => inversion H; clear H; subst
            | H : translate_prog _ _ × translateP (G _) =
                    translateP (G _) × translate_prog _ _  |- _ => simpl in H
            end);
  try split; simpl;
  try(apply Heisenberg_neg_l; constructor);
  try(apply Heisenberg_neg_r; constructor);
  try(apply Heisenberg_Err_l);
  try(apply Heisenberg_Err_r);
  try(apply Heisenberg;
      match goal with
      | |- APredicate (G _) => constructor
      | |- translate_prog _ _ × translateP (G _) =
             translateP (G _) × translate_prog _ _  => simpl
      end).

Ltac unfold_triple  :=
  unfold triple in *;
  unfold tripleA in *;
  repeat (match goal with
          | H : _ /\ is_Heisenberg_triple _ _ _ |- _ => destruct H
          end;
          try match goal with
            | H : is_Heisenberg_triple _ _ _ |- _ => inversion H; clear H
            end;
          repeat match goal with
            | H : translate_prog _ _ × translateA _ =
                    translateA _ × translate_prog _ _  |- _ => simpl in H
            end);
  try split; simpl in *;
  try(apply Heisenberg;
      match goal with
      | |- translate_prog _ _ × translateA _ =
             translateA _ × translate_prog _ _  => simpl
      end).
*)



Lemma SEQ : forall {n} {A : Predicate n} (B : Predicate n) {C : Predicate n} {g1 g2 : prog},
    {{ A }} g1 {{ B }} -> {{ B }} g2 {{ C }} ->  {{ A }} g1 ;; g2 {{ C }}.
Proof.
  intros n A B C g1 g2 H0 H1.
  unfold triple in *.
  intros v H2.
  specialize (H0 v).
  specialize (H1 (translate_prog n g1 × v)).
  apply H0 in H2.
  apply H1 in H2.
  simpl.
  rewrite Mmult_assoc.
  assumption.
Qed.

(*Lemma CAP : forall {n : nat} {A A' B B' : Predicate n} {g : prog},
    {{ A }} g {{ A' }} -> {{ B }} g {{ B' }} -> {{ A ∩ B }} g {{ A' ∩ B' }}.
Proof. intros n A A' B B' g H0 H1.
  unfold triple in *.
  intros v H2.
  destruct H2.
  specialize (H0 v H2).
  specialize (H1 v H3).
  split; auto.
Qed.*)
Lemma CAP : forall {n : nat} {La La' : list (AType n)} {g : prog},
    length La = length La' ->
    Forall (fun p : (AType n)*(AType n) => {{ fst p }} g {{ snd p }}) (combine La La') ->
    {{ Cap La }} g {{ Cap La' }}.
Proof. intros n La La' g H0 H1.
  unfold triple in *.
  intros v H2.
  destruct H2.
  gen La'. induction H3; intros.
  - simpl in *.
    split; auto with wf_db.
    symmetry in H0.
    rewrite length_zero_iff_nil in H0.
    subst; auto.
  - destruct La'. 
    + simpl; split; auto with wf_db.
    + simpl in *. 
      split; auto with wf_db.
      inversion H4; subst; clear H4.
      simpl in *. constructor. 
      * apply H7; auto. 
      * apply IHForall; auto.
Qed.

Lemma CAP' : forall {n : nat} {La La' : list (AType n)} {g : prog},
    Forall2 (fun a b : AType n => {{ a }} g {{ b }}) La La' ->
    {{ Cap La }} g {{ Cap La' }}.
Proof. intros n La La' g H0.
  apply CAP.
  apply Forall2_length in H0; auto.
  induction H0; auto.
  simpl.
  rewrite Forall_cons_iff.
  simpl; split; auto.
Qed.

Lemma split_Forall2 : 
  forall {A B : Type} {R : A -> B -> Prop} {a : A} {la : list A} {b : B} {lb : list B},
    R a b -> Forall2 R la lb ->
    Forall2 R (a :: la) (b :: lb).
Proof. intros. constructor; auto. Qed. 

Lemma CUP : forall {n : nat} {A A' B B' : Predicate n} {g : prog},
    {{ A }} g {{ A' }} -> {{ B }} g {{ B' }} -> {{ A ⊍ B }} g {{ A' ⊍ B' }}.
Proof. intros n A A' B B' g H0 H1.
  unfold triple in *.
  intros v H2.
  destruct H2.
  - specialize (H0 v H2).
    simpl. left. auto.
  - specialize (H1 v H2).
    simpl. right. auto.
Qed.


(** The SCALE, MUL, ADD rules can be replaced by the POLY / LINCOMB rule **)
Lemma SCALE : forall {n : nat} (c : Coef) (a a' : AType n) (g : prog),
    WF_AType a -> WF_AType a' ->
    {{ AtoPred a }} g {{ AtoPred a' }} -> {{ scale c (AtoPred a) }} g {{ scale c (AtoPred a') }}.
Proof. intros n c a a' g H0 H1 H2.
  apply Heisenberg_Eigenvector_semantics.
  pose (WF_AType_implies_proper_length_AType a H0).
  pose (WF_AType_implies_proper_length_AType a' H1).
  rewrite (translateA_gScaleA c a p).
  rewrite (translateA_gScaleA c a' p0).
  distribute_scale.
  f_equal.
  inversion H0. inversion H1. subst.
  apply Eigenvector_Heisenberg_semantics in H2;
    try apply proper_length_AType_implies_proper_length_AType_nil;
    try apply restricted_addition_semantic_implies_Unitary;
    try apply restricted_addition_semantic_implies_Hermitian;
    try apply restricted_addition_semantic_implies_trace_zero;
    try apply restricted_addition_syntactic_implies_semantic;
    try apply restricted_addition_syntactic_implies_proper_length_AType;
    auto.
Qed.

Lemma SCALE' : forall {n : nat} (c : Coef) (a a' : AType n) {a0 a0' : AType n} {g : prog},
    WF_AType a -> WF_AType a' -> a0 = gScaleA c a -> a0' = gScaleA c a' ->
    {{ AtoPred a }} g {{ AtoPred a' }} -> {{ AtoPred a0 }} g {{ AtoPred a0' }}.
Proof. intros n c a a' a0 a0' g H0 H1 H2 H3 H4.
  subst. apply SCALE; auto.
Qed.

Lemma UNFLIP : forall {n : nat} (a a' : AType n) {a0 a0' : AType n} {g : prog},
    WF_AType a -> WF_AType a' -> a0 = gScaleA (- C1)%C a -> a0' = gScaleA (- C1)%C a' -> {{ AtoPred a }} g {{ AtoPred a' }} -> {{ AtoPred a0 }} g {{ AtoPred a0' }}.
Proof. intros n c a a' a0 a0' g H0 H1 H2 H3 H4.
  subst. apply SCALE; auto.
Qed.

Lemma FLIP : forall {n : nat} (a a' : AType n) {a0 a0' : AType n} {g : prog},
    WF_AType a -> WF_AType a' -> a = gScaleA (- C1)%C a0 -> a' = gScaleA (- C1)%C a0' -> {{ AtoPred a }} g {{ AtoPred a' }} -> {{ AtoPred a0 }} g {{ AtoPred a0' }}.
Proof. intros n a a' a0 a0' g H0 H1 H2 H3 H4.
  subst. eapply UNFLIP. Unshelve. 
  6 : apply (gScaleA (- C1)%C a0). 6 : apply (gScaleA (- C1)%C a0').
  all : auto.
  - unfold gScaleA. rewrite map_map.
    assert ((fun x : TType n => gScaleT (- C1)%C (gScaleT (- C1)%C x)) = fun x => x).
    + apply functional_extensionality. intros x.
      rewrite gScaleT_merge. replace (- C1 * - C1)%C with C1 by lca.
      rewrite gScaleT_1. auto.
    + rewrite H2. rewrite map_id. auto.
  - unfold gScaleA. rewrite map_map.
    assert ((fun x : TType n => gScaleT (- C1)%C (gScaleT (- C1)%C x)) = fun x => x).
    + apply functional_extensionality. intros x.
      rewrite gScaleT_merge. replace (- C1 * - C1)%C with C1 by lca.
      rewrite gScaleT_1. auto.
    + rewrite H2. rewrite map_id. auto.
Qed.

Lemma MUL : forall {n : nat} (a b a' b' : AType n) (g : prog),
    WF_AType a -> WF_AType a' -> WF_AType b -> WF_AType b' ->
    {{ AtoPred a }} g {{ AtoPred b }} -> {{ AtoPred a' }} g {{ AtoPred b' }} -> {{ mul (AtoPred a) (AtoPred a') }} g {{ mul (AtoPred b) (AtoPred b') }}.
Proof. intros n a b a' b' g H0 H1 H2 H3 H4 H5. 
  apply Heisenberg_Eigenvector_semantics.
  inversion H0. inversion H1. inversion H2. inversion H3. subst.
  repeat (rewrite translateA_Mmult;
          try apply restricted_addition_syntactic_implies_proper_length_AType;
          auto).
  apply Eigenvector_Heisenberg_semantics in H4;
    try apply proper_length_AType_implies_proper_length_AType_nil;
    try apply restricted_addition_semantic_implies_Unitary;
    try apply restricted_addition_semantic_implies_Hermitian;
    try apply restricted_addition_semantic_implies_trace_zero;
    try apply restricted_addition_syntactic_implies_semantic;
    try apply restricted_addition_syntactic_implies_proper_length_AType;
    auto.
  apply Eigenvector_Heisenberg_semantics in H5;
    try apply proper_length_AType_implies_proper_length_AType_nil;
    try apply restricted_addition_semantic_implies_Unitary;
    try apply restricted_addition_semantic_implies_Hermitian;
    try apply restricted_addition_semantic_implies_trace_zero;
    try apply restricted_addition_syntactic_implies_semantic;
    try apply restricted_addition_syntactic_implies_proper_length_AType;
    auto.
  rewrite <- Mmult_assoc, H4, Mmult_assoc, H5, Mmult_assoc; auto.
Qed.

Lemma MUL' : forall {n : nat} (a b a' b' : AType n) {a0 b0 : AType n} {g : prog},
    WF_AType a -> WF_AType a' -> WF_AType b -> WF_AType b' ->
    a0 = gMulA a a' -> b0 = gMulA b b' ->
    {{ AtoPred a }} g {{ AtoPred b }} -> {{ AtoPred a' }} g {{ AtoPred b' }} ->
    {{ AtoPred a0 }} g {{ AtoPred b0 }}.
Proof. intros n a b a' b' a0 b0 g H0 H1 H2 H3 H4 H5 H6 H7.
  subst. apply MUL; auto.
Qed.

Lemma MUL_T_anticomm : forall {n : nat} (t0 t1 t2 t3 : TType n) {t t' : TType n} {g : prog},
    anticommute_TType t0 t2 -> WF_TType t0 -> WF_TType t2 ->
    anticommute_TType t1 t3 -> WF_TType t1 -> WF_TType t3 ->
    t = (gScaleT Ci (gMulT t0 t2)) -> t' = (gScaleT Ci (gMulT t1 t3)) ->
    {{ AtoPred [t0] }} g {{ AtoPred [t1] }} -> {{ AtoPred [t2] }} g {{ AtoPred [t3] }} ->
    {{ AtoPred [t] }} g {{ AtoPred [t'] }}.
Proof. intros n t0 t1 t2 t3 t t' g H0 H1 H2 H3 H4 H5 H6 H7 H8 H9. 
  subst.
  replace ([gScaleT Ci (gMulT t0 t2)])
    with (gScaleA Ci (gMulA [t0] [t2]))
    by auto.
  replace ([gScaleT Ci (gMulT t1 t3)])
    with (gScaleA Ci (gMulA [t1] [t3]))
    by auto.
  apply Heisenberg_Eigenvector_semantics.
  rewrite ! translateA_gScaleA.
  rewrite ! translateA_Mmult.
  apply Eigenvector_Heisenberg_semantics' in H8, H9.
  distribute_scale.
  f_equal.
  rewrite <- Mmult_assoc.
  rewrite H8.
  rewrite Mmult_assoc.
  rewrite H9.
  rewrite Mmult_assoc.
  easy.
  all : constructor;
  repeat match goal with
         | |- restricted_addition_syntactic _ => constructor; auto
         | |- proper_length_TType (gMulT _ _) => apply proper_length_TType_gMulT
         | [H' : WF_TType _ |- proper_length_TType _] => inversion H'; subst; clear H'; auto
         end.
Qed.
  
Lemma WF_MUL_T_anticomm : forall {n : nat} (t t' : TType n) {t0 : TType n},
    anticommute_TType t t' -> WF_TType t -> WF_TType t' ->
    t0 = (gScaleT Ci (gMulT t t')) -> WF_AType [t0].
Proof. intros n t t' t0 H0 H1 H2 H3.
  do 2 constructor. subst. apply WF_TType_mul_anticommute; auto.
Qed.

Lemma MUL_T_comm : forall {n : nat} (t0 t1 t2 t3 : TType n) {t t' : TType n} {g : prog},
    commute_TType t0 t2 -> snd t0 <> snd t2 -> WF_TType t0 -> WF_TType t2 ->
    commute_TType t1 t3 -> snd t1 <> snd t3 -> WF_TType t1 -> WF_TType t3 ->
    t = (gMulT t0 t2) -> t' = (gMulT t1 t3) ->
    {{ AtoPred [t0] }} g {{ AtoPred [t1] }} -> {{ AtoPred [t2] }} g {{ AtoPred [t3] }} ->
    {{ AtoPred [t] }} g {{ AtoPred [t'] }}.
Proof. intros n t0 t1 t2 t3 t t' g H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11. 
  subst.
  replace ([gMulT t0 t2])
    with (gMulA [t0] [t2])
    by auto.
  replace ([gMulT t1 t3])
    with (gMulA [t1] [t3])
    by auto.
  apply Heisenberg_Eigenvector_semantics.
  rewrite ! translateA_Mmult.
  apply Eigenvector_Heisenberg_semantics' in H10, H11.
  rewrite <- Mmult_assoc.
  rewrite H10.
  rewrite Mmult_assoc.
  rewrite H11.
  rewrite Mmult_assoc.
  easy.
  all : constructor;
  repeat match goal with
         | |- restricted_addition_syntactic _ => constructor; auto
         | |- proper_length_TType (gMulT _ _) => apply proper_length_TType_gMulT
         | [H' : WF_TType _ |- proper_length_TType _] => inversion H'; subst; clear H'; auto
         end.
Qed.
    
Lemma WF_MUL_T_comm : forall {n : nat} (t t' : TType n) {t0 : TType n},
    commute_TType t t' -> snd t <> snd t' -> WF_TType t -> WF_TType t' ->
    t0 = (gMulT t t') -> WF_AType [t0].
Proof. intros n t t' t0 H0 H1 H2 H3 H4.
  do 2 constructor. subst. apply WF_TType_mul_commute'; auto.
Qed.

Lemma ADD : forall {n : nat} (a a' b b' : AType n) (g : prog),
    WF_AType a -> WF_AType a' -> WF_AType b -> WF_AType b' ->
    {{ AtoPred a }} g {{ AtoPred b }} -> {{ AtoPred a' }} g {{ AtoPred b' }} -> {{ add (AtoPred a) (AtoPred a') }} g {{ add (AtoPred b) (AtoPred b') }}.
Proof. intros n a b a' b' g H0 H1 H2 H3 H4 H5. 
  apply Heisenberg_Eigenvector_semantics.
  inversion H0. inversion H1. inversion H2. inversion H3. subst.
  repeat (rewrite translateA_Add;
          try apply restricted_addition_syntactic_implies_proper_length_AType;
          auto).
  apply Eigenvector_Heisenberg_semantics in H4;
    try apply proper_length_AType_implies_proper_length_AType_nil;
    try apply restricted_addition_semantic_implies_Unitary;
    try apply restricted_addition_semantic_implies_Hermitian;
    try apply restricted_addition_semantic_implies_trace_zero;
    try apply restricted_addition_syntactic_implies_semantic;
    try apply restricted_addition_syntactic_implies_proper_length_AType;
    auto.
  apply Eigenvector_Heisenberg_semantics in H5;
    try apply proper_length_AType_implies_proper_length_AType_nil;
    try apply restricted_addition_semantic_implies_Unitary;
    try apply restricted_addition_semantic_implies_Hermitian;
    try apply restricted_addition_semantic_implies_trace_zero;
    try apply restricted_addition_syntactic_implies_semantic;
    try apply restricted_addition_syntactic_implies_proper_length_AType;
    auto.
  rewrite Mmult_plus_distr_l, Mmult_plus_distr_r, H4, H5; auto.
Qed.

Lemma ADD' : forall {n : nat} (a a' b b' : AType n) {a0 b0 : AType n} {g : prog},
    WF_AType a -> WF_AType a' -> WF_AType b -> WF_AType b' ->
    a0 = gAddA a a' -> b0 = gAddA b b' ->
    {{ AtoPred a }} g {{ AtoPred b }} -> {{ AtoPred a' }} g {{ AtoPred b' }} -> {{ AtoPred a0 }} g {{ AtoPred b0 }}.
Proof. intros n a a' b b' a0 b0 g H0 H1 H2 H3 H4 H5 H6 H7.
  subst. apply ADD; auto.
  Qed.



(* 
U A  =  B  U
U A' =  B' U

We need a more general 'operation' for {A} g {B} and {A'} g {B'} 
when we have well-formedness for A, A', B, B'.

**************************

Given
WF_ATypes A1, ..., An, B1, ..., Bn, and
{A1} g {B1}
{A2} g {B2}
...
{An} g {Bn},

for any polynomial p∈C[X1,...,Xn],
{p(A1,...,An)} g {p(B1,...,Bn)}
holds.

**************************

WE DO NOT WANT TO ADD ANOTHER LAYER ABOVE THE ADDITIVE LAYER TO IMPLEMENT ARBITRARY MULTIPLICATION BETWEEN ADDITIVE TERMS!!!

**************************

HT := Σ_A Σ_g Σ_B ({A} g {B})
pre : HT -> AType (↦ A)
post : HT -> AType (↦ B)
L : list HT
lincombAC : list AType -> list C -> AType
La : list AType
Lc : list C
lincomb La Lc := zipWith gScaleA Lc La
WTS
length Lc = length L -> for every ht in L, pre ht and post ht are WF_ATypes ->
    {lincombAC (map pre L) Lc} g {lincombAC (map post L) Lc}

 *)



Definition HoareTriple (n : nat) :=
  { t : AType n * prog * AType n | (uncurry (uncurry (fun A g B => @triple n (AtoPred A) g (AtoPred B)))) t}.
Definition packHT {n : nat} 
  (pr : AType n) (g : prog) (po : AType n) (pf : @triple n (AtoPred pr) g (AtoPred po)) : HoareTriple n :=
    (exist (uncurry (uncurry (fun A g B => @triple n (AtoPred A) g (AtoPred B)))) (pr, g, po) pf).
Definition precond {n : nat} (ht : HoareTriple n) : AType n := fst (fst (proj1_sig ht)).
Definition circuit {n : nat} (ht : HoareTriple n) : prog := snd (fst (proj1_sig ht)).
Definition postcond {n : nat} (ht : HoareTriple n) : AType n := snd (proj1_sig ht).
Definition validation {n : nat} (ht : HoareTriple n) := proj2_sig ht.

Lemma precond_packHT : 
  forall {n : nat} (pr : AType n) (g : prog) (po : AType n) (pf : @triple n (AtoPred pr) g (AtoPred po)),
    precond (packHT pr g po pf) = pr.
Proof. intros n pr g po pf. auto. Qed.

Lemma circuit_packHT : 
  forall {n : nat} (pr : AType n) (g : prog) (po : AType n) (pf : @triple n (AtoPred pr) g (AtoPred po)),
    circuit (packHT pr g po pf) = g.
Proof. intros n pr g po pf. auto. Qed.

Lemma postcond_packHT : 
  forall {n : nat} (pr : AType n) (g : prog) (po : AType n) (pf : @triple n (AtoPred pr) g (AtoPred po)),
    postcond (packHT pr g po pf) = po.
Proof. intros n pr g po pf. auto. Qed.

Lemma validation_packHT : 
  forall {n : nat} (pr : AType n) (g : prog) (po : AType n) (pf : @triple n (AtoPred pr) g (AtoPred po)),
    validation (packHT pr g po pf) = pf.
Proof. intros n pr g po pf. auto. Qed.

Definition lincombCA {n : nat} (Lc : list C) (La : list (AType n)) : AType n :=
  fold_right (@app (TType n)) [] (zipWith gScaleA Lc La).

Lemma lincombCA_cons : forall {n : nat} (Lc : list C) (La : list (AType n)) (c : C) (a : AType n),
    lincombCA (c :: Lc) (a :: La) = (gScaleA c a) ++ lincombCA Lc La.
Proof. intros n Lc La c a.
    unfold lincombCA.
    rewrite ! zipWith_cons.
    rewrite cons_conc.
    rewrite ! fold_right_app.
    simpl. easy.
Qed.

Lemma LINCOMB :
  forall {n : nat} (g : prog) (Lc : list C) (Lht : list (HoareTriple n)),
    length Lc = length Lht -> Lht <> [] -> Forall (fun ht => WF_AType (precond ht)) Lht ->
    Forall (fun ht => WF_AType (postcond ht)) Lht -> Forall (fun ht => circuit ht = g) Lht ->
    {{ AtoPred (lincombCA Lc (map precond Lht)) }} g {{ AtoPred (lincombCA Lc (map postcond Lht)) }}.
Proof. intros n g Lc Lht H0 H1 H2 H3 H4.
  apply Heisenberg_Eigenvector_semantics.
  gen Lc.
  induction Lht; intros; try contradiction.
  destruct Lc; try discriminate.
  destruct (Nat.eq_dec (length Lht) 0%nat) as [E | E].
  - clear IHLht.
    rewrite length_zero_iff_nil in E.
    subst.
    simpl in H0.
    inversion H0.
    rewrite length_zero_iff_nil in H6.
    subst.
    clear H0. clear H1.
    inversion H4; subst; clear H4.
    inversion H3; subst; clear H3.
    inversion H2; subst; clear H2.
    clear H5. clear H6. clear H7.
    unfold lincombCA, precond, postcond, circuit in *.
    unfold "`" in *.
    destruct a as [[[pr pg] po] pf].
    simpl in *.
    rewrite ! app_nil_r.
    unfold uncurry in *; simpl in *.
    apply Eigenvector_Heisenberg_semantics' in pf; auto.
    apply WF_AType_implies_proper_length_AType in H3, H4.
    rewrite ! translateA_gScaleA; auto.
    distribute_scale.
    f_equal.
    apply pf.
  - pose (length_zero_iff_nil Lht) as E'.
    apply not_iff_compat in E'.
    rewrite E' in E.
    simpl in *.
    rewrite ! lincombCA_cons.
    rewrite ! translateA_app.
    rewrite Mmult_plus_distr_l, Mmult_plus_distr_r.
    inversion H0; clear H0.
    assert (Forall (fun ht : HoareTriple n => WF_AType (precond ht)) Lht)
      by (inversion H2; subst; auto).
    assert (Forall (fun ht : HoareTriple n => WF_AType (postcond ht)) Lht)
      by (inversion H3; subst; auto).
    assert (Forall (fun ht : HoareTriple n => circuit ht = g) Lht)
      by (inversion H4; subst; auto).
    specialize (IHLht E H0 H5 H7 Lc H6).
    rewrite IHLht.
    f_equal.
    assert (WF_AType (precond a))
      by (inversion H2; subst; auto).
    assert (WF_AType (postcond a))
      by (inversion H3; subst; auto).
    assert (circuit a = g)
      by (inversion H4; subst; auto).
    clear H1. clear H2. clear H3. clear H4.
    destruct a as [[[pr pg] po] pf].
    unfold precond, postcond, circuit, uncurry in *.
    simpl in *.
    apply Eigenvector_Heisenberg_semantics' in pf; auto.
    apply WF_AType_implies_proper_length_AType in H8, H9.
    rewrite ! translateA_gScaleA; auto.
    distribute_scale.
    f_equal.
    subst.
    apply pf.
Qed.

Lemma LINCOMB' :
  forall {n : nat} {g : prog} {pr po : AType n} (Lc : list C) (Lpr Lpo : list (AType n))
     (Lht : list (HoareTriple n)),
    length Lc = length Lpr -> length Lpr = length Lpo -> Lc <> [] -> 
    Forall WF_AType Lpr -> Forall WF_AType Lpo -> Forall (fun ht => circuit ht = g) Lht ->
    map precond Lht = Lpr -> map postcond Lht = Lpo ->
    pr = lincombCA Lc Lpr -> po = lincombCA Lc Lpo ->
    {{ AtoPred pr }} g {{ AtoPred po }}.
Proof. intros n g pr po Lc Lpr Lpo Lht H0 H1 H2 H3 H4 H5 H6 H7 H8 H9.
  subst. apply LINCOMB; rewrite ! map_length in *; auto.
  - intro; subst; simpl in *. rewrite length_zero_iff_nil in H0; auto.
  - rewrite <- Forall_map; auto.
  - rewrite <- Forall_map; auto.
Qed.
(* Lemma LINCOMB' :
  forall {n : nat} {g : prog} (Lc : list C) (Lht : list (HoareTriple n)) {pr po : AType n},
    length Lc = length Lht -> Lht <> [] -> Forall (fun ht => WF_AType n (precond ht)) Lht ->
    Forall (fun ht => WF_AType n (postcond ht)) Lht -> Forall (fun ht => circuit ht = g) Lht ->
    pr = lincombCA Lc (map precond Lht) -> po = lincombCA Lc (map postcond Lht) ->
    {{G pr }} g {{G po }}.
Proof. intros n g Lc Lht pr po H0 H1 H2 H3 H4 H5 H6.
  subst. apply LINCOMB; auto.
Qed. *)


(** Not needed??
Definition freemonoidA {n : nat} (La : list (AType n)) : AType n :=
  fold_left gMulA La [(C1, repeat gI n)].

Lemma freemonoidA_cons ...
Lemma freemonoidA_singleton ...
???????????????????????????????????

Definition freealgCA {n : nat} (Lc : list C) (LLa : list (list (AType n))) : AType n :=
  lincombCA Lc (map freemonoidA LLa).

Lemma freealgCA_cons :
  forall {n : nat} (Lc : list C) (LLa : list (list (AType n))) (c : C) (La : list (AType n)),
    freealgCA (c :: Lc) (La :: LLa) = gScaleA c (freemonoidA La) ++ freealgCA Lc LLa.
Proof. intros n Lc LLa c La.
  unfold freealgCA, freemonoidA. simpl.
  rewrite lincombCA_cons. auto.
Qed.

Lemma FREEALG :
  forall {n : nat} (g : prog) (Lc : list C) (LLht : list (list (HoareTriple n))),
    length Lc = length LLht -> LLht <> [] -> Forall (fun Lht => Lht <> []) LLht ->
    Forall (fun Lht => Forall (fun ht => WF_AType n (precond ht)) Lht) LLht ->
    Forall (fun Lht => Forall (fun ht => WF_AType n (postcond ht)) Lht) LLht ->
    Forall (fun Lht => Forall (fun ht => circuit ht = g) Lht) LLht ->
    {{G (freealgCA Lc (map (fun Lht => map precond Lht) LLht)) }}
    g
    {{G (freealgCA Lc (map (fun Lht => map postcond Lht) LLht)) }}.
Proof. intros n g Lc LLht H0 H1 H2 H3 H4 H5.
  apply Heisenberg_Eigenvector_semantics.
  gen Lc.
  induction LLht as [ | Lht LLht]; intros.
  - contradiction.
  - clear H1.
    destruct Lc; simpl in *.
    + inversion H0.
    + inversion H0. clear H0.
      * destruct (Nat.eq_dec (length LLht) 0%nat) as [E | E].
        -- rewrite length_zero_iff_nil in E.
           subst.
           simpl in *.
           rewrite length_zero_iff_nil in H6.
           subst.
           unfold freealgCA, lincombCA; simpl.
           rewrite ! app_nil_r.
           unfold uncurry; simpl.
           destruct Lht; simpl.
**)

           
Lemma prog_simpl_inc_reduce : forall (p : nat -> prog) (prg_len bit : nat),
  simpl_prog p -> bit < prg_len ->
  translate_prog prg_len (p bit) = 
  (Matrix.I (2^bit)) ⊗ translate_prog 1 (p 0) ⊗ (Matrix.I (2^(prg_len - bit - 1))).
Proof. intros p prg_len bit H0 H1. 
       destruct H0; [ | destruct H0];
         do 2 (rewrite H0); 
         simpl;
         unfold prog_simpl_app;
         bdestruct_all;
         rewrite Nat.sub_0_r, Nat.sub_diag, 
                 Nat.pow_0_r, kron_1_l, kron_1_r; auto with wf_db.
Qed.


Lemma prog_ctrl_reduce : forall (prg_len ctrl targ : nat),
  translate_prog (s prg_len) (CNOT (s ctrl) (s targ)) = 
  (Matrix.I 2) ⊗ translate_prog prg_len (CNOT ctrl targ).
Proof. intros.    
       unfold translate_prog, prog_ctrl_app.
       bdestruct_all; simpl.
       all : try (rewrite id_kron, Nat.add_0_r, double_mult; easy).
       - replace (2 ^ ctrl + (2 ^ ctrl + 0)) with (2 * 2^ctrl) by lia. 
         rewrite <- id_kron.
         repeat rewrite kron_assoc; auto with wf_db.  
         repeat rewrite Nat.add_0_r. repeat rewrite double_mult.
         replace 2 with (2^1) by easy. 
         repeat rewrite <- Nat.pow_add_r. 
         replace (ctrl + ((1 + (targ - ctrl)) + (prg_len - targ - 1))) with prg_len by lia; 
         easy. 
       - replace (2 ^ targ + (2 ^ targ + 0)) with (2 * 2^targ) by lia. 
         rewrite <- id_kron.
         repeat rewrite kron_assoc; auto with wf_db.  
         repeat rewrite Nat.add_0_r. repeat rewrite double_mult.
         replace 2 with (2^1) by easy. 
         repeat rewrite <- Nat.pow_add_r. 
         replace (targ + (((ctrl - targ) + 1) + (prg_len - ctrl - 1))) with prg_len by lia;
         easy. 
Qed.

Lemma prog_ctrl_reduce' : forall (prg_len ctrl targ : nat),
    prog_ctrl_app (s prg_len) σx (s ctrl) (s targ) =
      (Matrix.I 2) ⊗ prog_ctrl_app prg_len σx ctrl targ.
Proof. intros prg_len ctrl targ.
  pose (prog_ctrl_reduce prg_len ctrl targ) as H0.
  unfold translate_prog in H0; auto.
Qed.

Lemma WF_helper : forall (l : list Pauli) (i : nat),
  WF_Matrix (nth i (map translate_P l) Zero).
Proof. intros. 
       destruct (nth_in_or_default i (map translate_P l) Zero).
       - apply in_map_iff in i0.
         destruct i0 as [x [H H0] ].
         rewrite <- H.
         apply WF_Matrix_Pauli.
       - rewrite e. easy. 
Qed.

Lemma WF_helper2 : forall {bit} (l : list Pauli), 
  length l = bit ->
  @WF_Matrix (2^ bit) (2^ bit) (⨂ map translate_P l).
Proof. intros; subst.
       assert (H' := (WF_big_kron _ _ (map translate_P l) Zero)).
       rewrite map_length in H'.
       apply H'.
       intros; apply WF_helper.
Qed.

Hint Resolve WF_helper WF_helper2 : wf_db.

Lemma kron_simplify : forall (n m o p : nat) (a b : Matrix n m) (c d : Matrix o p), 
    a = b -> c = d -> a ⊗ c = b ⊗ d.
Proof. intros n m o p a b c d H H0.
       rewrite H, H0.
       easy.
Qed.

Lemma WF_AType_in_trace_zero_syntax : forall {n : nat} (a : AType n) (t : TType n),
    WF_AType a -> In t a -> trace_zero_syntax (snd t).
Proof. intros n a t H0 H1.
  destruct t.
  simpl.
  gen c l.
  inversion H0; subst; clear H0.
  induction H1; intros.
  - inversion H1; subst; clear H1.
    + inversion H0; clear H0.
      auto.
    + inversion H2.
  - rewrite gScaleA_dist_app in H1.
    rewrite in_app_iff in H1.
    assert (H' : (C1 * √ 2 * (C1 / √ 2))%C = C1)
      by (field_simplify_eq; auto; nonzero).
    destruct H1 as [H1 | H1].
    + apply in_gScaleTA_mult with (c := (C1 * √2)%C) in H1.
      rewrite gScaleA_merge in H1.
      rewrite H' in H1.
      rewrite gScaleA_1 in H1.
      simpl in H1.
      specialize (IHrestricted_addition_syntactic1 (C1 * √ 2 * c)%C l H1); auto.
    + apply in_gScaleTA_mult with (c := (C1 * √2)%C) in H1.
      rewrite gScaleA_merge in H1.
      rewrite H' in H1.
      rewrite gScaleA_1 in H1.
      simpl in H1.
      specialize (IHrestricted_addition_syntactic2 (C1 * √ 2 * c)%C l H1); auto.
Qed.

Lemma TEN1 : forall (bit : nat) (pm c : Coef) (l : list Pauli) (A : Pauli) (U : nat -> prog),
    bit < length l -> simpl_prog U -> not_gI (nth bit l gI) -> not_gI A ->
    pm = C1 \/ pm = (- C1)%C ->
    @triple 1 ( AtoPred [ (C1, [nth bit l gI]) ] ) (U 0) ( AtoPred [ (pm, [A]) ] ) ->
    @triple (length l) ( AtoPred [(c, l)] ) (U bit) ( AtoPred [((c * pm)%C, switch l A bit)] ).
Proof. intros bit pm c l A U i_lessthan_n simpl_prog_U notgInth notgIA pm_1 H0.
  apply Heisenberg_Eigenvector_semantics.
  apply Eigenvector_Heisenberg_semantics in H0.

  unfold translateA. simpl. rewrite ! Mplus_0_l.
  unfold translateA in H0. simpl in H0. rewrite ! Mplus_0_l in H0.
  unfold translate in H0. simpl in H0. rewrite ! kron_1_r in H0.
  rewrite ! Mscale_1_l in H0.
  rewrite prog_simpl_inc_reduce. unfold translate. simpl.
  rewrite ! map_length, ! switch_map, ! switch_len.
  rewrite Mscale_mult_dist_r, Mscale_mult_dist_l.
  rewrite <- Mscale_assoc. apply Mscale_inj.
  
  rewrite (switch_inc bit (map translate_P l) (translate_P A)).
  replace (big_kron (map translate_P l))
    with (big_kron (map translate_P (firstn bit l ++ [nth bit l gI] ++ skipn (s bit) l)))
    by (rewrite <- (nth_inc bit l gI); try rewrite length_l_is_n; auto).
  
  rewrite ! map_app, firstn_map, skipn_map.
  replace (map translate_P [nth bit l gI]) with ([translate_P (nth bit l gI)]) by auto.
  rewrite ! big_kron_split.
  setoid_rewrite <- kron_assoc.

  rewrite ! map_length, ! firstn_length.
  replace (Init.Nat.min bit (length l)) with bit by lia.
  
  repeat setoid_rewrite kron_mixed_product'.

  setoid_rewrite <- Mscale_kron_dist_l.
  setoid_rewrite <- Mscale_kron_dist_r.

  all : intros; auto with wf_db unit_db.
 
  f_equal.

  all : try setoid_rewrite map_length; try setoid_rewrite firstn_length; try setoid_rewrite skipn_length.

  all : replace ((length l) - bit - 1) with ((length l) - s bit) by lia; auto.

  f_equal.

  rewrite Mmult_1_l, Mmult_1_r; auto with wf_db.

  1-2 :pose (WF_Matrix_Big_Pauli (firstn bit l)) as w;
  rewrite ! map_length, ! firstn_length in w;
  replace (Init.Nat.min bit (length l)) with bit in w by lia;
  apply w.

  simpl. setoid_rewrite kron_1_r. rewrite <- Mscale_mult_dist_l. assumption.

  setoid_rewrite Mmult_1_l. setoid_rewrite <- Mmult_1_r at 1.
  rewrite map_length, skipn_length.
  f_equal.

  all : try setoid_rewrite map_length; try setoid_rewrite skipn_length; auto with wf_db.

  1-2 :pose (WF_Matrix_Big_Pauli (skipn (s bit) l)) as w;
  rewrite ! map_length, ! skipn_length in w;
  replace (Init.Nat.min bit (length l)) with bit in w by lia.
  replace (((fix length (l : list (Square 2)) : nat := match l with
                                                   | [] => 0
                                                   | _ :: l' => s (length l')
                                                   end)
          (@map Pauli (Square 2) translate_P (@skipn Pauli (s bit) l))))
    with ((length l) - s bit)
    by (setoid_rewrite map_length; rewrite skipn_length; auto).
  apply w.

  all : replace ((fix pow (n m : nat) {struct m} : nat := match m with
                                           | 0 => 1
                                           | s m0 => n * pow n m0
                                           end) 2 ((length l) - s bit))
    with (2 ^ ((length l) - s bit))
    by (unfold pow; auto).
  
  1-3 : setoid_rewrite <- Nat.pow_1_r at 13;
    rewrite <- ! Nat.pow_add_r;
  replace (bit + 1 + ((length l) - s bit)) with (length l) by lia;
  auto.

                                                                 1-2 : simpl; auto with wf_db.
  
  all : try (inversion H1;
             [rewrite <- H2; auto with wf_db | inversion H2]);
    try (rewrite in_map_iff in H1;
         destruct H1 as [x [H1 H2]];
         rewrite <- H1;
         auto with wf_db);
    try (rewrite in_app_iff in H1;
         destruct H1;
         [inversion H1;
          [rewrite <- H2; auto with wf_db | inversion H2] | rewrite in_map_iff in H1;
                                                           destruct H1 as [x [H1 H2]];
                                                           rewrite <- H1;
                                                           auto with wf_db]).
  
  all : try (repeat constructor; intro; lia).
  
  4-6 : destruct pm_1 as [pm_1 | pm_1]; try rewrite ! pm_1.

  all : unfold translateA; simpl; try rewrite Mplus_0_l;
  unfold translate; simpl; try rewrite Mscale_1_l;
  try rewrite kron_1_r; 
  try apply scale_unitary; try lca;
  auto with unit_db.

  1,3-4 : try (rewrite Mscale_adj; f_equal);
  destruct (nth bit l gI); destruct A; simpl;
  try apply id_sa; try apply σx_sa;
  try apply σy_sa; try apply σz_sa;
  try lca.

  1 : unfold not_gI in notgInth;
    destruct notgInth as [H1 | [H1 | H1]];
    rewrite H1; unfold trace; simpl; try lca.
  
  all : unfold not_gI in notgIA;
  destruct notgIA as [H1 | [H1 | H1]];
    rewrite H1; unfold trace; simpl; lca.
Qed.

Lemma TEN1' : forall {bit len : nat} (pm : Coef) {c c' : Coef} {l l' : list Pauli} (A A' : Pauli) {U : nat -> prog},
    bit < len -> simpl_prog U -> not_gI A' -> not_gI A -> pm = C1 \/ pm = (- C1)%C ->
    @triple 1 ( AtoPred [ (C1, [A]) ] ) (U 0) ( AtoPred [ (pm, [A']) ] ) ->
    len = length l -> A = nth bit l gI -> l' = switch l A' bit -> c' = (pm * c)%C ->
    @triple len ( AtoPred [(c, l)] ) (U bit) ( AtoPred [(c', l')] ).
Proof. intros bit len pm c c' l l' A A' U H0 H1 H2 H3 H4 H5 H6 H7 H8 H9. 
  rewrite Cmult_comm in H9.
  subst. apply TEN1; auto.
Qed.

Lemma WF_TEN1 : forall (bit len : nat) (c : Coef) (l : list Pauli),
    bit < len -> not_gI (nth bit l gI) -> len = length l -> c = C1 \/ c = (- C1)%C ->
    @WF_TType len (c, l).
Proof. intros bit len c l H0 H1 H2 H3.
  subst. constructor; simpl; auto.
  - constructor; simpl; auto; lia.
  - destruct H1 as [H' | [H' | H']];
      rewrite nth_inc with (ls := l) (x := gI) (n := bit); auto;
      apply trace_zero_syntax_R;
      apply trace_zero_syntax_L;
      rewrite H'; constructor.
Qed.
  
Lemma WF_TEN2 : forall (bit len : nat) (c : Coef) (l : list Pauli) (A : Pauli),
    bit < len -> not_gI A -> len = length l -> c = C1 \/ c = (- C1)%C ->
    @WF_TType len (c%C, switch l A bit).
Proof. intros bit len c l A H0 H1 H2 H3.
  subst. constructor; simpl; auto.
  - constructor; simpl; try lia.
    rewrite switch_len; auto.
  - destruct H1 as [H' | [H' | H']];
      rewrite switch_inc with (ls := l) (x := A) (n := bit); auto;
      apply trace_zero_syntax_R;
      apply trace_zero_syntax_L;
      rewrite H'; constructor.
Qed.

Lemma TEN_ID : forall (bit : nat) (c : Coef) (l : list Pauli) (U : nat -> prog),
    bit < length l -> simpl_prog U -> nth bit l gI = gI ->
    @triple (length l) ( AtoPred [(c, l)] ) (U bit) ( AtoPred [(c, l)] ).
Proof. intros bit c l U H0 H1 H2.
  apply Heisenberg_Eigenvector_semantics.
  unfold translateA. simpl. rewrite ! Mplus_0_l.

  rewrite prog_simpl_inc_reduce. unfold translate. simpl.
  rewrite ! map_length.
  rewrite Mscale_mult_dist_r, Mscale_mult_dist_l.
  apply Mscale_inj.

  replace (big_kron (map translate_P l))
    with (big_kron (map translate_P (firstn bit l ++ [nth bit l gI] ++ skipn (s bit) l)))
    by (rewrite <- (nth_inc bit l gI); try rewrite length_l_is_n; auto).
  rewrite ! H2.
  
  rewrite ! map_app.
  replace (map translate_P [gI]) with ([translate_P gI]) by auto.
  rewrite ! big_kron_split.
  setoid_rewrite <- kron_assoc.

  rewrite ! map_length, ! firstn_length.
  replace (Init.Nat.min bit (length l)) with bit by lia.
  
  repeat setoid_rewrite kron_mixed_product'.

  all : intros; auto with wf_db unit_db.
 
  f_equal.

  all : try setoid_rewrite map_length; try setoid_rewrite firstn_length; try setoid_rewrite skipn_length.

  all : replace ((length l) - bit - 1) with ((length l) - s bit) by lia; auto.

  f_equal.

  rewrite Mmult_1_l, Mmult_1_r; auto with wf_db.

  1-2 :pose (WF_Matrix_Big_Pauli (firstn bit l)) as w;
  rewrite ! map_length, ! firstn_length in w;
  replace (Init.Nat.min bit (length l)) with bit in w by lia;
  apply w.

  simpl. setoid_rewrite kron_1_r. rewrite Mmult_1_l. rewrite Mmult_1_r. reflexivity.

  1 - 2 : replace 2%nat with (2 ^ 1)%nat by (simpl; lia);
  apply WF_Matrix_translate_prog.

  setoid_rewrite Mmult_1_l. setoid_rewrite <- Mmult_1_r at 1.
  rewrite map_length, skipn_length.
  f_equal.

  all : try setoid_rewrite map_length; try setoid_rewrite skipn_length; auto with wf_db.

  pose (WF_Matrix_Big_Pauli (skipn (s bit) l)) as w;
  rewrite ! map_length, ! skipn_length in w;
  replace (Init.Nat.min bit (length l)) with bit in w by lia.
  replace (((fix length (l : list (Square 2)) : nat := match l with
                                                   | [] => 0
                                                   | _ :: l' => s (length l')
                                                   end)
          (@map Pauli (Square 2) translate_P (@skipn Pauli (s bit) l))))
    with ((length l) - s bit)
    by (setoid_rewrite map_length; rewrite skipn_length; auto).
  apply w.

  all : replace ((fix pow (n m : nat) {struct m} : nat := match m with
                                           | 0 => 1
                                           | s m0 => n * pow n m0
                                           end) 2 ((length l) - s bit))
    with (2 ^ ((length l) - s bit))
    by (unfold pow; auto).
  
  1-3 : setoid_rewrite <- Nat.pow_1_r at 13;
    rewrite <- ! Nat.pow_add_r;
  replace (bit + 1 + ((length l) - s bit)) with (length l) by lia;
  auto.

  all : simpl; auto with wf_db.
  all : try (inversion H3; try inversion H4; subst; clear H3; auto with wf_db).
  all : try (rewrite in_map_iff in H3;
             destruct H3 as [x [H' H'']];
             subst; auto with wf_db).
  all : rewrite app_nil_l in H4;
    rewrite in_map_iff in H4;
    destruct H4 as [x [H' H'']];
    subst; auto with wf_db.
Qed.

Lemma TEN_ID' : forall {bit len : nat} {c c' : Coef} {l l' : list Pauli} {U : nat -> prog},
    bit < len -> len = length l -> simpl_prog U -> nth bit l gI = gI -> l = l' -> c = c' ->
    @triple (len) ( AtoPred [(c, l)] ) (U bit) ( AtoPred [(c', l')] ).
Proof. intros bit len c c' l l' U H0 H1 H2 H3 H4 H5.
  subst; apply TEN_ID; auto.
Qed.

Lemma TEN2_helper1_helper1 : forall (prg_len ctrl targ : nat),
    targ < prg_len -> ctrl < targ -> 
    prog_ctrl_app prg_len σx ctrl targ
    = (I (2^ctrl)) ⊗ prog_ctrl_app (prg_len - ctrl) σx 0 (targ - ctrl).
Proof. intros prg_len ctrl targ targ_bounded ctrl_less_targ.
  gen prg_len targ.
  induction ctrl.
  - intros prg_len targ targ_bounded ctrl_less_targ. 
    simpl.
    replace (prg_len - 0) with prg_len by lia.
    replace (targ - 0) with targ by lia.
    rewrite kron_1_l; auto with wf_db.
  - intros prg_len targ targ_bounded ctrl_less_targ.
    assert (prog_ctrl_app prg_len σx (s ctrl) targ = prog_ctrl_app (s (prg_len - 1)) σx (s ctrl) (s (targ - 1))).
    { replace (s (prg_len - 1)) with prg_len by lia.
      replace (s (targ - 1)) with targ by lia. reflexivity. }
    rewrite H0.
    rewrite prog_ctrl_reduce'.
    rewrite IHctrl; try lia.
    replace (prg_len - 1 - ctrl) with (prg_len - s ctrl) by lia.
    replace (targ - 1 - ctrl) with (targ - s ctrl) by lia.
    replace (2 ^ s ctrl) with (2 * 2 ^ ctrl) by auto.
    rewrite <- id_kron.
    rewrite kron_assoc; auto with wf_db.
    f_equal.
    1 - 2 : rewrite <- Nat.pow_add_r;
    replace (ctrl + (prg_len - s ctrl)) with (prg_len - 1) by lia; auto.
Qed.

Lemma TEN2_helper1_helper2_helper_helper : forall (d : nat),
    (d > 0)%nat ->
    prog_ctrl_app (s d) σx 0 (d) =
      (∣0⟩⟨0∣ ⊗ (I (2 ^ (d - 1)) ⊗ I 2) .+ ∣1⟩⟨1∣ ⊗ (I (2 ^ (d - 1)) ⊗ σx)).
Proof. intros d H0.
  unfold prog_ctrl_app.
  bdestruct_all; simpl.
  rewrite kron_1_l; auto with wf_db.
  replace (d - 0) with d by lia.
  setoid_rewrite <- kron_1_r at 18.
  replace (2 ^ (match d with
                | 0 => s d
                | s l => d - l
                end - 1))
    with 1
    by (destruct d; try contradiction; replace (s d - d - 1) with 0 by lia; auto).
  rewrite ! kron_1_r.
  f_equal.
  4 : rewrite <- kron_assoc; auto with wf_db.
  3 : f_equal.
  5 : rewrite id_kron.
  1 - 5 : replace (2 ^ d) with (2 ^ (d - 1) * 2); auto;
  setoid_rewrite <- Nat.pow_1_r at 10;
  rewrite <- Nat.pow_add_r;
  replace (d - 1 + 1) with d  by lia; auto.
Qed.

Lemma TEN2_helper1_helper2_helper : forall (d a : nat),
    (d > 0)%nat ->
    prog_ctrl_app (a + s d) σx 0 (d) =
      (∣0⟩⟨0∣ ⊗ (I (2 ^ (d - 1)) ⊗ I 2) .+ ∣1⟩⟨1∣ ⊗ (I (2 ^ (d - 1)) ⊗ σx)) ⊗ (I (2 ^ a)).
Proof. intros d a H0.
  destruct a.
  - simpl. replace (d + 0) with d by lia.
    rewrite kron_1_r.
    apply TEN2_helper1_helper2_helper_helper; auto.
  - unfold prog_ctrl_app.
    bdestruct_all.
    simpl.
    rewrite kron_1_l; auto with wf_db.
    replace (d - 0) with d by lia.
    rewrite id_kron.
    replace (2 ^ (d - 1) * 2) with (2 ^ d)
      by (assert (TEMP : d = d - 1 + 1) by lia;
          rewrite TEMP at 1;
          rewrite Nat.pow_add_r;
          auto).
    replace (match d with
             | 0 => s (a + s d)
             | s l => a + s d - l
             end - 1)
      with (a + 1)
      by (destruct d; lia).
    replace (2 ^ a + (2 ^ a + 0))
      with (2 ^ (a + 1))
      by (rewrite Nat.pow_add_r; simpl; lia). 
    f_equal; try lia.
    f_equal.
    setoid_rewrite kron_assoc; auto with wf_db.
    f_equal;
      replace (2 ^ (d - 1) * 2) with (2 ^ d)
      by (assert (TEMP : d = d - 1 + 1) by lia;
          rewrite TEMP at 1;
          rewrite Nat.pow_add_r;
          auto);
      reflexivity.
Qed.

Lemma TEN2_helper1_helper2 : forall (prg_len ctrl targ : nat),
    targ < prg_len -> ctrl < targ -> 
    prog_ctrl_app (prg_len - ctrl) σx 0 (targ - ctrl)
    = (∣0⟩⟨0∣ ⊗ I (2^(targ - ctrl - 1)) ⊗ I 2 .+ ∣1⟩⟨1∣ ⊗ I (2^(targ - ctrl - 1)) ⊗ σx) ⊗
        (I (2^(prg_len - targ - 1))).
Proof. intros prg_len ctrl targ H0 H1.
  pose (TEN2_helper1_helper2_helper (targ - ctrl) (prg_len - targ - 1))
    as H2.
  assert (H3 : targ - ctrl > 0) by lia.
  specialize (H2 H3).
  replace (prg_len - targ - 1 + s (targ - ctrl)) with (prg_len - ctrl) in H2 by lia.
  rewrite H2.
  f_equal; auto with wf_db.
  f_equal; auto with wf_db;
    rewrite kron_assoc;
    auto with wf_db.
Qed.
  
Lemma TEN2_helper1 : forall (prg_len ctrl targ : nat),
    targ < prg_len -> ctrl < targ -> 
    prog_ctrl_app prg_len σx ctrl targ
    = (I (2^ctrl)) ⊗
                    ( ∣0⟩⟨0∣ ⊗ I (2^(targ - ctrl - 1)) ⊗ I 2 .+
                      ∣1⟩⟨1∣ ⊗ I (2^(targ - ctrl - 1)) ⊗ σx) ⊗
                                                                                 (I (2^(prg_len - targ - 1))).
Proof. intros prg_len ctrl targ targ_bounded ctrl_less_targ.
  rewrite TEN2_helper1_helper1; auto.
  rewrite ! kron_assoc; auto with wf_db.
  f_equal.
  1 - 2 : replace (prg_len - ctrl) with (1 + (targ - ctrl - 1) + 1 + (prg_len - targ -1)) by lia;
  rewrite ! Nat.pow_add_r; auto.
  rewrite TEN2_helper1_helper2; try lia.
  f_equal; auto with wf_db.
  f_equal; auto with wf_db;
    setoid_rewrite kron_assoc;
    auto with wf_db.
Qed.

Lemma TEN2_helper2_helper : forall (ctrl targ : nat) (l : list Pauli),
    targ > ctrl ->
    l = (firstn ctrl l) ++
          (firstn 1 (skipn ctrl l)) ++
          (firstn (targ - ctrl - 1) (skipn (ctrl + 1) l)) ++
          (firstn 1 (skipn targ l)) ++
          (skipn (targ + 1) l).
Proof. intros ctrl targ l H0.
  rewrite <- firstn_skipn with (n := ctrl) (l := l) at 1.
  f_equal.
  rewrite <- firstn_skipn with (n := 1) (l := skipn ctrl l) at 1.
  f_equal.
  rewrite skipn_skipn.
  replace (1 + ctrl) with (ctrl + 1) by lia.
  rewrite <- firstn_skipn with (n := (targ - ctrl - 1)) (l := skipn (ctrl + 1) l) at 1.
  f_equal.
  rewrite skipn_skipn.
  replace (targ - ctrl - 1 + (ctrl + 1)) with targ by lia.
  rewrite <- firstn_skipn with (n := 1) (l := (skipn targ l)) at 1.
  f_equal.
  rewrite skipn_skipn.
  replace (1 + targ) with (targ + 1) by lia.
  reflexivity.
Qed.
          
Lemma TEN2_helper2 : forall (ctrl targ : nat) (l : list Pauli),
    targ > ctrl ->
    (⨂ map translate_P l) =
      (⨂ map translate_P (firstn ctrl l))
        ⊗ (⨂ map translate_P (firstn 1 (skipn ctrl l)))
        ⊗ (⨂ map translate_P (firstn (targ - ctrl - 1) (skipn (ctrl + 1) l)))
        ⊗ (⨂ map translate_P (firstn 1 (skipn targ l)))
        ⊗ (⨂ map translate_P (skipn (targ + 1) l)).
Proof. intros ctrl targ l H0.
  repeat (try setoid_rewrite <- big_kron_app;
          try setoid_rewrite <- (map_app translate_P);
          intros; auto with wf_db).
  f_equal.
  repeat setoid_rewrite <- (map_app translate_P).
  f_equal.
  rewrite <- ! app_assoc.
  apply TEN2_helper2_helper; auto.
Qed. 

Lemma switch_inc2: forall {X : Type} (n m : nat) (ls : list X) (x y : X),
    n < length ls -> m < n ->
    (switch (switch ls x n) y m) = firstn m ls ++ [y] ++
                                     firstn (n - m - 1) (skipn (s m) ls) ++ [x] ++
                                     skipn (s n) ls.
Proof. intros X n m ls x y H0 H1.
  assert (m < length (switch ls x n)) by (rewrite switch_len; lia).
  rewrite (switch_inc m (switch ls x n) y H2).
  rewrite (switch_inc n ls x H0).
  setoid_rewrite <- firstn_skipn with (n := m) (l := ls) at 1.
  assert (n = (length (firstn m ls)) + (n - m)) by (rewrite firstn_length_le; lia).
  setoid_rewrite H3 at 1.
  rewrite firstn_app_2 with (n := (n - m)) (l1 := firstn m ls) (l2 := skipn m ls).
  rewrite <- app_assoc.
  rewrite firstn_app with (n := m) (l1 := firstn m ls).
  replace (m - length (firstn m ls)) with 0%nat by (rewrite firstn_length; lia).
  replace (firstn 0%nat (firstn (n - m) (skipn m ls) ++ [x] ++ skipn (s n) ls)) with (@nil X)
    by auto.
  rewrite app_nil_r.
  rewrite firstn_firstn.
  replace (Init.Nat.min m m) with m by lia.
  do 2 f_equal.
  rewrite skipn_app with (n := s m) (l1 := firstn n ls).
  rewrite firstn_skipn_comm with (m := n - m - 1) (n := s m) (l := ls).
  replace (s m + (n - m - 1)) with n by lia.
  f_equal.
  rewrite firstn_length.
  replace (Init.Nat.min n (length ls)) with n by lia.
  replace (s m - n) with 0%nat by lia.
  rewrite skipn_O.
  reflexivity.
Qed.

Lemma TEN2_helper3 : forall (ctrl targ : nat) (l : list Pauli) (A B : Pauli),
    targ > ctrl -> length l > targ ->
    (⨂ map translate_P (switch (switch l A ctrl) B targ)) =
      (⨂ map translate_P (firstn ctrl l))
        ⊗ (⨂ map translate_P [A])
        ⊗ (⨂ map translate_P (firstn (targ - ctrl - 1) (skipn (ctrl + 1) l)))
        ⊗ (⨂ map translate_P [B])
        ⊗ (⨂ map translate_P (skipn (targ + 1) l)).
Proof. intros ctrl targ l A B H0 H1.
  repeat (try setoid_rewrite <- big_kron_app;
          try setoid_rewrite <- map_app;
          intros; auto with wf_db).
  f_equal.
  repeat rewrite <- app_assoc.
  repeat rewrite <- map_app.
  f_equal.
  rewrite switch_switch_diff, switch_inc2; try lia.
  repeat f_equal; lia.
Qed.

Lemma TEN2_helper4_helper1 : forall (prg_len ctrl targ : nat),
    ctrl < prg_len -> targ < ctrl ->
    prog_ctrl_app prg_len σx ctrl targ =
      I (2 ^ targ) ⊗ prog_ctrl_app (prg_len - targ) σx (ctrl - targ) 0.
Proof. intros prg_len ctrl targ H0 H1.
  gen prg_len ctrl.
  induction targ.
  - intros prg_len ctrl H0 H1.
    replace (prg_len - 0) with prg_len by lia.
    replace (ctrl - 0) with ctrl by lia.
    unfold prog_ctrl_app.
    bdestruct_all.
    simpl.
    repeat rewrite ! kron_1_l; auto with wf_db.
    apply WF_kron; auto with wf_db.
    replace (ctrl - 0) with ctrl by lia.
    rewrite ! Nat.add_0_r.
    apply WF_plus; auto with wf_db.
  - intros prg_len ctrl H0 H1.
    destruct ctrl; try lia.
    apply PeanoNat.lt_S_n in H1.
    destruct prg_len; try lia.
    apply PeanoNat.lt_S_n in H0.
    rewrite prog_ctrl_reduce'.
    rewrite IHtarg; try lia.
    replace (s targ) with (1 + targ) by lia.
    rewrite Nat.pow_add_r.
    rewrite <- id_kron.
    replace (2 ^ 1) with 2 by auto.
    rewrite kron_assoc; auto with wf_db.
    f_equal.
    1 - 2 : rewrite <- Nat.pow_add_r;
    f_equal; lia.
Qed.

Lemma TEN2_helper4_helper2_helper_helper : forall (d : nat),
    d > 0 ->
    prog_ctrl_app (s d) σx d 0 =
      I 2 ⊗ I (2 ^ (d - 1)) ⊗ ∣0⟩⟨0∣ .+ σx ⊗ I (2 ^ (d - 1)) ⊗ ∣1⟩⟨1∣ .
Proof. intros d H0.
  unfold prog_ctrl_app.
  bdestruct_all.
  replace (s d - d - 1) with 0%nat by lia.
  simpl.
  rewrite kron_1_l, kron_1_r; auto with wf_db.
  rewrite ! id_kron.
  replace (2 * 2 ^ (d - 1)) with (2 ^ 1 * 2 ^ (d - 1)) by auto.
  rewrite <- Nat.pow_add_r.
  replace (d - 0) with d by lia.
  replace (1 + (d - 1)) with d by lia.
  reflexivity.
Qed. 

Lemma TEN2_helper4_helper2_helper : forall (d a : nat),
    d > 0 ->
    prog_ctrl_app (a + s d) σx d 0 =
      (I 2 ⊗ I (2 ^ (d - 1)) ⊗ ∣0⟩⟨0∣ .+ σx ⊗ I (2 ^ (d - 1)) ⊗ ∣1⟩⟨1∣) ⊗ I (2 ^ a).
Proof. intros d a H0.
  destruct a.
  - simpl. rewrite kron_1_r.
    apply (TEN2_helper4_helper2_helper_helper d H0).
  - unfold prog_ctrl_app.
    bdestruct_all.
    simpl.
    rewrite kron_1_l; auto with wf_db.
    replace (d - 0) with d by lia.
    rewrite id_kron.
    replace (2 ^ (d - 1) * 2) with (2 ^ d)
      by (assert (TEMP : d = d - 1 + 1) by lia;
          rewrite TEMP at 1;
          rewrite Nat.pow_add_r;
          auto).
    replace (match d with
             | 0 => s (a + s d)
             | s l => a + s d - l
             end - 1)
      with (a + 1)
      by (destruct d; lia).
    replace (2 ^ a + (2 ^ a + 0))
      with (2 ^ (a + 1))
      by (rewrite Nat.pow_add_r; simpl; lia).
    replace (2 * 2 ^ (d - 1)) with (2 ^ 1 * 2 ^ (d - 1)) by auto.
    rewrite <- Nat.pow_add_r.
    replace (1 + (d - 1)) with d by lia.
    reflexivity.
Qed.

Lemma TEN2_helper4_helper2 : forall (prg_len ctrl targ : nat),
    ctrl < prg_len ->
    targ < ctrl ->
    prog_ctrl_app (prg_len - targ) σx (ctrl - targ) 0 =
      (I 2 ⊗ I (2 ^ (ctrl - targ - 1)) ⊗ ∣0⟩⟨0∣
   .+ σx ⊗ I (2 ^ (ctrl - targ - 1)) ⊗ ∣1⟩⟨1∣) ⊗ I (2 ^ (prg_len - ctrl - 1)).
Proof. intros prg_len ctrl targ H0 H1.
  replace (prg_len - targ) with ((prg_len - ctrl - 1) + s (ctrl - targ)) by lia.
  apply TEN2_helper4_helper2_helper; lia.
Qed.

Lemma TEN2_helper4 : forall (prg_len ctrl targ : nat),
    ctrl < prg_len ->
    targ < ctrl ->
    prog_ctrl_app prg_len σx ctrl targ =
      I (2 ^ targ)
        ⊗ (I 2 ⊗ I (2 ^ (ctrl - targ - 1)) ⊗ ∣0⟩⟨0∣
         .+ σx ⊗ I (2 ^ (ctrl - targ - 1)) ⊗ ∣1⟩⟨1∣) ⊗ I (2 ^ (prg_len - ctrl - 1)).
Proof. intros prg_len ctrl targ H0 H1.
  rewrite TEN2_helper4_helper1; try lia.
  rewrite kron_assoc; auto with wf_db.
  f_equal;
    try (ring_simplify; replace 4%nat with (2 ^ 2) by auto;
         repeat rewrite <- Nat.pow_add_r; f_equal; lia).
  rewrite TEN2_helper4_helper2; auto; lia.
Qed.


Lemma firstn1_singleton : forall {A : Type} (d : A) (l : list A),
    l <> [] -> firstn 1 l = [hd d l].
Proof. intros A d l H0.
  destruct l; try contradiction; auto.
Qed.

Lemma hd_skipn_nth : forall {A : Type} (d : A) (l : list A) (m : nat),
    hd d (skipn m l) = nth m l d.
Proof. intros A d l m.
  gen m.
  induction l; intros m;  destruct m; simpl; auto.
Qed.


Lemma TEN2 : forall (l : list Pauli) (ctrl targ : nat) (pm c : Coef) (A B : Pauli),
    ctrl < length l -> targ < length l -> ctrl <> targ ->
    not_gI (nth ctrl l gI) \/ not_gI (nth targ l gI) -> not_gI A \/ not_gI B ->
    pm = C1 \/ pm = (- C1)%C ->
    @triple 2 (AtoPred [(C1, [nth ctrl l gI; nth targ l gI])]) (CNOT 0 1) (AtoPred [(pm, [A; B])])  ->
    @triple (length l)
      (AtoPred [(c, l)])
      (CNOT ctrl targ)
      (AtoPred [((c * pm)%C, switch (switch l A ctrl) B targ)]).
Proof. intros l ctrl targ pm c A B ctrl_bounded targ_bounded ctrl_targ_different not_both_gI_ctrl_targ not_both_gI_A_B pm_1 H0.
  apply Heisenberg_Eigenvector_semantics.
  apply Eigenvector_Heisenberg_semantics in H0.

    unfold translateA, translate in H0; simpl in H0.
    rewrite ! Mplus_0_l, ! Mscale_1_l, ! kron_1_r in H0.
    setoid_rewrite <- Mscale_kron_dist_r in H0.

    unfold prog_ctrl_app in H0.
    simpl in H0.
    rewrite ! kron_1_l, ! kron_1_r in H0.
    setoid_rewrite CX_is_CNOT in H0.

    unfold translateA, translate; simpl.
    rewrite ! Mplus_0_l.

    rewrite ! map_length, ! switch_len.
    rewrite Mscale_mult_dist_r,  Mscale_mult_dist_l.
    rewrite <- Mscale_assoc.
    apply Mscale_inj.

    bdestruct (ctrl <? targ).
    2 : shelve.
    rename H1 into ctrl_lt_targ.
    
    rewrite TEN2_helper1.
    rewrite TEN2_helper2 with (ctrl := ctrl) (targ := targ).
    rewrite TEN2_helper3 with (ctrl := ctrl) (targ := targ).

    repeat setoid_rewrite <- kron_assoc.
    repeat rewrite ! kron_1_l.
    repeat rewrite ! kron_1_r.

    rewrite ! map_length.
    rewrite ! firstn_length.
    rewrite ! skipn_length.
    minmax_breakdown.
    rewrite ! Nat.sub_add_distr.

    setoid_rewrite <- Mscale_mult_dist_l with (x := pm).
    setoid_rewrite <- Mscale_kron_dist_l with (x := pm).
    setoid_rewrite <- Mscale_kron_dist_r with (x := pm).

    repeat setoid_rewrite kron_assoc. 
    setoid_rewrite kron_mixed_product'.
    rewrite ! Mmult_1_l.
    rewrite ! Mmult_1_r.
    f_equal.

    3 : repeat setoid_rewrite <- kron_assoc;
    try setoid_rewrite kron_mixed_product';
    try rewrite ! Mmult_1_l;
    try rewrite ! Mmult_1_r.

    3 : f_equal.
    
    3 : setoid_rewrite kron_assoc;
    replace (I (2 ^ (targ - ctrl - 1)) ⊗ I 2) with (I (2 * (2 ^ (targ - ctrl - 1))))
      by (rewrite id_kron; f_equal; lia);
    try setoid_rewrite <- kron_assoc.
    3 : rewrite ! firstn1_singleton with (d := gI);
    try rewrite ! hd_skipn_nth.
    3 : replace (⨂ map translate_P [nth ctrl l gI])
      with (translate_P (nth ctrl l gI)) by (simpl; rewrite kron_1_r; auto).
    3 : replace (⨂ map translate_P [nth targ l gI])
      with (translate_P (nth targ l gI)) by (simpl; rewrite kron_1_r; auto).
    3 : replace (length [A]) with 1 by auto;
      replace (length [B]) with 1 by auto;
      replace (2 ^ 1)%nat with 2 by auto;
      replace (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                   (Nat.pow (Datatypes.S (Datatypes.S O))
                      (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))))
        with (Init.Nat.mul
                 (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                    (Nat.pow (Datatypes.S (Datatypes.S O))
                       (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
                 (Datatypes.S (Datatypes.S O)))
        by lia;
      replace 
        (@Mplus
           (Init.Nat.mul
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (Datatypes.S (Datatypes.S O)))
           (Init.Nat.mul
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (Datatypes.S (Datatypes.S O)))
           (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
              (Init.Nat.mul
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))
                 (Datatypes.S (Datatypes.S O)))
              (Init.Nat.mul
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))
                 (Datatypes.S (Datatypes.S O)))
              (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
                 (Datatypes.S (Datatypes.S O)) qubit0
                 (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit0))
              (I
                 (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                    (Nat.pow (Datatypes.S (Datatypes.S O))
                       (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))))
           (@kron
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
              (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))
                 (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
                    (Datatypes.S (Datatypes.S O)) qubit1
                    (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit1))
                 (I
                    (Nat.pow (Datatypes.S (Datatypes.S O))
                       (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))) σx))
        with
        (@Mplus
           (Init.Nat.mul (Datatypes.S (Datatypes.S O))
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))))
           (Init.Nat.mul (Datatypes.S (Datatypes.S O))
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))))
           (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
                 (Datatypes.S (Datatypes.S O)) qubit0
                 (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit0))
              (I
                 (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                    (Nat.pow (Datatypes.S (Datatypes.S O))
                       (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))))
           (@kron
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))
              (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
              (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))
                 (Nat.pow (Datatypes.S (Datatypes.S O))
                    (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O)))
                 (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
                    (Datatypes.S (Datatypes.S O)) qubit1
                    (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit1))
                 (I
                    (Nat.pow (Datatypes.S (Datatypes.S O))
                       (Init.Nat.sub (Init.Nat.sub targ ctrl) (Datatypes.S O))))) σx))
         by (f_equal; try ring_simplify; replace 4 with (2^2)%nat by (simpl; lia);
            try rewrite <- ! Nat.pow_add_r; f_equal; ring_simplify; lia);
      eapply @cnot_conv_inc with (n := (targ - ctrl - 1))
                                           (a := translate_P (nth ctrl l gI))
                                           (b := translate_P (nth targ l gI))
                                           (a' := translate_P A) (b' := pm .* (translate_P B))
                                           (C := (⨂ map translate_P (firstn (targ - ctrl - 1) (skipn (ctrl + 1) l))))
                                           (C' := (⨂ map translate_P (firstn (targ - ctrl - 1) (skipn (ctrl + 1) l)))).

  all : repeat (try rewrite ! map_length; try rewrite ! firstn_length;
                try rewrite ! skipn_length; minmax_breakdown;
                minmax_breakdown_context;
                repeat rewrite ! Nat.sub_add_distr;
                auto;
                match goal with
                | |- skipn _ _ <> [] => intro H'; apply skipn_nil_length in H'; lia
                | |- (_ <> _)%nat => try (intro; lia)
                | |- trace_zero_syntax _ => simpl;
                                          try (destruct not_both_gI_ctrl_targ
                                              as [[not_gI | [not_gI | not_gI]]  | [not_gI | [not_gI | not_gI]]];
                                               rewrite not_gI);
                                          try (destruct not_both_gI_A_B
                                              as [[not_gI | [not_gI | not_gI]]  | [not_gI | [not_gI | not_gI]]];
                                               rewrite ! not_gI);
                                          match goal with
                                          | |- trace_zero_syntax [?x; ?y] =>
                                              replace [x; y] with ([x] ++ [y]) by auto
                                          end;
                                          try (apply trace_zero_syntax_L; constructor);
                                          try (apply trace_zero_syntax_R; constructor)
                | |- proper_length_AType_nil _ => repeat constructor; try (intro; lia) 
                | |- WF_Unitary _ =>
                    apply restricted_addition_semantic_implies_Unitary;
                    do 2 constructor; simpl; auto
                | |- adjoint _ = _ =>
                    apply restricted_addition_semantic_implies_Hermitian;
                    do 2 constructor ; simpl; auto
                | |- trace _ = _ =>
                    apply restricted_addition_semantic_implies_trace_zero;
                    do 2 constructor; simpl; auto
                | |- _ > _ => try lia
                | |- _ < _ => try lia
                | |- WF_Matrix (_ ⊗ _) => apply WF_kron
                | |- WF_Matrix (⨂ ?l) =>
                    let WF := fresh "WF" in
                    pose (WF_big_kron' 2 2 l) as WF;
                    repeat rewrite ! map_length in WF;
                    repeat rewrite ! firstn_length in WF;
                    repeat rewrite ! skipn_length in WF;
                    minmax_breakdown_context;
                    repeat rewrite ! Nat.sub_add_distr in WF;
                    apply WF;
                    let A' := fresh "A'" in
                    let H' := fresh "H'" in
                    intros A' H';
                    rewrite in_map_iff in H';
                    let x' := fresh "x'" in
                    let H'1 := fresh "H'1" in
                    let H'2 := fresh "H'2" in
                    destruct H' as [x' [H'1 H'2]];
                    rewrite <- H'1;
                    auto with wf_db
                | |- WF_Matrix _ => auto with wf_db
                | |- proper_length_TType _ => split; simpl; auto; try (intro; lia)
                | |- context[(2*?n)%nat] => 
                    replace (2*n)%nat with (2^1 * n)%nat 
                    by (simpl; auto)
                | |- context[(?n*2)%nat] => 
                    replace (n*2)%nat with (n * 2^1)%nat 
                    by (simpl; auto)
                | |- (2 ^ _ = 2 ^ _)%nat =>  f_equal; simpl; try lia
                | |- coef_plus_minus_1 _ => 
                    unfold coef_plus_minus_1; simpl; try (left; easy); try (right; easy)
                | |- _ => try rewrite ! Nat.mul_1_l; try rewrite ! Nat.mul_1_r;
                        repeat setoid_rewrite <- Nat.pow_add_r
                end).

  Unshelve.
  
  rewrite Mscale_kron_dist_r in H0.
  rewrite <- Mscale_kron_dist_l in H0.
  
  assert (targ_lt_ctrl : targ < ctrl) by lia.
  clear H1.

  rewrite TEN2_helper4; try lia.
  rewrite TEN2_helper2 with (ctrl := targ) (targ := ctrl); auto with wf_db.
  rewrite switch_switch_diff; try lia.
  rewrite TEN2_helper3 with (ctrl := targ) (targ := ctrl); auto with wf_db.

  repeat setoid_rewrite <- kron_assoc.
  repeat rewrite ! kron_1_l.
  repeat rewrite ! kron_1_r.

  rewrite ! map_length.
  rewrite ! firstn_length.
  rewrite ! skipn_length.
  minmax_breakdown.
  rewrite ! Nat.sub_add_distr.

  setoid_rewrite <- Mscale_mult_dist_l with (x := pm).
  setoid_rewrite <- Mscale_kron_dist_l with (x := pm).
  setoid_rewrite <- Mscale_kron_dist_r with (x := pm).

  repeat setoid_rewrite kron_assoc. 
  setoid_rewrite kron_mixed_product'.
  rewrite ! Mmult_1_l.
  rewrite ! Mmult_1_r.
  f_equal.
 
  3 : repeat setoid_rewrite <- kron_assoc.
  3 : setoid_rewrite kron_mixed_product';
  try rewrite ! Mmult_1_l;
  try rewrite ! Mmult_1_r.
  3 : f_equal.
  
  3 : replace (I 2 ⊗ I (2 ^ (ctrl - targ - 1))) with (I (2 * (2 ^ (ctrl - targ - 1))))
    by (rewrite id_kron; f_equal; lia).
  3 : rewrite ! firstn1_singleton with (d := gI);
  try rewrite ! hd_skipn_nth.
  3 : replace (⨂ map translate_P [nth ctrl l gI])
    with (translate_P (nth ctrl l gI)) by (simpl; rewrite kron_1_r; auto).
  3 : replace (⨂ map translate_P [nth targ l gI])
    with (translate_P (nth targ l gI)) by (simpl; rewrite kron_1_r; auto).
  3 : replace (length [A]) with 1 by auto;
  replace (length [B]) with 1 by auto;
  replace (2 ^ 1)%nat with 2 by auto;
  replace (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                (Nat.pow (Datatypes.S (Datatypes.S O))
                   (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))))
    with (Init.Nat.mul
            (Init.Nat.mul (Datatypes.S (Datatypes.S O))
               (Nat.pow (Datatypes.S (Datatypes.S O))
                  (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
            (Datatypes.S (Datatypes.S O)))
    by lia;
  replace 
    (@Mplus
       (Init.Nat.mul
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (Datatypes.S (Datatypes.S O)))
       (Init.Nat.mul
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (Datatypes.S (Datatypes.S O)))
       (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
          (Init.Nat.mul
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))
             (Datatypes.S (Datatypes.S O)))
          (Init.Nat.mul
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))
             (Datatypes.S (Datatypes.S O)))
          (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
             (Datatypes.S (Datatypes.S O)) qubit0
             (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit0))
          (I
             (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                (Nat.pow (Datatypes.S (Datatypes.S O))
                   (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))))
       (@kron
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
          (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))
             (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
                (Datatypes.S (Datatypes.S O)) qubit1
                (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit1))
             (I
                (Nat.pow (Datatypes.S (Datatypes.S O))
                   (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))) σx))
    with
    (@Mplus
       (Init.Nat.mul (Datatypes.S (Datatypes.S O))
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))))
       (Init.Nat.mul (Datatypes.S (Datatypes.S O))
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))))
       (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
             (Datatypes.S (Datatypes.S O)) qubit0
             (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit0))
          (I
             (Init.Nat.mul (Datatypes.S (Datatypes.S O))
                (Nat.pow (Datatypes.S (Datatypes.S O))
                   (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))))
       (@kron
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (Init.Nat.mul (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))
          (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
          (@kron (Datatypes.S (Datatypes.S O)) (Datatypes.S (Datatypes.S O))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))
             (Nat.pow (Datatypes.S (Datatypes.S O))
                (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O)))
             (@Mmult (Datatypes.S (Datatypes.S O)) (Datatypes.S O)
                (Datatypes.S (Datatypes.S O)) qubit1
                (@adjoint (Datatypes.S (Datatypes.S O)) (Datatypes.S O) qubit1))
             (I
                (Nat.pow (Datatypes.S (Datatypes.S O))
                   (Init.Nat.sub (Init.Nat.sub ctrl targ) (Datatypes.S O))))) σx))
    by (f_equal; try ring_simplify; replace 4 with (2^2)%nat by (simpl; lia);
        try rewrite <- ! Nat.pow_add_r; f_equal; ring_simplify; lia).

  3 : apply cnot_conv in H0;
  try eapply @notc_conv_inc with (n := (ctrl - targ - 1))
                             (a := translate_P (nth targ l gI))
                             (b := translate_P (nth ctrl l gI))
                             (a' := translate_P B) (b' := pm .* (translate_P A))
                             (C := (⨂ map translate_P (firstn (ctrl - targ - 1) (skipn (targ + 1) l))))
                             (C' := (⨂ map translate_P (firstn (ctrl - targ - 1) (skipn (targ + 1) l)))).

  all : repeat (try rewrite ! map_length; try rewrite ! firstn_length;
                try rewrite ! skipn_length; minmax_breakdown;
                minmax_breakdown_context;
                repeat rewrite ! Nat.sub_add_distr;
                auto;
                match goal with
                | |- skipn _ _ <> [] => intro H'; apply skipn_nil_length in H'; lia
                | |- (_ <> _)%nat => try (intro; lia)
                | |- trace_zero_syntax _ => simpl;
                                          try (destruct not_both_gI_ctrl_targ
                                              as [[not_gI | [not_gI | not_gI]]  | [not_gI | [not_gI | not_gI]]];
                                               rewrite not_gI);
                                          try (destruct not_both_gI_A_B
                                              as [[not_gI | [not_gI | not_gI]]  | [not_gI | [not_gI | not_gI]]];
                                               rewrite ! not_gI);
                                          match goal with
                                          | |- trace_zero_syntax [?x; ?y] =>
                                              replace [x; y] with ([x] ++ [y]) by auto
                                          end;
                                          try (apply trace_zero_syntax_L; constructor);
                                          try (apply trace_zero_syntax_R; constructor)
                | |- proper_length_AType_nil _ _ => repeat constructor; try (intro; lia) 
                | |- WF_Unitary _ =>
                    apply restricted_addition_semantic_implies_Unitary;
                    do 2 constructor; simpl; auto
                | |- adjoint _ = _ =>
                    apply restricted_addition_semantic_implies_Hermitian;
                    do 2 constructor ; simpl; auto
                | |- trace _ = _ =>
                    apply restricted_addition_semantic_implies_trace_zero;
                    do 2 constructor; simpl; auto
                | |- _ > _ => try lia
                | |- _ < _ => try lia
                | |- WF_Matrix (_ ⊗ _) => apply WF_kron
                | |- WF_Matrix (⨂ ?l) =>
                    let WF := fresh "WF" in
                    pose (WF_big_kron' 2 2 l) as WF;
                    repeat rewrite ! map_length in WF;
                    repeat rewrite ! firstn_length in WF;
                    repeat rewrite ! skipn_length in WF;
                    minmax_breakdown_context;
                    repeat rewrite ! Nat.sub_add_distr in WF;
                    apply WF;
                    let A' := fresh "A'" in
                    let H' := fresh "H'" in
                    intros A' H';
                    rewrite in_map_iff in H';
                    let x' := fresh "x'" in
                    let H'1 := fresh "H'1" in
                    let H'2 := fresh "H'2" in
                    destruct H' as [x' [H'1 H'2]];
                    rewrite <- H'1;
                    auto with wf_db
                | |- WF_Matrix _ => auto with wf_db
                | |- proper_length_TType _ _ => split; simpl; auto; try (intro; lia)
                | |- context[(2*?n)%nat] => 
                    replace (2*n)%nat with (2^1 * n)%nat 
                    by (simpl; auto)
                | |- context[(?n*2)%nat] => 
                    replace (n*2)%nat with (n * 2^1)%nat 
                    by (simpl; auto)
                | |- (2 ^ _ = 2 ^ _)%nat =>  f_equal; simpl; try lia
                | |- _ => try rewrite ! Nat.mul_1_l; try rewrite ! Nat.mul_1_r;
                        repeat setoid_rewrite <- Nat.pow_add_r
                end).
Qed.

Lemma TEN2' : forall {l l' : list Pauli} {len ctrl targ : nat} (pm : Coef) {c c' : Coef} (A B A' B' : Pauli),
    ctrl < len -> targ < len -> ctrl <> targ ->
    not_gI A \/ not_gI B -> not_gI A' \/ not_gI B' -> len = length l ->
    A = nth ctrl l gI -> B = nth targ l gI -> l' = switch (switch l A' ctrl) B' targ ->
    pm = C1 \/ pm = (- C1)%C -> c' = (pm * c)%C ->
    @triple 2  (AtoPred [(C1, [A; B])]) (CNOT 0 1) (AtoPred [(pm, [A'; B'])])  ->
    @triple len (AtoPred [(c, l)]) (CNOT ctrl targ) (AtoPred [(c', l')]).
Proof. intros l l' len ctrl targ pm c c' A B A' B' H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11. 
  rewrite Cmult_comm in H10.
  subst. apply TEN2; auto.
Qed.

Lemma WF_TEN3 : forall (l : list Pauli) (ctrl targ len : nat) (A B : Pauli) (c : Coef),
    ctrl < len -> targ < len -> ctrl <> targ -> len = length l -> c = C1 \/ c = (- C1)%C ->
    not_gI (nth ctrl l gI) \/ not_gI (nth targ l gI) ->
    @WF_TType len (c, l).
Proof. intros l ctrl targ len A B c H0 H1 H2 H3 H4 H5. 
  destruct H5.
  - apply (WF_TEN1 ctrl len c l H0 H5 H3 H4).
  - apply (WF_TEN1 targ len c l H1 H5 H3 H4).
Qed. 

Lemma WF_TEN4 : forall (l : list Pauli) (ctrl targ len : nat) (A B : Pauli) (c : Coef),
    ctrl < len -> targ < len -> ctrl <> targ -> len = length l -> c = C1 \/ c = (- C1)%C ->
    not_gI A \/ not_gI B ->
    @WF_TType (len) (c, switch (switch l A ctrl) B targ).
Proof. intros l ctrl targ len A B c H0 H1 H2 H3 H4 H5.
  destruct H5; [rewrite switch_switch_diff; auto | idtac];
    apply WF_TEN2;
    try rewrite switch_len;
    auto.
Qed.

Lemma TEN_ID2 : forall (l : list Pauli) (ctrl targ : nat) (c : Coef),
    ctrl < length l -> targ < length l -> ctrl <> targ -> nth ctrl l gI = gI -> nth targ l gI = gI ->
    @triple (length l) (AtoPred [(c, l)]) (CNOT ctrl targ) (AtoPred [(c, l)]).
Proof. intros l ctrl targ c H0 H1 H2 H3 H4.
  apply Heisenberg_Eigenvector_semantics.
  unfold translateA, translate; simpl.
  rewrite ! Mplus_0_l.

  rewrite ! map_length.
  rewrite Mscale_mult_dist_r,  Mscale_mult_dist_l.
  apply Mscale_inj.

  bdestruct (ctrl <? targ).
  2 : shelve.
  
  rewrite TEN2_helper1.
  rewrite TEN2_helper2 with (ctrl := ctrl) (targ := targ).

  repeat setoid_rewrite kron_assoc.
  setoid_rewrite kron_mixed_product'.
  
  rewrite ! Mmult_1_l.
  rewrite ! map_length.
  rewrite ! firstn_length.
  rewrite ! skipn_length.
  minmax_breakdown.
  rewrite ! Nat.sub_add_distr.
  rewrite ! Mmult_1_r.
  f_equal.
  3 : repeat setoid_rewrite <- kron_assoc;
  try setoid_rewrite kron_mixed_product';
  try rewrite ! Mmult_1_l;
  try rewrite ! Mmult_1_r.
  3 : f_equal.
  3 : repeat setoid_rewrite kron_assoc.
  3 : rewrite ! Mmult_plus_distr_r; rewrite ! Mmult_plus_distr_l.
  3 : repeat setoid_rewrite kron_mixed_product'.
  3 : rewrite ! firstn1_singleton with (d := gI);
  try rewrite ! hd_skipn_nth;
  replace (⨂ map translate_P [nth targ l gI])
    with (translate_P (nth targ l gI))
    by (simpl; rewrite kron_1_r; auto);
  replace (⨂ map translate_P [nth ctrl l gI])
    with (translate_P (nth ctrl l gI))
    by (simpl; rewrite kron_1_r; auto);
  try rewrite H3; try rewrite H4; simpl;
  try rewrite ! Mmult_1_l; try rewrite ! Mmult_1_r; auto.
  
  all : repeat (try rewrite ! map_length; try rewrite ! firstn_length;
                try rewrite ! skipn_length; minmax_breakdown;
                repeat rewrite ! Nat.sub_add_distr;
                match goal with
                | |- skipn _ _ <> [] => intro H'; apply skipn_nil_length in H'; lia
                | |- (_ <> _)%nat => try (intro; lia)
                | |- WF_Matrix (_ ⊗ _) => apply WF_kron
                | |- WF_Matrix (⨂ ?l) =>
                    let WF := fresh "WF" in
                    pose (WF_big_kron' 2 2 l) as WF;
                    repeat rewrite ! map_length in WF;
                    repeat rewrite ! firstn_length in WF;
                    repeat rewrite ! skipn_length in WF;
                    minmax_breakdown_context;
                    repeat rewrite ! Nat.sub_add_distr in WF;
                    apply WF;
                    let A' := fresh "A'" in
                    let H' := fresh "H'" in
                    intros A' H';
                    rewrite in_map_iff in H';
                    let x' := fresh "x'" in
                    let H'1 := fresh "H'1" in
                    let H'2 := fresh "H'2" in
                    destruct H' as [x' [H'1 H'2]];
                    rewrite <- H'1;
                    auto with wf_db
                | |- WF_Matrix _ => auto with wf_db
                | |- _ => simpl; ring_simplify; auto;
                        replace 4%nat with (2^2)%nat by auto;
                        repeat setoid_rewrite <- Nat.pow_add_r;
                        try match goal with
                        | |- (2 ^ _ = 2 ^ _)%nat =>  f_equal
                        end;
                        repeat rewrite ! Nat.sub_add_distr;
                        try lia
                end).

  Unshelve.
  
  rewrite TEN2_helper4; try lia.
  rewrite TEN2_helper2 with (ctrl := targ) (targ := ctrl); auto with wf_db; try lia.
  
  repeat setoid_rewrite kron_assoc.
  setoid_rewrite kron_mixed_product'.
  
  rewrite ! Mmult_1_l.
  rewrite ! map_length.
  rewrite ! firstn_length.
  rewrite ! skipn_length.
  minmax_breakdown.
  rewrite ! Nat.sub_add_distr.
  rewrite ! Mmult_1_r.
  f_equal.
  3 : repeat setoid_rewrite <- kron_assoc;
  try setoid_rewrite kron_mixed_product';
  try rewrite ! Mmult_1_l;
  try rewrite ! Mmult_1_r.
  3 : f_equal.
  3 : repeat setoid_rewrite kron_assoc.
  3 : rewrite ! Mmult_plus_distr_r; rewrite ! Mmult_plus_distr_l.
  3 : repeat setoid_rewrite kron_mixed_product'.
  3 : rewrite ! firstn1_singleton with (d := gI);
  try rewrite ! hd_skipn_nth;
  replace (⨂ map translate_P [nth targ l gI])
    with (translate_P (nth targ l gI))
    by (simpl; rewrite kron_1_r; auto);
  replace (⨂ map translate_P [nth ctrl l gI])
    with (translate_P (nth ctrl l gI))
    by (simpl; rewrite kron_1_r; auto);
  try rewrite H3; try rewrite H4; simpl;
  try rewrite ! Mmult_1_l; try rewrite ! Mmult_1_r; auto.
  
  all : repeat (try rewrite ! map_length; try rewrite ! firstn_length;
                try rewrite ! skipn_length; minmax_breakdown;
                repeat rewrite ! Nat.sub_add_distr;
                match goal with
                | |- skipn _ _ <> [] => intro H'; apply skipn_nil_length in H'; lia
                | |- (_ <> _)%nat => try (intro; lia)
                | |- WF_Matrix (_ ⊗ _) => apply WF_kron
                | |- WF_Matrix (⨂ ?l) =>
                    let WF := fresh "WF" in
                    pose (WF_big_kron' 2 2 l) as WF;
                    repeat rewrite ! map_length in WF;
                    repeat rewrite ! firstn_length in WF;
                    repeat rewrite ! skipn_length in WF;
                    minmax_breakdown_context;
                    repeat rewrite ! Nat.sub_add_distr in WF;
                    apply WF;
                    let A' := fresh "A'" in
                    let H' := fresh "H'" in
                    intros A' H';
                    rewrite in_map_iff in H';
                    let x' := fresh "x'" in
                    let H'1 := fresh "H'1" in
                    let H'2 := fresh "H'2" in
                    destruct H' as [x' [H'1 H'2]];
                    rewrite <- H'1;
                    auto with wf_db
                | |- WF_Matrix _ => auto with wf_db
                | |- _ => simpl; ring_simplify; auto;
                        replace 4%nat with (2^2)%nat by auto;
                        repeat setoid_rewrite <- Nat.pow_add_r;
                        try match goal with
                        | |- (2 ^ _ = 2 ^ _)%nat =>  f_equal
                        end;
                        repeat rewrite ! Nat.sub_add_distr;
                        try lia
                end).
Qed.

Lemma TEN_ID2' : forall {ctrl targ len : nat} {c c' : Coef} {l l' : list Pauli},
    ctrl < len -> targ < len -> ctrl <> targ -> len = length l-> 
    nth ctrl l gI = gI -> nth targ l gI = gI -> c = c' -> l = l' ->
    @triple len (AtoPred [(c, l)]) (CNOT ctrl targ) (AtoPred [(c', l')]).
Proof. intros ctrl targ len c c' l l' H0 H1 H2 H3 H4 H5 H6 H7. 
  subst; apply TEN_ID2; auto.
Qed.

Lemma TEN3 : forall (bit : nat) (pm c : Coef) (l : list Pauli) (A B : Pauli),
    bit < length l -> not_gI (nth bit l gI) -> not_gI A -> not_gI B -> anticommute_Pauli A B ->
    pm = C1 \/ pm = (- C1)%C ->
@triple 1 (AtoPred [(C1, [nth bit l gI])]) (T 0) (AtoPred [((C1/√2)%C, [A]); (((C1/√2) * pm)%C, [B])]) ->
@triple (length l) (AtoPred [(c, l)]) (T bit) (AtoPred [(((C1/√2)*c)%C, switch l A bit); (((C1/√2)*(c * pm))%C, switch l B bit)]).
Proof. intros bit pm c l A B H0 H1 H2 H3 H4 H5 H6. 
  apply Heisenberg_Eigenvector_semantics.
  apply Eigenvector_Heisenberg_semantics in H6.

  unfold translateA, translate in H6; simpl in H6.
  rewrite ! Mplus_0_l, ! Mscale_1_l, ! kron_1_r in H6.

  unfold prog_simpl_app in H6.
  simpl in H6.
  rewrite ! kron_1_l, ! kron_1_r in H6; auto with wf_db.
  rewrite <- Mscale_assoc in H6.
  rewrite <- Mscale_plus_distr_r in H6.
  rewrite  Mscale_mult_dist_l in H6.

  unfold translateA, translate; simpl.
  rewrite ! Mplus_0_l.

  rewrite ! map_length, ! switch_len.
  rewrite Mscale_mult_dist_r.
  rewrite <- ! Mscale_assoc.
  rewrite <- ! Mscale_plus_distr_r.
  rewrite  ! Mscale_mult_dist_l.
  rewrite Mscale_assoc.
  replace (C1 / √ 2 * c)%C with (c * (C1 / √ 2))%C by lca.
  rewrite <- Mscale_assoc.
  apply Mscale_inj.

  unfold prog_simpl_app.
  bdestruct_all.

  replace (⨂ map translate_P l)
    with (⨂ map translate_P (firstn bit l ++ [nth bit l gI] ++ skipn (s bit) l))
    by (rewrite <- (nth_inc bit l gI); auto).
  rewrite ! switch_inc.
  replace (s bit) with (bit + 1) by lia.
  rewrite ! map_app.
  rewrite ! big_kron_app;
    try (intros; auto with wf_db).
  setoid_rewrite <- Mscale_kron_dist_r with (x := pm).
  setoid_rewrite <- Mscale_kron_dist_l with (x := pm).
  setoid_rewrite <- kron_plus_distr_l.
  setoid_rewrite <- kron_plus_distr_r.
  
  setoid_rewrite <- Mscale_mult_dist_l.
  setoid_rewrite <- Mscale_kron_dist_r.
  setoid_rewrite <- Mscale_kron_dist_l.

  repeat setoid_rewrite <- kron_assoc;
    replace ((fix pow (n m : nat) {struct m} : nat :=
                match m with
                | 0 => 1
                | s m0 => n * pow n m0
                end) 2
               ((fix length (l0 : list (Square 2)) : nat :=
                   match l0 with
                   | [] => 0
                   | _ :: l' => s (length l')
                   end) (map translate_P (skipn (bit + 1) l))))
    with (2 ^ (length (map translate_P (skipn (bit + 1) l))))
    by auto.
  
  rewrite ! map_length.
  rewrite ! firstn_length.
  minmax_breakdown.

  setoid_rewrite kron_mixed_product';
    repeat match goal with
      | |- context [2 * ?x] => replace (2 * x) with (2 ^ 1 * x) by (auto; lia)
      end;
    try rewrite <- ! Nat.pow_add_r;
    try match goal with
      | |- 2 ^ _ = 2 ^ _ => f_equal
      end;
    try lia;
    
    try setoid_rewrite map_length;
    try setoid_rewrite firstn_length;
    minmax_breakdown;
    try setoid_rewrite skipn_length;
    try setoid_rewrite Nat.sub_add_distr;
    try ring_simplify; auto; try lia.

  setoid_rewrite kron_mixed_product'; auto; try lia.

  minmax_breakdown.
  rewrite skipn_length.
  
  setoid_rewrite Mmult_1_l.
  rewrite Nat.sub_add_distr.
  setoid_rewrite Mmult_1_r.
  
  do 2 f_equal; try lia.
  simpl. rewrite ! kron_1_r.
  rewrite Mscale_mult_dist_l.
  all : destruct H5; subst;
    auto with wf_db;
    try apply WF_scale;
    try apply WF_plus;
    try rewrite ! Nat.sub_add_distr.
  all : try apply WF_scale;
    try match goal with
      | |- WF_Matrix (⨂ map translate_P ?l) =>
          pose (WF_big_kron' 2 2) as WF;
          specialize (WF (map translate_P l));
          rewrite map_length in WF;
          try rewrite ! firstn_length in WF;
          try rewrite ! skipn_length in WF;
          minmax_breakdown_context;
          try rewrite ! Nat.sub_add_distr in WF;
          apply WF; intros M inM;
          rewrite in_map_iff in inM;
          destruct inM as [X [XM inX]];
          rewrite <- XM;
          auto with wf_db
      end;
    try destruct i; simpl; auto with wf_db;
    replace 2 with (2 ^ 1)%nat by auto;
    repeat match goal with
      | |- coef_plus_minus_1 _ =>
          unfold coef_plus_minus_1; simpl
      | |- C1 = C1 \/ _ => left; reflexivity
      | |- _ \/ (- C1)%C = (- C1)%C => right; reflexivity
      | |- proper_length_TType _ => split; auto; try lia
      | |- trace_zero_syntax _ => simpl;
                                try (destruct H1
                                    as [not_gI | [not_gI | not_gI]];
                                     rewrite ! not_gI);
                                try (destruct H2
                                    as [not_gI | [not_gI | not_gI]];
                                     destruct H3
                                       as [not_gI' | [not_gI' | not_gI']];
                                     try rewrite ! not_gI; try rewrite ! not_gI');
                                constructor
      | |- proper_length_AType_nil _ => repeat constructor; try (intro; lia)
      | |- WF_Unitary _ =>
          apply restricted_addition_semantic_implies_Unitary
      | |- adjoint _ = _ =>
          apply restricted_addition_semantic_implies_Hermitian
      | |- trace _ = _ =>
          apply restricted_addition_semantic_implies_trace_zero
      | |- restricted_addition_semantic [_] => do 2 constructor; simpl
      | |- restricted_addition_semantic [_; _] =>
          replace [((C1 / √ 2)%C, [A]); ((C1 / √ 2 * C1)%C, [B])]
          with (@gScaleA 1 (C1 / √ 2)%C ([(C1,[A])] ++ [(C1,[B])]))
          by (unfold gScaleA; simpl; rewrite ! Cmult_1_r; auto);
          replace [((C1 / √ 2)%C, [A]); ((C1 / √ 2 * - C1)%C, [B])]
            with (@gScaleA 1 (C1 / √ 2)%C ([(C1,[A])] ++ [((- C1)%C,[B])]))
            by (unfold gScaleA; simpl; rewrite ! Cmult_1_r; auto);
          constructor
      end;
    unfold anticommute_AType_semantic, translateA, translate;
    simpl; rewrite ! Mplus_0_l; rewrite ! kron_1_r; repeat rewrite ! Mscale_1_l; auto;
    distribute_scale; rewrite H4; lma'.
Qed.

Lemma TEN3' : forall {bit len : nat} (pm : Coef) {c c0 c1 : Coef} {l la lb : list Pauli} (P A B : Pauli),
    bit < len -> not_gI P -> not_gI A -> not_gI B -> anticommute_Pauli A B ->
    pm = C1 \/ pm = (- C1)%C -> len = length l -> P = nth bit l gI ->
    la = switch l A bit -> lb = switch l B bit ->
    c0 = ((C1/√2)*c)%C -> c1 = (pm * c * (C1/√2))%C ->
    @triple 1 (AtoPred [(C1, [P])]) (T 0) (AtoPred [((C1/√2)%C, [A]); (((C1/√2) * pm)%C, [B])]) ->
    @triple len (AtoPred [(c, l)]) (T bit) (AtoPred [(c0, la); (c1, lb)]).
Proof. intros bit len pm c c0 c1 l la lb A B P H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12.
  assert (pm * c * (C1/√2) = (C1/√2)*(c * pm))%C by lca. rewrite H13 in H11.
  subst. apply TEN3; auto.
Qed.

Lemma TEN3'' :
  forall {bit n : nat} (pm : Coef) {c : Coef} {l : list Pauli} (P A B : Pauli)
    {t0 t1 : TType 1} {t2 t3 : TType n},
    bit < n -> not_gI P -> not_gI A -> not_gI B -> anticommute_Pauli A B ->
    pm = C1 \/ pm = (- C1)%C -> n = length l -> P = nth bit l gI ->
    t0 = ((C1/√2)%C, [A]) -> t1 = (((C1/√2) * pm)%C, [B]) ->
    t2 = (((C1/√2)*c)%C, switch l A bit) -> t3 = (((C1/√2)*(c * pm))%C, switch l B bit) ->
    @triple 1 (AtoPred [(C1, [P])]) (T 0) (AtoPred [t0; t1]) ->
    @triple n (AtoPred [(c, l)]) (T bit) (AtoPred [t2; t3]).
Proof. intros bit n pm c l A B P t0 t1 t2 t3 H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12.
  subst. apply TEN3; auto.
Qed.

Lemma TEN3''' :
  forall {bit n : nat} (pm : Coef) {c : Coef} {l : list Pauli} (P A B : Pauli)
    {a : AType 1} {a' : AType n},
    bit < n -> not_gI P -> not_gI A -> not_gI B -> anticommute_Pauli A B ->
    pm = C1 \/ pm = (- C1)%C -> n = length l -> P = nth bit l gI ->
    a = [((C1/√2)%C, [A]); (((C1/√2) * pm)%C, [B])] ->
    a' = [(((C1/√2)*c)%C, switch l A bit); (((C1/√2)*(c * pm))%C, switch l B bit)] ->
    @triple 1 (AtoPred [(C1, [P])]) (T 0) (AtoPred a) ->
    @triple n (AtoPred [(c, l)]) (T bit) (AtoPred a').
Proof. intros bit n pm c l A B P a a' H0 H1 H2 H3 H4 H5 H6 H7 H8 H9 H10.
  subst. apply TEN3; auto.
Qed.

Lemma WF_TEN5 : forall (bit len : nat) (pm c : Coef) (l : list Pauli) (A B : Pauli),
    bit < len -> not_gI A -> not_gI B -> anticommute_Pauli A B ->
    pm = C1 \/ pm = (- C1)%C -> len = length l -> c = C1 \/ c = (- C1)%C ->
    @WF_AType len [(((C1/√2)*c)%C, switch l A bit); (((C1/√2)*(c * pm))%C, switch l B bit)].
Proof. intros bit len pm c l A B H0 H1 H2 H3 H4 H5 H6. 
  replace [((C1 / √ 2 * c)%C, switch l A bit); ((C1 / √ 2 * (c * pm))%C, switch l B bit)]
    with (@gScaleA len (C1 / √ 2)%C ([(c,switch l A bit)] ++ [((c * pm)%C,switch l B bit)]))
    by (unfold gScaleA; auto).
  do 2 constructor.
  1 - 2 : constructor.
  - apply WF_TEN2; auto.
  - destruct H1;
      destruct H4 as [H4 | H4];
      rewrite H4;
      destruct H6 as [H6 | H6];
      rewrite H6;
      try rewrite Cmult_1_l;
      try rewrite Cmult_1_r;
      replace ((- C1)%C * (- C1)%C)%C with C1 by lca;
      apply WF_TEN2; auto.
  - subst; simpl.
    repeat (constructor; auto).
    rewrite ! switch_inc; auto.
    unfold cBigMul.
    setoid_rewrite <- zipWith_app_product with (n := bit) at 1.
    setoid_rewrite <- zipWith_app_product with (n := 1) at 1.
    setoid_rewrite <- zipWith_app_product with (n := bit) at 1.
    setoid_rewrite <- zipWith_app_product with (n := 1) at 1.
    rewrite ! fold_left_Cmult_app.
    replace (fold_left Cmult (zipWith gMul_Coef [A] [B]) C1)
      with (gMul_Coef A B)
      by (simpl; unfold uncurry; rewrite Cmult_1_l; auto).
    replace (fold_left Cmult (zipWith gMul_Coef [B] [A]) C1)
      with (gMul_Coef B A)
      by (simpl; unfold uncurry; rewrite Cmult_1_l; auto).
    rewrite Copp_mult_distr_r.
    rewrite Copp_mult_distr_l.
    do 2 f_equal.
    destruct H1 as [EA | [EA | EA]];
      destruct H2 as [EB | [EB | EB]];
      rewrite EA; rewrite EB;
      unfold gMul_Coef; simpl; try lca.
    1 - 3 : unfold anticommute_Pauli in H3;
    rewrite EA in H3; rewrite EB in H3;
    unfold translate_P in H3;
    rewrite Mscale_mult_dist_l in H3;
    try rewrite ! XtimesXid in H3;
    try rewrite ! YtimesYid in H3;
    try rewrite ! ZtimesZid in H3;
    contradict_matrix_equalities.
    all : try rewrite firstn_length;
      simpl; minmax_breakdown; auto.
Qed.


Lemma triple_A_eq : forall {n : nat} {pre  post : AType n} (pre' post' : AType n) {g : prog},
    pre' = pre -> post' = post ->
    {{ AtoPred pre' }} g {{ AtoPred post' }} -> {{ AtoPred pre }} g {{ AtoPred post }}.
Proof. intros n pre post pre' post' g H0 H1 H2.  
  subst. auto.
Qed.

Lemma triple_A_reorder_L : forall {n : nat} {a b : AType n} (a' : AType n) {g : prog},
    WF_AType a -> WF_AType b -> WF_AType a' ->
    translateA a' = translateA a -> {{ AtoPred a' }} g {{ AtoPred b }} -> {{ AtoPred a }} g {{ AtoPred b }}.
Proof. intros n a b a' g H0 H1 H2 H3 H4. 
  apply Heisenberg_Eigenvector_semantics.
  rewrite <- H3.
  apply Eigenvector_Heisenberg_semantics'; auto.
Qed.

Lemma triple_A_reorder_R : forall {n : nat} {a b : AType n} (b' : AType n) {g : prog},
    WF_AType a -> WF_AType b -> WF_AType b' ->
    translateA b' = translateA b -> {{ AtoPred a }} g {{ AtoPred b' }} -> {{ AtoPred a }} g {{ AtoPred b }}.
Proof. intros n a b b' g H0 H1 H2 H3 H4. 
  apply Heisenberg_Eigenvector_semantics.
  rewrite <- H3.
  apply Eigenvector_Heisenberg_semantics'; auto.
Qed.

Ltac trace_zero_auto listP :=
  match listP with
  | gI :: ?t => replace (gI :: t) with ([gI] ++ t) by auto;
              apply trace_zero_syntax_R; trace_zero_auto t
  | gX :: ?t => replace (gX :: t) with ([gX] ++ t) by auto;
              apply trace_zero_syntax_L; apply trace_zero_syntax_X
  | gY :: ?t => replace (gY :: t) with ([gY] ++ t) by auto;
              apply trace_zero_syntax_L; apply trace_zero_syntax_Y
  | gZ :: ?t => replace (gZ :: t) with ([gZ] ++ t) by auto;
              apply trace_zero_syntax_L; apply trace_zero_syntax_Z
  | nil => idtac
  end.


Ltac WF_auto :=
  repeat (match goal with
   | |- Forall2 _ [] [] => constructor
   | |- Forall2 _ _ [] => try constructor
   | |- Forall2 _ [] _ => try constructor
   | |- Forall WF_AType _ => constructor
   | |- Forall (fun ht : HoareTriple _ => circuit ht = _) _ =>
          constructor; try (rewrite circuit_packHT)
   | |- context [lincombCA _ _] => unfold lincombCA; repeat (simpl; repeat rewrite Cmult_assoc; try rewrite Cmult_neg1_mult; try rewrite Copp_involutive; Csimpl)
   | |- context [cBigMul (zipWith gMul_Coef _ _)] => 
       unfold cBigMul, zipWith, gMul_Coef, uncurry; simpl; Csimpl
    | |- WF_AType
          (gScaleA
             (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH))))))
             [?a; ?b]) =>
        auto with wf_db; constructor; replace [a; b] with 
           ([a] ++ [b]) by (simpl; auto); do 2 constructor
    | |- @WF_AType ?n [
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * ?c1)%C, ?l1);
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * ?c2)%C, ?l2)
          ] =>
        auto with wf_db;
        let Htemp := fresh "Htemp" in
        assert (Htemp : [
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c1)%C, l1);
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c2)%C, l2)
          ] = (@gScaleA n
                     (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH))))))
                     [(c1, l1); (c2, l2)]))
      by (simpl; auto); setoid_rewrite Htemp
    | |- @WF_AType ?n [
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l1);
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l2)
          ] =>
        auto with wf_db;
        let Htemp := fresh "Htemp" in
        assert (Htemp : [
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l1);
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l2)
          ] = (@gScaleA n
                     (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH))))))
                     [(C1, l1); (C1, l2)]))
          by (simpl; rewrite ! Cmult_1_r; auto); setoid_rewrite Htemp
    | |- @WF_AType ?n [
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * ?c1)%C, ?l1);
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l2)
          ] =>
        auto with wf_db;
        let Htemp := fresh "Htemp" in
        assert (Htemp : [
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c1)%C, l1);
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l2)
          ] = (@gScaleA n
                     (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH))))))
                     [(c1, l1); (C1, l2)]))
      by (simpl; rewrite ! Cmult_1_r; auto); setoid_rewrite Htemp
    | |- @WF_AType ?n [
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l1);
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * ?c2)%C, ?l2)
          ] =>
        auto with wf_db;
        let Htemp := fresh "Htemp" in
        assert (Htemp : [
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l1);
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c2)%C, l2)
          ] = (@gScaleA n
                     (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH))))))
                     [(C1, l1); (c2, l2)]))
      by (simpl; rewrite Cmult_1_r; auto); setoid_rewrite Htemp
    | |- @WF_AType ?n [
            ((?c1 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l1);
            ((?c2 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l2)
          ] =>
        auto with wf_db;
        let Htemp := fresh "Htemp" in
        assert (Htemp : [
              ((c1 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l1);
              ((c2 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l2)
          ] = [
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c1)%C, l1);
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c2)%C, l2)])
      by (rewrite Cmult_comm; auto); setoid_rewrite Htemp
    | |- @WF_AType ?n [
            ((?c1 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l1);
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l2)
          ] =>
        auto with wf_db;
        let Htemp := fresh "Htemp" in
        assert (Htemp : [
              ((c1 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l1);
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l2)
          ] = [
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c1)%C, l1);
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l2)])
      by (rewrite Cmult_comm; auto); setoid_rewrite Htemp
    | |- @WF_AType ?n [
            (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l1);
            ((?c2 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, ?l2)
          ] =>
        auto with wf_db;
        let Htemp := fresh "Htemp" in
        assert (Htemp : [
              (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l1);
              ((c2 * (Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l2)
          ] = [
                (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))))%C, l1);
                (((Cdiv (RtoC (IZR (Zpos xH))) (RtoC (sqrt (IZR (Zpos (xO xH)))))) * c2)%C, l2)])
          by (rewrite Cmult_comm; auto); setoid_rewrite Htemp
   | |- WF_AType (gScaleA _ [_]) => auto with wf_db; simpl
   | |- WF_AType [_] => auto with wf_db; do 2 constructor; simpl
   | |- WF_TType _ => auto with wf_db; constructor; simpl
   | |- proper_length_TType _ => constructor; simpl; try lia
   | |- coef_plus_minus_1 _ => unfold coef_plus_minus_1; simpl
   | |- _ <> C0 => try nonzero;
                let Htemp := fresh "Htemp" in
                intro Htemp;
                inversion Htemp; subst; clear Htemp;
                try lra
   | |- _ <> _ => let Htemp := fresh "Htemp" in
               intro Htemp;
               inversion Htemp; subst; clear Htemp;
               try lra
   | |- _ = C1 \/ _ = (- C1)%C => try (left; lca); try (right; lca)
   | |- C1 = _ => try lca
   | |- (- C1)%C = _ => try lca
   | |- trace_zero_syntax ?l => trace_zero_auto l
   | |- {{ AtoPred [(?c, _)] }} _ {{ AtoPred [(?c', _)] }} => 
       auto with ht_db; simpl; auto with ht_db; field_simplify c c'; Csimpl; auto with ht_db
   | |- {{ _ }} _ {{ AtoPred [(?c, _)] }} => 
       auto with ht_db; simpl; auto with ht_db; field_simplify c; Csimpl; auto with ht_db
   | |- {{ AtoPred [(?c, _)] }} ?g {{ _ }} => 
       match g with
       | T _ => auto with ht_db; simpl; auto with ht_db; Csimpl; auto with ht_db
       | _ => auto with ht_db; simpl; auto with ht_db; field_simplify c; Csimpl; auto with ht_db
       end
   | |- {{_}} _ {{_}} => repeat (simpl; auto with ht_db; repeat rewrite Cmult_assoc; try rewrite Cmult_neg1_mult; try rewrite Copp_involutive; Csimpl)
   | |- simpl_prog _ => try (left; easy); try (right; left; easy); try (right; right; easy)
   | |- _ /\ _ => split
   | |- _ \/ False => left
   | |- False \/ _ => right
   | |- not_gI _ => try (left; easy);
                           try (right; left; easy);
                           try (right; right; easy)
   | |- not_gI _ \/ not_gI _ =>
       try (left; left; easy);
       try (left; right; left; easy);
       try (left; right; right; easy);
       try (right; left; easy);
       try (right; right; left; easy);
       try (right; right; right; easy)
   | |- anticommute_AType_syntactic [] _ => simpl
   | |- anticommute_TType_AType _ _ => simpl
   | |- context [translateA _] =>
       simpl; unfold translateA;
       simpl; unfold translate;
       simpl; matrix_compute
   | |- anticommute_Pauli _ _ => unfold anticommute_Pauli; simpl; matrix_compute
   | |- _ < _ => simpl; auto; try lia
   | |- _ > _ => simpl; auto; try lia
   | |- _ = _ => repeat (simpl; auto; try field_simplify; try nonzero; try lca; f_equal)
   | |- _ => simpl
   end; auto).


(** Well-formedness for Pauli X, Y, Z **)

Lemma WF_TType_X : @WF_TType 1 tX. Proof. WF_auto. Qed.
Lemma WF_TType_Y : @WF_TType 1 tY. Proof. WF_auto. Qed.
Lemma WF_TType_Z : @WF_TType 1 tZ. Proof. WF_auto. Qed.
Lemma WF_TType_mX : @WF_TType 1 (mtX). Proof. WF_auto. Qed.
Lemma WF_TType_mY : @WF_TType 1 (mtY). Proof. WF_auto. Qed.
Lemma WF_TType_mZ : @WF_TType 1 (mtZ). Proof. WF_auto. Qed.
Lemma WF_AType_X : @WF_AType 1 aX. Proof. WF_auto. Qed.
Lemma WF_AType_Y : @WF_AType 1 aY. Proof. WF_auto. Qed.
Lemma WF_AType_Z : @WF_AType 1 aZ. Proof. WF_auto. Qed.
Lemma WF_AType_mX : @WF_AType 1 (maX). Proof. simpl. WF_auto. Qed.
Lemma WF_AType_mY : @WF_AType 1 (maY). Proof. WF_auto. Qed.
Lemma WF_AType_mZ : @WF_AType 1 (maZ). Proof. WF_auto. Qed.

#[export] Hint Resolve WF_TType_X WF_TType_Y WF_TType_Z WF_TType_mX WF_TType_mY WF_TType_mZ WF_AType_X WF_AType_Y WF_AType_Z WF_AType_mX WF_AType_mY WF_AType_mZ : wf_db.


(*** Core rules : use lma'
Non-core rules : use inference rules and core rules ***)

(** Core Rules **)

Lemma XHZ : {{ pX }} H 0 {{ pZ }}.
Proof. apply Heisenberg_Eigenvector_semantics;
    lma'; apply WF_mult; auto with wf_db;
    apply WF_Matrix_translateA;
    repeat apply proper_length_AType_gScaleA;
    repeat constructor;
    intro; lia.
Qed.

Lemma ZHX : {{ pZ }} H 0 {{ pX }}.
Proof. apply Heisenberg_Eigenvector_semantics;
    lma'; apply WF_mult; auto with wf_db;
    apply WF_Matrix_translateA;
    repeat apply proper_length_AType_gScaleA;
    repeat constructor;
    intro; lia.
Qed.

Lemma XSY : {{ pX }} S 0 {{ pY }}.
Proof. apply Heisenberg_Eigenvector_semantics; lma'; 
  unfold prog_simpl_app, translateA, translate, translate_P, Sgate;
    matrix_compute.
Qed.

Lemma ZSZ : {{ pZ }} S 0 {{ pZ }}.
Proof. apply Heisenberg_Eigenvector_semantics;
    lma'; apply WF_mult; auto with wf_db;
    apply WF_Matrix_translateA;
    repeat apply proper_length_AType_gScaleA;
    repeat constructor;
    intro; lia.
Qed.

Lemma ZTZ : {{ pZ }} T 0 {{ pZ }}.
Proof. apply Heisenberg_Eigenvector_semantics;
    lma'; apply WF_mult; auto with wf_db;
    apply WF_Matrix_translateA;
    repeat apply proper_length_AType_gScaleA;
    repeat constructor;
    intro; lia.
Qed.

Lemma XTXY2 : {{ pX }} T 0 {{ pXY2 }}.
Proof. apply Heisenberg_Eigenvector_semantics;
    lma'.
  
  1 : apply WF_mult; auto with wf_db;
  apply WF_Matrix_translateA;
  repeat apply proper_length_AType_gScaleA;
  repeat constructor;
  intro; lia.
  
  1 - 2 : unfold prog_simpl_app, translateA, translate, translate_P;
  matrix_compute.
Qed.
  
Lemma XTX2Y2 : {{ pX }} T 0 {{ pX2Y2 }}.
Proof. pose XTXY2 as H0.
  unfold gScaleA in H0.
  simpl in H0.
  rewrite ! Cmult_1_r in H0.
  assumption.
Qed.

Lemma YTYmX2 : {{ pY }} T 0 {{ pYmX2 }}.
Proof. apply Heisenberg_Eigenvector_semantics;
    lma'.
  
  1 : apply WF_mult; auto with wf_db;
  apply WF_Matrix_translateA;
  repeat apply proper_length_AType_gScaleA;
  repeat constructor;
  intro; lia.
  
  1 - 2 : unfold prog_simpl_app, translateA, translate, translate_P;
  matrix_compute.
Qed.

Lemma YTY2mX2 : {{ pY }} T 0 {{ pY2mX2 }}.
Proof. pose YTYmX2 as H0.
  unfold gScaleA in H0.
  simpl in H0.
  rewrite ! Cmult_1_r in H0.
  assumption.
Qed.
  
Lemma XICNOTXX : {{ pXI }} CNOT 0 1 {{ pXX }}.
Proof. apply Heisenberg_Eigenvector_semantics. simpl.
  unfold prog_ctrl_app, translateA, translate, translate_P. simpl.
  rewrite ! kron_1_l, ! kron_1_r, ! Mscale_1_l, ! Mplus_0_l;
    auto with wf_db.
  matrix_compute.
Qed.

Lemma IXCNOTIX : {{ pIX }} CNOT 0 1 {{ pIX }}.
Proof. apply Heisenberg_Eigenvector_semantics. simpl.
  unfold prog_ctrl_app, translateA, translate, translate_P. simpl.
  rewrite ! kron_1_l, ! kron_1_r, ! Mscale_1_l, ! Mplus_0_l;
    auto with wf_db.
  matrix_compute.
Qed.

Lemma ZICNOTZI : {{ pZI }} CNOT 0 1 {{ pZI }}.
Proof. apply Heisenberg_Eigenvector_semantics. simpl.
  unfold prog_ctrl_app, translateA, translate, translate_P. simpl.
  rewrite ! kron_1_l, ! kron_1_r, ! Mscale_1_l, ! Mplus_0_l;
    auto with wf_db.
  matrix_compute.
Qed.

Lemma IZCNOTZZ : {{ pIZ }} CNOT 0 1 {{ pZZ }}.
Proof. apply Heisenberg_Eigenvector_semantics. simpl.
  unfold prog_ctrl_app, translateA, translate, translate_P. simpl.
  rewrite ! kron_1_l, ! kron_1_r, ! Mscale_1_l, ! Mplus_0_l;
    auto with wf_db.
  matrix_compute.
Qed.

#[export] Hint Resolve XHZ ZHX XSY ZSZ ZTZ XTXY2 XTX2Y2 YTYmX2 YTY2mX2 XICNOTXX IXCNOTIX ZICNOTZI IZCNOTZZ : ht_db.


Tactic Notation "MUL_T_anticomm_auto"
  constr(pre1_T) constr(pre2_T) constr(post1_T) constr(post2_T) :=
  simpl;
  apply MUL_T_anticomm with (t0 := pre1_T) (t2 := pre2_T) (t1 := post1_T) (t3 := post2_T);
  WF_auto.

Tactic Notation "MUL_T_comm_auto"
  constr(pre1_T) constr(pre2_T) constr(post1_T) constr(post2_T) :=
  simpl;
  apply MUL_T_comm with (t0 := pre1_T) (t2 := pre2_T) (t1 := post1_T) (t3 := post2_T);
  WF_auto.

(** non-core triples **)

Lemma IHI : {{ pI }} H 0 {{ pI }}.
Proof. apply Heisenberg_Eigenvector_semantics.
  unfold translateA; simpl;
    unfold translate; simpl;
    rewrite Mplus_0_l, Mscale_1_l, kron_1_r;
    rewrite Mmult_1_l; try rewrite Mmult_1_r;
    replace 2%nat with (2 ^ 1)%nat by auto;
    auto with wf_db.
Qed.

Lemma ISI : {{ pI }} S 0 {{ pI }}.
Proof. apply Heisenberg_Eigenvector_semantics.
  unfold translateA; simpl;
    unfold translate; simpl;
    rewrite Mplus_0_l, Mscale_1_l, kron_1_r;
    rewrite Mmult_1_l; try rewrite Mmult_1_r;
    replace 2%nat with (2 ^ 1)%nat by auto;
    auto with wf_db.
Qed.

Lemma ITI : {{ pI }} T 0 {{ pI }}.
Proof. apply Heisenberg_Eigenvector_semantics.
  unfold translateA; simpl;
    unfold translate; simpl;
    rewrite Mplus_0_l, Mscale_1_l, kron_1_r;
    rewrite Mmult_1_l; try rewrite Mmult_1_r;
    replace 2%nat with (2 ^ 1)%nat by auto;
    auto with wf_db.
Qed.

Lemma IICNOTII : {{ pII }} CNOT 0 1 {{ pII }}.
Proof. apply Heisenberg_Eigenvector_semantics.
  unfold translateA; simpl;
    unfold translate; simpl;
    rewrite Mplus_0_l, Mscale_1_l, kron_1_r, ! id_kron;
    rewrite Mmult_1_l; try rewrite Mmult_1_r;
    auto; simpl; replace 4%nat with (2 ^ 2)%nat by auto;
    auto with wf_db.
Qed.

Lemma XTYX2 : {{ pX }} T 0 {{ pYX2 }}.
Proof. apply (triple_A_reorder_R aXY2); WF_auto. Qed.

Lemma XTY2X2 : {{ pX }} T 0 {{ pY2X2 }}.
Proof. apply (triple_A_reorder_R aX2Y2); WF_auto. Qed.

Lemma YTmXY2 : {{ pY }} T 0 {{ pmXY2 }}.
Proof. apply (triple_A_reorder_R aYmX2); WF_auto. Qed.

Lemma YTmX2Y2 : {{ pY }} T 0 {{ pmX2Y2 }}.
Proof. apply (triple_A_reorder_R aY2mX2); WF_auto. Qed.

Lemma YHmY : {{ pY }} H 0 {{ mpY }}.
Proof. MUL_T_anticomm_auto tX tZ tZ tX. Qed.

Lemma YSmX : {{ pY }} S 0 {{ mpX }}.
Proof. MUL_T_anticomm_auto tX tZ tY tZ. Qed.

Lemma XXCNOTXI : {{ pXX }} CNOT 0 1 {{ pXI }}.
Proof. MUL_T_comm_auto tXI tIX tXX tIX. Qed.

Lemma ZZCNOTIZ : {{ pZZ }} CNOT 0 1 {{ pIZ }}.
Proof. MUL_T_comm_auto tZI tIZ tZI tZZ. Qed.

Lemma YICNOTYX : {{ pYI }} CNOT 0 1 {{ pYX }}.
Proof. MUL_T_anticomm_auto tXI tZI tXX tZI. Qed.

Lemma IYCNOTZY : {{ pIY }} CNOT 0 1 {{ pZY }}.
Proof. MUL_T_anticomm_auto tIX tIZ tIX tZZ. Qed.

#[export] Hint Resolve IHI ISI ITI IICNOTII XTYX2 XTY2X2 YTmXY2 YTmX2Y2 YHmY YSmX XXCNOTXI ZZCNOTIZ YICNOTYX IYCNOTZY : ht_db.

Lemma YYCNOTmXZ : {{ pYY }} CNOT 0 1 {{ mpXZ }}.
Proof. MUL_T_comm_auto tYI tIY tYX tZY. Qed.

Lemma XYCNOTYZ : {{ pXY }} CNOT 0 1 {{ pYZ }}.
Proof. MUL_T_comm_auto tXI tIY tXX tZY. Qed.

Lemma XZCNOTYY : {{ pXZ }} CNOT 0 1 {{ mpYY }}.
Proof. MUL_T_comm_auto tXI tIZ tXX tZZ. Qed.

Lemma YXCNOTYI : {{ pYX }} CNOT 0 1 {{ pYI }}.
Proof. MUL_T_comm_auto tYI tIX tYX tIX. Qed.

Lemma YZCNOTXY : {{ pYZ }} CNOT 0 1 {{ pXY }}.
Proof. MUL_T_comm_auto tYI tIZ tYX tZZ. Qed.

Lemma ZXCNOTZX : {{ pZX }} CNOT 0 1 {{ pZX }}.
Proof. MUL_T_comm_auto tZI tIX tZI tIX. Qed.

Lemma ZYCNOTIY : {{ pZY }} CNOT 0 1 {{ pIY }}.
Proof. MUL_T_comm_auto tZI tIY tZI tZY. Qed.

#[export] Hint Resolve YYCNOTmXZ XYCNOTYZ XZCNOTYY YXCNOTYI YZCNOTXY ZXCNOTZX ZYCNOTIY : ht_db.


Tactic Notation "doSEQ" constr(p) := apply SEQ with (B := p); auto with ht_db.

Ltac doSEQs list_p :=
  match list_p with
  | nil => idtac
  | ?p :: ?list_p' => doSEQ p; doSEQs list_p'
  end.

Ltac eSEQ := eapply SEQ; auto with ht_db.
Ltac eSEQs := repeat eSEQ.

Ltac eFLIP := eapply FLIP; auto with ht_db; do 2 WF_auto.
Ltac eUNFLIP := eapply UNFLIP; auto with ht_db; do 2 WF_auto.


Definition Z (n : nat) := S n ;; S n.

Lemma ZZZ : {{ pZ }} Z 0 {{ pZ }}.
Proof. eSEQ. Qed.

Lemma XZmX : {{ pX }} Z 0 {{ mpX }}.
Proof. eSEQ. Qed.

Lemma YZmY : {{ pY }} Z 0 {{ mpY }}.
Proof. eSEQ. eFLIP. Qed.

#[export] Hint Resolve ZZZ XZmX YZmY : ht_db.

Definition X (n : nat) := H n ;; Z n ;; H n.

Lemma XXX : {{ pX }} X 0 {{ pX }}.
Proof. eSEQs. Qed.

Lemma ZXmZ : {{ pZ }} X 0 {{ mpZ }}.
Proof. eSEQs. eFLIP. Qed.

Lemma YXmY : {{ pY }} X 0 {{ mpY }}.
Proof. eSEQs. eFLIP. Qed.

#[export] Hint Resolve XXX ZXmZ YXmY : ht_db.

Definition Y (n : nat) := S n ;; X n ;; Z n ;; S n.

Lemma XYmX : {{ pX }} Y 0 {{ mpX }}.
Proof. eSEQs. eFLIP. Qed.

Lemma ZYmZ : {{ pZ }} Y 0 {{ mpZ }}.
Proof. doSEQs [pZ; mpZ]. eFLIP. eSEQ. Qed.

Lemma YYY : {{ pY }} Y 0 {{ pY }}.
Proof. doSEQs [mpX; mpX]. eFLIP. eSEQ. eFLIP. Qed.

#[export] Hint Resolve XYmX ZYmZ YYY : ht_db. 

Definition Td (n : nat) := Z n ;; S n ;; T n.

Lemma ZTdZ : {{ pZ }} Td 0 {{ pZ }}.
Proof. eSEQs. Qed.

Lemma XTdXmY2 : {{ pX }} Td 0 {{ - pYmX2 }}.
Proof. doSEQs [mpX; mpY]. eFLIP. eUNFLIP. Qed.

Lemma YTdmXmY2 : {{ pY }} Td 0 {{ pXY2 }}.
Proof. eSEQs. eFLIP. Qed.

#[export] Hint Resolve ZTdZ XTdXmY2 YTdmXmY2 : ht_db. 



(** ** Definitions and tactics for automation. ** **)

Definition extractC {n : nat} (a : AType n) : list Coef := map fst a.
Definition extractA {n : nat} (a : AType n) : list (AType n) := map (fun t => [(C1, snd t)]) a.
Fixpoint computeHT (g : prog) {n : nat} (a : AType n) : list (AType n) :=
  match a with
  | [] => []
  | t :: a' => match t with
             | (_, l) => match g with
                        | CNOT ctrl targ => match nth ctrl l gI with
                                           | gI => match nth targ l gI with
                                                  | gI => [(C1, l)] :: (computeHT g a')
                                                  | gX => [(C1, l)] :: (computeHT g a')
                                                  | gZ => [(C1, switch (switch l gZ ctrl) gZ targ)] :: (computeHT g a')
                                                  | gY => [(C1, switch (switch l gZ ctrl) gY targ)] :: (computeHT g a')
                                                  end
                                           | gX => match nth targ l gI with
                                                  | gI => [(C1, switch (switch l gX ctrl) gX targ)] :: (computeHT g a')
                                                  | gX => [(C1, switch (switch l gX ctrl) gI targ)] :: (computeHT g a')
                                                  | gZ => [((- C1)%C, switch (switch l gY ctrl) gY targ)] :: (computeHT g a')
                                                  | gY => [(C1, switch (switch l gY ctrl) gZ targ)] :: (computeHT g a')
                                                  end
                                           | gZ => match nth targ l gI with
                                                  | gI => [(C1, l)] :: (computeHT g a')
                                                  | gX => [(C1, l)] :: (computeHT g a')
                                                  | gZ => [(C1, switch (switch l gI ctrl) gZ targ)] :: (computeHT g a')
                                                  | gY => [(C1, switch (switch l gI ctrl) gY targ)] :: (computeHT g a')
                                                  end
                                           | gY => match nth targ l gI with
                                                  | gI => [(C1, switch (switch l gY ctrl) gX targ)] :: (computeHT g a')
                                                  | gX => [(C1, switch (switch l gY ctrl) gI targ)] :: (computeHT g a')
                                                  | gZ => [(C1, switch (switch l gX ctrl) gY targ)] :: (computeHT g a')
                                                  | gY => [((- C1)%C, switch (switch l gX ctrl) gZ targ)] :: (computeHT g a')
                                                  end
                                           end
                        | H n => match nth n l gI with
                                | gI => [(C1, l)] :: (computeHT g a')
                                | gX => [(C1, switch l gZ n)] :: (computeHT g a')
                                | gZ => [(C1, switch l gX n)] :: (computeHT g a')
                                | gY => [((- C1)%C, l)] :: (computeHT g a')
                                end
                        | S n => match nth n l gI with
                                | gI => [(C1, l)] :: (computeHT g a')
                                | gX => [(C1, switch l gY n)] :: (computeHT g a')
                                | gZ => [(C1, l)] :: (computeHT g a')
                                | gY => [((- C1)%C, switch l gX n)] :: (computeHT g a')
                                end
                        | T n => match nth n l gI with
                                | gI => [(C1, l)] :: (computeHT g a')
                                | gX => [((C1/√2)%C, l); ((C1/√2)%C, switch l gY n)] :: (computeHT g a')
                                | gZ => [(C1, l)] :: (computeHT g a')
                                | gY => [((C1/√2)%C, l); (((- C1) * (C1/√2))%C, switch l gX n)] :: (computeHT g a')
                                end
                        | _ ;; _ => []
                        end
             end
  end.

Definition computeFinalStep (g : prog) (n : nat) (a : AType n) :=
  lincombCA (@extractC n a) (@computeHT g n a).

Ltac  BASE_auto_loop n p l g :=
  match n with
  | 0%nat =>  
      match p with
      | gI => eapply TEN_ID'
      | gX => match g with
             | H => eapply (TEN1' C1 p gZ)
             | S => eapply (TEN1' C1 p gY)
             | T => eapply (TEN3' C1 p gX gY)
             end
      | gY => match g with
             | H => eapply (TEN1' (- C1)%C p gY)
             | S => eapply (TEN1' (- C1)%C p gX)
             | T => eapply (TEN3' (- C1)%C p gY gX)
             end
      | gZ => match g with
             | H => eapply (TEN1' C1 p gX)
             | _ => eapply (TEN1' C1 p gZ)
             end
      end
  | s ?m => 
      match l with
      | ?h :: ?t => BASE_auto_loop m h t g
      | nil => idtac
      end
  end.

Ltac CNOT_auto_loop ctrl p1 l1 targ p2 l2 :=
  match ctrl with
  | 0%nat => 
      match targ with
      | 0%nat => 
          match p1 with
          | gI => match p2 with
                 | gI => eapply TEN_ID2'
                 | gX => eapply (TEN2' C1 p1 p2 gI gX)
                 | gY => eapply (TEN2' C1 p1 p2 gZ gY)
                 | gZ => eapply (TEN2' C1 p1 p2 gZ gZ)
                 end
          | gX => match p2 with
                 | gI => eapply (TEN2' C1 p1 p2 gX gX)
                 | gX => eapply (TEN2' C1 p1 p2 gX gI)
                 | gY => eapply (TEN2' C1 p1 p2 gY gZ)
                 | gZ => eapply (TEN2' (- C1)%C p1 p2 gY gY)
                 end
          | gY => match p2 with
                 | gI => eapply (TEN2' C1 p1 p2 gY gX)
                 | gX => eapply (TEN2' C1 p1 p2 gY gI)
                 | gY => eapply (TEN2' (- C1)%C p1 p2 gX gZ)
                 | gZ => eapply (TEN2' C1 p1 p2 gX gY)
                 end
          | gZ => match p2 with
                 | gI => eapply (TEN2' C1 p1 p2 gZ gI)
                 | gX => eapply (TEN2' C1 p1 p2 gZ gX)
                 | gY => eapply (TEN2' C1 p1 p2 gI gY)
                 | gZ => eapply (TEN2' C1 p1 p2 gI gZ)
                 end
          end
      | s ?t => match l2 with
               | ?h2 :: ?t2 => CNOT_auto_loop ctrl p1 l1 t h2 t2 
               | nil => idtac
               end
      end
  | s ?c => match l1 with
           | ?h1 :: ?t1 => CNOT_auto_loop c h1 t1 targ p2 l2
           | nil => idtac
           end
  end.

Ltac simplify_kth_Coef n k final :=
  let coef := fresh "coef" in
  pose (fst (nth k final (defaultT_Z n))) as coef; simpl in coef;
  let Htemp'' := fresh "Htemp''" in
  assert (Htemp'' : (C0, coef) = (C0, coef)) by reflexivity;
  unfold coef in Htemp'';
  match goal with
  | _ : (C0, ?cf) = (C0, ?cf) |- _ => field_simplify cf in final
  end;
  clear coef; clear Htemp''.

Ltac simplifyCoef_loop n k final :=
  match k with
  | 0%nat => idtac
  | s ?k' =>  try simplify_kth_Coef n k' final; simplifyCoef_loop n k' final
  end.

Ltac simplifyCoef n final :=
  let len := fresh "len" in
  pose (length final) as len; simpl in len;
  let Htemp' := fresh "Htemp'" in
  assert (Htemp' : (0%nat, len) = (0%nat, len)) by reflexivity;
  unfold len in Htemp';
  match goal with
  | _ : (0%nat, ?k) = (0%nat, ?k) |- _ => simplifyCoef_loop n k final
  end;
  clear len; clear Htemp'.

Ltac validateU :=
  repeat (simpl; Csimpl; repeat rewrite Cmult_assoc; repeat rewrite Cmult_neg1_mult; repeat rewrite Copp_involutive);
  match goal with
  | |- {{ AtoPred [(?c, ?l)] }} CNOT ?ctrl ?targ {{ _ }} => 
      match l with
      | ?h :: ?t => CNOT_auto_loop ctrl h t targ h t; 
                  repeat (simpl; Csimpl; repeat rewrite Cmult_assoc; repeat rewrite Cmult_neg1_mult; repeat rewrite Copp_involutive);
                  WF_auto;
                  let final := fresh "final" in
                  pose (computeFinalStep (CNOT ctrl targ) (length l) [(c, l)]) as final;
                  unfold computeFinalStep, lincombCA in final; simpl in final;
                  simplifyCoef (length l) final
      | nil => idtac
      end
  | |- {{ AtoPred [(?c, ?l)] }} ?g ?n {{ _ }} => 
      match l with
      | ?h :: ?t => BASE_auto_loop n h t g; 
                  repeat (simpl; Csimpl; repeat rewrite Cmult_assoc; repeat rewrite Cmult_neg1_mult; repeat rewrite Copp_involutive);
                  WF_auto;
                  let final := fresh "final" in
                  pose (computeFinalStep (g n) (length l) [(c, l)]) as final;
                  unfold computeFinalStep, lincombCA in final; simpl in final;
                  simplifyCoef (length l) final
      | nil => idtac
      end
  end.

Ltac loopHT n Lc Lpre Lpost prg listApre listApost listHT :=
  match listApre with
  | ?hpr :: ?tpr =>
      match listApost with
      | ?hpo :: ?tpo =>
          let pfHT := fresh "pfHT" in
          assert (pfHT : @triple n (AtoPred hpr) (prg) (AtoPred hpo));
          [auto with ht_db; try validateU | loopHT n Lc Lpre Lpost prg tpr tpo ((packHT hpr prg hpo pfHT) :: listHT)]
      | [] => let Lht := fresh "Lht" in (pose (rev listHT) as Lht); simpl in Lht;
                                      eapply (LINCOMB' Lc Lpre Lpost Lht)
      end
  | [] => let Lht := fresh "Lht" in (pose (rev listHT) as Lht); simpl in Lht;
                                  eapply (LINCOMB' Lc Lpre Lpost Lht)
  end.

Ltac validateLC :=
  repeat (simpl; Csimpl; repeat rewrite Cmult_assoc; repeat rewrite Cmult_neg1_mult; repeat rewrite Copp_involutive);
  unfold lincombCA; simpl;
  match goal with
  | |- @triple ?n _ (_ ;; _) _ => idtac
  | |- @triple ?n (AtoPred ?a) (?g) (?B) => 
      let listC := fresh "listC" in
      pose (@extractC n a) as listC; simpl in listC;
      let listApre := fresh "listApre" in
      pose (@extractA n a) as listApre; simpl in listApre;
      let listApost := fresh "listApost" in
      pose (@computeHT g n a) as listApost; simpl in listApost;
      let Htemp := fresh "Htemp" in
      assert (Htemp : (listApre, listApost, listC) = (listApre, listApost, listC)) by reflexivity;
      unfold listApre, listApost, listC in Htemp;
      match goal with
      | _ : (?Lpre, ?Lpost, ?Lc) = (?Lpre, ?Lpost, ?Lc) |- @triple n (AtoPred a) (g) (B) => 
          clear listC; clear listApre; clear listApost; clear Htemp;
          loopHT n Lc Lpre Lpost g Lpre Lpost (@nil (HoareTriple n));
          repeat (simpl; Csimpl; repeat rewrite Cmult_assoc; repeat rewrite Cmult_neg1_mult; repeat rewrite Copp_involutive);
          WF_auto;
          let final := fresh "final" in
          pose (computeFinalStep g n a) as final;
          unfold computeFinalStep, lincombCA in final; simpl in final;
          simplifyCoef n final
      end
  end.

Ltac simplifyCoefLC_C_loop base init final :=
  match final with
  | (Cdiv (RtoC (IZR (Zpos xH)))  (*  this is (C1 / √2)%C  *)
       (RtoC (sqrt (IZR (Zpos (xO xH)))))) => 
      match init with
      | (?c1 * ?c2)%C => simplifyCoefLC_C_loop init c1 c2
      | _ => repeat rewrite Cmult_assoc; repeat (try rewrite Cmult_neg1_mult; Csimpl)
      end
  | (- C1)%C => 
      replace base with (final * init)%C by (rewrite Cmult_comm; reflexivity);
      match init with
      | (?c1 * ?c2)%C => simplifyCoefLC_C_loop init c1 c2
      | _ => repeat rewrite Cmult_assoc; repeat (try rewrite Cmult_neg1_mult; Csimpl)
      end
  | _ => repeat rewrite Cmult_assoc; repeat (try rewrite Cmult_neg1_mult; Csimpl)
  end.  

Ltac simplifyCoefLC_C C := 
  repeat rewrite Cmult_assoc;
  match C with
  | (?c1 * ?c2)%C => simplifyCoefLC_C_loop C c1 c2
  | _ => idtac
  end.

Ltac simplifyCoefLC_loop a :=
  match a with
  | (?c, ?l) :: ?a' => simplifyCoefLC_C c; simplifyCoefLC_loop a'
  | [] => idtac 
  end.

Ltac simplifyCoefLC :=
  match goal with
  | |- {{ _ }} _ {{ AtoPred ?a }} => 
      match a with
      | (?c, ?l) :: ?a' => simplifyCoefLC_C c; repeat simplifyCoefLC_loop a'
      | [] => idtac 
      end
  | |- _ => idtac
  end.

Ltac simplifyCoefLC_C_loop_context H base init final :=
  match final with
  | (Cdiv (RtoC (IZR (Zpos xH)))  (*  this is (C1 / √2)%C  *)
       (RtoC (sqrt (IZR (Zpos (xO xH)))))) => 
      match init with
      | (?c1 * ?c2)%C => simplifyCoefLC_C_loop_context H init c1 c2
      | _ => repeat rewrite Cmult_assoc in H; repeat (try rewrite Cmult_neg1_mult in H; Csimpl_context H)
      end
  | (- C1)%C => 
      replace base with (final * init)%C in H by (rewrite Cmult_comm; reflexivity);
      match init with
      | (?c1 * ?c2)%C => simplifyCoefLC_C_loop_context H init c1 c2
      | _ => repeat rewrite Cmult_assoc in H; repeat (try rewrite Cmult_neg1_mult in H; Csimpl_context H)
      end
  | _ => repeat rewrite Cmult_assoc in H; repeat (try rewrite Cmult_neg1_mult in H; Csimpl_context H)
  end.  

Ltac simplifyCoefLC_C_context H C := 
  repeat rewrite Cmult_assoc in H;
  match C with
  | (?c1 * ?c2)%C => simplifyCoefLC_C_loop_context H C c1 c2
  | _ => idtac
  end.

Ltac simplifyCoefLC_loop_context H a :=
  match a with
  | (?c, ?l) :: ?a' => simplifyCoefLC_C_context H c; simplifyCoefLC_loop_context H a'
  | [] => idtac 
  end.

Ltac simplifyCoefLC_context :=
  match goal with
  | [H : {{ _ }} _ {{ AtoPred ?a }} |- _ ] => 
      match a with
      | (?c, ?l) :: ?a' => simplifyCoefLC_C_context H c; repeat simplifyCoefLC_loop_context H a'
      | [] => idtac 
      end
  |  _ => idtac
  end.

Ltac validate_single := 
  repeat (try eapply CAP'; try eapply split_Forall2;
          repeat
            (simpl; Csimpl; repeat rewrite Cmult_assoc;
             repeat rewrite Cmult_neg1_mult;
             repeat rewrite Copp_involutive); 
          try validateU; try validateLC;
          WF_auto).

Ltac validate :=
  repeat (tryif eSEQ then [> eSEQs; validate_single | idtac] else validate_single).

Ltac solvePlaceholder :=
  intros;
  eexists ?[Ph];
  match goal with
  | |- ?g => let G := fresh "G" in assert (G : g);
                                [> validate | idtac ];
                                simpl in *; Csimpl; Csimpl_context G;
                                repeat simplifyCoefLC; repeat simplifyCoefLC_context
  end.


(* Computation for "non-additive" gate application function since T gates don't preserve well-formedness *)
(** ** Calculate Postcondition Function ** **)

Inductive nonadditive_prog : prog -> Prop :=
| H_nonadditive : forall (bit : nat), nonadditive_prog (H bit)
| S_nonadditive : forall (bit : nat), nonadditive_prog (S bit)
| CNOT_nonadditive : forall (ctrl targ : nat), nonadditive_prog (CNOT ctrl targ)
| seq_nonadditive : forall (g1 g2 : prog), nonadditive_prog g1 -> nonadditive_prog g2 ->
                                      nonadditive_prog (g1 ;; g2).

Inductive prog_bound (n : nat) : prog -> Prop :=
| H_bound : forall (bit : nat), bit < n -> prog_bound n (H bit)
| S_bound : forall (bit : nat), bit < n -> prog_bound n (S bit)
| T_bound : forall (bit : nat), bit < n -> prog_bound n (T bit)
| CNOT_bound : forall (ctrl targ : nat), ctrl < n -> targ < n -> ctrl <> targ -> 
                                  prog_bound n (CNOT ctrl targ)
| seq_bound : forall (g1 g2 : prog), prog_bound n g1 -> prog_bound n g2 ->
                                prog_bound n (g1 ;; g2).

(* AType version
Definition gate_on_TType {n : nat} (g : prog) (t : TType n) : AType n :=
  match g with
  | H n => 
      match t with
      | (c, lp) => match nth n lp gI with
                  | gI => [t]
                  | gX => [(c, switch lp gZ n)]
                  | gY => [((- C1 * c)%C, lp)]
                  | gZ => [(c, switch lp gX n)]
                  end
      end
  | S n => match t with
          | (c, lp) => match nth n lp gI with
                      | gI => [t]
                      | gX => [(c, switch lp gY n)]
                      | gY => [((- C1 * c)%C, switch lp gX n)]
                      | gZ => [t]
                      end
          end 
  | T n => match t with
          | (c, lp) => match nth n lp gI with
                      | gI => [t]
                      | gX => [((C1/√2 * c)%C, lp); ((C1/√2 * c)%C, switch lp gY n)]
                      | gY => [((C1/√2 * c)%C, lp); ((- C1 * C1/√2 * c)%C , switch lp gX n)]
                      | gZ => [t]
                      end
          end
  | CNOT ctrl targ => match t with
                     | (c, lp) =>
                         match nth ctrl lp gI with
                         | gI => match nth targ lp gI with
                                | gI => [t]
                                | gX => [t]
                                | gZ => [(c, switch (switch lp gZ ctrl) gZ targ)]
                                | gY => [(c, switch (switch lp gZ ctrl) gY targ)]
                                end
                         | gX => match nth targ lp gI with
                                | gI => [(c, switch (switch lp gX ctrl) gX targ)]
                                | gX => [(c, switch (switch lp gX ctrl) gI targ)]
                                | gZ => [((- C1 * c)%C, switch (switch lp gY ctrl) gY targ)]
                                | gY => [(c, switch (switch lp gY ctrl) gZ targ)]
                                end
                         | gZ => match nth targ lp gI with
                                | gI => [t]
                                | gX => [t]
                                | gZ => [(c, switch (switch lp gI ctrl) gZ targ)]
                                | gY => [(c, switch (switch lp gI ctrl) gY targ)]
                                end
                         | gY => match nth targ lp gI with
                                | gI => [(c, switch (switch lp gY ctrl) gX targ)]
                                | gX => [(c, switch (switch lp gY ctrl) gI targ)]
                                | gZ => [(c, switch (switch lp gX ctrl) gY targ)]
                                | gY => [((- C1 * c)%C, switch (switch lp gX ctrl) gZ targ)]
                                end
                         end
                     end
  | _ ;; _ => [t]
  end.

Lemma gate_on_TType_gScaleT_comm : forall {n : nat} (g : prog) (t : TType n) (c : Coef),
    gate_on_TType g (gScaleT c t) = gScaleA c (gate_on_TType g t).
Proof. intros n g t c. 
  unfold gScaleA. destruct t.
  induction g; simpl; auto;
    try destruct (nth n0 l gI) eqn:E;
    try destruct (nth n1 l gI) eqn:E1;
    try destruct (nth n2 l gI) eqn:E2;
    simpl; auto;
    repeat (f_equal; try lca).
Qed.

Lemma map_gate_on_TType_gScaleA_comm : forall {n : nat} (g : prog) (a : AType n) (c : Coef),
    map (gate_on_TType g) (gScaleA c a) = (map (fun t => gScaleA c (gate_on_TType g t)) a).
Proof. intros n g a c.
  unfold gScaleA.
  rewrite ! map_map.
  f_equal.
  apply functional_extensionality; intros.
  unfold gScaleT. destruct x.
  induction g; simpl; auto;
    try destruct (nth n0 l gI) eqn:E;
    try destruct (nth n1 l gI) eqn:E1;
    try destruct (nth n2 l gI) eqn:E2;
    simpl; auto;
    repeat (f_equal; try lca).
Qed.

Lemma WF_AType_gate_on_TType : forall {n : nat} (g : prog) (t : TType n),
    prog_bound n g -> WF_TType t -> WF_AType (gate_on_TType g t).
Proof. intros n g t H0 H1.
  induction g; destruct t; simpl;
  try destruct (nth n0 l gI) eqn:E;
  try destruct (nth n1 l gI) eqn:E1;
  try destruct (nth n2 l gI) eqn:E2;
  try do 3 constructor;
  try inversion H1; try inversion H2; try inversion H3; try inversion H0;
    simpl in *; subst; try (left; lca); try (right; lca);
    try split; simpl in *; try rewrite ! switch_len; auto;
    try (rewrite switch_inc;
         [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
           try rewrite ! switch_len; auto]);
    try (rewrite switch_switch_diff; auto;
         try (rewrite switch_inc;
              [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
                try rewrite ! switch_len; auto])).
  - assert ((@gScaleA (length l) (C1 / √ 2)%C ([((C1)%C, l)] ++ [((C1)%C, switch l gY n0)])) = [((C1 / √ 2 * C1)%C, l); ((C1 / √ 2 * C1)%C, switch l gY n0)]).
    { unfold gScaleA. simpl. repeat (f_equal; try lca).  }
    rewrite <- H6.
    constructor. 
    1-2: constructor; simpl in *; try rewrite switch_len; auto.
    constructor; 
      [> repeat constructor; simpl; try rewrite switch_len; try lca; auto |
        try (left; lca); try (right; lca) |
        rewrite switch_inc;
        [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
          try rewrite ! switch_len; auto]].
    unfold anticommute_AType_syntactic.
    rewrite kill_true.
    unfold anticommute_TType_AType.
    rewrite kill_true.
    destruct (@anticommute_commute_T_TType_iff (length l) (C1, l) (C1, switch l gY n0))
      as [H' [H'' [H''' H'''']]].
    auto. split; simpl; auto; rewrite switch_len; auto.
    rewrite <- H'.
    constructor. simpl. 
    clear - n0 l E H5 H9.
    gen n0. induction l; intros. contradiction. simpl.
    destruct n0. simpl in *; subst.
    destruct l. do 2 constructor; intro; discriminate.
    apply anticommuting_listP_anticommP_commL.
    constructor; try intro; discriminate.
    apply self_commute_listP; intro; discriminate.
    apply anticommuting_listP_commP_anticommL.
    destruct a; constructor; auto.
    apply IHl; simpl in *; auto; try lia.
  - assert ((@gScaleA (length l) (C1 / √ 2)%C ([((- C1)%C, l)] ++ [((- C1)%C, switch l gY n0)])) = [((C1 / √ 2 * - C1)%C, l); ((C1 / √ 2 * - C1)%C, switch l gY n0)]).
    { unfold gScaleA. simpl. repeat (f_equal; try lca). }
    rewrite <- H6.
    constructor. 
    1-2: constructor; simpl in *; try rewrite switch_len; auto.
    constructor; 
      [> repeat constructor; simpl; try rewrite switch_len; try lca; auto |
        try (left; lca); try (right; lca) |
        rewrite switch_inc;
        [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
          try rewrite ! switch_len; auto]].
    unfold anticommute_AType_syntactic.
    rewrite kill_true.
    unfold anticommute_TType_AType.
    rewrite kill_true.
    destruct (@anticommute_commute_T_TType_iff (length l) ((- C1)%C, l) ((- C1)%C, switch l gY n0))
      as [H' [H'' [H''' H'''']]].
    auto. split; simpl; auto; rewrite switch_len; auto.
    rewrite <- H'.
    constructor. simpl. 
    clear - n0 l E H5 H9.
    gen n0. induction l; intros. contradiction. simpl.
    destruct n0. simpl in *; subst.
    destruct l. do 2 constructor; intro; discriminate.
    apply anticommuting_listP_anticommP_commL.
    constructor; try intro; discriminate.
    apply self_commute_listP; intro; discriminate.
    apply anticommuting_listP_commP_anticommL.
    destruct a; constructor; auto.
    apply IHl; simpl in *; auto; try lia.
  - assert ((@gScaleA (length l) (C1 / √ 2)%C ([((C1)%C, l)] ++ [((- C1 * C1)%C, switch l gX n0)])) = [((C1 / √ 2 * C1)%C, l); ((- C1 * C1 / √ 2 * C1)%C, switch l gX n0)]).
    { unfold gScaleA. simpl. repeat (f_equal; try lca). }
    rewrite <- H6.
    constructor. 
    1-2: constructor; simpl in *; try rewrite switch_len; auto.
    constructor; 
      [> repeat constructor; simpl; try rewrite switch_len; try lca; auto |
        try (left; lca); try (right; lca) |
        rewrite switch_inc;
        [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
          try rewrite ! switch_len; auto]].
    unfold anticommute_AType_syntactic.
    rewrite kill_true.
    unfold anticommute_TType_AType.
    rewrite kill_true.
    destruct (@anticommute_commute_T_TType_iff (length l) (C1, l) ((- C1 * C1)%C, switch l gX n0))
      as [H' [H'' [H''' H'''']]].
    auto. split; simpl; auto; rewrite switch_len; auto.
    rewrite <- H'.
    constructor. simpl. 
    clear - n0 l E H5 H9.
    gen n0. induction l; intros. contradiction. simpl.
    destruct n0. simpl in *; subst.
    destruct l. do 2 constructor; intro; discriminate.
    apply anticommuting_listP_anticommP_commL.
    constructor; try intro; discriminate.
    apply self_commute_listP; intro; discriminate.
    apply anticommuting_listP_commP_anticommL.
    destruct a; constructor; auto.
    apply IHl; simpl in *; auto; try lia.
  - assert ((@gScaleA (length l) (C1 / √ 2)%C ([((- C1)%C, l)] ++ [((C1)%C, switch l gX n0)])) = [((C1 / √ 2 * - C1)%C, l); ((- C1 * C1 / √ 2 * - C1)%C, switch l gX n0)]).
    { unfold gScaleA. simpl. repeat (f_equal; try lca).  }
    rewrite <- H6.
    constructor. 
    1-2: constructor; simpl in *; try rewrite switch_len; auto.
    constructor; 
      [> repeat constructor; simpl; try rewrite switch_len; try lca; auto |
        try (left; lca); try (right; lca) |
        rewrite switch_inc;
        [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
          try rewrite ! switch_len; auto]].
    unfold anticommute_AType_syntactic.
    rewrite kill_true.
    unfold anticommute_TType_AType.
    rewrite kill_true.
    destruct (@anticommute_commute_T_TType_iff (length l) ((- C1)%C, l) (C1, switch l gX n0))
      as [H' [H'' [H''' H'''']]].
    auto. split; simpl; auto; rewrite switch_len; auto.
    rewrite <- H'.
    constructor. simpl. 
    clear - n0 l E H5 H9.
    gen n0. induction l; intros. contradiction. simpl.
    destruct n0. simpl in *; subst.
    destruct l. do 2 constructor; intro; discriminate.
    apply anticommuting_listP_anticommP_commL.
    constructor; try intro; discriminate.
    apply self_commute_listP; intro; discriminate.
    apply anticommuting_listP_commP_anticommL.
    destruct a; constructor; auto.
    apply IHl; simpl in *; auto; try lia.
Qed.


Definition gate_on_AType {n : nat} (g : prog) (a : AType n) : AType n :=
  fold_right (@app (TType n)) [] (map (gate_on_TType g) a).

Lemma gate_on_AType_app_split : forall {n : nat} (g : prog) (a1 a2 : AType n),
    gate_on_AType g (a1 ++ a2) = 
      (gate_on_AType g a1) ++ (gate_on_AType g a2).
Proof. intros n g a1 a2.
  unfold gate_on_AType.
  rewrite map_app.
  setoid_rewrite fold_right_app_nil_app; auto.
Qed.

Lemma gate_on_AType_gScaleA_comm : forall {n : nat} (g : prog) (a : AType n) (c : Coef),
    gate_on_AType g (gScaleA c a) = gScaleA c (gate_on_AType g a).
Proof. intros n g a c.
  unfold gate_on_AType. unfold gScaleA at 1.
  rewrite map_map.
  assert ((fun x : TType n => gate_on_TType g (gScaleT c x)) = 
            (fun x : TType n => gScaleA c (gate_on_TType g x))).
  { apply functional_extensionality; intros.
    rewrite gate_on_TType_gScaleT_comm. auto. }
  rewrite H0.
  rewrite <- map_map with (g := gScaleA c) (f := gate_on_TType g).
  unfold gScaleA.
  setoid_rewrite fold_right_app_nil_map. auto.
Qed.



(** T gate application does not preserve well-formedness
{X} T {X + Y}
{Y} T {Y - X}
left side: term-wise anticommutativity
right side: no term-wise anticommutativity
**) 
Lemma anticommute_AType_syntactic_gate_on_AType : forall {n : nat} (g : prog) (a1 a2 : AType n),
    proper_length_AType a1 -> proper_length_AType a2 ->
    anticommute_AType_syntactic a1 a2 ->
    anticommute_AType_syntactic (gate_on_AType g a1) (gate_on_AType g a2).
Proof. intros n g a1 a2 H0 H1 H2.
  induction a1; auto; simpl in *.
  destruct H2.
  inversion H0; subst.
  - simpl in *. unfold gate_on_AType at 1. simpl. rewrite app_nil_r.
    clear H0 IHa1 H3.
    induction a2; simpl in *.
    + unfold gate_on_AType. simpl. rewrite anticommute_AType_syntactic_nil_r; auto.
    + destruct H2. inversion H1; subst.
      * simpl in *. unfold gate_on_AType. simpl. rewrite app_nil_r.
        clear H1 H2 IHa2.
        destruct (anticommute_commute_T_TType_iff a a0) as [H' [H'' [H''' H'''']]]; auto.
        remember H0 as H0'. clear HeqH0'. rewrite <- H' in H0.
        inversion H0. clear H0 H' H'' H''' H''''.
        destruct a, a0. destruct H5, H4. simpl in *.
        induction g; simpl; auto.
        -- destruct (nth n0 l gI) eqn:E1;
             destruct (nth n0 l0 gI) eqn:E2;
             simpl; repeat rewrite kill_true; auto. (*



           rewrite ! switch_inc. fold_left_Cmult_app
cBigMul_zipWith_gMul_Coef
 combine_app
*) Admitted.



Lemma WF_AType_gate_on_AType : forall {n : nat} (g : prog) (a : AType n),
    prog_bound n g -> WF_AType a -> WF_AType (gate_on_AType g a).
Proof. intros n g a H0 H1.
  inversion H1; subst; clear H1.
  induction H2.
  - unfold gate_on_AType. simpl. rewrite app_nil_r. 
    apply WF_AType_gate_on_TType; auto.
  - rewrite gate_on_AType_gScaleA_comm.
    rewrite gate_on_AType_app_split.
    inversion IHrestricted_addition_syntactic1; subst.
    inversion IHrestricted_addition_syntactic2; subst.
    do 2 constructor; auto.

Admitted.



Fixpoint prog_on_AType {n : nat} (g : prog) (a : AType n) : AType n :=
  match g with
  | g1 ;; g2 => prog_on_AType g2 (prog_on_AType g1 a)
  | _ => gate_on_AType g a
  end.



Lemma compute_postcond : forall {n : nat} (g : prog) (a : AType n),
    a <> [] -> prog_bound n g -> WF_AType a ->
    {{ AtoPred a }} g {{ AtoPred (prog_on_AType g a) }}.
Proof. intros n g a H0 H1 H2.
  induction g.
  - simpl. 
    inversion H2; subst.
    induction H3.
    + unfold gate_on_AType. simpl. rewrite app_nil_r. destruct t.
      destruct (nth n0 l gI) eqn:E.
      * (* eapply TEN_ID'. *) admit.
      * (* eapply TEN1'. *) admit.
      * admit.
      * admit.
    + rewrite gate_on_AType_gScaleA_comm.
      rewrite gate_on_AType_app_split.
      remember H3_. remember H3_0. clear Heqr Heqr0. 
      apply restricted_addition_syntactic_implies_WF_AType in r, r0.
      apply restricted_addition_syntactic_implies_not_nil in H3_, H3_0.
      specialize (IHrestricted_addition_syntactic1 H3_ r).
      specialize (IHrestricted_addition_syntactic2 H3_0 r0).
      eapply LINCOMB'.
      Unshelve.
      11: apply [(C1 / √ 2)%C; (C1 / √ 2)%C].
      11: apply [a1; a2].
      11: apply [gate_on_AType (H n0) a1; gate_on_AType (H n0) a2].
      11: apply [exist (fun t : AType n * prog * AType n => uncurry (uncurry (fun (A : AType n) (g : prog) (B : AType n) => {{A}} g {{B}})) t) (a1, H n0, gate_on_AType (H n0) a1) IHrestricted_addition_syntactic1; exist (fun t : AType n * prog * AType n => uncurry (uncurry (fun (A : AType n) (g : prog) (B : AType n) => {{A}} g {{B}})) t) (a2, H n0, gate_on_AType (H n0) a2) IHrestricted_addition_syntactic2].
      all: WF_auto.
      apply WF_AType_gate_on_TType

*)

Definition gate_on_TType {n : nat} (g : prog) (t : TType n) : TType n :=
  match g with
  | H n => 
      match t with
      | (c, lp) => match nth n lp gI with
                  | gI => t
                  | gX => (c, switch lp gZ n)
                  | gY => ((- C1 * c)%C, lp)
                  | gZ => (c, switch lp gX n)
                  end
      end
  | S n => match t with
          | (c, lp) => match nth n lp gI with
                      | gI => t
                      | gX => (c, switch lp gY n)
                      | gY => ((- C1 * c)%C, switch lp gX n)
                      | gZ => t
                      end
          end 
  | T n => match t with
          | (c, lp) => match nth n lp gI with
                      | gI => t
                      | gX => t (* [((C1/√2 * c)%C, lp); ((C1/√2 * c)%C, switch lp gY n)] *)
                      | gY => t (* [((C1/√2 * c)%C, lp); ((- C1 * C1/√2 * c)%C , switch lp gX n)] *)
                      | gZ => t
                      end
          end
  | CNOT ctrl targ => match t with
                     | (c, lp) =>
                         match nth ctrl lp gI with
                         | gI => match nth targ lp gI with
                                | gI => t
                                | gX => t
                                | gZ => (c, switch (switch lp gZ ctrl) gZ targ)
                                | gY => (c, switch (switch lp gZ ctrl) gY targ)
                                end
                         | gX => match nth targ lp gI with
                                | gI => (c, switch (switch lp gX ctrl) gX targ)
                                | gX => (c, switch (switch lp gX ctrl) gI targ)
                                | gZ => ((- C1 * c)%C, switch (switch lp gY ctrl) gY targ)
                                | gY => (c, switch (switch lp gY ctrl) gZ targ)
                                end
                         | gZ => match nth targ lp gI with
                                | gI => t
                                | gX => t
                                | gZ => (c, switch (switch lp gI ctrl) gZ targ)
                                | gY => (c, switch (switch lp gI ctrl) gY targ)
                                end
                         | gY => match nth targ lp gI with
                                | gI => (c, switch (switch lp gY ctrl) gX targ)
                                | gX => (c, switch (switch lp gY ctrl) gI targ)
                                | gZ => (c, switch (switch lp gX ctrl) gY targ)
                                | gY => ((- C1 * c)%C, switch (switch lp gX ctrl) gZ targ)
                                end
                         end
                     end
  | _ ;; _ => t
  end.

Lemma gate_on_TType_gScaleT_comm : forall {n : nat} (g : prog) (t : TType n) (c : Coef),
    gate_on_TType g (gScaleT c t) = gScaleT c (gate_on_TType g t).
Proof. intros n g t c. 
  unfold gScaleT. destruct t.
  gen c; induction g; intros; simpl; auto;
    try destruct (nth n0 l gI) eqn:E;
    try destruct (nth n1 l gI) eqn:E1;
    try destruct (nth n2 l gI) eqn:E2;
    simpl; auto;
    repeat (f_equal; try lca).
Qed.

Lemma WF_TType_gate_on_TType : forall {n : nat} (g : prog) (t : TType n),
    prog_bound n g -> WF_TType t -> WF_TType (gate_on_TType g t).
Proof. intros n g t H0 H1.
  induction g; destruct t; simpl;
  try destruct (nth n0 l gI) eqn:E;
  try destruct (nth n1 l gI) eqn:E1;
  try destruct (nth n2 l gI) eqn:E2;
  try constructor;
  try inversion H1; try inversion H2; try inversion H3; try inversion H0;
    simpl in *; subst; try (left; lca); try (right; lca);
    try split; simpl in *; try rewrite ! switch_len; auto;
    try (rewrite switch_inc;
         [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
           try rewrite ! switch_len; auto]);
    try (rewrite switch_switch_diff; auto;
         try (rewrite switch_inc;
              [> apply trace_zero_syntax_R; apply trace_zero_syntax_L; constructor |
                try rewrite ! switch_len; auto])).
Qed.

Fixpoint prog_on_TType {n : nat} (g : prog) (t : TType n) : TType n :=
  match g with
  | g1 ;; g2 => prog_on_TType g2 (prog_on_TType g1 t)
  | _ => gate_on_TType g t
  end.

Lemma WF_TType_prog_on_TType : forall {n : nat} (g : prog) (t : TType n),
    prog_bound n g -> WF_TType t -> WF_TType (prog_on_TType g t).
Proof. intros n g t H0 H1.
  gen t; induction g; intros;  try apply WF_TType_gate_on_TType; auto.
  simpl. inversion H0; subst. auto.
Qed.

Lemma compute_postcond : forall {n : nat} (g : prog) (t : TType n),
    nonadditive_prog g -> prog_bound n g -> WF_TType t ->
    {{ AtoPred [t] }} g {{ AtoPred [prog_on_TType g t] }}.
Proof. intros n g t H0 H1 H2.
  gen t; induction g; intros; destruct t; simpl;
    try destruct (nth n0 l gI) eqn:E;
    try destruct (nth n1 l gI) eqn:E1;
    try destruct (nth n2 l gI) eqn:E2;
    inversion H2; inversion H3; inversion H4; inversion H0; inversion H1; simpl in *; subst.
  1-16: try match goal with
          | Hyp : nth ?n0 ?l gI = gI |- {{ ?A }} _ {{ ?A }} => eapply TEN_ID'; WF_auto
          end.
 1-12: try match goal with
         | Hyp : nth ?n0 ?l gI = _ |- _ => 
             eapply TEN1'; try (symmetry; apply E); try easy;
             try match goal with 
               | Hyp: _ |- {{ _ }} _ {{ _ }} => auto with ht_db
               end; WF_auto;
             try (rewrite switch_inc; auto; rewrite <- E; rewrite <- nth_inc; auto)
         end.
 1-32: try match goal with
          | Hyp : nth ?n0 ?l gI = gI |- {{ ?A }} _ {{ ?A }} => 
              try (eapply TEN_ID2'; easy)
          end.
 1-30: eapply TEN2'; try (symmetry; apply E1); try (symmetry; apply E2); try easy; 
 try match goal with 
   | Hyp: _ |- {{ _ }} _ {{ _ }} => auto with ht_db
   end; WF_auto;
 try (rewrite switch_inc with (n := n1); auto; try rewrite <- E1; rewrite <- nth_inc; auto;
      rewrite switch_inc with (n := n2); auto; try rewrite <- E2; rewrite <- nth_inc; auto).
 all: eapply SEQ; try apply IHg1; auto; try apply IHg2; auto;
   apply WF_TType_prog_on_TType; auto.
 Qed.

Lemma compute_postcond_CAP : forall {n : nat} (g : prog) (lt : list (TType n)),
    nonadditive_prog g -> prog_bound n g -> Forall WF_TType lt ->
    {{ Cap (map TtoA lt) }} g {{ Cap (map (fun t => TtoA (prog_on_TType g t)) lt) }}.
Proof. intros n g lt H0 H1 H2.
  apply CAP'. 
  induction lt; auto.
  rewrite Forall_cons_iff in H2. destruct H2. specialize (IHlt H3).
  constructor; auto.
  apply compute_postcond; auto.
Qed.



(** ** Toffoli ** **)

Definition TOFFOLI (a b c : nat) :=
  H c ;; CNOT b c ;; Td c ;; CNOT a c ;; T c ;; CNOT b c ;; Td c ;; CNOT a c ;; T b ;; T c ;; H c ;; CNOT a b ;; T a ;; Td b ;; CNOT a b.


Lemma ZIITOFFOLI :
  {{ @AtoPred 3 [(C1, [gZ; gI; gI])] }} TOFFOLI 0 1 2 {{ @AtoPred 3 [(C1, [gZ; gI; gI])] }}.
Proof. time validate. Qed.

Lemma IZITOFFOLI :
  {{ @AtoPred 3 [(C1, [gI; gZ; gI])] }} TOFFOLI 0 1 2 {{ @AtoPred 3 [(C1, [gI; gZ; gI])] }}.
Proof. time validate. Qed.


Lemma IIZTOFFOLI_solve : 
exists Placeholder,
{{ @AtoPred 3 [(C1, [gI; gI; gZ])] }} TOFFOLI 0 1 2 {{ Placeholder }}.
Proof. time solvePlaceholder.
(* time solvePlaceholder.
Tactic call ran for 60.051 secs (56.539u,1.708s) (success) *)
assumption.
Qed.


Lemma IIZTOFFOLI : 
{{ @AtoPred 3 [(C1, [gI; gI; gZ])] }} TOFFOLI 0 1 2 {{ @AtoPred 3  
           [((- C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gZ; gZ]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gZ; gY]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gZ; gY]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gZ; gZ]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gI; gY]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gI; gZ]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gI; gZ]);
            ((- C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gI; gY]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gI; gY]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gI; gZ]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gI; gZ]);
            ((- C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gI; gY]);
            ((C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gZ; gZ]);
            ((- C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gI; gZ; gY]);
            ((- C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gZ; gY]);
            ((- C1 / (√ 2 * √ 2 * √ 2 * √ 2))%C, [gZ; gZ; gZ])]
 }}.
Proof. time validate. Qed.
(* time validate
Tactic call ran for 47.226 secs (44.475u,1.429s) (success) *)


(** ** Steane code on 7 qubits ** **)
(* 
g1 = IIIXXXX
g2 = IXXIIXX
g3 = XIXIXIX
g4 = IIIZZZZ
g5 = IZZIIZZ
g6 = ZIZIZIZ
Xb = XXXXXXX
Zb = ZZZZZZZ
Yb = YYYYYYY

ZL := g1 ∩ ... ∩ g6 ∩ Zb
XL := g1 ∩ ... ∩ g6 ∩ Xb
YL := g1 ∩ ... ∩ g6 ∩ Yb
St7 := g1 ∩ ... ∩ g6

ZL = St7 ∩ Zb
XL = St7 ∩ Xb
YL = St7 ∩ Yb

Definition g1 := @G 7 (F [(C1, [gI; gI; gI; gX; gX; gX; gX])]).
Definition g2 := @G 7 (F [(C1, [gI; gX; gX; gI; gI; gX; gX])]).
Definition g3 := @G 7 (F [(C1, [gX; gI; gX; gI; gX; gI; gX])]).
Definition g4 := @G 7 (F [(C1, [gI; gI; gI; gZ; gZ; gZ; gZ])]).
Definition g5 := @G 7 (F [(C1, [gI; gZ; gZ; gI; gI; gZ; gZ])]).
Definition g6 := @G 7 (F [(C1, [gZ; gI; gZ; gI; gZ; gI; gZ])]).
Definition Xbar := @G 7 (F [(C1, [gX; gX; gX; gX; gX; gX; gX])]).
Definition Zbar := @G 7 (F [(C1, [gZ; gZ; gZ; gZ; gZ; gZ; gZ])]).
*)

Definition Steane7 q0 q1 q2 q3 q4 q5 q6 := 
H q4 ;; H q5 ;; H q6 ;; 
CNOT q0 q1 ;; CNOT q0 q2 ;; 
CNOT q6 q0 ;; CNOT q6 q1 ;; CNOT q6 q3 ;; 
CNOT q5 q0 ;; CNOT q5 q2 ;; CNOT q5 q3 ;; 
CNOT q4 q1 ;; CNOT q4 q2 ;; CNOT q4 q3. 

Lemma Steane7Z : 
@triple 7 (Cap ([
[(C1, [gZ; gI; gI; gI; gI; gI; gI])];
[(C1, [gI; gZ; gI; gI; gI; gI; gI])];
[(C1, [gI; gI; gZ; gI; gI; gI; gI])];
[(C1, [gI; gI; gI; gZ; gI; gI; gI])];
[(C1, [gI; gI; gI; gI; gZ; gI; gI])];
[(C1, [gI; gI; gI; gI; gI; gZ; gI])];
[(C1, [gI; gI; gI; gI; gI; gI; gZ])]
])) (Steane7 0 1 2 3 4 5 6) (Cap ([

[(C1, [gZ; gI; gI; gI; gI; gZ; gZ])];
[(C1, [gZ; gZ; gI; gI; gZ; gZ; gI])];
[(C1, [gZ; gI; gZ; gI; gZ; gI; gZ])];
[(C1, [gI; gI; gI; gZ; gZ; gZ; gZ])];
[(C1, [gI; gX; gX; gX; gX; gI; gI])];
[(C1, [gX; gI; gX; gX; gI; gX; gI])];
[(C1, [gX; gX; gI; gX; gI; gI; gX])]


(* [(C1, [gZ; gI; gI; gI; gI; gZ; gZ])];
[(C1, [gZ; gZ; gI; gI; gZ; gZ; gI])];
[(C1, [gZ; gI; gZ; gI; gZ; gI; gZ])];
[(C1, [gI; gI; gI; gZ; gZ; gZ; gZ])];
[(C1, [gI; gX; gX; gX; gX; gI; gI])];
[(C1, [gX; gI; gX; gX; gI; gX; gI])];
[(C1, [gX; gX; gI; gX; gI; gI; gX])] *)
])).
Proof. time validate. Qed.
(* time validate
Tactic call ran for 18.646 secs (17.973u,0.353s) (success) *)


Lemma Steane7Z_solve : 
exists Placeholder,
@triple 7 (Cap ([
[(C1, [gZ; gI; gI; gI; gI; gI; gI])];
[(C1, [gI; gZ; gI; gI; gI; gI; gI])];
[(C1, [gI; gI; gZ; gI; gI; gI; gI])];
[(C1, [gI; gI; gI; gZ; gI; gI; gI])];
[(C1, [gI; gI; gI; gI; gZ; gI; gI])];
[(C1, [gI; gI; gI; gI; gI; gZ; gI])];
[(C1, [gI; gI; gI; gI; gI; gI; gZ])]
])) (Steane7 0 1 2 3 4 5 6) (Placeholder).
Proof. time solvePlaceholder.
(* time solvePlaceholder.
Tactic call ran for 17.471 secs (16.808u,0.27s) (success) *)
assumption.
Qed.


Compute map snd (@normalize 7 ([
(C1, [gZ; gI; gI; gI; gI; gZ; gZ]);
(C1, [gZ; gZ; gI; gI; gZ; gZ; gI]);
(C1, [gZ; gI; gZ; gI; gZ; gI; gZ]);
(C1, [gI; gI; gI; gZ; gZ; gZ; gZ]);
(C1, [gI; gX; gX; gX; gX; gI; gI]);
(C1, [gX; gI; gX; gX; gI; gX; gI]);
(C1, [gX; gX; gI; gX; gI; gI; gX])
])).
(* [
[gX; gI; gX; gI; gX; gI; gX]; 
[gI; gX; gX; gI; gI; gX; gX];
[gZ; gZ; gZ; gI; gI; gI; gI]; 
[gI; gI; gI; gX; gX; gX; gX];
[gZ; gI; gI; gZ; gZ; gI; gI]; 
[gI; gZ; gI; gZ; gI; gZ; gI];
[gZ; gZ; gI; gZ; gI; gI; gZ]
] *)


(** ** Separability ** **)

Fixpoint separate_loop {n : nat} (lt : list (TType n)) (input : list (list nat)) (acc : (list nat) * (list (list TTypes)) * (list nat)) : (list nat) * (list (list TTypes)) * (list nat) :=
  match input with
  | h :: t => separate_loop lt t 
         ((length h) :: (fst (fst acc)), 
           (map (fun k => ForgetT (unpad_Sep_TType (nth (get_pivot lt k) lt (defaultT_I n)) h)) h) :: (snd (fst acc)), 
           snd acc)
  | [] => (rev (fst (fst acc)), rev (snd (fst acc)), snd acc)
  end.

Definition separate {n : nat} (lt : list (TType n)) (input : list (list nat)) :=
  separate_loop lt input ([], [], fold_right (@app nat) [] input).

Ltac validateCapImpliesSep :=
  repeat 
    match goal with 
    | |- _ ⇒ Sep _ => compute; Rsimpl; eapply CaptoSep; compute; Rsimpl; auto;
                    repeat (constructor; try split; intros; try lia; auto)
    | |- Permutation _ _ => try (apply Permutation_sym; apply sort_seq_Permutation; compute;  easy); try (apply sort_seq_Permutation; compute;  easy)
    end.

Ltac validateCapImpliesCap :=
  apply CapElim;
  unfold incl;
  let a := fresh "a" in 
  let H' := fresh "H'" in 
  intros a H';
  repeat (first [destruct H' as [H' | H']; subst; [> try (left; easy); repeat (right; try easy; try (left; easy)) | idtac] | inversion H']).

Ltac validateCaptoSep :=
  match goal with 
  | |- {{ Cap _  }} _ {{ Sep _ }} => eapply CONS; [> compute; Rsimpl; apply ID_implies | 
                                                            validateCapImpliesSep | 
                                                            eapply CONS; [> apply ID_implies | idtac | validate] ];
                                   validateCapImpliesCap
  end.


(* map snd (normalize Test''')
[[gY; gZ; gI; gI];
 [gZ; gX; gI; gI];
 [gI; gI; gY; gZ];
 [gI; gI; gZ; gY]] *)
(* normalize Test'''
[(C1, [gY; gZ; gI; gI]); 
(C1, [gZ; gX; gI; gI]);
(C1, [gI; gI; gY; gZ]);
(C1, [gI; gI; gZ; gY])] *)
Compute map snd (normalize Test''').
Compute separable (normalize Test''') [0; 1]%nat.

Goal ((separate (normalize Test''') [[0; 1]; [2; 3]]%nat) = (separate (normalize Test''') [[0; 1]; [2; 3]]%nat)).
compute; Rsimpl. reflexivity. Qed.

Lemma separation_test''' :
Cap (map TtoA (normalize Test''')) ⇒ Sep ((separate (normalize Test''') [[0; 1]; [2; 3]]%nat)).
Proof. time (validateCapImpliesSep).
Qed.

Example separation_test'''1 :
@Cap 4 (map TtoA ( normalize
[(C1, [gY; gI; gZ; gI]); 
(C1, [gI; gY; gI; gZ]);
(C1, [gZ; gI; gX; gI]);
(C1, [gI; gZ; gI; gY])]
)) ⇒ @Sep 4 (@separate 4 ( normalize
[(C1, [gY; gI; gZ; gI]); 
(C1, [gI; gY; gI; gZ]);
(C1, [gZ; gI; gX; gI]);
(C1, [gI; gZ; gI; gY])]
) [[0; 2]; [1; 3]]%nat).
Proof. time (validateCapImpliesSep).
(* time (validateCapImpliesSep)
Tactic call ran for 0.202 secs (0.177u,0.018s) (success) *)
Admitted.

Example separation_test'''2 :
{{ @Cap 4 (map TtoA ( normalize
[(C1, [gY; gI; gZ; gI]); 
(C1, [gI; gY; gI; gZ]);
(C1, [gZ; gI; gX; gI]);
(C1, [gI; gZ; gI; gY])] )) }}
H 0 ;; H 0
{{ @Sep 4 (@separate 4 ( normalize
[(C1, [gY; gI; gZ; gI]); 
(C1, [gI; gY; gI; gZ]);
(C1, [gZ; gI; gX; gI]);
(C1, [gI; gZ; gI; gY])]
) [[0; 2]; [1; 3]]%nat) }}.
Proof. time validateCaptoSep. 
(* time validateCaptoSep
Tactic call ran for 0.522 secs (0.497u,0.013s) (success) *)
Qed.


(* map snd (normalize Test')
[[gY; gZ; gI; gI; gI; gI; gI]; 
 [gZ; gX; gI; gI; gI; gI; gI];
 [gI; gI; gX; gZ; gZ; gI; gI]; 
 [gI; gI; gZ; gX; gZ; gI; gI];
 [gI; gI; gZ; gZ; gY; gI; gI]; 
 [gI; gI; gI; gI; gI; gY; gZ];
 [gI; gI; gI; gI; gI; gZ; gX]] *)
Compute map snd (normalize Test').
Compute separable (normalize Test') [2; 3; 4]%nat.
Compute separable (normalize Test') [0; 1]%nat.
Compute separable (normalize Test') [5; 6]%nat.
Compute separable_all (normalize Test') [[2; 3; 4]; [0;1]; [5;6]]%nat.

Goal (separate (normalize Test') [[2; 3; 4]; [0;1]; [5;6]]%nat = separate (normalize Test') [[2; 3; 4]; [0;1]; [5;6]]%nat).
compute; Rsimpl. reflexivity. Qed.

Lemma separation_test'_1 :
{{ Cap (map TtoA (normalize Test')) }}
H 0 ;; H 0
{{ Sep (separate (normalize Test') [[2; 3; 4]; [0;1]; [5;6]]%nat) }}.
Proof. time validateCaptoSep.
(* time validateCaptoSep.
Tactic call ran for 7.411 secs (6.551u,0.452s) (success) *)
Qed.


(** ** Graph States ** **)

Definition CZ q0 q1 := H q1 ;; CNOT q0 q1 ;; H q1.

(*
n = 3
edges = [ (0, 1); (1, 2) ]
*) 

Fixpoint edges_to_CZ_loop (progs : list prog) (last_prog : prog) : prog :=
  match progs with 
  | h :: t => h ;; (edges_to_CZ_loop t last_prog)
  | [] => last_prog
  end.

Definition edges_to_CZ (edges : list (nat * nat)) := 
  let progs := (map (fun e => CZ (fst e) (snd e)) edges) in
  edges_to_CZ_loop (removelast progs) (last progs (H 0%nat)).

Compute edges_to_CZ [ (0, 1); (1, 2) ]%nat.


Fixpoint vertex_edges_to_stabilizer_loop (size : nat) (edges : list (nat * nat)) (v : nat) (acc : list Pauli) :=
  match edges with
  | [] => acc
  | (e1, e2) :: t => if Nat.eqb v e1 then
                     vertex_edges_to_stabilizer_loop size t v (switch acc gZ e2)
                   else if Nat.eqb v e2 then
                          vertex_edges_to_stabilizer_loop size t v (switch acc gZ e1)
                        else vertex_edges_to_stabilizer_loop size t v acc
  end.

Definition vertex_edges_to_stabilizer (size : nat) (edges : list (nat * nat)) (v : nat) : TType size :=
  (C1, vertex_edges_to_stabilizer_loop size edges v (switch (repeat gI size) gX v)).

Definition graph_to_stabilizers (size : nat) (edges : list (nat * nat)) : list (TType size) :=
  map (vertex_edges_to_stabilizer size edges) (List.seq 0%nat size).

Definition graph_to_Predicate (size : nat) (edges : list (nat * nat)) : Predicate size :=
  Cap (map TtoA (graph_to_stabilizers size edges)).

Compute graph_to_Predicate 3 [ (0, 1); (1, 2) ]%nat.


Definition nat_to_X_i (size i : nat) := (C1, switch (repeat gI size) gX i).

Definition graph_init (size : nat) : Predicate size :=
  @Cap size (map (fun i => TtoA (nat_to_X_i size i)) (List.seq 0%nat size)).


Ltac unfoldGraphState :=
  unfold  graph_init, nat_to_X_i, graph_to_Predicate, graph_to_stabilizers, vertex_edges_to_stabilizer, edges_to_CZ, TtoA; simpl.

(*
Lemma GraphState_compute_postcond : 
Lemma compute_postcond_CAP : forall {n : nat} (g : prog) (lt : list (TType n)),
    nonadditive_prog g -> prog_bound n g -> Forall WF_TType lt ->
    {{ Cap (map TtoA lt) }} g {{ Cap (map (fun t => TtoA (prog_on_TType g t)) lt) }}.
Proof. intros n g lt H0 H1 H2.
  apply CAP'. 
  induction lt; auto.
  rewrite Forall_cons_iff in H2. destruct H2. specialize (IHlt H3).
  constructor; auto.
  apply compute_postcond; auto.
Qed.


*)


Lemma TestGraphState0 : 
exists Placeholder,
{{ graph_init 3 }} 
edges_to_CZ [ (0, 1); (1, 2) ]%nat
{{ Placeholder }}.
Proof. unfoldGraphState.
  time solvePlaceholder.
  assumption.
Qed.

Compute @normalize 3 [(C1, [gZ; gX; gZ]); (C1, [gI; gZ; gX]); (C1, [gX; gZ; gI])].


Lemma TestGraphState1 : 
{{ graph_init 3 }} 
edges_to_CZ [ (0, 1); (1, 2) ]%nat
{{ graph_to_Predicate 3 [ (0, 1); (1, 2) ]%nat }}.
Proof. unfoldGraphState.
  time validate.
Qed.

Lemma TestGraphState2 : (* complete graph K3 in 10 qubits *)
{{ graph_init 10 }} 
edges_to_CZ [ (0, 1); (0, 2); (1, 2)]%nat
{{ graph_to_Predicate 10 [ (0, 1); (0, 2); (1, 2)]%nat }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 9.833 secs (7.683u,0.791s) (success) *)
Qed.

Lemma TestGraphState3 :  (* complete graph K5 in 5 qubits *)
{{ graph_init 5 }}
edges_to_CZ [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat
{{ graph_to_Predicate 5 [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 10.225 secs (9.296u,0.365s) (success) *)
Qed.

Lemma TestGraphState4 :  (* complete graph K5 in 10 qubits *)
{{ graph_init 10 }}
edges_to_CZ [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat
{{ graph_to_Predicate 10 [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 26.271 secs (24.517u,0.744s) (success) *)
Qed.

Lemma TestGraphState5 :  (* complete graph K10 in 10 qubits *)
{{ graph_init 10 }}
edges_to_CZ
[(0,1); (0,2); (0,3); (0,4); (0,5); (0,6); (0,7); (0,8); (0,9);
 (1,2); (1,3); (1,4); (1,5); (1,6); (1,7); (1,8); (1,9);
 (2,3); (2,4); (2,5); (2,6); (2,7); (2,8); (2,9);
 (3,4); (3,5); (3,6); (3,7); (3,8); (3,9);
 (4,5); (4,6); (4,7); (4,8); (4,9);
 (5,6); (5,7); (5,8); (5,9);
 (6,7); (6,8); (6,9);
 (7,8); (7,9);
 (8,9)]%nat
{{ graph_to_Predicate 10
[(0,1); (0,2); (0,3); (0,4); (0,5); (0,6); (0,7); (0,8); (0,9);
 (1,2); (1,3); (1,4); (1,5); (1,6); (1,7); (1,8); (1,9);
 (2,3); (2,4); (2,5); (2,6); (2,7); (2,8); (2,9);
 (3,4); (3,5); (3,6); (3,7); (3,8); (3,9);
 (4,5); (4,6); (4,7); (4,8); (4,9);
 (5,6); (5,7); (5,8); (5,9);
 (6,7); (6,8); (6,9);
 (7,8); (7,9);
 (8,9)]%nat
 }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 128.407 secs (118.935u,4.08s) (success) *)
Qed.

Lemma TestGraphState6 :  (* complete graph K5 in 15 qubits *)
{{ graph_init 15 }}
edges_to_CZ [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat
{{ graph_to_Predicate 15 [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 60.459 secs (56.59u,1.244s) (success) *)
Qed.

Lemma TestGraphState7 :  (* complete graph K5 in 20 qubits *)
{{ graph_init 20 }}
edges_to_CZ [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat
{{ graph_to_Predicate 20 [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 118.262 secs (108.817u,3.359s) (success) *)
Qed.

Lemma TestGraphState8 :  (* complete graph K5 in 25 qubits *)
{{ graph_init 25 }}
edges_to_CZ [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat
{{ graph_to_Predicate 25 [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 194.406 secs (180.787u,5.28s) (success) *)
Qed.

Lemma TestGraphState9 :  (* complete graph K5 in 30 qubits *)
{{ graph_init 30 }}
edges_to_CZ [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat
{{ graph_to_Predicate 30 [(0,1); (0,2); (0,3); (0,4); (1,2); (1,3); (1,4); (2,3); (2,4); (3,4)]%nat }}.
Proof. unfoldGraphState.
  time validate.
(* Tactic call ran for 337.781 secs (305.632u,10.749s) (success) *)
Qed.

(** time complexity seems to be larger than the number of qubits squared (~ n^2 log n)
time complexity seems to be linear in the number of edges **)

